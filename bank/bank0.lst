AS65 Assembler for R6502 [1.42].                                     Page    1
-------------------------------- bank\bank0.s --------------------------------

<<<<<<< HEAD
8284 lines read, no errors in pass 1.
=======
7883 lines read, no errors in pass 1.
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
c000 =                       _bank0_start=0xc000
                             	include "kernel\kernel.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  KERNEL.S
                             ;*	The 'kernel' routine includes code and data wh
                             ;* 	be in every ROM bank.  In the auto-generated 
                             ;*  files, the kernel is added before the bank sp
                             ;*	code.  See bank0.s as an example.
                             ;*
                             ;************************************************
                             
                             ;* Include all definition and code files in the r
                             	include "inc\includes.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  INCLUDES.S
                             ;*  Main include file for key definitions and mac
                             ;*  Many of the settings here are exremely machin
                             ;*  Defines : IO block addresses, VIA port usage,
                             ;*  settings, useful macros, sound chip registers
                             ;*  VDP registers, ACIA registers.
                             ;*
                             ;************************************************
                             
                             ;* The IO block is at 0x04000 and decodes up to
                             ;* eight IO addresses, at 0x0080 intervals
                             ;* All eight are not used at the present time:
                             ;* - 0 : VIA 1 (Keyboard)
                             ;* - 1 : VIA 2 (Sound and SD card interface)
                             ;* - 2 : VDP (Video)
                             ;* - 3 : ACIA (Serial)
                             ;* - 4 : RTC (DS12887 real time clock + RAM)
0400 =                       IO_0		= 0x0400
0480 =                       IO_1		= 0x0480
0500 =                       IO_2		= 0x0500
0580 =                       IO_3		= 0x0580
0600 =                       IO_4		= 0x0600
0680 =                       IO_5		= 0x0680
0700 =                       IO_6		= 0x0700
0780 =                       IO_7		= 0x0780
                             
                             ;* VDP is accessed through IO_2
0500 =                       VDP_MODE0		= IO_2
0501 =                       VDP_MODE1		= IO_2+1
0501 =                       VDP_STATUS		= IO_2+1
0501 =                       VDP_ADDR		= IO_2+1
0500 =                       VDP_VRAM		= IO_2
0001 =                       VDP_SHORTDELAY	= 1
AS65 Assembler for R6502 [1.42].                                     Page    2
-------------------------------- bank\bank0.s --------------------------------

0002 =                       VDP_LONGDELAY 	= 2
0010 =                       VDP_FLASH		= 0x10				;* Must be a power of 2 *
                             
                             ;* This structure defines the key information
                             ;* kept about the VDP current mode
0000 =                       	struct vdp_addr_struct
0000 =                       	dw vdp_addr_nme				;* Address of name table
0002 =                       	dw vdp_addr_col				;* Address of colour table
0004 =                       	dw vdp_addr_pat				;* Address of pattern table
0006 =                       	dw vdp_addr_spa				;* Address of sprite pattern 
0008 =                       	dw vdp_addr_spp				;* Address of sprite position
000a =                       	db vdp_bord_col				;* Value of border colour
000b =                       	db vdp_gmode				;* Graphics mode 0,1,2 or 0x80 (
                             	end struct
                             
                             ;* Standard definitions of 6522 registers
                             ;* As found in the datasheets
0000 =                       PRB			= 0x00
0001 =                       PRA			= 0x01
0002 =                       DDRB		= 0x02
0003 =                       DDRA		= 0x03
0004 =                       T1CL		= 0x04
0005 =                       T1CH		= 0x05
0006 =                       T1LL		= 0x06
0007 =                       T1LH		= 0x07
0008 =                       T2CL		= 0x08
0009 =                       T2CH		= 0x09
000a =                       SR			= 0x0a
000b =                       ACR			= 0x0b
000c =                       PCR			= 0x0c
000d =                       IFR			= 0x0d
000e =                       IER			= 0x0e
000f =                       PRAH		= 0x0f
                             
0001 =                       IFR_CA2		= 0x01
0002 =                       IFR_CA1		= 0x02
                             
                             ;* AY-3-8910 definitions
                             ;* The sound chip is accessed through VIA 2
0481 =                       SND_ADBUS	= IO_1+PRA
0480 =                       SND_MODE	= IO_1+PRB
                             
0040 =                       SND_SELREAD			= 0x40
0002 =                       SND_SELWRITE		= 0x02
0042 =                       SND_SELSETADDR		= (SND_SELREAD|SND_SELWRITE)
00bd =                       SND_DESELECT_MASK	= (0xff-SND_SELREAD-SND_SELWRIT
                             
0000 =                       SND_REG_CHAPL	= 0x00
0001 =                       SND_REG_CHAPH	= 0x01
0002 =                       SND_REG_CHBPL	= 0x02
0003 =                       SND_REG_CHBPH	= 0x03
0004 =                       SND_REG_CHCPL	= 0x04
0005 =                       SND_REG_CHCPH	= 0x05
0006 =                       SND_REG_CHNP	= 0x06
0007 =                       SND_REG_CTL		= 0x07
0008 =                       SND_REG_CHAVOL	= 0x08
0009 =                       SND_REG_CHBVOL	= 0x09
000a =                       SND_REG_CHBVOL	= 0x0a
000b =                       SND_REG_ENVPL	= 0x0b
000c =                       SND_REG_ENVPH	= 0x0c
000d =                       SND_REG_ENVCYC	= 0x0d
                             
AS65 Assembler for R6502 [1.42].                                     Page    3
-------------------------------- bank\bank0.s --------------------------------

000e =                       SND_REG_IOA	= 0x0e
000f =                       SND_REG_IOB	= 0x0f
                             
                             ;* 6551 ACIA definitions
                             ;* As found in the datasheets
0580 =                       SER_DATA	= (IO_3+0)
0581 =                       SER_STATUS	= (IO_3+1)
0581 =                       SER_RESET	= (IO_3+1)
0582 =                       SER_CMD		= (IO_3+2)
0583 =                       SER_CTL		= (IO_3+3)
                             
0080 =                       SER_IRQ		= 0x80
0040 =                       SER_DSRB	= 0x40
0020 =                       SER_DCDB	= 0x20
0010 =                       SER_TDRE	= 0x10
0008 =                       SER_RDRF	= 0x08
0004 =                       SER_OVRN	= 0x04
0002 =                       SER_FE		= 0x02
0001 =                       SER_PE		= 0x01
0080 =                       SER_SBN		= 0x80
0040 =                       SER_WL1		= 0x40
0020 =                       SER_WL0		= 0x20
0060 =                       SER_WL		= (SER_WL1|SER_WL0)
0010 =                       SER_RCS		= 0x10
0008 =                       SER_SBR3	= 0x08
0004 =                       SER_SBR2	= 0x04
0002 =                       SER_SBR1	= 0x02
0001 =                       SER_SBR0	= 0x01
000f =                       SER_SBR		= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0)
000f =                       SER_19200B	= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0
000e =                       SER_9600B	= (SER_SBR3|SER_SBR2|SER_SBR1)
0080 =                       SER_PMC1	= 0x80
0040 =                       SER_PMC0	= 0x40
00c0 =                       SER_PMC		= (SER_PMC1|SER_PMC0)
0020 =                       SER_PME		= 0x20
0010 =                       SER_REM		= 0x10
0008 =                       SER_TIC1	= 0x08
0004 =                       SER_TIC0	= 0x04
000c =                       SER_TIC		= (SER_TIC1|SER_TIC0)
0002 =                       SER_IRD		= 0x02
0001 =                       SER_DTR		= 0x01
                             
                             ;* BBC keyboard definitions
                             ;* The keyboard is accessed through VIA 1
                             ;* Port A - all output
0001 =                       KB_ROWA		= 0x01
0002 =                       KB_ROWB		= 0x02
0004 =                       KB_ROWC		= 0x04
0008 =                       KB_COLA		= 0x08
0010 =                       KB_COLB		= 0x10
0020 =                       KB_COLC		= 0x20
0040 =                       KB_COLD		= 0x40
0080 =                       KB_EN		= 0x80
                             ;* Port B
0001 =                       KB_W		= 0x01			; Input - BBC keyboard hardware se
0002 =                       KB_LED0		= 0x02			; Output - led 0
0004 =                       KB_LED1		= 0x04			; Output - led 1
0008 =                       KB_LED2		= 0x08			; Output - led 2
0001 =                       KB_CAPSLK	= 0x01			; Id of Caps Lock - maps to Le
0002 =                       KB_SHIFTLK	= 0x02			; Id of Shift lock - maps to 
                             
0003 =                       KB_REP_TIM	= 3				; Number of VB periods for the 
AS65 Assembler for R6502 [1.42].                                     Page    4
-------------------------------- bank\bank0.s --------------------------------

0014 =                       KB_REP_DEL	= 20			; Number of VB periods before r
0002 =                       KB_DEBOUNCE	= 2				; Number of VB periods before 
                             
0001 =                       UTF_SOH		= 0x01
0003 =                       UTF_ETX		= 0x03			; Break character
0007 =                       UTF_BEL		= 0x07
0008 =                       CRSR_LEFT	= 0x08
0009 =                       CRSR_RIGHT	= 0x09
000a =                       CRSR_DOWN	= 0x0a
000b =                       CRSR_UP		= 0x0b
0006 =                       UTF_ACK		= 0x06			; Used for the copy key in this
000c =                       UTF_FF		= 0x0c
000d =                       UTF_CR		= 0x0d
0015 =                       UTF_NACK	= 0x15
0017 =                       UTF_ETB		= 0x17
001a =                       UTF_BRK		= 0x1a			; Debug - drop in to monitor
007f =                       UTF_DEL		= 0x7f
0020 =                       UTF_SPECIAL = 0x20
                             
                             ;* SD Card interface definitions
                             ;* The card is accessed through port B of VIA 2
0001 =                       SD_CLK		= 0x01			; Clock output to SD card
0004 =                       SD_CD		= 0x04			; Card detect input
0008 =                       SD_CS		= 0x08			; Card select output
0010 =                       SD_DI		= 0x10			; Data output from VIA to SD Card
0080 =                       SD_DO		= 0x80			; Data input to VIA from SD card
                             
0010 =                       SD_MOSI		= SD_DI
0080 =                       SD_MISO		= SD_DO
0480 =                       SD_REG		= IO_1+PRB
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
                             
                             ;* Memory management definitions
                             ;* Y1,Y0 = ROM bank selection CIA1 PORTB
0080 =                       MM_Y1					= 0x80
0040 =                       MM_Y0					= 0x40
                             ;* X1,X0 = RAM bank selection CIA1 PORTB
0020 =                       MM_X1					= 0x20
0010 =                       MM_X0					= 0x10
                             ;* DIS = ROM disable *CIA2* PORTB
0020 =                       MM_DIS					= 0x20
                             
                             ;* Number formats for conversion routines
0000 =                       NUM_ANY		= 0x00
0001 =                       NUM_DEC		= 0x01
0002 =                       NUM_HEX		= 0x02
0003 =                       NUM_BIN		= 0x03
                             
                             	
                             ;* SD Card Master Boot Record (MBR) definitions
                             ;* The MBR contains the essential information
                             ;* needed to access the data on the card
                             ;* MBR is usually sector 0, but not always
                             ;* however the card I am using does work ok.
0000 =                       MBR_Code				=	0x0000
0003 =                       MBR_OEMName				=	0x0003
000b =                       MBR_BytesPerSect		=	0x000b
000d =                       MBR_SectPerClust		=	0x000d
AS65 Assembler for R6502 [1.42].                                     Page    5
-------------------------------- bank\bank0.s --------------------------------

000e =                       MBR_ResvSect			=	0x000e
0010 =                       MBR_FATCopies			=	0x0010
0011 =                       MBR_RootEntries			=	0x0011
0013 =                       MBR_SmlSect				=	0x0013
0015 =                       MBR_MediaDesc			=	0x0015
0016 =                       MBR_SectPerFAT			=	0x0016
0018 =                       MBR_SectPerTrk			=	0x0018
001a =                       MBR_NumHeads			=	0x001a
001c =                       MBR_NumHidSect			=	0x001c
0020 =                       MBR_NumSect				=	0x0020
0024 =                       MBR_DrvNum				=	0x0024
0026 =                       MBR_ExtSig				=	0x0026
0027 =                       MBR_SerNo				=	0x0027
002b =                       MBR_VolName				=	0x002b
0036 =                       MBR_FATName				=	0x0036
003e =                       MBR_ExeCode				=	0x003e
01c6 =                       MBR_BootPart1			=	(0x01be+0x08)
01fe =                       MBR_ExeMark				=	0x01fe
                             
                             ;* FAT16 definitions - these are offsets
                             ;* in to a FAT table entry which is
                             ;* 32 bytes in length.
0000 =                       	struct FATFileDesc
0000 =                       	ds FAT_Name,8
0008 =                       	ds FAT_Ext,3
000b =                       	ds FAT_Attr,1
000c =                       	ds FAT_Resv,1
000d =                       	ds FAT_Createms,1
000e =                       	ds FAT_CreateTime,2
0010 =                       	ds FAT_CreateDate,2
0012 =                       	ds FAT_AccessDate,2
0014 =                       	ds FAT_EAIndex,2
0016 =                       	ds FAT_ModTime,2
0018 =                       	ds FAT_ModDate,2
001a =                       	ds FAT_FirstClust,2
001c =                       	ds FAT_FileSize,4
                             	end struct
                             
                             ;* Flag to mark file as a directory
0010 =                       FAT_Attr_Dir			=	0x10
                             
                             ;* The FileHandle stucture is key to
                             ;* accessing the file system
0000 =                       	struct FileHandle
0000 =                       	ds FH_Name, 13				; 8 name, 3 extension, 1 separ
000d =                       	ds FH_Attr, 1				; What kind of file ** keep str
000e =                       	ds FH_Size, 4				; File size
0012 =                       	ds FH_CurrClust, 2			; Current cluster
0014 =                       	ds FH_SectCounter, 1		; Sector counter to know w
0015 =                       	ds FH_CurrSec, 4			; Current sector
0019 =                        	ds FH_Pointer, 4			; Pointer in to file for nex
001d =                       	ds FH_DirSect, 4			; Parent directory sector
0021 =                       	ds FH_DirOffset, 2			; Offset of this entry in t
0023 =                       	ds FH_FirstClust, 2			; First cluster of file da
0025 =                       	ds FH_LastClust, 2			; Last cluster accessed
0027 =                       	ds FH_TimeDate, 5			; Time-Date created (ms, tim
002c =                       	ds FH_FileMode, 1			; File mode (0=read, else wr
002d =                       	ds FH_FSpecPtr, 2			; Pointer to file spec being
                             	end struct
                             
0001 =                       FS_BLK_FLG_LOAD		 	= 	0x01		; On next byte, load 
0002 =                       FS_BLK_FLG_FLUSH		=	0x02		; Block has changed, ne
AS65 Assembler for R6502 [1.42].                                     Page    6
-------------------------------- bank\bank0.s --------------------------------

                             	
0001 =                       FS_ERR_EOF				=	0x01
                             
                             
                             ;* USEFUL MACROS HERE
                             
                             ;* Software break to throw errors
                             ;* use like this : SWBRK XX
                             ;* Where XX is the error code
                             SWBRK macro sig
                             	brk
                             	db sig
                             	endm
                             
                             _pushAXY macro
                             	pha
                             	phx
                             	phy
                             	endm
                             
                             _pullAXY macro
                             	ply
                             	plx
                             	pla
                             	endm
                             
                             _println macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	_pullAXY
                             	endm
                             
                             _println_low macro msg
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	endm
                             
                             _printmsgA macro msg
                             	phx
                             	phy
                             	pha
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	pla
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printA macro
                             	phx
AS65 Assembler for R6502 [1.42].                                     Page    7
-------------------------------- bank\bank0.s --------------------------------

                             	phy
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printCRLF macro
                             	pha
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printC macro ch
                             	pha
                             	lda #ch
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printCA macro
                             	pha
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _sendcmd macro cmd
                             	_pushAXY
                             	ldx #lo(cmd)
                             	lda #hi(cmd)
                             	jsr sd_sendcmd
                             	_pullAXY
                             	endm
                             
                             _incZPWord macro wordp
                             	inc wordp
                             	db	0xd0, 0x02
                             	inc wordp+1
                             	endm
                             
                             _decZPWord macro wordp
                             	pha
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	pla
                             	endm
                             
                             _decZPWordA macro wordp
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
AS65 Assembler for R6502 [1.42].                                     Page    8
-------------------------------- bank\bank0.s --------------------------------

                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	endm
                             
                             _cpyZPWord macro worda,wordb
                             	lda worda
                             	sta wordb
                             	lda worda+1
                             	sta wordb+1
                             	endm
                             	
                             _addZPWord macro worda, wordb
                             	clc
                             	lda worda
                             	adc wordb
                             	sta worda
                             	lda worda+1
                             	adc wordb+1
                             	sta worda+1
                             	endm
                             
                             _subZPWord macro worda, wordb
                             	sec
                             	lda worda
                             	sbc wordb
                             	sta worda
                             	lda worda+1
                             	sbc wordb+1
                             	sta worda+1
                             	endm
                             	
                             _adcZPWord macro worda,const
                             	clc
                             	lda worda
                             	adc #const
                             	sta worda
                             	lda worda+1
                             	adc #0
                             	sta worda+1
                             	endm
                             
                             _adcZPByte macro worda, byte
                             	clc
                             	lda worda
                             	adc byte
                             	sta worda
                             	db 0x90, 0x02		; bcc 2
                             	inc worda+1
                             	endm
                             
                             _sbcZPByte macro worda, byte
                             	sec
                             	lda worda
                             	sbc byte
                             	sta worda
                             	db 0xb0, 0x02		; bcs 2
                             	inc worda+1
                             	endm
                             
                             _bcc macro skip
                             	db 0x90, skip
AS65 Assembler for R6502 [1.42].                                     Page    9
-------------------------------- bank\bank0.s --------------------------------

                             	endm
                             
                             _bcs macro skip
                             	db 0xb0, skip
                             	endm
                             
                             _df_ost_peekType macro
                             	ldy df_parmtop
                             	lda df_rtstck-1,y
                             	endm
                             
                             	include "inc\graph.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  GRAPH.I
                             ;*  This is the definition file for graphics, spe
                             ;*  The graphics screen handling module.  It is j
                             ;*  structure definition - but this structure is 
                             ;*  record the important attributes of a text scr
                             ;*  Needed because there is both a 40 and 32 colu
                             ;*  supported by the VDP, and the screens are not
                             ;*  same location.
                             ;*
                             ;************************************************
                             
0000 =                       	struct gr_screen
0000 =                       	dw gr_screen_start			; Start of screen memory in
0002 =                       	dw gr_screen_size			; Number of bytes screen occ
0004 =                       	db gr_screen_w				; Number of columns
0005 =                       	db gr_screen_h				; Number of rows
0006 =                       	db gr_cur_off				; Y offset of cursor image from
0007 =                       	db gr_cur_x					; Current X position of cursor
0008 =                       	db gr_cur_y					; Current Y position of cursor
0009 =                       	dw gr_cur_ptr				; VDP address of cursor
000b =                       	db gr_pixmode				; Pixel plot mode (0=Erase, 1=P
000c =                       	db gr_pixmask				; Pixel plot mask
000d =                       	db gr_pixcol				; Pixel colour
000e =                       	dw gr_geom_tmp				; One word of temp storage for
                             	end struct
                             	include "io\io.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.I
                             ;*  Definitions file for the IO module.  The key 
                             ;*  used by the IO system is defined here.
                             ;*
                             ;************************************************
                             
                             ;* General IO structure allows the system to swap
                             ;* different IO devices by using indirect calls t
AS65 Assembler for R6502 [1.42].                                     Page   10
-------------------------------- bank\bank0.s --------------------------------

                             ;* the appropriate routines.
0000 =                       	struct io_struct
0000 =                       	ds	io_get_byte,	2			;* Address of get byte
0002 =                       	ds	io_put_byte,	2			;* Address of put byte
0004 =                       	ds	io_open_r,		2			;* Address of open file for r
0006 =                       	ds	io_open_w,		2			;* Address of open file for w
0008 =                       	ds	io_close_f,		2			;* Address of close file
000a =                       	ds	io_del_f,		2			;* Address of delete file
000c =                       	ds	io_ext1,		2			;* Address of extended function
000e =                       	ds	io_ext2,		2			;* Address of extended function
                             	end struct
                             	include "rtc\rtc.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTC.I
                             ;*  Definitions file for the RTC module.  The key
                             ;*  used by the real time clock is defined here.
                             ;*  It is a DS1288
                             ;*
                             ;************************************************
                             
0000 =                       RTC_SEC		= 0x00
0001 =                       RTC_SECA	= 0x01
0002 =                       RTC_MIN		= 0x02
0003 =                       RTC_MINA	= 0x03
0004 =                       RTC_HR		= 0x04
0005 =                       RTC_HRA		= 0x05
0006 =                       RTC_DOW		= 0x06
0007 =                       RTC_DAY		= 0x07
0008 =                       RTC_MTH		= 0x08
0009 =                       RTC_YR		= 0x09
000a =                       RTC_REGA	= 0x0a
000b =                       RTC_REGB	= 0x0b
000c =                       RTC_REGC	= 0x0c
000d =                       RTC_REGD	= 0x0d
                             
0080 =                       RTC_UIP		= 0x80
0040 =                       RTC_DV2		= 0x40
0020 =                       RTC_DV1		= 0x20
0010 =                       RTC_DV0		= 0x10
0080 =                       RTC_RS3		= 0x80
0040 =                       RTC_RS2		= 0x40
0020 =                       RTC_RS1		= 0x20
0010 =                       RTC_RS0		= 0x10
                             
0080 =                       RTC_SET		= 0x80
0040 =                       RTC_PIE		= 0x40
0020 =                       RTC_AIE		= 0x20
0010 =                       RTC_UIE		= 0x10
0080 =                       RTC_SQWE	= 0x80
0004 =                       RTC_DM		= 0x04
0002 =                       RTC_2412	= 0x02
0001 =                       RTC_DSE		= 0x01
                             
0080 =                       RTC_IRQF	= 0x80
0040 =                       RTC_PF		= 0x40
AS65 Assembler for R6502 [1.42].                                     Page   11
-------------------------------- bank\bank0.s --------------------------------

0020 =                       RTC_AF		= 0x20
0010 =                       RTC_UF		= 0x10
                             
0080 =                       RTC_VRT		= 0x80
                             
0600 =                       RTC_ADDR	= 0x600
0601 =                       RTC_DATA	= 0x601
                             
000e =                       NV_MODE     = 0x0e          ; Default boot up scr
000f =                       NV_COLOUR   = 0x0f          ; Default boot up col
                             
003f =                       NV_RAMSZ    = 63            ; Checksum byte in NV
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0c69 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
AS65 Assembler for R6502 [1.42].                                     Page   12
-------------------------------- bank\bank0.s --------------------------------

000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_PTR	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0003 =                       DFST_INT	=	DFVVT_INT|DFVVT_BYT
0004 =                       DFST_STR	=	DFVVT_STR
00ff =                       DFST_PTR	=	0xff
AS65 Assembler for R6502 [1.42].                                     Page   13
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0c69 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
AS65 Assembler for R6502 [1.42].                                     Page   14
-------------------------------- bank\bank0.s --------------------------------

                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_PTR	=	0x80
                             
                             ;* Flags indicating the meaning of a token
AS65 Assembler for R6502 [1.42].                                     Page   15
-------------------------------- bank\bank0.s --------------------------------

                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0003 =                       DFST_INT	=	DFVVT_INT|DFVVT_BYT
0004 =                       DFST_STR	=	DFVVT_STR
00ff =                       DFST_PTR	=	0xff
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             	include "dflat\error.i"
                             ;************************************************
                             ;*
                             ;*	BBC128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.I
AS65 Assembler for R6502 [1.42].                                     Page   16
-------------------------------- bank\bank0.s --------------------------------

                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  It issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_SYNTAX	=	1
0002 =                       DFERR_TYPEMISM	=	2
0003 =                       DFERR_DIM		=	3
0004 =                       DFERR_UNTIL		=	4
0005 =                       DFERR_NOPROC	=	5
0006 =                       DFERR_PROCPARM	=	6
0007 =                       DFERR_IMMEDIATE	=	7
0008 =                       DFERR_UNCLOSEDIF=	8
0009 =                       DFERR_NOIF		=	9
000a =                       DFERR_NEXTFOR	=	10
000b =                       DFERR_FNAME		=	11
000c =                       DFERR_STRLONG	=	12
000d =                       DFERR_BREAK		=	13
000e =                       DFERR_NODATA	=	14
000f =                       DFERR_WEND		=	15
0010 =                       DFERR_NOLINE	=	16
0011 =                       DFERR_RETURN	=	17
0012 =                       DFERR_ABORT		=	18
0013 =                       DFERR_QUANTITY	=	19
0014 =                       DFERR_NOORG		=	20
                             
                             
                             
                             	include "bank\bank.i"
c000 =                       bankjsr_nul_addr	=	0xc000
0000 =                       bankjsr_nul_bank	=	0x00
003f =                       ROM_ZMASK			=	0x3f
00cf =                       RAM_ZMASK			=	0xcf
                             
                             _bankjsr	macro	addr,bank
                             	; Save A
                             	sta tmp_bank1
                             	
                             	; Save current bank
                             	lda bank_num
                             	pha
                             	
                             	; Switch to new bank
                             	lda IO_0+PRB
                             	and #ROM_ZMASK
                             	ora #(bank^3) << 6			; Shift left 6 bits
                             	sta IO_0+PRB
                             
                             	; Restore A
                             	lda tmp_bank1
                             	; JSR to the routine
                             	jsr addr
                             	
AS65 Assembler for R6502 [1.42].                                     Page   17
-------------------------------- bank\bank0.s --------------------------------

                             	jmp _restore_bank
                             	; 62 clock cycles inc restore vs 6 for a near js
                             
                             	endm
                             	
                             _bankram macro bank
                             	pha
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
                             	sta IO_0+PRB
                             	pla
                             	endm
                             	
                             _bankram_fast macro bank
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
                             	sta IO_0+PRB
                             	endm
                             	
                             
                             	include "kernel\zeropage.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ZEROPAGE.I
                             ;*  This module name is misleading it is not only
                             ;*  allocations, but also page 2, 3, 4, 5, 6, 7 a
                             ;*  Basically, this module defines:
                             ;*  - All zero page variables for system and dfla
                             ;*  - Page 1 is stack so no need to worry about t
                             ;*  - Page 2 is the serial IO buffer for the 6551
                             ;*  - Page 3 and 4 is a 512 buffer for SD card se
                             ;*  - Page 5 onwards is mainly for dflat working 
                             ;*    but also non-zero page storage for general 
                             ;*    system and scratch usage.
                             ;*  memstart is a handy label that indicates the 
                             ;*  location that we can store dflat programs fro
                             ;*  Zero page is a valuable asset as the 6502 can
                             ;*  this page one cycle quicker than the rest of 
                             ;*  and infact some addressing modes can only use
                             ;*  Due to the value of zero page, a lot of syste
                             ;*  dflat variables are put here.  But we don't h
                             ;*  luxury for single use variables - so you will
                             ;*  see a lot of temporary sounding names which a
                             ;*  have multiple used across the code base.
                             ;*
                             ;************************************************
                             
                             	; Zero page declarations
                             	bss
0000 =                       	org 0x0000
                             
0000 =                       tmp_bank1	ds	1		; Temp storage ONLY FOR USE BY BA
0001 =                       tmp_bank2	ds	1		; Temp storage ONLY FOR USE BY BA
                             
AS65 Assembler for R6502 [1.42].                                     Page   18
-------------------------------- bank\bank0.s --------------------------------

                             ; Interrupt routine addresses
0002 =                       int_nmi		 ds 2		; Master NMI handler
0004 =                       int_irq		 ds	2		; Master IRQ handler
0006 =                       int_brk		 ds	2		; Master BRK handler
0008 =                       int_uservdp	 ds	2		; Where to jump for VDP interr
000a =                       int_usercia0 ds	2		; Where to jump for CIA0 inter
000c =                       int_usercia1 ds	2		; Where to jump for CIA1 inter
                             
                             ; Serial FIFO buffer pointers
000e =                       ser_first	ds	1		; Pointer to first byte in buffer
000f =                       ser_last	ds	1		; Pointer to last byte in buffer
                             ; VDP parameters
0010 =                       vdp_int_cnt	ds  2		; VDP interrupt counter
0012 =                       vdp_curoff	ds	1		; Cursor off (0 = On)
0013 =                       vdp_curstat	ds	1		; Cursor status
0014 =                       vdp_curval	ds	1		; Cursor value on screen
0015 =                       vdp_blank	ds	1		; Screen blank value normally 32
0016 =                       vdp_delay	ds	1		; Delay counter for VRAM access
                             
                             ; vdp settings
0017 =                       vdp_base	ds	vdp_addr_struct
                             
                             ; Screen geometry
0023 =                       gr_scrngeom	ds	gr_screen
                             
                             ;Keyboard parameters
0033 =                       kb_raw  	ds	1		; Raw keyboard code
0034 =                       kb_last		ds	1		; Raw code of last key
0035 =                       kb_code 	ds	1		; Converted keyboard code
0036 =                       kb_stat		ds	1		; Keyboard status for caps and shi
0037 =                       kb_deb		ds	1		; VB periods since last KB spike
0038 =                       kb_rep		ds	1		; Keyboard repeat timer
0039 =                       kb_rep_tim 	ds	1		; Default repeat speed
003a =                       kb_rep_del 	ds	1		; Default repeat delay timing
003b =                       kb_debounce ds	1		; Default repeat debounce
003c =                       kb_pressed	ds	1		; Set by the interrupt handler i
                             
003d =                       tmp_c		ds	2		; Temp address c
003f =                       tmp_v1		ds	2		; VDP temp addresses
0041 =                       tmp_a		ds	2		; Temp storage a
0043 =                       tmp_b 		ds	2		; Temp address b
0045 =                       tmp_d		ds	2		; Temp storage d
                             
                             ; Raw input/output parameters
0047 =                       buf_adr		ds	2		; Line buffer address
0049 =                       buf_sz		ds	1		; Buffer size
004a =                       buf_ef		ds	1		; End file / line marker
                             
                             ; SD card driver parameters
004b =                       sd_status	ds	1		; SD card status
004c =                       sd_slo		ds	1		; Sector pointer low
004d =                       sd_shi		ds	1		; Sector pointer high
004e =                       sd_sect		ds	4		; SD Card sector address
0052 =                       sd_addr		ds	4		; SD Card byte address
                             
                             ; File system zp parameters
0056 =                       fh_handle	ds	FileHandle ; File handle parameters
                             
                             ; ** Integer function storage **
0085 =                       ztmp_16					; Start of 16 byte scratch area (all 
0085 =                       num_a		ds	4		; 4 byte primary accumulator
0089 =                       num_b		ds	4		; 4 byte secondary accumulator
AS65 Assembler for R6502 [1.42].                                     Page   19
-------------------------------- bank\bank0.s --------------------------------

008d =                       num_x		ds	4		; 4 byte x register
0091 =                       num_tmp		ds	4		; 4 byte temp space
0095 =                       num_buf		ds	8		; 8 byte string buffer
                             
                             ;
                             ; **** INTERPRETER ZERO PAGE ****
                             ;
009d =                       dflat_zp_s
009d =                       dflat_zp_save_s			; ZP save dflat from here
009d =                       df_checkkey	ds	1		; Key check interval counter
009e =                       df_checkmsk	ds	1		; Mask for check key
009f =                       errno		ds	1		; General error condition status
00a0 =                       df_immed	ds	1		; Immediate mode (0 = not immediat
00a1 =                       df_sp		ds	1		; Stack pointer after error to resto
00a2 =                       df_pc		ds	2		; PC after error to return to
00a4 =                       df_brkpc	ds	2		; PC pushed on the stack for BRK
00a6 =                       df_brkval	ds	1		; Byte after BRK instruction
00a7 =                       df_prgstrt	ds	2		; Start of program code
00a9 =                       df_prgend	ds	2		; End of program code
00ab =                       df_vntstrt	ds	2		; Variable name table start
00ad =                       df_vntend	ds	2		; Variable name table end
00af =                       df_vvtstrt	ds	2		; Variable value table start
00b1 =                       df_vvtend	ds	2		; Variable value table end
00b3 =                       df_varcnt	ds	1		; Variable counter
00b4 =                       df_starstrt	ds	2		; String and array table start
00b6 =                       df_starend	ds	2		; String and array table end
00b8 =                       df_rtstop	ds	1		; Runtime stack pointer
00b9 =                       df_parmtop	ds	1		; Top of parameter stack (grows 
00ba =                       df_strbuff	ds	1		; String expression buffer
00bb =                       df_stridx	ds	1		; Top of string buffer (grows dow
00bc =                       df_sevalptr	ds	2		; Pointer to next free char in 
                             
00be =                       df_linoff	ds	1		; Offset in to line buffer
00bf =                       df_tokoff	ds	1		; Offset in to tokenised buffer
00c0 =                       df_eolidx	ds	1		; End of line index (i.e length)
00c1 =                       df_nxtstidx	ds	1		; Offset to the next statement 
00c2 =                       df_curstidx	ds	1		; Offset to the start of curren
00c3 =                       df_symtab	ds	2		; Pointer to next free symtab ent
00c5 =                       df_symoff	ds	1		; Offset in to token table
00c6 =                       df_symini	ds	2		; Start of symtab
00c8 =                       df_currlin	ds	2		; Execution current line pointer
00ca =                       df_exeoff	ds	1		; Execution line buffer offset
00cb =                       df_nextlin	ds	2		; Next line to execute
00cd =                       df_procmode	ds	1		; Only used during tokenisation
00ce =                       df_procargs	ds	1		; Only used during tokenisation
00cf =                       df_procloc	ds	1		; Counts the number of local par
00d0 =                       df_procptr	ds	2		; Pointer to proc vvt slot
00d2 =                       df_lineptr	ds	2		; Pointer to line during searche
00d4 =                       df_lineidx	ds	1		; Pointer to line index during s
00d5 =                       df_ifnest	ds	1		; Global nested if counter
00d6 =                       df_currdat	ds	2		; Data current line pointer
00d8 =                       df_datoff	ds	1		; Data line buffer offset
00d9 =                       df_rnd		ds	2		; Random number seed
                             
00db =                       df_asmpc	ds	2		; Assembler program counter
00dd =                       df_asmopt	ds	1		; Assembler current option
00de =                       df_asmadmd	ds	1		; Addressing mode
00df =                       df_asmopcde	ds	1		; Current opcode
00e0 =                       df_asmoprnd	ds	2		; Current operand
00e2 =                       df_asmlen	ds	1		; Instruction length
                             
00e3 =                       dflat_zp_save_e			; Save up to this place
AS65 Assembler for R6502 [1.42].                                     Page   20
-------------------------------- bank\bank0.s --------------------------------

                             
                             ; Temp space for dflat
00e3 =                       df_tmpptra	ds	2		; Temp pointer a
00e5 =                       df_tmpptrb	ds	2		; Temp pointer b
00e7 =                       df_tmpptrc	ds	2		; Temp pointer c
00e9 =                       df_tmpptrd	ds	2		; Temp pointer d
00eb =                       df_tmpptre	ds	2		; Temp pointer e
                             
                             
                             ;***** END OF ZERO PAGE *****
00ed =                       _end_zero_page
                             
                             ;***** Page 1 is CPU stack ****
0100 =                       	org 0x0100
0100 =                       _cpu_stack
0100 =                       			ds	256		; All of page 1
                             
                             ;***** Page 2 and 3 is SD card buffer
0200 =                       	org 0x0200			; SD Card data buffer 512 bytes
0200 =                       sd_buf		ds	512
                             
                             ;***** Page 4,5,6,7 is IO space
0400 =                       	org 0x0400
0400 =                       			ds	1024	; 1 k area divided in to 8x128 byte de
                             
                             
                             ;***** Page 8 is serial buffer *****
0800 =                       	org 0x0800
0800 =                       ser_buf		ds	256		; Serial input / output line buf
                             
                             ;***** Scratch area, used by many things - do not
                             ; string and numeric expression evaluation, scree
0900 =                       	org 0x0900
0900 =                       scratch		ds	256
                             
                             ;***** Dflat space *****
0a00 =                       	org 0x0a00			; Page 9 = dflat space
0a00 =                       df_linbuff
0a00 =                       df_raw		ds	128		; untokenised input line
0a80 =                       df_tokbuff
0a80 =                       df_tok		ds 	128		; tokenised output line
                             
0b00 =                       	org 0x0b00			; Page 10 = fixed space for runtime
0b00 =                       df_rtstck				; operator stack grows up, runtime g
0b00 =                       df_rtspace	ds	256
                             
                             ;***** NON-ZERO PAGE VARIABLES *****
                             
                             ; Active IO device settings
0c00 =                       io_default	ds	1		; The default device number - es
                             ; Copy of jump tables to active device io routine
0c01 =                       io_block	ds	io_struct
                             
                             ; Copy of FAT16 directory
0c11 =                       fs_direntry	ds	FATFileDesc ; copy of dir entry - 
                             
                             ; Filesystem parameters
0c31 =                       fs_bootsect	ds	4		; Start of partition (usually 0
0c35 =                       fs_fatsect	ds	4		; Start of FAT tables
0c39 =                       fs_rootsect	ds	4		; Start of Root Directory
0c3d =                       fs_datasect	ds	4		; Start of Data Area
0c41 =                       fs_dirsect	ds	4		; Current directory sector numbe
AS65 Assembler for R6502 [1.42].                                     Page   21
-------------------------------- bank\bank0.s --------------------------------

0c45 =                       fs_dirclust	ds	2		; Current directory cluster num
                             
                             ; Working and scratch for filesystem - some data 
0c47 =                       fs_scratch	ds	32		; 32 bytes should be more than 
                             
                             ; Dflat top of memory+1 - normally initialised to
0c67 =                       df_memtop	ds	2
                             
                             ;***** THIS IS THE START OF FREE SPACE for DFLAT 
0c69 =                       mem_start
                             
                             
                             
                             
                             ;****************************************
                             ;*	Set 6502 default vectors	*
                             ;****************************************
                             	data				; Set vectors
fffa =                       	org 0xfffa			; Vectors lie at addresses
fffa : f7c6                  	fcw call_nmi_master	; 0xfffa : NMI Vector
fffc : e4ca                  	fcw init			; 0xfffc : Reset Vector
fffe : 34c7                  	fcw call_irq_master	; 0xfffe : IRQ Vector
                             	
                             	; ROM code
                             	code				;  
c000 =                       	org 0xc000			; Start of ROM
                             
                             	; The bank number is hardwired and aligned to PB
c000 :                       bank_num
                             	if BANK0
c000 : c0                    	  db 192
                             	endif
                             	if BANK1
                             	  db 128
                             	endif
                             	if BANK2
                             	  db 64
                             	endif
                             	if BANK3
                             	  db 0
                             	endif
                             
c001 :                       _code_start
                             	; Restore current bank always at address c001
c001 :                       _OSVectors
                             	include "kernel\osvec.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  OSVEC.S
                             ;*  Simply this is a bunch of JMP XXXX the order 
                             ;*  will always be maintained.  This is to allow 
                             ;*  code programs to be able to rely on fixed loc
                             ;*  some key low-level functions.
                             ;*  Only low level functions are needed, the idea
                             ;*  as the assembler is part of the BASIC, one ca
                             ;*  level slow stuff using BASIC then switch to M
AS65 Assembler for R6502 [1.42].                                     Page   22
-------------------------------- bank\bank0.s --------------------------------

                             ;*  speed up.
                             ;*  This code goes straight after the bank number
                             ;*  Each JMP is at 0xc001+3*(vector #)
                             ;*
                             ;************************************************
                             
c001 : 4c60c5           [ 3] 	jmp	io_put_ch			; Vec 0
c004 : 4c5dc5           [ 3] 	jmp io_get_ch			; Vec 1
c007 : 4cf0c5           [ 3] 	jmp vdp_wr_reg			; Vec 2
c00a : 4c28c6           [ 3] 	jmp vdp_poke			; Vec 3
c00d : 4c34c6           [ 3] 	jmp vdp_peek			; Vec 4
c010 : 4c95c6           [ 3] 	jmp snd_get_joy0		; Vec 5
c013 : 4c3dc6           [ 3] 	jmp snd_set				; Vec 6
c016 : 4cfdc5           [ 3] 	jmp vdp_wr_addr			; Vec 7
c019 : 4c14c6           [ 3] 	jmp	vdp_rd_addr			; Vec 8
c01c :                       _restore_bank
                             	; Save A
c01c : 8500             [ 3] 	sta tmp_bank1
                             	; Get old bank from stack
c01e : 68               [ 4] 	pla
c01f : 8501             [ 3] 	sta tmp_bank2
c021 : ad0004           [ 4] 	lda IO_0+PRB
c024 : 293f             [ 2] 	and #ROM_ZMASK
c026 : 0501             [ 3] 	ora tmp_bank2
c028 : 8d0004           [ 4] 	sta IO_0+PRB
                             	
                             	; Restore A
c02b : a500             [ 3] 	lda tmp_bank1
                             
c02d : 60               [ 6] 	rts
                             
                             	; include cross-bank functions (see extern.mak)
                             	include "bank\autogen.s"	
                             ; 
c02e :                       mod_sz_autogen_s 
c02e :                       _df_init 
                               _bankjsr $f1da, 1 
                             
c046 :                       _df_pg_dflat 
                               _bankjsr $d781, 1 
                             
c05e :                       _fs_chdir_w 
                               _bankjsr $d511, 2 
                             
c076 :                       _fs_mkdir_w 
                               _bankjsr $d5a4, 2 
                             
c08e :                       _fs_delete_w 
                               _bankjsr $d4ad, 2 
                             
c0a6 :                       _fs_close_w 
                               _bankjsr $d46c, 2 
                             
c0be :                       _fs_get_byte_w 
                               _bankjsr $d189, 2 
                             
c0d6 :                       _fs_open_read_w 
                               _bankjsr $d358, 2 
                             
c0ee :                       _fs_open_write_w 
                               _bankjsr $d41c, 2 
                             
AS65 Assembler for R6502 [1.42].                                     Page   23
-------------------------------- bank\bank0.s --------------------------------

c106 :                       _fs_put_byte_w 
                               _bankjsr $d2e5, 2 
                             
c11e :                       _fs_dir_find_entry_w 
                               _bankjsr $cfcc, 2 
                             
c136 :                       _fs_dir_entry_next_w 
                               _bankjsr $d002, 2 
                             
c14e :                       _fs_dir_root_start_w 
                               _bankjsr $cf87, 2 
                             
c166 :                       _get_byte 
                               _bankjsr $d1d1, 0 
                             
c17e :                       _put_byte 
                               _bankjsr $d1e6, 0 
                             
c196 :                       _gr_get_key 
<<<<<<< HEAD
                               _bankjsr $e28c, 0 
                             
c1ae :                       _gr_put_byte 
                               _bankjsr $e299, 0 
=======
                               _bankjsr $df90, 0 
                             
c1ae :                       _gr_put_byte 
                               _bankjsr $df9d, 0 
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
c1c6 :                       _gr_init_screen 
                               _bankjsr $dd59, 0 
                             
c1de :                       _init_acia 
                               _bankjsr $d1f3, 0 
                             
c1f6 :                       _init_cia0 
                               _bankjsr $d17e, 0 
                             
c20e :                       _init_cia1 
                               _bankjsr $d1af, 0 
                             
c226 :                       _init_fs 
                               _bankjsr $ce64, 2 
                             
c23e :                       _init_sdcard 
                               _bankjsr $cb5e, 2 
                             
c256 :                       _init_snd 
                               _bankjsr $d5bc, 0 
                             
c26e :                       _init_keyboard 
                               _bankjsr $d205, 0 
                             
c286 :                       _kb_read_raw 
                               _bankjsr $d214, 0 
                             
c29e :                       _kb_read_dip 
                               _bankjsr $d27f, 0 
                             
c2b6 :                       _command_line 
                               _bankjsr $cb5e, 0 
                             
c2ce :                       _gr_cls 
                               _bankjsr $dd6c, 0 
                             
c2e6 :                       _gr_init_hires 
<<<<<<< HEAD
                               _bankjsr $dd16, 0 
AS65 Assembler for R6502 [1.42].                                     Page   24
-------------------------------- bank\bank0.s --------------------------------

                             
c2fe :                       _gr_line 
                               _bankjsr $e0c6, 0 
                             
c316 :                       _gr_box 
                               _bankjsr $df06, 0 
                             
c32e :                       _gr_circle 
                               _bankjsr $e011, 0 
=======
                               _bankjsr $da16, 0 
                             
c2fe :                       _gr_line 
                               _bankjsr $ddca, 0 
                             
c316 :                       _gr_box 
                               _bankjsr $dc0a, 0 
                             
c32e :                       _gr_circle 
AS65 Assembler for R6502 [1.42].                                     Page   24
-------------------------------- bank\bank0.s --------------------------------

                               _bankjsr $dd15, 0 
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
c346 :                       _gr_plot 
                               _bankjsr $ddd7, 0 
                             
c35e :                       _gr_hchar 
                               _bankjsr $de15, 0 
                             
c376 :                       _gr_point 
                               _bankjsr $debb, 0 
                             
c38e :                       _gr_get 
                               _bankjsr $ddf2, 0 
                             
c3a6 :                       _gr_set_cur 
                               _bankjsr $ddfa, 0 
                             
c3be :                       _snd_get_note 
                               _bankjsr $d5b5, 0 
                             
c3d6 :                       _snd_get_joy0 
                               _bankjsr $c695, 0 
                             
c3ee :                       _snd_set 
                               _bankjsr $c63d, 0 
                             
c406 :                       _vdp_peek 
                               _bankjsr $c634, 0 
                             
c41e :                       _vdp_poke 
                               _bankjsr $c628, 0 
                             
c436 :                       _vdp_init 
                               _bankjsr $db00, 0 
                             
c44e :                       _rtc_init 
                               _bankjsr $d3db, 0 
                             
c466 :                       _rtc_gettimedate 
                               _bankjsr $d541, 0 
                             
c47e :                       _rtc_setdatetime 
                               _bankjsr $d492, 0 
                             
c496 :                       _rtc_nvread 
                               _bankjsr $d5ac, 0 
                             
c4ae :                       _rtc_nvwrite 
                               _bankjsr $d594, 0 
                             
c4c6 :                       _fs_dir_fhandle_str 
                               _bankjsr $d5b8, 2 
                             
c4de :                       _sd_sendcmd17 
AS65 Assembler for R6502 [1.42].                                     Page   25
-------------------------------- bank\bank0.s --------------------------------

                               _bankjsr $cd36, 2 
                             
c4f6 :                       _sd_sendcmd24 
                               _bankjsr $cdaf, 2 
                             
c50e :                       _cmd_immediate 
                               _bankjsr $cb6a, 0 
                             
c526 :                       mod_sz_autogen_e 
                             
                             	
c526 :                       mod_sz_kernel_s
                             
                             ;* Include all common code in the right order
                             	include "io\io.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.S
                             ;*  General IO module.  Allows different IO devic
                             ;*  utilised transparently by the rest of the cod
                             ;*  Other code should use "io_" commands so that 
                             ;*  do not need to know what specific device is p
                             ;*  input and output capabilities.  On startup, t
                             ;*  examines the BBC DIP switch to decide whether
                             ;*  initialise the IO to serial through the ACIA 
                             ;*  the BBC keyboard for input with the VDP for o
                             ;*  Loading and saving files from the SD card is 
                             ;*  achieved by pointing to SD card get and put b
                             ;*  routines.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c526 :                       mod_sz_io_s
                             
                             ;****************************************
                             ;* io_init
                             ;* Initialise the default device and make active
                             ;* No keys pressed = serial (default)
                             ;* F0 pressed = KB/VDP
                             ;* F1 pressed = Serial
                             ;* Keyboard and screen or serial port
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c526 :                       io_init
c526 : a900             [ 2] 	lda #0				; Assume it's serial
c528 : 48               [ 3] 	pha
c529 : 209ec2           [ 6] 	jsr _kb_read_dip	; Check DIPs if 0xff then assum
c52c : 2910             [ 2] 	and #0x10
c52e : d00b             [ 3] 	bne io_init_set_default
c530 : 2086c2           [ 6] 	jsr _kb_read_raw	; Check pressed key
c533 : e081             [ 2] 	cpx #0x81			; f1 key pressed (i.e. boot up in se
c535 : f004             [ 3] 	beq io_init_set_default
AS65 Assembler for R6502 [1.42].                                     Page   26
-------------------------------- bank\bank0.s --------------------------------

                             	; Else set to KB/screen for IO
c537 : 68               [ 4] 	pla
c538 : a901             [ 2] 	lda #1
c53a : 48               [ 3] 	pha
c53b :                       io_init_set_default
c53b : 68               [ 4] 	pla
c53c : 8d000c           [ 4] 	sta io_default
c53f : 4c42c5           [ 3] 	jmp io_set_default	; Activate the default device
                             
                             ;****************************************
                             ;* io_set_default, io_active_device
                             ;* Activate device based on default or A
                             ;* Input : A = Device number
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c542 :                       io_set_default			; Entry point for default
c542 : ad000c           [ 4] 	lda io_default
c545 :                       io_active_device		; Entry point for A set
c545 : 0a               [ 2] 	asl	a				; x16 the Block number
c546 : 0a               [ 2] 	asl a
c547 : 0a               [ 2] 	asl a
c548 : 0a               [ 2] 	asl a
c549 : a8               [ 2] 	tay
c54a : a200             [ 2] 	ldx #0
                             	; Copy device settings to io block
c54c :                       io_copy_data
c54c : b9c0c5           [ 4] 	lda io_devices,y
c54f : 9d010c           [ 5] 	sta io_block,x
c552 : c8               [ 2] 	iny
c553 : e8               [ 2] 	inx
c554 : e010             [ 2] 	cpx #io_struct
c556 : d0f4             [ 3] 	bne io_copy_data
                             	
c558 : a90d             [ 2] 	lda #UTF_CR		; Line terminator is CR
c55a : 854a             [ 3] 	sta buf_ef
c55c : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* io_get_ch
                             ;* Get a char (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 0 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
c55d :                       io_get_ch
c55d : 6c010c           [ 6] 	jmp (io_block+io_get_byte)
                             	
                             
                             ;****************************************
                             ;* io_put_ch
                             ;* Put a char
                             ;* Input : A = char
                             ;* Regs affected : P, A
                             ;****************************************
c560 :                       io_put_ch
c560 : 6c030c           [ 6] 	jmp (io_block+io_put_byte)
                             	
                             ;****************************************
                             ;* io_open_read
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
AS65 Assembler for R6502 [1.42].                                     Page   27
-------------------------------- bank\bank0.s --------------------------------

                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c563 :                       io_open_read
c563 : 6c050c           [ 6] 	jmp (io_block+io_open_r)
                             	
                             ;****************************************
                             ;* io_open_write
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c566 :                       io_open_write
c566 : 6c070c           [ 6] 	jmp (io_block+io_open_w)
                             
                             ;****************************************
                             ;* io_close
                             ;* Close a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c569 :                       io_close
c569 : 6c090c           [ 6] 	jmp (io_block+io_close_f)
                             	
                             ;****************************************
                             ;* io_delete
                             ;* Delete a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c56c :                       io_delete
c56c : 6c0b0c           [ 6] 	jmp (io_block+io_del_f)
                             	
                             ;****************************************
                             ;* io_read_line
                             ;* Read a line, terminated by terminating char or
                             ;* Input : buf_(sz/ef) : Address, Max size, end m
                             ;*		    X,A = destination (uses buf_adr)
                             ;*		    Y=max line length
                             ;* Output : Y = Line length C = Buffer limit reac
                             ;* Regs affected : None
                             ;****************************************
c56f :                       io_read_line
c56f : 8647             [ 3] 	stx buf_adr			; Save pointer to storage
c571 : 8548             [ 3] 	sta buf_adr+1
c573 : 8449             [ 3] 	sty buf_sz			; Max length
c575 : 08               [ 3] 	php					; Save echo state
c576 : a000             [ 2] 	ldy #0x00			; Starting at first byte
c578 :                       io_get_line_byte
c578 : 38               [ 2] 	sec					; Getting bytes synchronously
c579 : 205dc5           [ 6] 	jsr io_get_ch		; Get a byte
c57c : b026             [ 3] 	bcs io_get_line_done; Got nothing then finish
c57e : 28               [ 4] 	plp					; Get echo state
c57f : 08               [ 3] 	php					; Instantly save it back
c580 : 900c             [ 3] 	bcc io_skip_echo	; Carry not set = don't echo
c582 : c97f             [ 2] 	cmp #UTF_DEL		; Delete?
c584 : d005             [ 3] 	bne io_do_echo
c586 : c000             [ 2] 	cpy #0				; Already at beginning?
c588 : f004             [ 3] 	beq io_skip_echo	; Don't echo delete
AS65 Assembler for R6502 [1.42].                                     Page   28
-------------------------------- bank\bank0.s --------------------------------

c58a : 88               [ 2] 	dey					; Else decrement length
c58b :                       io_do_echo
c58b : 2060c5           [ 6] 	jsr io_put_ch		; Echo it
c58e :                       io_skip_echo
c58e : c920             [ 2] 	cmp #UTF_SPECIAL	; Special character?
c590 : 9007             [ 3] 	bcc io_skip_special	; Skip if so (don't add to b
c592 : c97f             [ 2] 	cmp #UTF_DEL		; Don't proces DEL either
c594 : f003             [ 3] 	beq io_skip_special
c596 : 9147             [ 5] 	sta (buf_adr),y		; Save it
c598 : c8               [ 2] 	iny					; Increase length
c599 :                       io_skip_special
c599 : c54a             [ 3] 	cmp buf_ef			; Is it the terminating char?
c59b : f007             [ 3] 	beq io_get_line_done	; If yes then done
c59d : c449             [ 3] 	cpy buf_sz			; Reached the buffer max size?
c59f : d0d7             [ 3] 	bne io_get_line_byte	; No, get another byte
c5a1 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c5a2 : 38               [ 2] 	sec					; Yes, set carry flag
c5a3 : 60               [ 6] 	rts					; And done
c5a4 :                       io_get_line_done
c5a4 : a900             [ 2] 	lda #0
c5a6 : 9147             [ 5] 	sta (buf_adr),y		; Terminate with 0
c5a8 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c5a9 : 18               [ 2] 	clc					; Clear carry flag
c5aa : 60               [ 6] 	rts					; Fin
                             
                             ;****************************************
                             ;* io_print_line
                             ;* Print a line (when data is not already in seri
                             ;* Input : X = Address Lo, A = Address Hi
                             ;* Output : Y=number chars output
                             ;* Regs affected : All
                             ;****************************************
c5ab :                       io_print_line
c5ab : 48               [ 3] 	pha
                             
c5ac : 863d             [ 3] 	stx tmp_c					; Store the string pointer
c5ae : 853e             [ 3] 	sta tmp_c+1					; lo and hi
c5b0 : a000             [ 2] 	ldy #0						; Start at the beginning!
c5b2 :                       io_print_line_byte
c5b2 : b13d             [ 5] 	lda (tmp_c),y				; Copy byte to
c5b4 : f006             [ 3] 	beq io_print_done			; If zero then done - print
c5b6 : 2060c5           [ 6] 	jsr io_put_ch				; Transmit
c5b9 : c8               [ 2] 	iny
c5ba : d0f6             [ 3] 	bne io_print_line_byte		; Carry on until zero fo
c5bc :                       io_print_done
c5bc : 68               [ 4] 	pla
c5bd : 60               [ 6] 	rts
                             
                             
                             ;*** Null operation just clc and return ***
c5be :                       io_null_op
c5be : 18               [ 2] 	clc
c5bf : 60               [ 6] 	rts
                             	
                             ;* IO devices defined here
c5c0 :                       io_devices
                             ;* Device zero is the serial port
                             ;* only offers get and put
c5c0 :                       io_device0					; Serial device, input = Ser, outp
c5c0 : 66c1                  	dw	_get_byte			; io_get_ch
c5c2 : 7ec1                  	dw	_put_byte			; io_put_ch
c5c4 : bec5                  	dw	io_null_op			; io_open_r
AS65 Assembler for R6502 [1.42].                                     Page   29
-------------------------------- bank\bank0.s --------------------------------

c5c6 : bec5                  	dw	io_null_op			; io_open_w
c5c8 : bec5                  	dw	io_null_op			; io_close_f
c5ca : bec5                  	dw	io_null_op			; io_del_f
c5cc : bec5                  	dw	io_null_op			; io_ext1
c5ce : bec5                  	dw	io_null_op			; io_ext2
                             ;* Device one is keyboard / screen
                             ;* only offers get and put
c5d0 :                       io_device1					; Default device, input = screen e
c5d0 : 96c1                  	dw	_gr_get_key			; io_get_ch
c5d2 : aec1                  	dw	_gr_put_byte		; io_put_ch
c5d4 : bec5                  	dw	io_null_op			; io_open_r
c5d6 : bec5                  	dw	io_null_op			; io_open_w
c5d8 : bec5                  	dw	io_null_op			; io_close_f
c5da : bec5                  	dw	io_null_op			; io_del_f
c5dc : bec5                  	dw	io_null_op			; io_ext1
c5de : bec5                  	dw	io_null_op			; io_ext2
                             ;* Device two is the file system on SD card
                             ;* Offers all IO functions
c5e0 :                       io_device2					; SD device, input = SD, output = 
c5e0 : bec0                  	dw	_fs_get_byte_w		; io_get_ch
c5e2 : 06c1                  	dw	_fs_put_byte_w		; io_put_ch
c5e4 : d6c0                  	dw	_fs_open_read_w		; io_open_r
c5e6 : eec0                  	dw	_fs_open_write_w	; io_open_w
c5e8 : a6c0                  	dw	_fs_close_w			; io_close_f
c5ea : 8ec0                  	dw	_fs_delete_w		; io_del_f
c5ec : bec5                  	dw	io_null_op			; io_ext1
c5ee : bec5                  	dw	io_null_op			; io_ext2
                             
c5f0 :                       mod_sz_io_e
                             
                             
                             	include "kernel\vdp-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  VDP-LOW.S
                             ;*  Low level VDP routines which will always be p
                             ;*  every ROM bank.  This is to ensure if IRQ nee
                             ;*  no slow bank switching is needed, but also to
                             ;*	OS vectored access to VDP routines for M/C fro
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* vdp_wr_reg
                             ;* Write to Register A the value X
                             ;* Input : A - Register Number, X - Data
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c5f0 :                       vdp_wr_reg
c5f0 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c5f3 : ea               [ 2] 	nop
c5f4 : ea               [ 2] 	nop
c5f5 : 0980             [ 2] 	ora #0x80
c5f7 : 8d0105           [ 4] 	sta VDP_MODE1
AS65 Assembler for R6502 [1.42].                                     Page   30
-------------------------------- bank\bank0.s --------------------------------

c5fa : 4980             [ 2] 	eor #0x80
c5fc : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* vdp_wr_addr
                             ;* Write to address in X (low) and A (high) - for
                             ;* Input : A - Address high byte, X - Address low
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c5fd :                       vdp_wr_addr
c5fd : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c600 : ea               [ 2] 	nop
c601 : ea               [ 2] 	nop
c602 : 0940             [ 2] 	ora #0x40		; Required by VDP
c604 : 8d0105           [ 4] 	sta VDP_MODE1
c607 : 4940             [ 2] 	eor #0x40		; Undo that bit
c609 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* vdp_mem_wait
                             ;* Delay some time before a memory access,
                             ;* taking in to account mode 9918 needs up
                             ;* to 3.1uS for text mode, 8uS for graphics
                             ;* I and II
                             ;* @ 5.35Mhz	= 16 cycles for 3.1uS
                             ;*				= 43 cycles for 8uS
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c60a :                       vdp_mem_wait
c60a : da               [ 3] 	phx								; 3
c60b : a616             [ 3] 	ldx vdp_delay					; 3
c60d : f003             [ 3] 	beq vdp_mem_wait_end			; 3
c60f :                       vdp_mem_wait_loop
c60f : ca               [ 2] 	dex								; 2
c610 : d0fd             [ 3] 	bne	vdp_mem_wait_loop			; 3
c612 :                       vdp_mem_wait_end
c612 : fa               [ 4] 	plx								; 3
c613 : 60               [ 6] 	rts								; 6
                             	
                             ;****************************************
                             ;* vdp_rd_addr
                             ;* Set read address 
                             ;* Input : A - high, X - low 
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c614 :                       vdp_rd_addr
c614 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; These nops are needed for fast CPU
c617 : ea               [ 2] 	nop
c618 : ea               [ 2] 	nop
c619 : 8d0105           [ 4] 	sta VDP_MODE1
c61c : 80ec             [ 3] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_rd_vram
                             ;* Read VRAM byte, result in A
AS65 Assembler for R6502 [1.42].                                     Page   31
-------------------------------- bank\bank0.s --------------------------------

                             ;* Input : None
                             ;* Output : A - Byte from VRAM
                             ;* Regs affected : P
                             ;****************************************
c61e :                       vdp_rd_vram
c61e : ad0005           [ 4] 	lda VDP_VRAM
c621 : 80e7             [ 3] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_wr_vram
                             ;* Write VRAM byte in A
                             ;* Input : A - Byte to write
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c623 :                       vdp_wr_vram
c623 : 8d0005           [ 4] 	sta VDP_VRAM
c626 : 80e2             [ 3] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_poke
                             ;* Write VRAM byte in A, (YX)
                             ;* Input : A - Byte to write
                             ;*		   X = Low Address
                             ;*		   Y = High Address
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c628 :                       vdp_poke
c628 : 48               [ 3] 	pha
c629 : 98               [ 2] 	tya
c62a : 78               [ 2] 	sei
c62b : 20fdc5           [ 6] 	jsr vdp_wr_addr
c62e : 68               [ 4] 	pla
c62f : 2023c6           [ 6] 	jsr vdp_wr_vram
c632 : 58               [ 2] 	cli
c633 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* vdp_peek
                             ;* Get VRAM byte in (AX)
                             ;*		   X = Low Address
                             ;*		   A = High Address
                             ;* Output : A = byte read
                             ;* Regs affected : None
                             ;****************************************
c634 :                       vdp_peek
c634 : 78               [ 2] 	sei
c635 : 2014c6           [ 6] 	jsr vdp_rd_addr
c638 : 201ec6           [ 6] 	jsr vdp_rd_vram
c63b : 58               [ 2] 	cli
c63c : 60               [ 6] 	rts
                             
                             	include "kernel\snd-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   32
-------------------------------- bank\bank0.s --------------------------------

                             ;*  SND-LOW.S
                             ;*  Low level sound routines which will always be
                             ;*  in every ROM bank.  Mainly to provide fast OS
                             ;*	access to VDP routines for M/C from BASIC
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* snd_set
                             ;* Set AY register X to value Y
                             ;* Input : X = Reg no, Y = Value
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c63d :                       snd_set
c63d : 48               [ 3] 	pha
                             
c63e : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c640 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c643 : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c646 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c649 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c64b : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c64d : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c650 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c652 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             	
c655 : 8c8104           [ 4] 	sty SND_ADBUS			; Put Y on the sound bus (Y = va
c658 : 0902             [ 2] 	ora #SND_SELWRITE		; Select mode for writing dat
c65a : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             	
c65d : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c65f : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c662 : 68               [ 4] 	pla
                             	
c663 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get
                             ;* Get AY register X to Y
                             ;* Input : X = Reg no
                             ;* Output : Y = Value
                             ;* Regs affected : None
                             ;****************************************
c664 :                       snd_get
c664 : 48               [ 3] 	pha
                             
c665 : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c667 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c66a : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c66d : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c670 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c672 : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c674 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c677 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
AS65 Assembler for R6502 [1.42].                                     Page   33
-------------------------------- bank\bank0.s --------------------------------

c679 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c67c : a900             [ 2] 	lda #0x00				; Set Port A to input
c67e : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c681 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c684 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c686 : 0940             [ 2] 	ora #SND_SELREAD		; Select mode for reading data
c688 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c68b : ac8104           [ 4] 	ldy SND_ADBUS			; Get value in to Y
                             	
c68e : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c690 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c693 : 68               [ 4] 	pla
                             	
c694 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get_joy0
                             ;* Return value of joystick 0
                             ;* Input : None
                             ;* Output : Y = Value
                             ;* Regs affected : X
                             ;****************************************
c695 :                       snd_get_joy0
c695 : a20f             [ 2] 	ldx #SND_REG_IOB		; Joystick is plugged in to IO
c697 : 2064c6           [ 6] 	jsr snd_get				; Get IOB, result in Y
c69a : 60               [ 6] 	rts
                             
                             	include "kernel\main.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  MAIN.S
                             ;*  This is where the main user program is execut
                             ;*  the 'kernel' once the system is initialised a
                             ;*  Today, main does very little - first shows th
                             ;*  boot up message, and then passes control to d
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
c69b :                       main
                             
c69b :                       infinity
c69b : 2046c0           [ 6] 	jsr _df_pg_dflat
c69e : 4c9bc6           [ 3] 	jmp infinity
                             
c6a1 :                       msg_hello_world
                             	;* build.s is generated by the assemble.bat file
                             	;* all it does is echo an assembler line to
                             	;* including the build date in the message.
                             	include "kernel\build.s"
<<<<<<< HEAD
AS65 Assembler for R6502 [1.42].                                     Page   34
-------------------------------- bank\bank0.s --------------------------------

c6a1 : 4275696c64203a..       db "Build : 26/09/2024\r" 
c6b4 : 3132384b204272..       db "128K Breadboard Computer\r" 
c6cd : 42792040363530..       db "By @6502Nerd\r" 
c6da : 436f7079726967..       db "Copyright (c) 2024\r",0 
=======
c689 : 4275696c64203a..       db "Build : 03/09/2023\r" 
c69c : 3132384b204272..       db "128K Breadboard Computer\r" 
c6b5 : 42792040363530..       db "By @6502Nerd\r" 
c6c2 : 436f7079726967..       db "Copyright (c) 2022\r",0 
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             
                             	include "kernel\irq.s"
                             	
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IRQ.S
                             ;*	This is the IRQ handler - handles both the ver
                             ;*  blank interrupt from the VDP as well as softw
                             ;*  
                             ;*  As the handler has to be in every bank and it
                             ;*  accesses the VDP, then low level VDP routines
                             ;*  bundled in this file to ensure they are alway
                             ;*  without a bank switch being needed (which is 
                             ;************************************************
                             
                             ;* NMI handler installs to handle serial receive 
c6ee :                       init_nmi
                             	; Core IRQ handler
c6ee : a9f7             [ 2] 	lda #lo(nmi)
c6f0 : 8502             [ 3] 	sta int_nmi
c6f2 : a9c6             [ 2] 	lda #hi(nmi)
c6f4 : 8503             [ 3] 	sta int_nmi+1
c6f6 : 60               [ 6] 	rts
                             
                             ;* Calls the master IRQ handler
c6f7 :                       call_nmi_master
                             ;	jmp (int_nmi)
                             
                             ;* Master NMI handler
                             ;* Only the 6551 uses this - fills the receive bu
c6f7 :                       nmi
c6f7 : 48               [ 3] 	pha
                             
c6f8 : ad8105           [ 4] 	lda SER_STATUS				; Read status register (clears
c6fb : 100c             [ 4] 	bpl	nmi_fin					; If no interrupt don't do anyth
                             
c6fd : 5a               [ 3] 	phy
c6fe : ad8005           [ 4] 	lda SER_DATA				; Read the data register of 6551
c701 : a40f             [ 3] 	ldy ser_last				; Put byte in last position of F
c703 : 990008           [ 5] 	sta ser_buf,y
c706 : e60f             [ 5] 	inc ser_last				; Advance position of last
                             
c708 : 7a               [ 4] 	ply
c709 :                       nmi_fin
                             
c709 : 68               [ 4] 	pla
c70a : 40               [ 6] 	rti
                             
                             
                             ;* Obviously this can only be done with
                             ;* interrupts disabled!
AS65 Assembler for R6502 [1.42].                                     Page   35
-------------------------------- bank\bank0.s --------------------------------

c70b :                       init_irq
                             	; Core IRQ handler
c70b : a945             [ 2] 	lda #lo(irq)
c70d : 8504             [ 3] 	sta int_irq
c70f : a9c7             [ 2] 	lda #hi(irq)
c711 : 8505             [ 3] 	sta int_irq+1
                             	
                             	; Core BRK handler
c713 : a973             [ 2] 	lda #lo(irq_brk)
c715 : 8506             [ 3] 	sta int_brk
c717 : a9c7             [ 2] 	lda #hi(irq_brk)
c719 : 8507             [ 3] 	sta int_brk+1
                             
                             	; User handlers for VDP, PIA0, PIA1 interrupts
c71b : a944             [ 2] 	lda #lo(null_handler)
c71d : 8508             [ 3] 	sta int_uservdp
c71f : a9c7             [ 2] 	lda #hi(null_handler)
c721 : 8509             [ 3] 	sta int_uservdp+1
                             
c723 : a944             [ 2] 	lda #lo(null_handler)
c725 : 850a             [ 3] 	sta int_usercia0
c727 : a9c7             [ 2] 	lda #hi(null_handler)
c729 : 850b             [ 3] 	sta int_usercia0+1
                             
c72b : a944             [ 2] 	lda #lo(null_handler)
c72d : 850c             [ 3] 	sta int_usercia1
c72f : a9c7             [ 2] 	lda #hi(null_handler)
c731 : 850d             [ 3] 	sta int_usercia1+1
                             
c733 : 60               [ 6] 	rts
                             
                             ;* Calls the master IRQ handler
c734 :                       call_irq_master
c734 : 6c0400           [ 6] 	jmp (int_irq)
                             	
                             ;* Calls the BRK handler
c737 :                       call_irq_brk
c737 : 6c0600           [ 6] 	jmp (int_brk)
                             
                             ;* Call the userVDP handler
c73a :                       call_irq_uservdp
c73a : 6c0800           [ 6] 	jmp (int_uservdp)
                             	
                             ;* Call the user CIA0 handler
c73d :                       call_irq_usercia0
c73d : 6c0a00           [ 6] 	jmp (int_usercia0)
                             
                             ;* Call the user CIA1 handler
c740 :                       call_irq_usercia1
c740 : 6c0c00           [ 6] 	jmp (int_usercia1)
                             	
                             ;* null interrupt
c743 :                       null_irq
c743 : 40               [ 6] 	rti
                             
                             ;* null handler
c744 :                       null_handler
c744 : 60               [ 6] 	rts
                             	
                             
                             ;* Master IRQ handler
c745 :                       irq
AS65 Assembler for R6502 [1.42].                                     Page   36
-------------------------------- bank\bank0.s --------------------------------

                             	_pushAXY
                             
                             
                             	; Check if IRQ or BRK
                             	; load P from stack in to A
c748 : ba               [ 2] 	tsx
c749 : bd0401           [ 4] 	lda 0x104,x
                             	; BRK bit set?
c74c : 2910             [ 2] 	and #0x10
c74e : d0e7             [ 3] 	bne call_irq_brk
                             	
c750 : 18               [ 2] 	clc						; Standard behaviour
                             	
                             	;* Try PIA1 first for rapid Timer handling
c751 : ad8d04           [ 4] 	lda IO_1 + IFR
c754 : 1003             [ 3] 	bpl irq_check_vdp
c756 : 2040c7           [ 6] 	jsr call_irq_usercia1	; Call user cia1 handler
                             
                             	;* Try VDP next
c759 :                       irq_check_vdp	
c759 : ad0105           [ 4] 	lda VDP_STATUS			; Read status register
c75c : 1009             [ 3] 	bpl	irq_check_cia0		; Skip if not VBLANK
c75e : 203ac7           [ 6] 	jsr call_irq_uservdp	; Call use VDP handler
c761 : 20c0c7           [ 6] 	jsr int_vdp_handler		; Call  OS VDP handler
c764 : 209ec7           [ 6] 	jsr int_kb_handler		; Call OS cia0 handler (keyb
                             
                             	;* Try VIA0 last as it's keyboard (low speed)
c767 :                       irq_check_cia0
c767 : ad0d04           [ 4] 	lda IO_0 + IFR
c76a : 1003             [ 3] 	bpl irq_fin
c76c : 203dc7           [ 6] 	jsr call_irq_usercia0	; Call user cia0 handler
                             
c76f :                       irq_fin
                             	_pullAXY
                             
c772 : 40               [ 6] 	rti
                             	
                             ;* Handle BRK
c773 :                       irq_brk
                             	; Handle BRK
                             	; Get PCL,H minus 2 gives the BRK instruction ad
c773 : 38               [ 2] 	sec
c774 : bd0501           [ 4] 	lda 0x0105,x
c777 : e902             [ 2] 	sbc #2
c779 : 85a4             [ 3] 	sta df_brkpc
c77b : bd0601           [ 4] 	lda 0x0106,x
c77e : e900             [ 2] 	sbc #0
c780 : 85a5             [ 3] 	sta df_brkpc+1
                             	; Get the byte pointed to by old PC
                             	; which is 1 on from the BRK
c782 : a001             [ 2] 	ldy #1
c784 : b1a4             [ 5] 	lda (df_brkpc),y
c786 : 85a6             [ 3] 	sta df_brkval
c788 : 859f             [ 3] 	sta errno
                             	; now update the return address
c78a : a5a2             [ 3] 	lda df_pc
c78c : 9d0501           [ 5] 	sta 0x105,x
c78f : a5a3             [ 3] 	lda df_pc+1
c791 : 9d0601           [ 5] 	sta 0x106,x
                             	
                             	_pullAXY
                             
AS65 Assembler for R6502 [1.42].                                     Page   37
-------------------------------- bank\bank0.s --------------------------------

                             	; Save the registers in temp area
c797 : 8585             [ 3] 	sta num_a
c799 : 8686             [ 3] 	stx num_a+1
c79b : 8487             [ 3] 	sty num_a+2
                             	; when RTI occurs:
                             	;  will return to error handler
                             	;  df_brkval will contain signature
c79d : 40               [ 6] 	rti
                             	
                             ;****************************************
                             ;* int_kb_handler
                             ;* Keyboard interrupt handler
                             ;****************************************
c79e :                       int_kb_handler	
c79e : a537             [ 3] 	lda kb_deb				; If keyboard pressed is debounce 
c7a0 : d00d             [ 3] 	bne int_skip_scan		; If not zero, then don't che
c7a2 : ad0d04           [ 4] 	lda IO_0 + IFR			; Check status register CIA0
c7a5 : 2901             [ 2] 	and #IFR_CA2			; Keyboard pressed?
c7a7 : f00c             [ 3] 	beq int_keys_up
c7a9 :                       int_do_read
c7a9 : 853c             [ 3] 	sta kb_pressed			; Put non-zero in to this flag
c7ab : a53b             [ 3] 	lda kb_debounce			; Set debounce
c7ad : 8537             [ 3] 	sta kb_deb
c7af :                       int_skip_scan
c7af : a901             [ 2] 	lda #IFR_CA2			; Clear CA2
c7b1 : 8d0d04           [ 4] 	sta IO_0 + IFR
c7b4 : 60               [ 6] 	rts
c7b5 :                       int_keys_up					; No key pressed
c7b5 : 6433             [ 3] 	stz kb_raw				; Using 65c02 stz opcode
c7b7 : 6434             [ 3] 	stz kb_last
c7b9 : 6435             [ 3] 	stz kb_code
c7bb : 6437             [ 3] 	stz kb_deb
c7bd : 6438             [ 3] 	stz kb_rep
c7bf : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* int_vdp_handler
                             ;* VDP interrupt handler
                             ;****************************************
c7c0 :                       int_vdp_handler
c7c0 : 20ecc7           [ 6] 	jsr update_timers	; If it is then update system 
                             
c7c3 : a512             [ 3] 	lda vdp_curoff		; Is cursor enabled?
c7c5 : d024             [ 3] 	bne int_vdp_fin		; Skip if not
                             
c7c7 : c613             [ 5] 	dec vdp_curstat		; Decrement VDP counter
c7c9 : a513             [ 3] 	lda vdp_curstat		; Check it
c7cb : 297f             [ 2] 	and #0x7f			; If bottom 7 bits !=0
c7cd : d01c             [ 3] 	bne int_vdp_fin		; No flashing to be done
c7cf : a513             [ 3] 	lda vdp_curstat		; Invert top bit (bottoms bits=
c7d1 : 4990             [ 2] 	eor #0x80+VDP_FLASH	; Start counter again
c7d3 : 8513             [ 3] 	sta vdp_curstat		
                             
c7d5 : 18               [ 2] 	clc					; Add offset for cursor address in vram
c7d6 : a52c             [ 3] 	lda gr_scrngeom+gr_cur_ptr
c7d8 : 6529             [ 3] 	adc gr_scrngeom+gr_cur_off
c7da : aa               [ 2] 	tax
c7db : a52d             [ 3] 	lda gr_scrngeom+gr_cur_ptr+1
c7dd : 6900             [ 2] 	adc #0
                             
c7df : 20fdc5           [ 6] 	jsr vdp_wr_addr
                             	
AS65 Assembler for R6502 [1.42].                                     Page   38
-------------------------------- bank\bank0.s --------------------------------

c7e2 : a513             [ 3] 	lda vdp_curstat
c7e4 : 2980             [ 2] 	and #0x80
c7e6 : 4514             [ 3] 	eor vdp_curval		; EOR top bit with what is under
c7e8 : 2023c6           [ 6] 	jsr vdp_wr_vram
c7eb :                       int_vdp_fin	
c7eb : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* update_timers
                             ;* Update 24 bit timer and debounce counters
                             ;****************************************
c7ec :                       update_timers
c7ec : e610             [ 5] 	inc vdp_int_cnt
c7ee : d002             [ 3] 	bne inc_kb_timers
c7f0 : e611             [ 5] 	inc vdp_int_cnt+1
c7f2 :                       inc_kb_timers
c7f2 : a637             [ 3] 	ldx kb_deb			; Is debounce 0?
c7f4 : f002             [ 3] 	beq skip_kb_deb
c7f6 : c637             [ 5] 	dec kb_deb
c7f8 :                       skip_kb_deb
c7f8 : a638             [ 3] 	ldx kb_rep			; Is repeat timer 0?
c7fa : f002             [ 3] 	beq skip_kb_rep
c7fc : c638             [ 5] 	dec kb_rep
c7fe :                       skip_kb_rep
c7fe : 60               [ 6] 	rts
                             	
                             
                             	include "utils\misc.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  MISC.S
                             ;*  Miscellaneous module for commmon utility func
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* long_delay
                             ;* Long delay (X decremented every 0.125ms)
                             ;* Input : X = number of 0.125ms ticks to wait (m
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c7ff :                       long_delay
c7ff : 08               [ 3] 	php
                             	_pushAXY
                             
                             	
c803 : a000             [ 2] 	ldy #0x00
c805 :                       long_delay_1
c805 : ea               [ 2] 	nop
c806 : ea               [ 2] 	nop
c807 : ea               [ 2] 	nop
AS65 Assembler for R6502 [1.42].                                     Page   39
-------------------------------- bank\bank0.s --------------------------------

c808 : ea               [ 2] 	nop
c809 : 88               [ 2] 	dey
c80a : d0f9             [ 3] 	bne long_delay_1
c80c : ca               [ 2] 	dex
c80d : d0f6             [ 3] 	bne long_delay_1
                             
                             	_pullAXY
                             
c812 : 28               [ 4] 	plp
                             	
c813 : 60               [ 6] 	rts
                             
                             
                             	include "utils\utils.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  UTILS.S
                             ;*  This module implements various utility functi
                             ;*  converting from ASCII to binary form for numb
                             ;*  vice-versa to allow humans to actually be abl
                             ;*  and read numbers in their prefered form!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c814 :                       utilPrintSPC
c814 : 48               [ 3] 	pha
c815 : a920             [ 2] 	lda #' '
c817 : 2060c5           [ 6] 	jsr io_put_ch
c81a : 68               [ 4] 	pla
c81b : 60               [ 6] 	rts
                             
c81c :                       utilPrintCRLF
c81c : 48               [ 3] 	pha
c81d : a90d             [ 2] 	lda #UTF_CR
c81f : 2060c5           [ 6] 	jsr io_put_ch
c822 : 68               [ 4] 	pla
c823 : 60               [ 6] 	rts
                             
c824 :                       utilPrintA
c824 : 8545             [ 3] 	sta tmp_d
c826 : 48               [ 3] 	pha
c827 : 8a               [ 2] 	txa
c828 : 48               [ 3] 	pha
c829 : a545             [ 3] 	lda tmp_d
c82b : 2049c8           [ 6] 	jsr str_a_to_x
c82e : 2060c5           [ 6] 	jsr io_put_ch
c831 : 8a               [ 2] 	txa
c832 : 2060c5           [ 6] 	jsr io_put_ch
c835 : 68               [ 4] 	pla
c836 : aa               [ 2] 	tax
c837 : 68               [ 4] 	pla
c838 : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page   40
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
                             ;* util_clr_mem
                             ;* Clear a block of main ram
                             ;* Input : X, A = Block start, Y = Block size
                             ;* Regs affected : P
                             ;****************************************
c839 :                       util_clr_mem
c839 : 48               [ 3] 	pha
c83a : 5a               [ 3] 	phy
c83b : 863f             [ 3] 	stx tmp_v1
c83d : 8540             [ 3] 	sta tmp_v1+1
c83f : a900             [ 2] 	lda #0
c841 :                       mem_clr_byte
c841 : 88               [ 2] 	dey
c842 : 913f             [ 5] 	sta (tmp_v1),y
c844 : d0fb             [ 3] 	bne mem_clr_byte
c846 : 7a               [ 4] 	ply
c847 : 68               [ 4] 	pla
c848 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* str_a_to_x
                             ;* Convert accumulator to hex string
                             ;* Input : A = Byte to convert
                             ;* Output : A = High Char, X = Low Char
                             ;* Regs affected : P
                             ;****************************************
c849 :                       str_a_to_x
c849 : 48               [ 3] 	pha					; Save the byte using later on
c84a : 290f             [ 2] 	and #0x0f			; Mask low nibble
c84c : 18               [ 2] 	clc
c84d : 6930             [ 2] 	adc #'0'			; Convert to UTF
c84f : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c851 : 9002             [ 3] 	bcc skip_a_f_1		; skip a-f adjustment
c853 : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c855 :                       skip_a_f_1
c855 : aa               [ 2] 	tax					; Low char is in X
c856 : 68               [ 4] 	pla					; Get byte back
c857 : 4a               [ 2] 	lsr a				; Make high nibble low
c858 : 4a               [ 2] 	lsr a
c859 : 4a               [ 2] 	lsr a
c85a : 4a               [ 2] 	lsr a
c85b : 18               [ 2] 	clc
c85c : 6930             [ 2] 	adc #'0'			; Convert to UTF
c85e : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c860 : 9002             [ 3] 	bcc skip_a_f_2		; skip a-f adjustment
c862 : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c864 :                       skip_a_f_2
                             
c864 : 18               [ 2] 	clc					; No error
c865 : 60               [ 6] 	rts					; A high nibble
                             
                             ;****************************************
                             ;* str_x_to_a
                             ;* Convert hex string to accumulator
                             ;* Input : A = High Char, X = Low Char
                             ;* Output : A = Value
                             ;* Regs affected : P
                             ;****************************************
c866 :                       str_x_to_a
c866 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c868 : 38               [ 2] 	sec					; Process high char in A
AS65 Assembler for R6502 [1.42].                                     Page   41
-------------------------------- bank\bank0.s --------------------------------

c869 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c86b : c90a             [ 2] 	cmp #10				; If A < 10 then
c86d : 9002             [ 3] 	bcc skip_x_f_1		; skip a-f adjustment
c86f : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c871 :                       skip_x_f_1
c871 : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c873 : b01d             [ 3] 	bcs	str_x_to_a_err	; Error if not
                             
c875 : 0a               [ 2] 	asl a				; This is the high nibble
c876 : 0a               [ 2] 	asl a
c877 : 0a               [ 2] 	asl a
c878 : 0a               [ 2] 	asl a
c879 : 48               [ 3] 	pha					; Save the high nibble
c87a : 8a               [ 2] 	txa					; Now process the low char in X
c87b : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c87d : 38               [ 2] 	sec
c87e : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c880 : c90a             [ 2] 	cmp #10				; If A < 10 then
c882 : 9002             [ 3] 	bcc skip_x_f_2		; skip a-f adjustment
c884 : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c886 :                       skip_x_f_2
c886 : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c888 : b007             [ 3] 	bcs	str_x_to_a_errl	; Error if not
                             
c88a : 8585             [ 3] 	sta num_a			; Store low nibble in temp
c88c : 68               [ 4] 	pla					; Get high nibble
c88d : 0585             [ 3] 	ora num_a			; OR with low nibble
                             
c88f : 18               [ 2] 	clc					; No error
c890 : 60               [ 6] 	rts					; A contains value
                             
c891 :                       str_x_to_a_errl
c891 : 68               [ 4] 	pla
c892 :                       str_x_to_a_err
                             	SWBRK CMD_ERR_VAL
                             
                             
                             ;****************************************
                             ;* con_n_to_a
                             ;* Convert numeric string to accumulator (unsigne
                             ;* Input : Pointer to string (X=L, A=H), Y = Sour
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* A = Source type detected
                             ;* Regs affected : CS = Error
                             ;****************************************
c894 :                       con_n_to_a
c894 : 8691             [ 3] 	stx num_tmp
c896 : 8592             [ 3] 	sta num_tmp+1
c898 : 6485             [ 3] 	stz num_a
c89a : 6486             [ 3] 	stz num_a+1
c89c : c000             [ 2] 	cpy #NUM_ANY
c89e : f014             [ 3] 	beq con_n_to_a_detect
c8a0 : 88               [ 2] 	dey
c8a1 : d003             [ 3] 	bne con_n_not_dec
c8a3 :                       con_dec_jmp
c8a3 : 4c37c9           [ 3] 	jmp con_dec_to_a_int
c8a6 :                       con_n_not_dec
c8a6 : 88               [ 2] 	dey
c8a7 : d003             [ 3] 	bne con_n_not_hex
c8a9 :                       con_hex_jmp
c8a9 : 4ccec8           [ 3] 	jmp con_hex_to_a_int
c8ac :                       con_n_not_hex
AS65 Assembler for R6502 [1.42].                                     Page   42
-------------------------------- bank\bank0.s --------------------------------

c8ac : 88               [ 2] 	dey
c8ad : d003             [ 3] 	bne con_n_err
c8af :                       con_bin_jmp
c8af : 4c0dc9           [ 3] 	jmp con_bin_to_a_int
c8b2 :                       con_n_err
c8b2 : 38               [ 2] 	sec
c8b3 : 60               [ 6] 	rts
c8b4 :                       con_n_to_a_detect
c8b4 : b291             [ 5] 	lda (num_tmp)
c8b6 : c930             [ 2] 	cmp #'0'
c8b8 : d0e9             [ 3] 	bne con_dec_jmp
c8ba : a001             [ 2] 	ldy #1
c8bc : b191             [ 5] 	lda (num_tmp),y
c8be : 0920             [ 2] 	ora #0x20
c8c0 : c978             [ 2] 	cmp #'x'
c8c2 : f0e5             [ 3] 	beq con_hex_jmp
c8c4 : c962             [ 2] 	cmp #'b'
c8c6 : f0e7             [ 3] 	beq con_bin_jmp
c8c8 : 80d9             [ 3] 	bra con_dec_jmp
                             
                             ;****************************************
                             ;* con_hex_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c8ca :                       con_hex_to_a
c8ca : 8691             [ 3] 	stx num_tmp
c8cc : 8592             [ 3] 	sta num_tmp+1
c8ce :                       con_hex_to_a_int
c8ce : a205             [ 2] 	ldx #5			; > 4 digits will cause error
c8d0 : a002             [ 2] 	ldy #2			; start at first digit
c8d2 :                       con_hex_digit
c8d2 : b191             [ 5] 	lda (num_tmp),y
c8d4 : 0920             [ 2] 	ora #0x20					; Make alpha in to lower case
c8d6 : 38               [ 2] 	sec							; Process high char in A
c8d7 : e930             [ 2] 	sbc #'0'					; Convert to hex nibble
c8d9 : c90a             [ 2] 	cmp #10						; If A < 10 then
c8db : 9002             [ 3] 	bcc con_hex_skip_x_f_1		; skip a-f adjustment
c8dd : e927             [ 2] 	sbc #0x27					; Sub 7 to get in to A-F range
c8df :                       con_hex_skip_x_f_1
c8df : c910             [ 2] 	cmp #0x10					; Nibble should be <= 0x0f
c8e1 : b01c             [ 3] 	bcs	con_hex_done			; Potentially done if not
c8e3 : 48               [ 3] 	pha
                             	; make room for lo nibble
c8e4 : 0685             [ 5] 	asl num_a
c8e6 : 2686             [ 5] 	rol num_a+1
c8e8 : 0685             [ 5] 	asl num_a
c8ea : 2686             [ 5] 	rol num_a+1
c8ec : 0685             [ 5] 	asl num_a
c8ee : 2686             [ 5] 	rol num_a+1
c8f0 : 0685             [ 5] 	asl num_a
c8f2 : 2686             [ 5] 	rol num_a+1
                             	; save in low nibble
c8f4 : 68               [ 4] 	pla
c8f5 : 0585             [ 3] 	ora num_a
c8f7 : 8585             [ 3] 	sta num_a
c8f9 : c8               [ 2] 	iny
c8fa : ca               [ 2] 	dex
c8fb : d0d5             [ 3] 	bne con_hex_digit
                             	; if got to a 5th digit then error
AS65 Assembler for R6502 [1.42].                                     Page   43
-------------------------------- bank\bank0.s --------------------------------

c8fd :                       con_hex_err
c8fd : 38               [ 2] 	sec
c8fe : 60               [ 6] 	rts
                             	; found a non-hex digit
c8ff :                       con_hex_done
                             	; if no digits processed then error
c8ff : c002             [ 2] 	cpy #2
c901 : f0fa             [ 4] 	beq con_hex_err
                             	; move y to x for digits processed
c903 : 98               [ 2] 	tya
c904 : aa               [ 2] 	tax
c905 : a902             [ 2] 	lda #NUM_HEX
c907 : 18               [ 2] 	clc
c908 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_bin_to_a
                             ;* Convert binary string to accumulator (unsigned
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c909 :                       con_bin_to_a
c909 : 8691             [ 3] 	stx num_tmp
c90b : 8592             [ 3] 	sta num_tmp+1
c90d :                       con_bin_to_a_int
c90d : a002             [ 2] 	ldy #2
c90f : a211             [ 2] 	ldx #17						; Max 16 binary digits allowed
c911 :                       con_bin_digit
c911 : b191             [ 5] 	lda (num_tmp),y
c913 : c930             [ 2] 	cmp #'0'
c915 : 9010             [ 3] 	bcc con_bin_done
c917 : c932             [ 2] 	cmp #'1'+1
c919 : b00c             [ 3] 	bcs con_bin_done
                             	; sets C if '1' else resets C
c91b : 69cf             [ 2] 	adc #0xff-'0'
                             	; shift in digit
c91d : 2685             [ 5] 	rol num_a
c91f : 2686             [ 5] 	rol num_a+1
c921 : c8               [ 2] 	iny
c922 : ca               [ 2] 	dex
c923 : d0ec             [ 3] 	bne con_bin_digit
                             	; on the 17th digit is too much, error
c925 : 800a             [ 3] 	bra con_bin_err
c927 :                       con_bin_done
                             	; didn't process any digit = error
c927 : c002             [ 2] 	cpy #2
c929 : f006             [ 3] 	beq con_bin_err
                             	; put digits processed in to X
c92b : 98               [ 2] 	tya
c92c : aa               [ 2] 	tax
c92d : a903             [ 2] 	lda #NUM_BIN
c92f : 18               [ 2] 	clc
c930 : 60               [ 6] 	rts
c931 :                       con_bin_err
c931 : 38               [ 2] 	sec
c932 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_d_to_a
                             ;* Convert decimal string to accumulator (SIGNED)
                             ;* Input : Pointer to string (X=L, A=H)
AS65 Assembler for R6502 [1.42].                                     Page   44
-------------------------------- bank\bank0.s --------------------------------

                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c933 :                       con_dec_to_a
c933 : 8691             [ 3] 	stx num_tmp
c935 : 8592             [ 3] 	sta num_tmp+1
c937 :                       con_dec_to_a_int
c937 : a000             [ 2] 	ldy #0
                             	; Detect if leading minus sign
c939 : b291             [ 5] 	lda (num_tmp)
c93b : c92d             [ 2] 	cmp #'-'
c93d : d001             [ 3] 	bne str_d_find_end
                             	; skip over minus if found
c93f : c8               [ 2] 	iny
c940 :                       str_d_find_end
c940 : b191             [ 5] 	lda (num_tmp),y
c942 : c930             [ 2] 	cmp #'0'
c944 : 9007             [ 3] 	bcc str_d_found_end
c946 : c93a             [ 2] 	cmp #'9'+1
c948 : b003             [ 3] 	bcs str_d_found_end
c94a : c8               [ 2] 	iny
c94b : 80f3             [ 3] 	bra str_d_find_end
c94d :                       str_d_found_end
c94d : c007             [ 2] 	cpy #6+1			; Biggest int is 6 chars
c94f : b052             [ 3] 	bcs str_d_error		; e.g. -32767 including minus
c951 : 8494             [ 3] 	sty num_tmp+3
c953 : 6493             [ 3] 	stz num_tmp+2
c955 : 6485             [ 3] 	stz num_a
c957 : 6486             [ 3] 	stz num_a+1
c959 :                       str_d_process_digit
c959 : 88               [ 2] 	dey
c95a : 3026             [ 3] 	bmi str_d_digits_done
                             
c95c : b191             [ 5] 	lda (num_tmp),y
                             
c95e : c92d             [ 2] 	cmp #'-'			; Got to minus sign?
c960 : f020             [ 3] 	beq str_d_digits_done ; also done
                             
c962 : 38               [ 2] 	sec
c963 : e930             [ 2] 	sbc #'0'
                             	; Convert digit to number
                             	; and then offset in to
                             	; look up table of powers
c965 : 18               [ 2] 	clc
c966 : 0a               [ 2] 	asl a
c967 : 6593             [ 3] 	adc num_tmp+2
                             	; X contains index to powers
c969 : aa               [ 2] 	tax
c96a : a585             [ 3] 	lda num_a
c96c : 7da5c9           [ 4] 	adc str_d_powers,x
c96f : 8585             [ 3] 	sta num_a
c971 : a586             [ 3] 	lda num_a+1
c973 : 7da6c9           [ 4] 	adc str_d_powers+1,x
c976 : 8586             [ 3] 	sta num_a+1
c978 : b029             [ 3] 	bcs str_d_error
                             	; Move to next power of 10 index
c97a : a593             [ 3] 	lda num_tmp+2
c97c : 6914             [ 2] 	adc #20
c97e : 8593             [ 3] 	sta num_tmp+2
c980 : 80d7             [ 3] 	bra str_d_process_digit
c982 :                       str_d_digits_done
                             	; check if minus
AS65 Assembler for R6502 [1.42].                                     Page   45
-------------------------------- bank\bank0.s --------------------------------

c982 : b291             [ 5] 	lda (num_tmp)
c984 : c92d             [ 2] 	cmp #'-'
c986 : d011             [ 3] 	bne str_d_skip_neg
c988 : a694             [ 3] 	ldx num_tmp+3		; Must have >= 2 chars
c98a : e002             [ 2] 	cpx #2				; else it's an error
c98c : 9015             [ 3] 	bcc str_d_error
c98e : a685             [ 3] 	ldx num_a
c990 : a586             [ 3] 	lda num_a+1
c992 : 2009ca           [ 6] 	jsr twos_complement
c995 : 8685             [ 3] 	stx num_a
c997 : 8586             [ 3] 	sta num_a+1
c999 :                       str_d_skip_neg
c999 : a694             [ 3] 	ldx num_tmp+3
c99b : e001             [ 2] 	cpx #1				; must be at least 1 char
c99d : 9004             [ 3] 	bcc str_d_error
c99f : a901             [ 2] 	lda #NUM_DEC
c9a1 : 18               [ 2] 	clc
c9a2 : 60               [ 6] 	rts
c9a3 :                       str_d_error
c9a3 : 38               [ 2] 	sec
c9a4 : 60               [ 6] 	rts
                             
c9a5 :                       str_d_powers
c9a5 : 00000100020003..      	dw	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
c9b9 : 00000a0014001e..      	dw	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
c9cd : 00006400c8002c..      	dw	0, 100, 200, 300, 400, 500, 600, 700, 800, 90
c9e1 : 0000e803d007b8..      	dw	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 
c9f5 : 00001027204e30..      	dw	0, 10000, 20000, 30000, 40000, 50000, 60000, 
                             	
                             
                             ;****************************************
                             ;* twos_complement
                             ;* Twos complement of X,A (X=low)
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : X,A in 2's complement
                             ;* Regs affected : P
                             ;****************************************
ca09 :                       twos_complement
ca09 : 49ff             [ 2] 	eor #0xff
ca0b : 48               [ 3] 	pha
ca0c : 8a               [ 2] 	txa
ca0d : 49ff             [ 2] 	eor #0xff
ca0f : aa               [ 2] 	tax
ca10 : 68               [ 4] 	pla
ca11 : e8               [ 2] 	inx
ca12 : d001             [ 3] 	bne twos_complement_skip_X
ca14 : 1a               [ 2] 	inc a
ca15 :                       twos_complement_skip_X
ca15 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* int_to_bcd
                             ;* Convert A,X (signed int) to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated
                             ;* Regs affected : None
                             ;****************************************
ca16 :                       int_to_bcd
ca16 : 08               [ 3] 	php
ca17 : 48               [ 3] 	pha
ca18 : da               [ 3] 	phx
AS65 Assembler for R6502 [1.42].                                     Page   46
-------------------------------- bank\bank0.s --------------------------------

                             
ca19 : 8691             [ 3] 	stx num_tmp
ca1b : 8592             [ 3] 	sta num_tmp+1
ca1d : c980             [ 2] 	cmp #0x80			; Negative?
ca1f : 9003             [ 3] 	bcc int_to_bcd_skip_neg
ca21 : 2009ca           [ 6] 	jsr twos_complement
ca24 :                       int_to_bcd_skip_neg
ca24 : 6485             [ 3] 	stz num_a
ca26 : 6486             [ 3] 	stz num_a+1
ca28 : 6487             [ 3] 	stz num_a+2
ca2a : 6488             [ 3] 	stz num_a+3
ca2c : a210             [ 2] 	ldx #16
ca2e : f8               [ 2] 	sed
ca2f :                       int_to_bcd_bit
ca2f : 0691             [ 5] 	asl num_tmp
ca31 : 2692             [ 5] 	rol num_tmp+1
ca33 : a585             [ 3] 	lda num_a
ca35 : 6585             [ 3] 	adc num_a
ca37 : 8585             [ 3] 	sta num_a
ca39 : a586             [ 3] 	lda num_a+1
ca3b : 6586             [ 3] 	adc num_a+1
ca3d : 8586             [ 3] 	sta num_a+1
ca3f : a587             [ 3] 	lda num_a+2
ca41 : 6587             [ 3] 	adc num_a+2
ca43 : 8587             [ 3] 	sta num_a+2
ca45 : ca               [ 2] 	dex
ca46 : d0e7             [ 3] 	bne int_to_bcd_bit
                             	
ca48 : fa               [ 4] 	plx
ca49 : 68               [ 4] 	pla
ca4a : 28               [ 4] 	plp
ca4b : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* word_to_bcd
                             ;* Convert A,X (unsighed word) to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated as BCD
                             ;* Regs affected : None
                             ;****************************************
ca4c :                       word_to_bcd
ca4c : 08               [ 3] 	php
ca4d : 48               [ 3] 	pha
ca4e : da               [ 3] 	phx
                             
ca4f : 8691             [ 3] 	stx num_tmp
ca51 : 8592             [ 3] 	sta num_tmp+1
ca53 : 6485             [ 3] 	stz num_a
ca55 : 6486             [ 3] 	stz num_a+1
ca57 : 6487             [ 3] 	stz num_a+2
ca59 : 6488             [ 3] 	stz num_a+3
ca5b : a210             [ 2] 	ldx #16			; 16 binary bits
ca5d : f8               [ 2] 	sed
ca5e :                       word_to_bcd_bit
ca5e : 0691             [ 5] 	asl num_tmp
ca60 : 2692             [ 5] 	rol num_tmp+1
ca62 : a585             [ 3] 	lda num_a
ca64 : 6585             [ 3] 	adc num_a
ca66 : 8585             [ 3] 	sta num_a
ca68 : a586             [ 3] 	lda num_a+1
ca6a : 6586             [ 3] 	adc num_a+1
ca6c : 8586             [ 3] 	sta num_a+1
AS65 Assembler for R6502 [1.42].                                     Page   47
-------------------------------- bank\bank0.s --------------------------------

ca6e : a587             [ 3] 	lda num_a+2
ca70 : 6587             [ 3] 	adc num_a+2
ca72 : 8587             [ 3] 	sta num_a+2
ca74 : ca               [ 2] 	dex
ca75 : d0e7             [ 3] 	bne word_to_bcd_bit
                             	
ca77 : fa               [ 4] 	plx
ca78 : 68               [ 4] 	pla
ca79 : 28               [ 4] 	plp
ca7a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* int_to_str_ch
                             ;* Helper routine to stuff decimal char in to num
                             ;* Input : A=BCD digit, Y=num_buf index, C=insert
                             ;* Output : num_buf in ASCII, A=ASCII digit
                             ;* Regs affected : C cleared if non-zero
                             ;****************************************
ca7b :                       int_to_str_ch
ca7b : 290f             [ 2] 	and #0xf
ca7d : 0930             [ 2] 	ora #0x30					; Convert to ascii
ca7f : 4930             [ 2] 	eor #0x30					; Check if zero digit
ca81 : d005             [ 3] 	bne int_to_str_nz			; If not zero definitely sto
ca83 : b003             [ 3] 	bcs int_to_str_nz			; Also if C=1
ca85 : 4930             [ 2] 	eor #0x30					; Restore A
ca87 : 60               [ 6] 	rts							; Return without storing anything
ca88 :                       int_to_str_nz
ca88 : 4930             [ 2] 	eor #0x30					; Restore A
ca8a : 999500           [ 5] 	sta num_buf,y
ca8d : c8               [ 2] 	iny
ca8e : 38               [ 2] 	sec							; Set C as a non-zero encountered
ca8f :                       int_to_str_ch_fin
ca8f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* int_to_str
                             ;* Convert int to string
                             ;* Input : in X,A (low,high), C=leading zeros wan
                             ;* Output : num_buf in ASCII 6 digits + zero term
                             ;* Regs affected : P
                             ;****************************************
ca90 :                       int_to_str
                             	_pushAXY
                             
ca93 : a000             [ 2] 	ldy #0						; first pos of num_buf
ca95 : 0900             [ 2] 	ora #0						; Test A for sign bit
ca97 : 08               [ 3] 	php							; Remember C bit of P
ca98 : 100a             [ 3] 	bpl int_to_str_skip_neg		; Skip if not (postive 
ca9a : 2009ca           [ 6] 	jsr twos_complement			; Flip X,A from 2s complem
ca9d : 48               [ 3] 	pha							; Remember A
ca9e : a92d             [ 2] 	lda #'-'					; Put in negative sign
caa0 : 8595             [ 3] 	sta num_buf
caa2 : c8               [ 2] 	iny							; Start at second buffer pos
caa3 : 68               [ 4] 	pla							; Restore A
caa4 :                       int_to_str_skip_neg
caa4 : 204cca           [ 6]  	jsr word_to_bcd				; Convert X,A to BCD
caa7 : a202             [ 2] 	ldx #2						; Start at BCD high byte
caa9 :                       int_str
caa9 : 28               [ 4] 	plp							; Get C but immediately
caaa : 08               [ 3] 	php							; Save C (due to loop check later)
caab : b585             [ 4] 	lda num_a,x					; Get BCD digit
caad : 859c             [ 3] 	sta num_buf+7				; Save A it for the units later
AS65 Assembler for R6502 [1.42].                                     Page   48
-------------------------------- bank\bank0.s --------------------------------

caaf : 4a               [ 2] 	lsr a						; Tens - shift to lower nibble
cab0 : 4a               [ 2] 	lsr a
cab1 : 4a               [ 2] 	lsr a
cab2 : 4a               [ 2] 	lsr a
cab3 : 28               [ 4] 	plp							; Get C
cab4 : 207bca           [ 6] 	jsr int_to_str_ch			; Put ASCII code in num_buf
cab7 : a59c             [ 3] 	lda num_buf+7				; Get A for the units
cab9 : 207bca           [ 6] 	jsr int_to_str_ch			; Put ASCII code in num_buf
cabc : 08               [ 3] 	php							; Save C
cabd : ca               [ 2] 	dex
cabe : 10e9             [ 3] 	bpl int_str
cac0 : 28               [ 4] 	plp							; Check C
cac1 : b005             [ 3] 	bcs	int_to_str_fin			; If set then something pri
cac3 : a930             [ 2] 	lda #'0'					; Stuff a zero
cac5 : 8595             [ 3] 	sta num_buf					; Must be in first position..
cac7 : c8               [ 2] 	iny
cac8 :                       int_to_str_fin
cac8 : a900             [ 2] 	lda #0						; Terminator
caca : 999500           [ 5] 	sta num_buf,y
cacd : c8               [ 2] 	iny
                             	_pullAXY
                             
cad1 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* bcd_to_str
                             ;* Convert num_buf to chars
                             ;* Input : num_a in BCD format
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
                             ;bcd_to_str
                             ;	pha
                             ;	phx
                             ;	phy
                             ;
                             ;	ldx #5						; Index in to string
                             ;	ldy #0						; Current BCD digit
                             ;bcd_str
                             ;	lda num_a,y
                             ;	; Convert 1s digit of byte
                             ;	pha
                             ;	and #0xf
                             ;	clc
                             ;	adc #0x30
                             ;	sta num_buf,x
                             ;	; Convert 10s digit of byte
                             ;	pla
                             ;	lsr a
                             ;	lsr a
                             ;	lsr a
                             ;	lsr a
                             ;	clc
                             ;	adc #0x30					; Convert to ASCII
                             ;	sta num_buf-1,x
                             ;	dex
                             ;	dex
                             ;	iny
                             ;	cpy #3						; 3 BCD digits max
                             ;	bne bcd_str
AS65 Assembler for R6502 [1.42].                                     Page   49
-------------------------------- bank\bank0.s --------------------------------

                             ;
                             ;	ply
                             ;	plx
                             ;	pla
                             ;	rts
                             	
                             ;****************************************
                             ;* out_bcd
                             ;* Output a bcd string in num_buf
                             ;* Input : num_buf has the ASCII
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not, Y=digits p
                             ;* Regs affected : P
                             ;****************************************
                             ;out_bcd
                             ;	pha
                             ;	phx
                             ;	php
                             ;	ldy #0						; How many digits printed
                             ;	ldx #0						; Index in to string
                             ;out_bcd_digit
                             ;	lda num_buf,x
                             ;	cpy #0						; If not in leading zero mode
                             ;	bne out_bcd_print			; No then go print
                             ;
                             ;	cmp #'0'					; else check if zero
                             ;	bne out_bcd_print			; No then go print
                             ;
                             ;	plp
                             ;	php
                             ;	bcc out_bcd_next			; If C=0 go to next digit, e
                             ;out_bcd_print
                             ;	iny
                             ;	jsr io_put_ch
                             ;out_bcd_next
                             ;	inx
                             ;	cpx #6
                             ;	bne out_bcd_digit
                             ;	cpy #0						; If nothing printed
                             ;	bne out_bcd_fin
                             ;	lda #'0'					; Need to put out 1 zero
                             ;	jsr io_put_ch
                             ;	iny
                             ;out_bcd_fin
                             ;	plp
                             ;	plx
                             ;	pla
                             ;	clc
                             ;	rts
                             	
                             ;****************************************
                             ;* str_a_to_d
                             ;* Convert X,A to decimal string in sevalptr
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 keep leading zeros else not
                             ;* Output : sevalptr in ASCII max 6 digits
                             ;*          Y=length including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
cad2 :                       str_a_to_d
AS65 Assembler for R6502 [1.42].                                     Page   50
-------------------------------- bank\bank0.s --------------------------------

cad2 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* print_a_to_d
                             ;* Convert X,A to decimal string
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII max 6 digits
                             ;*          Y=digits printed including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
cad3 :                       print_a_to_d
cad3 : 2090ca           [ 6] 	jsr int_to_str
cad6 : a000             [ 2] 	ldy #0
cad8 :                       print_a_to_d_ch
cad8 : b99500           [ 4] 	lda num_buf,y
cadb : f006             [ 3] 	beq print_a_to_d_fin
cadd : 2060c5           [ 6] 	jsr io_put_ch
cae0 : c8               [ 2] 	iny
cae1 : d0f5             [ 3] 	bne print_a_to_d_ch
cae3 :                       print_a_to_d_fin
cae3 : 60               [ 6] 	rts
                             	
                             
                             ;* Reset vector points here - 6502 starts here
cae4 :                       init
                             ;	jmp init_test
                             	; First clear ram
                             ;	sei					; No need as disabled on startup
                             ;	cld					; No need as disabled on startup
cae4 : a2ff             [ 2] 	ldx #0xff			; Initialise stack pointer
cae6 : 9a               [ 2] 	txs
cae7 : 4c3fcb           [ 3] 	jmp init_ram		; jmp not jsr to ram initialiser
caea :                       init_2					; init_ram will jump back to here
                             	
caea : 20f0ca           [ 6] 	jsr kernel_init
                             
caed : 4c9bc6           [ 3] 	jmp main
                             
caf0 :                       kernel_init
caf0 : 20eec6           [ 6] 	jsr init_nmi		; Initialise NMI handling
caf3 : 200bc7           [ 6] 	jsr init_irq		; Initialise IRQ handling
caf6 : 20dec1           [ 6] 	jsr _init_acia		; initialise the serial chip
                             	
caf9 : 20f6c1           [ 6] 	jsr _init_cia0		; initialise cia 0
cafc : 200ec2           [ 6] 	jsr _init_cia1		; initialise cia 1
                             
caff :                       kernel_test
caff : 2056c2           [ 6] 	jsr _init_snd		; initialise the sound chip
cb02 : 206ec2           [ 6] 	jsr _init_keyboard	; initialise keyboard timer s
cb05 : 2036c4           [ 6] 	jsr _vdp_init		; initialise vdp
cb08 : a900             [ 2] 	lda #0				; Default = 40 column mode - put on st
cb0a : 48               [ 3] 	pha
cb0b : a20e             [ 2] 	ldx #NV_MODE		; NV location for default text mod
cb0d : 2096c4           [ 6] 	jsr _rtc_nvread		; Try to read location
cb10 : b00b             [ 3] 	bcs kernel_skip_nv	; If bad NV ram then skip try
cb12 : aa               [ 2] 	tax					; Save the mode temporarily
cb13 : 68               [ 4] 	pla					; Get the default mode from stack
cb14 : 8a               [ 2] 	txa					; And push the NV mode that was read
cb15 : 48               [ 3] 	pha
cb16 : a20f             [ 2] 	ldx #NV_COLOUR		; NV location for the default co
AS65 Assembler for R6502 [1.42].                                     Page   51
-------------------------------- bank\bank0.s --------------------------------

cb18 : 2096c4           [ 6] 	jsr _rtc_nvread		; Try to read location (assumed
cb1b : 8521             [ 3] 	sta vdp_base+vdp_bord_col	; Save it to the borde
cb1d :                       kernel_skip_nv	
cb1d : 68               [ 4] 	pla					; Get the mode (either default or the NV
cb1e : 20c6c1           [ 6] 	jsr _gr_init_screen
cb21 : 2026c5           [ 6] 	jsr io_init			; Set default input/output device
cb24 : 58               [ 2] 	cli					; irq interrupts enable
                             
                             	; Print the boot up message - requires IO and IR
                             	_println msg_hello_world
                             
                             
                             
cb32 : 204ec4           [ 6] 	jsr _rtc_init		; Initialise RTC - * AFTER INTERR
cb35 : 203ec2           [ 6] 	jsr _init_sdcard	; initialise the sd card interf
cb38 : 2026c2           [ 6] 	jsr _init_fs		; initialise the filesystem
cb3b : 202ec0           [ 6] 	jsr _df_init		; Initialise interpreter
                             
cb3e : 60               [ 6] 	rts
                             
                             	
                             ;* Initialises RAM, skipping pages 4-8 which are 
                             ;* Zeroes all addressable RAM in the default bank
cb3f :                       init_ram
cb3f : 6400             [ 3] 	stz 0x00			; Start at page 0
cb41 : 6401             [ 3] 	stz 0x01
cb43 : a002             [ 2] 	ldy #0x02			; But Y initially at 2 to not overwr
cb45 : a200             [ 2] 	ldx #0x00			; Page counter starts at zero
cb47 : a900             [ 2] 	lda #0				; Normal RAM filled with zero
cb49 :                       init_ram_1
cb49 : e005             [ 2] 	cpx	#5				; Page <5 is ok (zeroes out VIA0 and 1
cb4b : 9004             [ 3] 	bcc init_ram_fill
cb4d : e008             [ 2] 	cpx #8				; Page >=8 is ok
cb4f : 9005             [ 3] 	bcc init_ram_skip	; But >=5 and <8 do not initia
cb51 :                       init_ram_fill
cb51 : 9100             [ 5] 	sta (0x00),y		; Write initialisation value to RA
cb53 : c8               [ 2] 	iny
cb54 : d0fb             [ 3] 	bne init_ram_fill	; Do a whole page
cb56 :                       init_ram_skip
cb56 : e8               [ 2] 	inx					; Increment page counter
cb57 : 8601             [ 3] 	stx 0x01			; Save to address pointer
cb59 : d0ee             [ 3] 	bne init_ram_1		; Do all pages until page 0xff d
                             	
cb5b : 4ceaca           [ 3] 	jmp init_2			; Carry on initialisation
                             
cb5e :                       mod_sz_kernel_e
                             
                             
                             
                             ; Bank specific code goes here
                             	include "monitor\cmd.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  CMD.S
                             ;*	Simple monitor.
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   52
-------------------------------- bank\bank0.s --------------------------------

                             ;************************************************
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
00d6 =                       cmd_lo					= df_currdat
00d7 =                       cmd_hi					= (df_currdat+1)
00d8 =                       cmd_mem					= df_datoff
00d2 =                       cmd_msg_ptr				= df_lineptr
                             
                             	; ROM code
                             	code  
                             
cb5e :                       command_line
cb5e : a900             [ 2] 	lda #0						; Initialise monitor
cb60 : 85d6             [ 3] 	sta cmd_lo					; Monitor address lo
cb62 : 85d7             [ 3] 	sta cmd_hi					; Monitor address hi
cb64 : 85d8             [ 3] 	sta cmd_mem					; Memory = 0 RAM, 1 = VRAM
cb66 : a0a0             [ 2] 	ldy #160					; Maximum line length
cb68 : 8449             [ 3] 	sty buf_sz
                             
                             ; Immediate call to monitor from outside of monit
cb6a :                       cmd_immediate
cb6a : 20c8cb           [ 6] 	jsr cmd_parse				; Find command and execute
cb6d : b001             [ 3] 	bcs cmd_imerror				; Carry set = error condition
cb6f : 60               [ 6] 	rts
cb70 :                       cmd_imerror
cb70 : 4ca0cb           [ 3] 	jmp cmd_print_error
                             
cb73 :                       cmd_ready
                             	_println msg_ready
                             
                             
cb80 : 38               [ 2] 	sec							; Set carry flag = echo characters
cb81 : a200             [ 2] 	ldx #lo(df_linbuff)
cb83 : a90a             [ 2] 	lda #hi(df_linbuff)
cb85 : a050             [ 2] 	ldy #80
cb87 : 206fc5           [ 6] 	jsr io_read_line			; Get a command line
cb8a : 20c8cb           [ 6] 	jsr cmd_parse				; Find command and execute
cb8d : b003             [ 3] 	bcs cmd_error				; Carry set = error condition
cb8f : 4c73cb           [ 3] 	jmp cmd_ready
                             
cb92 :                       cmd_error
cb92 : a59f             [ 3] 	lda errno
cb94 : 1004             [ 3] 	bpl cmd_skip_quit
cb96 : 649f             [ 3] 	stz errno					; Clear error
cb98 : 18               [ 2] 	clc							; Clear carry
cb99 : 60               [ 6] 	rts							; Return to caller
cb9a :                       cmd_skip_quit	
cb9a : 20a0cb           [ 6] 	jsr cmd_print_error
cb9d : 4c73cb           [ 3] 	jmp cmd_ready
                             
                             ;****************************************
                             ;* cmd_print_error
                             ;* Given error code and Y offset in to buffer
                             ;* print the error message
                             ;* Input : errno, Y
                             ;* Regs affected :
                             ;****************************************
cba0 :                       cmd_print_error
cba0 : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page   53
-------------------------------- bank\bank0.s --------------------------------

cba1 : 5a               [ 3] 	phy
cba2 : a59f             [ 3] 	lda errno
cba4 : 0a               [ 2] 	asl a
cba5 : a8               [ 2] 	tay
cba6 : be91ce           [ 4] 	ldx cmd_error_messages,y
cba9 : b992ce           [ 4] 	lda cmd_error_messages+1,y
cbac : 20abc5           [ 6] 	jsr io_print_line
cbaf : a920             [ 2] 	lda #' '
cbb1 : 2060c5           [ 6] 	jsr io_put_ch
cbb4 : 68               [ 4] 	pla								; Pull Y off stack
cbb5 : 48               [ 3] 	pha								; And put it back
cbb6 : 2049c8           [ 6] 	jsr str_a_to_x
cbb9 : 2060c5           [ 6] 	jsr io_put_ch
cbbc : 8a               [ 2] 	txa
cbbd : 2060c5           [ 6] 	jsr io_put_ch
cbc0 : a90d             [ 2] 	lda #UTF_CR
cbc2 : 2060c5           [ 6] 	jsr io_put_ch
                             	
cbc5 : 7a               [ 4] 	ply
cbc6 : 68               [ 4] 	pla
cbc7 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* cmd_parse
                             ;* Parse the command line in the io buffer
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;*          x = index to routine pointer
                             ;* Regs affected : A
                             ;****************************************
cbc8 :                       cmd_parse
cbc8 : 48               [ 3] 	pha
cbc9 : da               [ 3] 	phx
                             	
cbca : a200             [ 2] 	ldx #0
cbcc :                       find_cmd_loop
cbcc : a000             [ 2] 	ldy #0
cbce : b9000a           [ 4] 	lda df_linbuff,y		; Need to check for ! now
cbd1 : c921             [ 2] 	cmp #'!'
cbd3 : d001             [ 3] 	bne find_cmd_byte
cbd5 : c8               [ 2] 	iny						; Skip over ! if needed
cbd6 :                       find_cmd_byte
cbd6 : bd40ce           [ 4] 	lda cmd_list,x			; Check the command list
cbd9 : c980             [ 2] 	cmp #0x80				; If not end of this command in lis
cbdb : d009             [ 3] 	bne cmd_do_match		; then do the check
cbdd : b9000a           [ 4] 	lda df_linbuff,y		; Check the command line
cbe0 : f02d             [ 4] 	beq cmd_found			; If zero then found
cbe2 : c920             [ 2] 	cmp #' '				; If space then
cbe4 : f029             [ 4] 	beq cmd_found			; also found
cbe6 :                       cmd_do_match				; If here then line <> 0/space an
cbe6 : b9000a           [ 4] 	lda df_linbuff,y		; Get char from command buffer
cbe9 : 0920             [ 2] 	ora #0x20				; Make lower case
cbeb : dd40ce           [ 4] 	cmp cmd_list,x			; Compare with char from comman
cbee : d004             [ 3] 	bne cmd_no_match		; Different = command does not
cbf0 : c8               [ 2] 	iny						; Advance command buffer and list
cbf1 : e8               [ 2] 	inx
cbf2 : 80e2             [ 3] 	bra find_cmd_byte		; Go check the next bytes
cbf4 :                       cmd_no_match				; A command didn't match, so find
cbf4 : bd40ce           [ 4] 	lda cmd_list,x			; Get the non-matching command 
cbf7 : c980             [ 2] 	cmp #0x80				; If already at command terminator 
cbf9 : f007             [ 4] 	beq cmd_next_cmd		; set up for next command
AS65 Assembler for R6502 [1.42].                                     Page   54
-------------------------------- bank\bank0.s --------------------------------

cbfb : c9ff             [ 2] 	cmp #0xff				; If end of command list
cbfd : f008             [ 4] 	beq cmd_not_found		; then not found
cbff : e8               [ 2] 	inx						; Else check next char
cc00 : 80f2             [ 4] 	bra cmd_no_match
cc02 :                       cmd_next_cmd
cc02 : e8               [ 2] 	inx						; Jump over 0x80
cc03 : e8               [ 2] 	inx						; Jump over command address
cc04 : e8               [ 2] 	inx
cc05 : 80c5             [ 4] 	bra find_cmd_loop		; Check for match again
                             
cc07 :                       cmd_not_found
cc07 : a901             [ 2] 	lda #CMD_ERR_NOTFOUND
cc09 : 859f             [ 3] 	sta errno
cc0b : 68               [ 4] 	pla
cc0c : fa               [ 4] 	plx
cc0d : 38               [ 2] 	sec
cc0e : 60               [ 6] 	rts
                             	
cc0f :                       cmd_found					; Found the command
cc0f : bd41ce           [ 4] 	lda cmd_list+1,x		; Low byte of jump pointer
cc12 : 853f             [ 3] 	sta tmp_v1				; Store in temp location
cc14 : bd42ce           [ 4] 	lda cmd_list+2,x		; High byte of jump pointer
cc17 : 8540             [ 3] 	sta tmp_v1+1			; Store in temp location
cc19 : 68               [ 4] 	pla
cc1a : fa               [ 4] 	plx
cc1b : 6c3f00           [ 6] 	jmp (tmp_v1)			; Jump to command (Y points at la
                             	
                             ;****************************************
                             ;* cmd_memtype
                             ;* Set the memory type to V or M
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;*          x = index to routine pointer
                             ;* Regs affected : A
                             ;****************************************
cc1e :                       cmd_memtype
cc1e : 48               [ 3] 	pha
cc1f : 18               [ 2] 	clc
cc20 : 20dfcd           [ 6] 	jsr cmd_parse_next_parm
cc23 : a902             [ 2] 	lda #CMD_ERR_PARM
cc25 : b01c             [ 3] 	bcs cmd_memtype_err
cc27 : b9000a           [ 4] 	lda df_linbuff,y
cc2a : 0920             [ 2] 	ora #0x20
cc2c : c976             [ 2] 	cmp #'v'
cc2e : f008             [ 3] 	beq cmd_setmemtypeV
cc30 : c96d             [ 2] 	cmp #'m'
cc32 : f00a             [ 3] 	beq cmd_setmemtypeM
cc34 : a903             [ 2] 	lda #CMD_ERR_VAL
cc36 : 800b             [ 3] 	bra cmd_memtype_err
cc38 :                       cmd_setmemtypeV
cc38 : a901             [ 2] 	lda #1
cc3a : 85d8             [ 3] 	sta cmd_mem
cc3c : 8002             [ 3] 	bra cmd_memtypeFin
cc3e :                       cmd_setmemtypeM
cc3e : 64d8             [ 3] 	stz cmd_mem
cc40 :                       cmd_memtypeFin
cc40 : 68               [ 4] 	pla
cc41 : 18               [ 2] 	clc
cc42 : 60               [ 6] 	rts
cc43 :                       cmd_memtype_err
cc43 : 859f             [ 3] 	sta errno
cc45 : 38               [ 2] 	sec
AS65 Assembler for R6502 [1.42].                                     Page   55
-------------------------------- bank\bank0.s --------------------------------

cc46 : 68               [ 4] 	pla
cc47 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_setmem
                             ;* Set the memory at address AAAA to byte string
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;*          x = index to routine pointer
                             ;* Regs affected : A
                             ;****************************************
cc48 :                       cmd_setmem
cc48 : 48               [ 3] 	pha
cc49 : da               [ 3] 	phx
                             	
cc4a : 18               [ 2] 	clc
cc4b : 20dfcd           [ 6] 	jsr cmd_parse_next_parm
cc4e : b022             [ 3] 	bcs cmd_setmem_err
cc50 : 20c4cd           [ 6] 	jsr cmd_parse_word
cc53 : b01d             [ 3] 	bcs cmd_setmem_err
cc55 : 86d6             [ 3] 	stx cmd_lo
cc57 : 85d7             [ 3] 	sta cmd_hi
cc59 : 20dfcd           [ 6] 	jsr cmd_parse_next_parm		; Should be at least 1 
cc5c : b014             [ 3] 	bcs cmd_setmem_err
cc5e :                       cmd_setmem_byte
cc5e : 20a1cd           [ 6] 	jsr cmd_parse_byte
cc61 : b00f             [ 3] 	bcs cmd_setmem_err
cc63 : 2087cd           [ 6] 	jsr cmd_poke				; Poke A in to cmd_lo, hi
cc66 : 206fcd           [ 6] 	jsr cmd_incmem
cc69 : 20dfcd           [ 6] 	jsr cmd_parse_next_parm		; Try and find another 
cc6c : 90f0             [ 3] 	bcc cmd_setmem_byte			; Process if found, else f
cc6e :                       cmd_setmemFin
cc6e : 18               [ 2] 	clc
cc6f : fa               [ 4] 	plx
cc70 : 68               [ 4] 	pla
cc71 : 60               [ 6] 	rts
cc72 :                       cmd_setmem_err
cc72 : 38               [ 2] 	sec
cc73 : fa               [ 4] 	plx
cc74 : 68               [ 4] 	pla
cc75 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* cmd_dumpmem
                             ;* Dump memory at address AAAA
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
cc76 :                       cmd_dumpmem
cc76 : 48               [ 3] 	pha
cc77 : da               [ 3] 	phx
cc78 : 5a               [ 3] 	phy
                             
cc79 : 18               [ 2] 	clc
cc7a : 20dfcd           [ 6] 	jsr cmd_parse_next_parm
cc7d : b014             [ 3] 	bcs cmd_dumpmem_err
cc7f : 20c4cd           [ 6] 	jsr cmd_parse_word			; Get hi byte of word
cc82 : b00f             [ 3] 	bcs cmd_dumpmem_err
cc84 : 20dfcd           [ 6] 	jsr cmd_parse_next_parm		; Should cause error, n
cc87 : 9006             [ 3] 	bcc cmd_dumpmem_parm_err
AS65 Assembler for R6502 [1.42].                                     Page   56
-------------------------------- bank\bank0.s --------------------------------

cc89 : 86d6             [ 3] 	stx cmd_lo
cc8b : 85d7             [ 3] 	sta cmd_hi
cc8d : 8009             [ 3] 	bra cmd_dumpmem_block		; Skip over error code to
cc8f :                       cmd_dumpmem_parm_err
cc8f : a902             [ 2] 	lda #CMD_ERR_PARM
cc91 : 859f             [ 3] 	sta errno
cc93 :                       cmd_dumpmem_err
cc93 : 7a               [ 4] 	ply
cc94 : fa               [ 4] 	plx
cc95 : 68               [ 4] 	pla
cc96 : 38               [ 2] 	sec
cc97 : 60               [ 6] 	rts
cc98 :                       cmd_dumpmem_block
cc98 : a5d7             [ 3] 	lda cmd_hi					; Show the address
cc9a : 2049c8           [ 6] 	jsr str_a_to_x
cc9d : 2060c5           [ 6] 	jsr io_put_ch
cca0 : 8a               [ 2] 	txa
cca1 : 2060c5           [ 6] 	jsr io_put_ch
cca4 : a5d6             [ 3] 	lda cmd_lo
cca6 : 2049c8           [ 6] 	jsr str_a_to_x
cca9 : 2060c5           [ 6] 	jsr io_put_ch
ccac : 8a               [ 2] 	txa
ccad : 2060c5           [ 6] 	jsr io_put_ch
ccb0 : a920             [ 2] 	lda #' '
ccb2 : 2060c5           [ 6] 	jsr io_put_ch
                             	
ccb5 : a008             [ 2] 	ldy #8						; 8 Bytes per line
ccb7 :                       cmd_dumpmem_byte
ccb7 : 2076cd           [ 6] 	jsr cmd_peek
ccba : 2049c8           [ 6] 	jsr str_a_to_x
ccbd : 2060c5           [ 6] 	jsr io_put_ch
ccc0 : 8a               [ 2] 	txa
ccc1 : 2060c5           [ 6] 	jsr io_put_ch
ccc4 : a920             [ 2] 	lda #' '
ccc6 : 2060c5           [ 6] 	jsr io_put_ch
ccc9 : 206fcd           [ 6] 	jsr cmd_incmem
cccc : 88               [ 2] 	dey
cccd : d0e8             [ 3] 	bne cmd_dumpmem_byte
cccf :                       cmd_dumpmemASCII
cccf : 38               [ 2] 	sec
ccd0 : a5d6             [ 3] 	lda cmd_lo
ccd2 : e908             [ 2] 	sbc #8
ccd4 : 85d6             [ 3] 	sta cmd_lo
ccd6 : a5d7             [ 3] 	lda cmd_hi
ccd8 : e900             [ 2] 	sbc #0
ccda : 85d7             [ 3] 	sta cmd_hi
                             	
ccdc : a920             [ 2] 	lda #' '
ccde : 2060c5           [ 6] 	jsr io_put_ch
cce1 : 2060c5           [ 6] 	jsr io_put_ch
cce4 : a008             [ 2] 	ldy #8						; 8 Bytes per line
cce6 :                       cmd_dumpmem_ascii
cce6 : 2076cd           [ 6] 	jsr cmd_peek
cce9 : c920             [ 2] 	cmp #' '					; <32 is unprintable
cceb : b002             [ 3] 	bcs cmd_dump_skip_ctrl
cced : a92e             [ 2] 	lda #'.'					; Replace with dot
ccef :                       cmd_dump_skip_ctrl
ccef : c97f             [ 2] 	cmp #UTF_DEL				; >= DEL is unprintable
ccf1 : 9002             [ 3] 	bcc cmd_dump_skip_del
ccf3 : a92e             [ 2] 	lda #'.'					; Replace with dot
ccf5 :                       cmd_dump_skip_del	
ccf5 : 2060c5           [ 6] 	jsr io_put_ch
AS65 Assembler for R6502 [1.42].                                     Page   57
-------------------------------- bank\bank0.s --------------------------------

ccf8 : 206fcd           [ 6] 	jsr cmd_incmem
ccfb : 88               [ 2] 	dey
ccfc : d0e8             [ 3] 	bne cmd_dumpmem_ascii
ccfe : 38               [ 2] 	sec
ccff : 205dc5           [ 6] 	jsr io_get_ch
cd02 : c90d             [ 2] 	cmp #UTF_CR
cd04 : d005             [ 3] 	bne cmd_dumpmemFin
cd06 : 2060c5           [ 6] 	jsr io_put_ch
cd09 : 808d             [ 4] 	bra cmd_dumpmem_block
cd0b :                       cmd_dumpmemFin
cd0b : a90d             [ 2] 	lda #UTF_CR
cd0d : 2060c5           [ 6] 	jsr io_put_ch
cd10 : 7a               [ 4] 	ply
cd11 : fa               [ 4] 	plx
cd12 : 68               [ 4] 	pla
cd13 : 18               [ 2] 	clc
cd14 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* cmd_sector
                             ;* Load sector
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
cd15 :                       cmd_sector
cd15 : 48               [ 3] 	pha
cd16 : da               [ 3] 	phx
cd17 : 5a               [ 3] 	phy
                             
cd18 : 18               [ 2] 	clc
                             	
cd19 : 20a1cd           [ 6] 	jsr cmd_parse_byte			; Get read or write indicat
cd1c : b044             [ 3] 	bcs cmd_sector_err
cd1e : 48               [ 3] 	pha							; Save the indicator
                             	
cd1f : 20c4cd           [ 6] 	jsr cmd_parse_word			; Get hi byte of word
cd22 : b03d             [ 3] 	bcs cmd_sector_errl
                             
cd24 : 864e             [ 3] 	stx sd_sect+0				; Initialise the sector
cd26 : 854f             [ 3] 	sta sd_sect+1
cd28 : 6450             [ 3] 	stz sd_sect+2
cd2a : 6451             [ 3] 	stz sd_sect+3
                             
cd2c : 20dfcd           [ 6] 	jsr cmd_parse_next_parm		; Should cause error, n
cd2f : 9030             [ 3] 	bcc cmd_sector_errl
                             
cd31 : a902             [ 2] 	lda #hi(sd_buf)				; Save/Load from sd_buf
                             
cd33 : fa               [ 4] 	plx							; Read or write?
cd34 : e000             [ 2] 	cpx #0x00
cd36 : d005             [ 3] 	bne cmd_sector_skip00
cd38 : 20dec4           [ 6] 	jsr _sd_sendcmd17
cd3b : 801f             [ 3] 	bra cmd_sector_done
cd3d :                       cmd_sector_skip00
cd3d : e001             [ 2] 	cpx #0x01
cd3f : d005             [ 3] 	bne cmd_sector_skip01
cd41 : 20f6c4           [ 6] 	jsr _sd_sendcmd24
cd44 : 8016             [ 3] 	bra cmd_sector_done
cd46 :                       cmd_sector_skip01
cd46 : e0ff             [ 2] 	cpx #0xff
AS65 Assembler for R6502 [1.42].                                     Page   58
-------------------------------- bank\bank0.s --------------------------------

cd48 : d008             [ 3] 	bne cmd_sector_skipff
cd4a : 20dec4           [ 6] 	jsr _sd_sendcmd17
cd4d : 20f6c4           [ 6] 	jsr _sd_sendcmd24
cd50 : 800a             [ 3] 	bra cmd_sector_done
cd52 :                       cmd_sector_skipff
cd52 : e0fe             [ 2] 	cpx #0xfe
cd54 : d006             [ 3] 	bne cmd_sector_done
cd56 : 20f6c4           [ 6] 	jsr _sd_sendcmd24
cd59 : 20dec4           [ 6] 	jsr _sd_sendcmd17
                             	
cd5c :                       cmd_sector_done	
cd5c : 7a               [ 4] 	ply
cd5d : fa               [ 4] 	plx
cd5e : 68               [ 4] 	pla
cd5f : 18               [ 2] 	clc
cd60 : 60               [ 6] 	rts
cd61 :                       cmd_sector_errl
cd61 : 68               [ 4] 	pla
cd62 :                       cmd_sector_err
cd62 : 859f             [ 3] 	sta errno
cd64 : 7a               [ 4] 	ply
cd65 : fa               [ 4] 	plx
cd66 : 68               [ 4] 	pla
cd67 : 38               [ 2] 	sec
cd68 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* cmd_quit
                             ;* To quit set err=255 and C=1
                             ;****************************************
cd69 :                       cmd_dflat
cd69 : a9ff             [ 2] 	lda #0xff
cd6b : 859f             [ 3] 	sta errno
cd6d : 38               [ 2] 	sec
cd6e : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_incmem
                             ;* Increment pointer
                             ;* Input : cmd_lo, cmd_hi
                             ;* Output : cmd_lo, cmd_hi
                             ;* Regs affected : 
                             ;****************************************
cd6f :                       cmd_incmem
cd6f : e6d6             [ 5] 	inc cmd_lo
cd71 : d002             [ 3] 	bne cmd_skipincmemhi
cd73 : e6d7             [ 5] 	inc cmd_hi
cd75 :                       cmd_skipincmemhi
cd75 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_peek
                             ;* Read byte
                             ;* Input : cmd_lo, cmd_hi
                             ;* Output : A
                             ;* Regs affected : 
                             ;****************************************
cd76 :                       cmd_peek
cd76 : a5d8             [ 3] 	lda cmd_mem
cd78 : d003             [ 3] 	bne cmd_peek_vram
cd7a : b2d6             [ 5] 	lda (cmd_lo)
AS65 Assembler for R6502 [1.42].                                     Page   59
-------------------------------- bank\bank0.s --------------------------------

cd7c : 60               [ 6] 	rts
cd7d :                       cmd_peek_vram
cd7d : da               [ 3] 	phx
cd7e : a6d6             [ 3] 	ldx cmd_lo
cd80 : a5d7             [ 3] 	lda cmd_hi
cd82 : 2006c4           [ 6] 	jsr _vdp_peek
cd85 : fa               [ 4] 	plx
cd86 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_poke
                             ;* Read byte
                             ;* Input : cmd_lo, cmd_hi, A
                             ;* Output : A
                             ;* Regs affected : 
                             ;****************************************
cd87 :                       cmd_poke
cd87 : 48               [ 3] 	pha
cd88 : a5d8             [ 3] 	lda cmd_mem
cd8a : d004             [ 3] 	bne cmd_poke_vram
cd8c : 68               [ 4] 	pla
cd8d : 92d6             [ 5] 	sta (cmd_lo)
cd8f : 60               [ 6] 	rts
cd90 :                       cmd_poke_vram
cd90 : 68               [ 4] 	pla
cd91 : da               [ 3] 	phx
cd92 : 5a               [ 3] 	phy
cd93 : a6d6             [ 3] 	ldx cmd_lo
cd95 : a4d7             [ 3] 	ldy cmd_hi
cd97 : 201ec4           [ 6] 	jsr _vdp_poke
cd9a : 7a               [ 4] 	ply
cd9b : fa               [ 4] 	plx
cd9c : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* cmd_time
                             ;* Set date and time
                             ;* Input : cmd_lo, cmd_hi, A
                             ;* Output : None
                             ;* Regs affected : 
                             ;****************************************
cd9d :                       cmd_time
cd9d : 207ec4           [ 6] 	jsr _rtc_setdatetime
cda0 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_byte
                             ;* Find 2 char hex byte
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = char after hex byte, A = value
                             ;* Regs affected : A,Y
                             ;****************************************
cda1 :                       cmd_parse_byte
cda1 : da               [ 3] 	phx
cda2 : 20dfcd           [ 6] 	jsr cmd_parse_next_parm	; Find the next paramete
cda5 : b016             [ 3] 	bcs cmd_parse_byte_err
cda7 : b9000a           [ 4] 	lda df_linbuff,y		; Get hi nibble of high byte
cdaa : 48               [ 3] 	pha						; Save on stack
cdab : c8               [ 2] 	iny
cdac : b9000a           [ 4] 	lda df_linbuff,y		; Get lo nibble of high byte
cdaf : f00b             [ 3] 	beq cmd_parse_byte_errl	; If no char then error 
AS65 Assembler for R6502 [1.42].                                     Page   60
-------------------------------- bank\bank0.s --------------------------------

cdb1 : aa               [ 2] 	tax						; Lo nibble goes to X
cdb2 : 68               [ 4] 	pla						; Restore hi nibble
cdb3 : 2066c8           [ 6] 	jsr str_x_to_a			; Convert from hex to A
cdb6 : b005             [ 3] 	bcs cmd_parse_byte_err	; If error then stop
cdb8 : c8               [ 2] 	iny						; Point to next char
cdb9 : 18               [ 2] 	clc
cdba : fa               [ 4] 	plx
cdbb : 60               [ 6] 	rts
cdbc :                       cmd_parse_byte_errl
cdbc : 68               [ 4] 	pla						; Pull low nibble off
cdbd :                       cmd_parse_byte_err
cdbd : a903             [ 2] 	lda #CMD_ERR_VAL		; Basic value error
cdbf : 859f             [ 3] 	sta errno
cdc1 : 38               [ 2] 	sec
cdc2 : fa               [ 4] 	plx
cdc3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_word
                             ;* Find 4 char hex word
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = char after hex byte, A = hi, X = 
                             ;* Regs affected : A,X,Y
                             ;****************************************
cdc4 :                       cmd_parse_word
cdc4 : 20dfcd           [ 6] 	jsr cmd_parse_next_parm		; Find the next paramet
cdc7 : b010             [ 3] 	bcs cmd_word_err
cdc9 : 20a1cd           [ 6] 	jsr cmd_parse_byte			; Get hi byte of word
cdcc : b00b             [ 3] 	bcs cmd_word_err
cdce : 48               [ 3] 	pha							; Save hi byte of word
cdcf : 20a1cd           [ 6] 	jsr cmd_parse_byte			; Get lo byte of word
cdd2 : b004             [ 3] 	bcs cmd_word_errl
cdd4 : aa               [ 2] 	tax							; Put in X
cdd5 : 68               [ 4] 	pla							; Get high byte back
cdd6 : 18               [ 2] 	clc
cdd7 : 60               [ 6] 	rts
cdd8 :                       cmd_word_errl
cdd8 : 68               [ 4] 	pla							; Pull off stack
cdd9 :                       cmd_word_err
cdd9 : a903             [ 2] 	lda #CMD_ERR_VAL
cddb : 859f             [ 3] 	sta errno
cddd : 38               [ 2] 	sec
cdde : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_next_parm
                             ;* Find next non-white space
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
cddf :                       cmd_parse_next_parm
cddf : 48               [ 3] 	pha
cde0 :                       cmd_find_parm
cde0 : b9000a           [ 4] 	lda df_linbuff,y
cde3 : c8               [ 2] 	iny
cde4 : c900             [ 2] 	cmp #0					; End of command line?
cde6 : f008             [ 3] 	beq cmd_next_parm_err	; ie no parms
cde8 : c920             [ 2] 	cmp #' '				; Ignore space
cdea : f0f4             [ 3] 	beq cmd_find_parm
cdec : 88               [ 2] 	dey						; Go back 1 to parm start
cded : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page   61
-------------------------------- bank\bank0.s --------------------------------

cdee : 18               [ 2] 	clc
cdef : 60               [ 6] 	rts
cdf0 :                       cmd_next_parm_err
cdf0 : 88               [ 2] 	dey						; Go back 1 to end of line
cdf1 : a902             [ 2] 	lda #CMD_ERR_PARM
cdf3 : 859f             [ 3] 	sta errno
cdf5 : 68               [ 4] 	pla
cdf6 : 38               [ 2] 	sec
cdf7 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_dcolour
                             ;* Set default boot up colour
                             ;****************************************
cdf8 :                       cmd_dcolour
cdf8 : da               [ 3] 	phx
cdf9 : 48               [ 3] 	pha
cdfa : 20a1cd           [ 6] 	jsr cmd_parse_byte
cdfd : b006             [ 4] 	bcs cmd_dcolour_fin
cdff : a20f             [ 2] 	ldx #NV_COLOUR
ce01 : 20aec4           [ 6] 	jsr _rtc_nvwrite
ce04 : 18               [ 2] 	clc
ce05 :                       cmd_dcolour_fin
ce05 : 68               [ 4] 	pla
ce06 : fa               [ 4] 	plx
ce07 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_dmode
                             ;* Set default boot up mode
                             ;****************************************
ce08 :                       cmd_dmode
ce08 : da               [ 3] 	phx
ce09 : 48               [ 3] 	pha
ce0a : 20a1cd           [ 6] 	jsr cmd_parse_byte
ce0d : b006             [ 3] 	bcs cmd_dmode_fin
ce0f : a20f             [ 2] 	ldx #NV_COLOUR
ce11 : 20aec4           [ 6] 	jsr _rtc_nvwrite
ce14 : 18               [ 2] 	clc
ce15 :                       cmd_dmode_fin
ce15 : 68               [ 4] 	pla
ce16 : fa               [ 4] 	plx
ce17 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_help
                             ;* Display help text
                             ;****************************************
ce18 :                       cmd_help
ce18 : a9d5             [ 2] 	lda #lo(msg_help)
ce1a : 85d2             [ 3] 	sta cmd_msg_ptr
ce1c : a9ce             [ 2] 	lda #hi(msg_help)
ce1e : 85d3             [ 3] 	sta cmd_msg_ptr+1
ce20 : a000             [ 2] 	ldy #0
ce22 :                       cmd_msg_char
ce22 : b1d2             [ 5] 	lda (cmd_msg_ptr),y
ce24 : f006             [ 3] 	beq cmd_msg_line_done
ce26 : 2060c5           [ 6] 	jsr io_put_ch
ce29 : c8               [ 2] 	iny
ce2a : d0f6             [ 3] 	bne cmd_msg_char
ce2c :                       cmd_msg_line_done
ce2c : c8               [ 2] 	iny
AS65 Assembler for R6502 [1.42].                                     Page   62
-------------------------------- bank\bank0.s --------------------------------

ce2d : 18               [ 2] 	clc
ce2e : 98               [ 2] 	tya
ce2f : 65d2             [ 3] 	adc cmd_msg_ptr
ce31 : 85d2             [ 3] 	sta cmd_msg_ptr
ce33 : a5d3             [ 3] 	lda cmd_msg_ptr+1
ce35 : 6900             [ 2] 	adc #0
ce37 : 85d3             [ 3] 	sta cmd_msg_ptr+1
ce39 : a000             [ 2] 	ldy #0
ce3b : b1d2             [ 5] 	lda (cmd_msg_ptr),y
ce3d : d0e3             [ 3] 	bne cmd_msg_char
ce3f : 60               [ 6] 	rts
                             
                             
ce40 :                       cmd_list
ce40 : 6d656d74797065..      	db "memtype",	0x80,	lo(cmd_memtype), 	hi(cmd_mem
ce4a : 64756d708076cc        	db "dump", 		0x80, 	lo(cmd_dumpmem), 	hi(cmd_dum
ce51 : 7365748048cc          	db "set", 		0x80,	lo(cmd_setmem), 	hi(cmd_setmem
ce57 : 736563746f7280..      	db "sector",	0x80,	lo(cmd_sector),		hi(cmd_secto
ce60 : 717569748069cd        	db "quit",		0x80,	lo(cmd_dflat),		hi(cmd_dflat)
ce67 : 74696d65809dcd        	db "time",		0x80,	lo(cmd_time),		hi(cmd_time)
ce6e : 726563768028d0        	db "recv",		0x80,	lo(cmd_recv),		hi(cmd_recv)
ce75 : 646d6f64658008ce      	db "dmode",		0x80,	lo(cmd_dmode),		hi(cmd_dmode)
ce7d : 64636f6c6f7572..      	db "dcolour",	0x80,	lo(cmd_dcolour),	hi(cmd_dcol
ce87 : 68656c708018ce        	db "help",		0x80,	lo(cmd_help),		hi(cmd_help)
ce8e : 0000ff                	db 0x00,		0x00,	0xff
                             
                             
ce91 :                       cmd_error_messages
ce91 : 9cce                  	dw msg_errmsg_none
ce93 : a5ce                  	dw msg_errmsg_notfound
ce95 : b7ce                  	dw msg_errmsg_parm
ce97 : c7ce                  	dw msg_errmsg_val
                             
ce99 : 233e00                msg_ready				db "#>",0
ce9c : 4e6f206572726f..      msg_errmsg_none			db "No error",0
cea5 : 436f6d6d616e64..      msg_errmsg_notfound		db "Command not found",0
ceb7 : 506172616d6574..      msg_errmsg_parm			db "Parameter error",0
cec7 : 496c6c6567616c..      msg_errmsg_val			db "Illegal value",0
                             
ced5 : 4d6f6e69746f72..      msg_help				db "Monitor commands:",UTF_CR,0
cee8 : 72656376202020..      						db "recv            RX file from PC",UTF_CR
cf09 : 6d656d74797065..      						db "memtype v|m     Select VRAM|RAM",UTF_CR
cf2a : 64756d70207878..      						db "dump xxxx       Dump memory",UTF_CR,0
cf47 : 73657420207878..      						db "set  xxxx [zz]* Set memory",UTF_CR,0
cf63 : 74696d65202020..      						db "time            Set clock",UTF_CR,0
cf7e : 646d6f64652078..      						db "dmode xx        Default mode",UTF_CR,0
cf9c : 64636f6c6f7572..      						db "dcolour xx      Default colour",UTF_CR,
cfbc : 736563746f7220..      						db "sector rw xxxx  SD sector",UTF_CR,0
cfd7 : 71756974202020..      						db "quit            Have a guess",UTF_CR,0,
                             
                             
                             
                             	include "monitor\recv.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RECV.S
AS65 Assembler for R6502 [1.42].                                     Page   63
-------------------------------- bank\bank0.s --------------------------------

                             ;*	Part of monitor - receive file from serial
                             ;*
                             ;************************************************
                             
0b00 =                       recv_buffer				= df_rtstck
0a00 =                       recv_csum				= df_linbuff
0a01 =                       recv_fopen				= df_linbuff+1
0a02 =                       recv_szlo				= df_linbuff+2
0a03 =                       recv_szhi				= df_linbuff+3
                             
                             
                             ; This is what a block looks like
0000 =                       	struct recv_block
0000 =                       	ds recv_block_number,1
0001 =                       	ds recv_block_payload_sz,1
0002 =                       	ds recv_block_payload,250
00fc =                       	ds recv_block_csum,1
                             	end struct
                             
                             
cff6 :                       recv_wait_msg
cff6 : 3f0800                	db "?",CRSR_LEFT,0
cff9 :                       recv_done_msg
cff9 : 0d00                  	db UTF_CR,0
cffb :                       recv_error_msg
cffb : 0d524543562065..      	db UTF_CR,"RECV error",UTF_CR,0
d008 :                       recv_col1_msg
d008 : 0b0d2000              	db CRSR_UP,UTF_CR," ",0
d00c :                       recv_8blanks_msg
d00c : 20202020202020..      	db "        ",0
d015 :                       recv_closed_file_msg
d015 : 0b0d2b00              	db CRSR_UP,UTF_CR,"+",0
                             
                             
                             ; Macro to load X,A with message address then pri
                             _recv_print macro msg
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	endm
                             
                             ; Macro to switch to serial
                             _serial macro
                             	; Switch to serial
                             	lda #0
                             	jsr io_active_device
                             	endm
                             
                             ; Macro to switch to default
                             _default macro
                             	; Switch to serial
                             	jsr io_set_default
                             	endm
                             
                             
                             ; Print block number in X,A
d019 :                       recv_print_block
d019 : da               [ 3] 	phx
d01a : 48               [ 3] 	pha
                             	_recv_print recv_col1_msg
                             
d022 : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page   64
-------------------------------- bank\bank0.s --------------------------------

d023 : fa               [ 4] 	plx
d024 : 18               [ 2] 	clc					; Leading zeros=false
d025 : 4cd3ca           [ 3] 	jmp print_a_to_d
                             
                             ;****************************************
                             ;* cmd_recv
                             ;* Receive file from serial and save to sd card
                             ;* Input : cmd_lo, cmd_hi, A
                             ;* Output : None
                             ;* Regs affected : 
                             ;****************************************
d028 :                       cmd_recv
                             	; Initialise file handle flag to nothing open
d028 : 9c010a           [ 4] 	stz recv_fopen
                             	; Zero out bytes received count
d02b : 9c020a           [ 4] 	stz recv_szlo
d02e : 9c030a           [ 4] 	stz recv_szhi
                             	; Flush the buffer - means that homebrew receive
d031 : 206ed0           [ 6] 	jsr recv_flush
                             	_recv_print recv_wait_msg
                             
d03b :                       cmd_recv_get_block
                             	; Get header byte
d03b : 207dd0           [ 6] 	jsr recv_get_block_start
                             	; Check if ETB (done)
d03e : c917             [ 2] 	cmp #UTF_ETB
d040 : f014             [ 3] 	beq cmd_recv_done
                             	; Else must be SOH to get the block
d042 : 2099d0           [ 6] 	jsr recv_get_block
                             	; If bad then don't process the block
d045 : b008             [ 3] 	bcs cmd_recv_error
d047 : 20cfd0           [ 6] 	jsr recv_process_block
                             	; If processed block bad then error
d04a : b003             [ 3] 	bcs cmd_recv_error
                             	; Else to get another block header
d04c : 4c3bd0           [ 3] 	jmp cmd_recv_get_block
d04f :                       cmd_recv_error
                             	_recv_print recv_error_msg
                             
d056 :                       cmd_recv_done
                             	; Only close a file if it was open
d056 : ad010a           [ 4] 	lda recv_fopen
d059 : f00a             [ 3] 	beq cmd_recv_skip_close
                             	_recv_print recv_closed_file_msg
                             
d062 : 20a6c0           [ 6] 	jsr _fs_close_w
d065 :                       cmd_recv_skip_close
                             	_recv_print recv_done_msg
                             
d06c : 18               [ 2] 	clc
d06d : 60               [ 6] 	rts
                             
                             ; Keep getting bytes from the serial device until
d06e :                       recv_flush
                             	_serial
                             
d073 :                       recv_flush_byte
                             	; C=0 means asynchronous
d073 : 18               [ 2] 	clc
d074 : 205dc5           [ 6] 	jsr io_get_ch
d077 : 90fa             [ 3] 	bcc recv_flush_byte
                             	; until C=1
AS65 Assembler for R6502 [1.42].                                     Page   65
-------------------------------- bank\bank0.s --------------------------------

                             	_default
                             
d07c : 60               [ 6] 	rts
                             
                             ; Wait for start or end of transmission (SOH, ETB
d07d :                       recv_get_block_start
                             	_serial
                             
d082 :                       recv_get_block_start_byte
                             	; C=1 means synchronous
d082 : 38               [ 2] 	sec
d083 : 205dc5           [ 6] 	jsr io_get_ch
d086 : c901             [ 2] 	cmp #UTF_SOH				; if SOH then reply with ACk to 
d088 : f004             [ 3] 	beq recv_get_block_fin
d08a : c917             [ 2] 	cmp #UTF_ETB				; if not ETB then keep checking!
d08c : d0f4             [ 3] 	bne recv_get_block_start_byte
d08e :                       recv_get_block_fin
d08e : 48               [ 3] 	pha
d08f : a906             [ 2] 	lda #UTF_ACK
d091 : 2060c5           [ 6] 	jsr io_put_ch
                             	_default
                             
                             	; SOH or ETB byte returned to caller
d097 : 68               [ 4] 	pla
d098 : 60               [ 6] 	rts
                             
                             ; Get block
d099 :                       recv_get_block
                             	_serial
                             
                             	; Initialise running checksum
d09e : 9c000a           [ 4] 	stz recv_csum
d0a1 : a200             [ 2] 	ldx #0
d0a3 :                       recv_get_block_byte
                             	; Get byte, C=1 means synchronous
d0a3 : 38               [ 2] 	sec
d0a4 : 205dc5           [ 6] 	jsr io_get_ch
d0a7 : 9d000b           [ 5] 	sta recv_buffer,x
                             	; Add to checksum total
d0aa : 18               [ 2] 	clc
d0ab : 6d000a           [ 4] 	adc recv_csum
d0ae : 8d000a           [ 4] 	sta recv_csum
d0b1 : e8               [ 2] 	inx
                             	; Keep going for the size of a block structure
d0b2 : e0fd             [ 2] 	cpx #recv_block
d0b4 : d0ed             [ 3] 	bne recv_get_block_byte
                             	; check running csum = 0
d0b6 : ad000a           [ 4] 	lda recv_csum
                             	; if Z=1 then block is ok so send ACK
d0b9 : d00a             [ 3] 	bne recv_bad_block
d0bb : a906             [ 2] 	lda #UTF_ACK
d0bd : 2060c5           [ 6] 	jsr io_put_ch
                             	_default
                             
                             	; C=0 means good block received
d0c3 : 18               [ 2] 	clc
d0c4 : 60               [ 6] 	rts
d0c5 :                       recv_bad_block
                             	; If not Z then block is bad so send NACK
d0c5 : a915             [ 2] 	lda #UTF_NACK
d0c7 : 2060c5           [ 6] 	jsr io_put_ch
                             	_default
AS65 Assembler for R6502 [1.42].                                     Page   66
-------------------------------- bank\bank0.s --------------------------------

                             
                             	; C=1 means bad block received
d0cd : 38               [ 2] 	sec
d0ce : 60               [ 6] 	rts
                             
                             
                             ; Process received block
                             ; Block zero is meta data block, else data block
d0cf :                       recv_process_block
d0cf : ae000b           [ 4] 	ldx recv_buffer+recv_block_number
d0d2 : f003             [ 3] 	beq recv_process_block0
d0d4 : 4c2bd1           [ 3] 	jmp recv_process_blockn
                             
                             
                             ; Process block zero meta data
                             ; After block # and payload size:
                             ;  zero terminated file name starting at position
                             ;  zero terminated directory from root
                             ;  final additional zero to indicate no more dire
d0d7 :                       recv_process_block0
                             	_recv_print recv_8blanks_msg
                             
d0de : a002             [ 2] 	ldy #recv_block_payload
                             	; Jump over the filename
d0e0 :                       recv_find_fname_end
d0e0 : b9000b           [ 4] 	lda recv_buffer,y
d0e3 : c8               [ 2] 	iny
d0e4 : c900             [ 2] 	cmp #0
d0e6 : d0f8             [ 3] 	bne recv_find_fname_end
d0e8 :                       recv_process_path
                             	; Load X,A with recv_buffer pointer indexed by Y
                             	; This gives the directory name to change to
d0e8 : 98               [ 2] 	tya
d0e9 : 18               [ 2] 	clc
d0ea : 6900             [ 2] 	adc #lo(recv_buffer)
d0ec : aa               [ 2] 	tax
d0ed : a90b             [ 2] 	lda #hi(recv_buffer)
d0ef : 6900             [ 2] 	adc #0
                             	; Print this directory name
d0f1 : 48               [ 3] 	pha
d0f2 : da               [ 3] 	phx
d0f3 : 5a               [ 3] 	phy
d0f4 : 20abc5           [ 6] 	jsr io_print_line
                             
d0f7 : a92f             [ 2] 	lda #'/'
d0f9 : 2060c5           [ 6] 	jsr io_put_ch	; Forward slash after dir name
d0fc : 7a               [ 4] 	ply
d0fd : fa               [ 4] 	plx
d0fe : 68               [ 4] 	pla
                             	; Change to this directory
d0ff : 205ec0           [ 6] 	jsr _fs_chdir_w
d102 : b026             [ 3] 	bcs block0_error
                             	; Now find end of this directory
d104 :                       recv_find_dir_end
d104 : b9000b           [ 4] 	lda recv_buffer,y
d107 : c8               [ 2] 	iny
d108 : c900             [ 2] 	cmp #0
d10a : d0f8             [ 3] 	bne recv_find_dir_end
                             	; If next byte is zero then done
d10c : b9000b           [ 4] 	lda recv_buffer,y
d10f : d0d7             [ 4] 	bne recv_process_path
                             	; Now we are in the right folder to write the fi
AS65 Assembler for R6502 [1.42].                                     Page   67
-------------------------------- bank\bank0.s --------------------------------

                             	; Need to open the file using the filename at st
                             	; Get X,A to point to this
d111 : 18               [ 2] 	clc
d112 : a902             [ 2] 	lda #recv_block_payload
d114 : 6900             [ 2] 	adc #lo(recv_buffer)
d116 : aa               [ 2] 	tax
d117 : a90b             [ 2] 	lda #hi(recv_buffer)
d119 : 6900             [ 2] 	adc #0
                             	; Print filename
d11b : 48               [ 3] 	pha
d11c : da               [ 3] 	phx
d11d : 20abc5           [ 6] 	jsr io_print_line
d120 : fa               [ 4] 	plx
d121 : 68               [ 4] 	pla
                             	; Now open for write
d122 : 20eec0           [ 6] 	jsr _fs_open_write_w
d125 : b003             [ 3] 	bcs block0_error
                             	; Set flag indicating file is opened
d127 : ee010a           [ 6] 	inc recv_fopen
d12a :                       block0_error
d12a : 60               [ 6] 	rts
                             
                             ; Process data block payload
d12b :                       recv_process_blockn
                             ;	_recv_print recv_got_block_msg
d12b : 18               [ 2] 	clc
d12c : ad010b           [ 4] 	lda recv_buffer+recv_block_payload_sz
d12f : 6d020a           [ 4] 	adc recv_szlo
d132 : 8d020a           [ 4] 	sta recv_szlo
d135 : aa               [ 2] 	tax
d136 : ad030a           [ 4] 	lda recv_szhi
d139 : 6900             [ 2] 	adc #0
d13b : 8d030a           [ 4] 	sta recv_szhi	
d13e : 2019d0           [ 6] 	jsr recv_print_block
d141 : a200             [ 2] 	ldx #0
d143 :                       recv_process_blockn_byte
                             	; Get byte from buffer
d143 : bd020b           [ 4] 	lda recv_buffer+recv_block_payload,x
                             	; Write to file previously opened for write
d146 : 2006c1           [ 6] 	jsr _fs_put_byte_w
d149 : e8               [ 2] 	inx
                             	; Processed all bytes?
d14a : ec010b           [ 4] 	cpx recv_buffer+recv_block_payload_sz
d14d : d0f4             [ 3] 	bne recv_process_blockn_byte
d14f : 18               [ 2] 	clc
d150 : 60               [ 6] 	rts
                             
                             
                             
                             	include "cia\cia.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  CIA.S
                             ;*  Code to initialise and utilise the two WDC65c
                             ;*
                             ;*  VIA1 is for keyboard, LEDs and RAM memory ban
AS65 Assembler for R6502 [1.42].                                     Page   68
-------------------------------- bank\bank0.s --------------------------------

                             ;*		Port A
                             ;*			PA0 to PA7 	- All output to keyboard
                             ;*		Port B
                             ;*			PB0			- Input from BBC keboard to sense matr
                             ;*			PB1			- Output - Led 0 (cassette motor Led)
                             ;*			PB2			- Output - Led 1 (caps lock Led)
                             ;*			PB3			- Output - Led 2 (shift lock Led)
                             ;*			PB4			- Output bit X0 RAM bank selector
                             ;*			PB5			- Output bit X1 RAM bank selector
                             ;*			PB6			- Output bit Y0 ROM bank selector
                             ;*			PB7			- Output bit Y1 ROM bank selector
                             ;*
                             ;*  VIA2 is for AY-3-8910 sound chip, SD Card int
                             ;*		Port A
                             ;*			PA0 to PA7	- Connected to 8910 data bus for 
                             ;*		Port B
                             ;*			PB0			- Output to SD card clock
                             ;*			PB1			- Output - Sound write select
                             ;*			PB2			- Input - SD Card detect
                             ;*			PB3			- Output - SD Card chip select
                             ;*			PB4			- Output - Data out from VIA to SD Car
                             ;*			PB5			- Output - ROM Disable (active low)
                             ;*			PB6			- Output - Sound read select
                             ;*			PB7			- Input - Data in to VIA from SD Card
                             ;*
                             ;* On startup;
                             ;* 	 		VIA0 PB4..7 are high (with weak pull-ups)
                             ;* 	 		VIA1 PB5 is high (with weak pull-ups)
                             ;*
                             ;*  This file is called cia.s because the origina
                             ;*  used a MOS 6526 from a C64.  However I update
                             ;*  design to use two 6522 chips, but never got a
                             ;*  renaming the file ;-)
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code
                             
d151 :                       mod_sz_cia_s
                             	
                             ;********************************
                             ;* set_led0
                             ;* Set the LED0 (cassette motor)
                             ;* Input : C = status (1 = on, 0 = off)
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d151 :                       set_led0
d151 : 48               [ 3] 	pha							; Save A
d152 : ad0004           [ 4] 	lda IO_0 + PRB				; Get current led status
d155 : 0902             [ 2] 	ora #KB_LED0					; Initially assume off
d157 : 9002             [ 3] 	bcc skip_led0_on
d159 : 4902             [ 2] 	eor #KB_LED0					; Switch on if C=1
d15b :                       skip_led0_on
d15b : 8d0004           [ 4] 	sta IO_0 + PRB				; Set the leds
d15e : 68               [ 4] 	pla							; Restore A
d15f : 60               [ 6] 	rts
                             
                             ;********************************
                             ;* set_led1
AS65 Assembler for R6502 [1.42].                                     Page   69
-------------------------------- bank\bank0.s --------------------------------

                             ;* Set the LED1 (caps lock)
                             ;* Input : C = status (1 = on, 0 = off)
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d160 :                       set_led1
d160 : 48               [ 3] 	pha							; Save A
d161 : ad0004           [ 4] 	lda IO_0 + PRB				; Get current led status
d164 : 0904             [ 2] 	ora #KB_LED1				; Initially assume off
d166 : 9002             [ 3] 	bcc skip_led1_on
d168 : 4904             [ 2] 	eor #KB_LED1				; Switch on if C=1
d16a :                       skip_led1_on
d16a : 8d0004           [ 4] 	sta IO_0 + PRB				; Set the leds
d16d : 68               [ 4] 	pla							; Restore A
d16e : 60               [ 6] 	rts
                             
                             ;********************************
                             ;* set_led2
                             ;* Set the LED2 (shift lock)
                             ;* Input : C = status (1 = on, 0 = off)
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d16f :                       set_led2
d16f : 48               [ 3] 	pha							; Save A
d170 : ad0004           [ 4] 	lda IO_0 + PRB				; Get current led status
d173 : 0908             [ 2] 	ora #KB_LED2				; Initially assume off
d175 : 9002             [ 3] 	bcc skip_led2_on
d177 : 4908             [ 2] 	eor #KB_LED2				; Switch on if C=1
d179 :                       skip_led2_on
d179 : 8d0004           [ 4] 	sta IO_0 + PRB				; Set the leds
d17c : 68               [ 4] 	pla							; Restore A
d17d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_cia0
                             ;* Initialise cia 0, controls the BBC keyboard
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : A
                             ;****************************************
d17e :                       init_cia0
d17e : a97f             [ 2] 	lda #0x7f					; Disable all interrupts
d180 : 8d0e04           [ 4] 	sta IO_0 + IER
d183 : a9ff             [ 2] 	lda #0xff					; Clear IFR
d185 : 8d0d04           [ 4] 	sta IO_0 + IFR				; Set IFR to clear flags
                             	
                             
d188 : a9ff             [ 2] 	lda #0xff			
d18a : 8d0304           [ 4] 	sta IO_0 + DDRA				; Port A all output
                             
d18d : a9fe             [ 2] 	lda #0xfe					; Make sure all outputs are high!
d18f : 8d0004           [ 4] 	sta IO_0 + PRB
                             	
d192 : 8d0204           [ 4] 	sta IO_0 + DDRB				; Port B output for leds and 
                             
d195 : a900             [ 2] 	lda #0x00					; Init control register - nothing 
d197 : 8d0b04           [ 4] 	sta IO_0 + ACR
d19a : a902             [ 2] 	lda #0x02					; CA2 independent interrupt
d19c : 8d0c04           [ 4] 	sta IO_0 + PCR
                             
d19f : a980             [ 2] 	lda #KB_EN 					; Set KB_EN bit to allow h/w str
AS65 Assembler for R6502 [1.42].                                     Page   70
-------------------------------- bank\bank0.s --------------------------------

d1a1 : 8d0104           [ 4] 	sta IO_0 + PRA
                             	
                             	; LEDS off
d1a4 : 18               [ 2] 	clc
d1a5 : 2051d1           [ 6] 	jsr set_led0
d1a8 : 2060d1           [ 6] 	jsr set_led1
d1ab : 206fd1           [ 6] 	jsr set_led2
                             
d1ae : 60               [ 6] 	rts							; return from sub
                             	
                             ;****************************************
                             ;* init_cia1
                             ;* Initialise cia 1, controls the sound chip
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : A
                             ;****************************************
d1af :                       init_cia1
d1af : a97f             [ 2] 	lda #0x7f					; Disable all interrupts
d1b1 : 8d8e04           [ 4] 	sta IO_1 + IER
                             	
d1b4 : a9ff             [ 2] 	lda #0xff					; Port A all output (AY-3 data bus
d1b6 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             	
d1b9 : a920             [ 2] 	lda #MM_DIS					; Make sure ROM is enabled in po
d1bb : 8d8004           [ 4] 	sta IO_1+PRB				; setting the data direction reg
                             	
d1be : a97b             [ 2] 	lda #0b01111011				; Set Port B input/output SD,
d1c0 : 8d8204           [ 4] 	sta IO_1+DDRB
                             	
d1c3 : a900             [ 2] 	lda #0x00					; Init control register - nothing 
d1c5 : 8d8b04           [ 4] 	sta IO_1 + ACR
d1c8 : 8d8c04           [ 4] 	sta IO_1 + PCR
                             
d1cb : a9ff             [ 2] 	lda #0xff					; Clear IFR
d1cd : 8d8d04           [ 4] 	sta IO_1 + IFR				; Read ICR to clear flags
                             	
d1d0 : 60               [ 6] 	rts							; return from sub
                             
d1d1 :                       mod_sz_cia_e
                             
                             	include "serial\serial.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SERIAL.S
                             ;*  Serial input/output handler - driving a 6551 
                             ;*  To handle WDC65c51 bug on transmit, use a del
                             ;*  to ensure byte is transmitted before the next
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   71
-------------------------------- bank\bank0.s --------------------------------

                             ;* get_byte
                             ;* Get a byte (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 1 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
d1d1 :                       get_byte
d1d1 : a50e             [ 3] 	lda ser_first			; if first==last then buffer emp
d1d3 : 450f             [ 3] 	eor ser_last
d1d5 : d004             [ 3] 	bne got_byte
d1d7 : b0f8             [ 3] 	bcs get_byte
d1d9 : 38               [ 2] 	sec
d1da : 60               [ 6] 	rts
d1db :                       got_byte
d1db : 5a               [ 3] 	phy
d1dc : a40e             [ 3] 	ldy ser_first			; Get first byte in FIFO
d1de : b90008           [ 4] 	lda ser_buf,y
d1e1 : e60e             [ 5] 	inc ser_first			; Advance first byte of FIFO
d1e3 : 7a               [ 4] 	ply
d1e4 : 18               [ 2] 	clc						; Indicate byte was got
d1e5 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* put_byte
                             ;* Put a byte out
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d1e6 :                       put_byte
d1e6 : 48               [ 3] 	pha						; Save A
                             ;	phx
                             ;	ldx #112				; Loop 112 times
d1e7 :                       put_byte_wait				; Delay 2512 cycles (19200bps, 1
                             ;	nop						; For 5.36Mhz clock
                             ;	nop						; ~25 cycles per loop (10xnop+dex+bne)
                             ;	nop						; 
                             ;	nop						; 
                             ;	nop						; 
                             ;	nop						; 
                             ;	nop						; 
                             ;	nop						; 
                             ;	nop						; 
                             ;	nop						; 
                             ;	dex						;
d1e7 : ad8105           [ 4] 	lda SER_STATUS			; Check status register
d1ea : 2910             [ 2] 	and #SER_TDRE			; Is transmit reg empty?
d1ec : f0f9             [ 3] 	beq put_byte_wait		; Keep waiting if not
                             ;	plx						; restore X
d1ee : 68               [ 4] 	pla						; Get A back
d1ef : 8d8005           [ 4] 	sta SER_DATA			; Write the data
d1f2 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* init_acia
                             ;* ACIA initialisation (this is IO_2)
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : X
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   72
-------------------------------- bank\bank0.s --------------------------------

d1f3 :                       init_acia
d1f3 : a21f             [ 2] 	ldx #0b00011111			; 19200 baud, 8 bits, 1 stop b
d1f5 : 8e8305           [ 4] 	stx SER_CTL
d1f8 : a209             [ 2] 	ldx #0b00001001			; No parity, no TX int plus RT
d1fa : 8e8205           [ 4] 	stx SER_CMD
d1fd : ae8105           [ 4] 	ldx SER_STATUS			; Read status reg to clear stuf
                             
d200 : 640e             [ 3] 	stz ser_first			; Initialise FIFO buffer pointer
d202 : 640f             [ 3] 	stz ser_last
                             
d204 : 60               [ 6] 	rts
                             
                             	include "keyboard\keyboard.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  KEYBOARD.S
                             ;*  This is the keyboard module to enable interfa
                             ;*  BBC keyboard using a 65c22.  The BBC keyboard
                             ;*  in that it provides a signal to know if somet
                             ;*  pressed in hardware, so the more cycle heavy 
                             ;*  actually check which key etc can be done only
                             ;*  necessary.  Debouncing is necessary to not sc
                             ;*  often, with the timing for this happening dur
                             ;*  interrupt cycle.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* init_keyboard
                             ;* Initialise the keyboard settings
                             ;****************************************
d205 :                       init_keyboard
d205 : a914             [ 2] 	lda #KB_REP_DEL
d207 : 853a             [ 3] 	sta kb_rep_del
d209 : a903             [ 2] 	lda #KB_REP_TIM
d20b : 8539             [ 3] 	sta kb_rep_tim
d20d : a902             [ 2] 	lda #KB_DEBOUNCE
d20f : 853b             [ 3] 	sta kb_debounce
d211 : 6436             [ 3] 	stz kb_stat
d213 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* kb_read_raw
                             ;* Read keyboard (not shift+ctrl)
                             ;* X = Keyboard code
                             ;* Carry = 1 means key found, 0 = no keys found
                             ;****************************************
d214 :                       kb_read_raw
d214 : 48               [ 3] 	pha
d215 : 5a               [ 3] 	phy
                             
d216 : a901             [ 2] 	lda #KB_W				; This is the mask to look for
AS65 Assembler for R6502 [1.42].                                     Page   73
-------------------------------- bank\bank0.s --------------------------------

d218 : a000             [ 2] 	ldy #0					; Start at row 1, column 0, KB_EN is 
d21a :                       kb_check_w_col
d21a : a207             [ 2] 	ldx #7					; Only 7 rows as row zero is skipped
d21c : c8               [ 2] 	iny						; Increment past row 0
d21d :                       kb_check_w_key
d21d : 8c0104           [ 4] 	sty IO_0 + PRA			; Set the row and column with K
d220 : ea               [ 2] 	nop						; Short delay for fast CPU
d221 : ea               [ 2] 	nop						; Short delay for fast CPU
d222 : 2c0004           [ 4] 	bit IO_0 + PRB			; Bit test for the W status
d225 : d00b             [ 3] 	bne got_key				; Found key
d227 : c8               [ 2] 	iny						; Advance row
d228 : ca               [ 2] 	dex						; Do each row
d229 : d0f2             [ 3] 	bne kb_check_w_key
d22b : c050             [ 2] 	cpy #0b01010000			; If not got to column 10 then
d22d : d0eb             [ 3] 	bne kb_check_w_col
                             
d22f :                       kb_no_key
                             	; no key found
d22f : 18               [ 2] 	clc						; Clear carry flag = no keys found
d230 : 8045             [ 3] 	bra kb_raw_done			; Exit nicely
                             
d232 :                       got_key
d232 : 8433             [ 3] 	sty kb_raw				; Save the raw key code
d234 : be15d3           [ 4] 	ldx kb_table_std,y		; Load up standard key code 
d237 : a900             [ 2] 	lda #0b00000000			; Check shift pressed (row=0, 
d239 : 8d0104           [ 4] 	sta IO_0 + PRA
d23c : ea               [ 2] 	nop						; Short delay for fast CPU
d23d : ea               [ 2] 	nop						; Short delay for fast CPU
d23e : ad0004           [ 4] 	lda IO_0 + PRB			; Read w
d241 : 2901             [ 2] 	and #KB_W
d243 : d006             [ 3] 	bne do_shifted_key
d245 : a536             [ 3] 	lda kb_stat
d247 : 2902             [ 2] 	and #KB_SHIFTLK			; Check shift lock
d249 : f003             [ 3] 	beq skip_shifted_key	
d24b :                       do_shifted_key
d24b : be66d3           [ 4] 	ldx kb_table_shift,y	; Overwrite X with shifted 
d24e :                       skip_shifted_key
d24e : a908             [ 2] 	lda #0b00001000			; Check ctrl pressed (row=0, c
d250 : 8d0104           [ 4] 	sta IO_0 + PRA
d253 : ea               [ 2] 	nop						; Short delay for fast CPU
d254 : ea               [ 2] 	nop						; Short delay for fast CPU
d255 : ad0004           [ 4] 	lda IO_0 + PRB			; Read w
d258 : 2901             [ 2] 	and #KB_W
d25a : f006             [ 3] 	beq skip_ctrl_key
d25c : 8a               [ 2] 	txa						; If ctrl pressed then only take bottom
d25d : 291f             [ 2] 	and #0x1f				; Which will result in codes 0 to 3
d25f : aa               [ 2] 	tax
d260 : 8012             [ 3] 	bra skip_caps_lock		; no point in checking caps 
d262 :                       skip_ctrl_key
d262 : a536             [ 3] 	lda kb_stat				; Check caps lock
d264 : 2901             [ 2] 	and #KB_CAPSLK
d266 : f00c             [ 3] 	beq skip_caps_lock
d268 : 8a               [ 2] 	txa						; Easier to modify in A
d269 : c961             [ 2] 	cmp #'a'				; If < 'a' then skip
d26b : 9007             [ 3] 	bcc skip_caps_lock
d26d : c97b             [ 2] 	cmp #'z'+1				; If > 'z' then skip
d26f : b003             [ 3] 	bcs skip_caps_lock
d271 : 4920             [ 2] 	eor #0x20				; Switch off bit 0x20
d273 : aa               [ 2] 	tax						; to make upper case
d274 :                       skip_caps_lock
d274 : 8635             [ 3] 	stx kb_code				; Store mapped key code
d276 : 38               [ 2] 	sec						; Set carry flag = key found
AS65 Assembler for R6502 [1.42].                                     Page   74
-------------------------------- bank\bank0.s --------------------------------

                             	
d277 :                       kb_raw_done
d277 : a080             [ 2] 	ldy #KB_EN				; Re-enable h/w strobe
d279 : 8c0104           [ 4] 	sty IO_0 + PRA
d27c : 7a               [ 4] 	ply
d27d : 68               [ 4] 	pla
d27e : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* kb_read_dip
                             ;* Scans options dip switch
                             ;* A = Options code for all 8 bits
                             ;****************************************
d27f :                       kb_read_dip
d27f : 5a               [ 3] 	phy
                             
d280 : a000             [ 2] 	ldy #0
d282 : 6441             [ 3] 	stz tmp_a
d284 :                       kb_check_dip
d284 : b9b7d3           [ 4] 	lda kb_dip_code, y		; Binary dip code, row = 0, 
d287 : 8d0104           [ 4] 	sta IO_0 + PRA
d28a : ea               [ 2] 	nop						; Short delay for fast CPU
d28b : ea               [ 2] 	nop						; Short delay for fast CPU
d28c : ad0004           [ 4] 	lda IO_0 + PRB			; Read w
d28f : 2901             [ 2] 	and #KB_W
d291 : f007             [ 3] 	beq kb_skip_dip
d293 : a541             [ 3] 	lda tmp_a
d295 : 19bfd3           [ 4] 	ora kb_dip_bit, y		; Set the bit if option on
d298 : 8541             [ 3] 	sta tmp_a
d29a :                       kb_skip_dip
d29a : c8               [ 2] 	iny
d29b : c008             [ 2] 	cpy #8
d29d : d0e5             [ 3] 	bne kb_check_dip
d29f : a541             [ 3] 	lda tmp_a
                             
d2a1 : a080             [ 2] 	ldy #KB_EN				; Re-enable h/w strobe
d2a3 : 8c0104           [ 4] 	sty IO_0 + PRA
                             
d2a6 : 7a               [ 4] 	ply
d2a7 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* kb_scan_key
                             ;* Scans for a key, returns zero for no key found
                             ;* Processes caps and shift lock but these don't 
                             ;* A = Key code
                             ;****************************************
d2a8 :                       kb_scan_key
d2a8 : a53c             [ 3] 	lda kb_pressed			; or if interrupt handler didn'
d2aa : f01d             [ 3] 	beq kb_scan_zero			
d2ac : 643c             [ 3] 	stz kb_pressed			; Zero the flag to indicate a s
d2ae : 5a               [ 3] 	phy
d2af : da               [ 3] 	phx
                             	
d2b0 : a43a             [ 3] 	ldy kb_rep_del			; Initially, assuming normal re
d2b2 : 2014d2           [ 6] 	jsr kb_read_raw			; H/W scan of keyboard
d2b5 : 9010             [ 3] 	bcc kb_scan_nothing		; C clear means nothing fou
d2b7 : e080             [ 2] 	cpx #0x80				; Was it a special key (caps/shift 
d2b9 : b01a             [ 3] 	bcs kb_special			; If so process
d2bb : a533             [ 3] 	lda kb_raw
AS65 Assembler for R6502 [1.42].                                     Page   75
-------------------------------- bank\bank0.s --------------------------------

d2bd : c534             [ 3] 	cmp kb_last
d2bf : d00b             [ 3] 	bne kb_return_code		; This key different from la
d2c1 : a439             [ 3] 	ldy kb_rep_tim
d2c3 : a638             [ 3] 	ldx kb_rep				; If repeat timer is zero then emi
d2c5 : f005             [ 3] 	beq kb_return_code
                             
d2c7 :                       kb_scan_nothing
d2c7 : fa               [ 4] 	plx
d2c8 : 7a               [ 4] 	ply
d2c9 :                       kb_scan_zero
d2c9 : a900             [ 2] 	lda #0					; 0 = no key	
d2cb : 60               [ 6] 	rts
d2cc :                       kb_return_code				; Return a key because raw != l
d2cc : 8438             [ 3] 	sty kb_rep				; Delay before the same key is emi
d2ce : 8534             [ 3] 	sta kb_last				; Now make last = raw
                             	
d2d0 : fa               [ 4] 	plx
d2d1 : 7a               [ 4] 	ply
                             	
d2d2 : a535             [ 3] 	lda kb_code				; Get the actual code
                             	
d2d4 : 60               [ 6] 	rts
                             
d2d5 :                       kb_special					; Process special keys
d2d5 : e434             [ 3] 	cpx kb_last				; If last is not zero then don't 
d2d7 : f0ee             [ 3] 	beq kb_scan_nothing		; special keys don't obey r
d2d9 : 8634             [ 3] 	stx kb_last				; Update last
d2db : e08a             [ 2] 	cpx #0x8a				; CAPS?
d2dd : f015             [ 3] 	beq kb_caps_lock		; Yes
d2df : e08b             [ 2] 	cpx #0x8b				; Shift Lock?
d2e1 : d0e4             [ 3] 	bne kb_scan_nothing		; No, then found nothing (F
                             	;Process shift lock
d2e3 : a536             [ 3] 	lda kb_stat
d2e5 : 4902             [ 2] 	eor #KB_SHIFTLK
d2e7 : 8536             [ 3] 	sta kb_stat
d2e9 : 18               [ 2] 	clc
d2ea : 2902             [ 2] 	and #KB_SHIFTLK
d2ec : f001             [ 3] 	beq kb_skip_shiftlk
d2ee : 38               [ 2] 	sec
d2ef :                       kb_skip_shiftlk
d2ef : 206fd1           [ 6] 	jsr set_led2
d2f2 : 80d3             [ 3] 	bra kb_scan_nothing
                             	;Process caps lock
d2f4 :                       kb_caps_lock
d2f4 : a536             [ 3] 	lda kb_stat
d2f6 : 4901             [ 2] 	eor #KB_CAPSLK
d2f8 : 8536             [ 3] 	sta kb_stat
d2fa : 18               [ 2] 	clc
d2fb : 2901             [ 2] 	and #KB_CAPSLK
d2fd : f001             [ 4] 	beq kb_skip_capslk
d2ff : 38               [ 2] 	sec
d300 :                       kb_skip_capslk
d300 : 2060d1           [ 6] 	jsr set_led1
d303 : 80c2             [ 4] 	bra kb_scan_nothing
                             
                             ;****************************************
                             ;* kb_get_key
                             ;* Waits for a key press, C=1 synchronous
                             ;* A = Key code
                             ;****************************************
d305 :                       kb_get_key
d305 : 08               [ 3] 	php
AS65 Assembler for R6502 [1.42].                                     Page   76
-------------------------------- bank\bank0.s --------------------------------

d306 : 20a8d2           [ 6] 	jsr kb_scan_key
d309 : c900             [ 2] 	cmp #0
d30b : d005             [ 3] 	bne kb_scan_got_key
d30d : 28               [ 4] 	plp						; No key, so check C
d30e : b0f5             [ 3] 	bcs kb_get_key			; Keep looking if C
d310 : 38               [ 2] 	sec						; Indicate key not got
d311 : 60               [ 6] 	rts
d312 :                       kb_scan_got_key
d312 : 28               [ 4] 	plp						; Pull stack
d313 : 18               [ 2] 	clc						; Indicate key valid
d314 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* kb_table_std (no shift)
                             ;* Keyboard table - zero indicates nothing
                             ;****************************************
d315 :                       kb_table_std
d315 : 00                    	db 0x00								; Zero entry means nothing
d316 : 7180318a8b091b        	db 'q',0x80, '1',0x8a,0x8b,   9, 27	; Q, F0, 1, 
d31d : 00                    	db 0x00								; Skip row 0
d31e : 33773261737a81        	db '3', 'w', '2', 'a', 's', 'z',0x81; 3, W, 2, A
d325 : 00                    	db 0x00								; Skip row 0
d326 : 34656478632082        	db '4', 'e', 'd', 'x', 'c', ' ',0x82; 4, E, D, X
d32d : 00                    	db 0x00								; Skip row 0
d32e : 35747266677683        	db '5', 't', 'r', 'f', 'g', 'v',0x83; 5, T, R, F
d335 : 00                    	db 0x00								; Skip row 0
d336 : 84373679686285        	db 0x84,'7', '6', 'y', 'h', 'b',0x85; F4, 7, 6, 
d33d : 00                    	db 0x00								; Skip row 0
d33e : 3869756a6e6d86        	db '8', 'i', 'u', 'j', 'n', 'm',0x86; 8, I, U, J
d345 : 00                    	db 0x00								; Skip row 0
d346 : 87396f6b6c2c88        	db 0x87,'9', 'o', 'k', 'l', ',',0x88; F7, 9, O, 
d34d : 00                    	db 0x00								; Skip row 0
d34e : 2d3070403b2e89        	db '-', '0', 'p', '@', ';', '.',0x89; -, 0, P, @
d355 : 00                    	db 0x00								; Skip row 0
d356 : 5e5f5b3a5d2f5c        	db '^', '_', '[', ':', ']', '/', 92	; ^, _, [, :
d35d : 00                    	db 0x00								; Skip row 0
d35e : 080a0b0d7f0609        	db   8,  10,  11,  13, 127,   6,  9	; Left, Down
d365 : 00                    	db 0x00								; Skip row 0
                             
                             ;****************************************
                             ;* kb_table_shift (with shift)
                             ;* Keyboard table - zero indicates nothing
                             ;****************************************
d366 :                       kb_table_shift
d366 : 00                    	db 0x00								; Zero entry means nothing
d367 : 51c0218a8b091b        	db 'Q',0xc0, '!',0x8a,0x8b,   9, 27	; Q, F0, 1, 
d36e : 00                    	db 0x00								; Skip row 0
d36f : 23572241535ac1        	db '#', 'W', '"', 'A', 'S', 'Z',0xc1; 3, W, 2, A
d376 : 00                    	db 0x00								; Skip row 0
d377 : 244544584320c2        	db '$', 'E', 'D', 'X', 'C', ' ',0xc2; 4, E, D, X
d37e : 00                    	db 0x00								; Skip row 0
d37f : 255452464756c3        	db '%', 'T', 'R', 'F', 'G', 'V',0xc3; 5, T, R, F
d386 : 00                    	db 0x00								; Skip row 0
d387 : 842726594842c5        	db 0x84, 39, '&', 'Y', 'H', 'B',0xc5; F4, 7, 6, 
d38e : 00                    	db 0x00								; Skip row 0
d38f : 2849554a4e4dc6        	db '(', 'I', 'U', 'J', 'N', 'M',0xc6; 8, I, U, J
d396 : 00                    	db 0x00								; Skip row 0
d397 : 87294f4b4c3cc8        	db 0x87,')', 'O', 'K', 'L', '<',0xc8; F7, 9, O, 
d39e : 00                    	db 0x00								; Skip row 0
d39f : 3d3050402b3ec9        	db '=', '0', 'P', '@', '+', '>',0xc9; -, 0, P, @
d3a6 : 00                    	db 0x00								; Skip row 0
d3a7 : 7e607b2a7d3f7c        	db '~', 96, '{', '*', '}', '?', '|'	; ^, _, [, :
AS65 Assembler for R6502 [1.42].                                     Page   77
-------------------------------- bank\bank0.s --------------------------------

d3ae : 00                    	db 0x00								; Skip row 0
d3af : 080a0b0d7f0609        	db   8,  10,  11,  13, 127,   6,  9	; Left, Down
d3b6 : 00                    	db 0x00								; Skip row 0
                             
                             ; Option switches
d3b7 :                       kb_dip_code
d3b7 : 10                    	db 0b00010000
d3b8 : 18                    	db 0b00011000
d3b9 : 20                    	db 0b00100000
d3ba : 28                    	db 0b00101000
d3bb : 30                    	db 0b00110000
d3bc : 38                    	db 0b00111000
d3bd : 40                    	db 0b01000000
d3be : 48                    	db 0b01001000
d3bf :                       kb_dip_bit
d3bf : 0102040810204080      	db 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80
                             	
                             
                             	include "rtc\rtc.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTC.S
                             ;*	Real time clock support.  Uses the DS12887 to 
                             ;*	time functions for use by the rest of the syst
                             ;*	notably for file date-time stamps.
                             ;*	Just basic functions supported so far.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
d3c7 :                       mod_sz_rtc_s
                             
                             
                             ;****************************************
                             ;* rtc_write
                             ;* Low level routine to write to a RTC location
                             ;* Inputs; X=location, A=Value
                             ;****************************************
d3c7 :                       rtc_write
d3c7 : 08               [ 3] 	php
d3c8 : 78               [ 2] 	sei
d3c9 : 8e0006           [ 4] 	stx RTC_ADDR
d3cc : 8d0106           [ 4] 	sta RTC_DATA
d3cf : 28               [ 4] 	plp
d3d0 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* rtc_read
                             ;* Low level routine to write to a RTC location
                             ;* Inputs; X=location
                             ;* Output; A=Value
                             ;****************************************
d3d1 :                       rtc_read
AS65 Assembler for R6502 [1.42].                                     Page   78
-------------------------------- bank\bank0.s --------------------------------

d3d1 : 08               [ 3] 	php
d3d2 : 78               [ 2] 	sei
d3d3 : 8e0006           [ 4] 	stx RTC_ADDR
d3d6 : ad0106           [ 4] 	lda RTC_DATA
d3d9 : 28               [ 4] 	plp
d3da : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* rtc_init
                             ;* Initialise the RTC.  Check the VRT
                             ;* and if suspect then offer option to
                             ;* set date-time.
                             ;* Check NV ram and warn if bad
                             ;****************************************
d3db :                       rtc_init
                             	; No interrupts
d3db : a20c             [ 2] 	ldx #RTC_REGC
d3dd : a900             [ 2] 	lda #0
d3df : 20c7d3           [ 6] 	jsr rtc_write
                             	
                             ;	; Clear alarm bytes
                             ;	lda #0
                             ;	ldx #RTC_SECA
                             ;	jsr rtc_write
                             ;	ldx #RTC_MINA
                             ;	jsr rtc_write
                             ;	ldx #RTC_HRA
                             ;	jsr rtc_write
                             ;	; Also clear day of week (not used yet)
                             ;	ldx #RTC_DOW
                             ;	jsr rtc_write
                             
                             	; Default is binary mode, 24 hour clock, no dayl
d3e2 : a20b             [ 2] 	ldx #RTC_REGB
d3e4 : a906             [ 2] 	lda #RTC_DM | RTC_2412
d3e6 : 20c7d3           [ 6] 	jsr rtc_write
                             
                             	; Make sure clock is ticking
d3e9 : a20a             [ 2] 	ldx #RTC_REGA
d3eb : a920             [ 2] 	lda #0b00100000			; Magic number to start the os
d3ed : 20c7d3           [ 6] 	jsr rtc_write
                             	
                             	; Check VRT - if zero then bad battery / RAM!
d3f0 : a20d             [ 2] 	ldx #RTC_REGD
d3f2 : 20d1d3           [ 6] 	jsr rtc_read
d3f5 : 2980             [ 2] 	and #RTC_VRT
d3f7 : d003             [ 3] 	bne rtc_badbattery_ok
d3f9 : 201fd4           [ 6] 	jsr rtc_badbattery
d3fc :                       rtc_badbattery_ok
                             	; Check NV ram - if C=1 then corrupted!
d3fc : 207cd5           [ 6] 	jsr rtc_nvvalid
d3ff : b046             [ 4] 	bcs rtc_badnvram
                             	
                             	;C=0
d401 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* rtc_badbattery
                             ;* Warn of bad battery and choice to set date/tim
                             ;****************************************
d402 :                       rtc_badbattery_msg
AS65 Assembler for R6502 [1.42].                                     Page   79
-------------------------------- bank\bank0.s --------------------------------

d402 : 5761726e696e67..      	db "Warning, RTC battery issue.",UTF_CR,0
                             	
d41f :                       rtc_badbattery
                             	; Print message
d41f : a202             [ 2] 	ldx #lo(rtc_badbattery_msg)
d421 : a9d4             [ 2] 	lda #hi(rtc_badbattery_msg)
d423 :                       rtc_printerror
d423 : 20abc5           [ 6] 	jsr io_print_line
                             	; Signifiy bad battery
d426 : 38               [ 2] 	sec
d427 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* rtc_badnvram
                             ;* Warn of bad NV ram
                             ;****************************************
d428 :                       rtc_badnvram_msg
d428 : 5761726e696e67..      	db "Warning, NV RAM checksum bad.",UTF_CR,0
                             
d447 :                       rtc_badnvram
                             	; Print message
d447 : a228             [ 2] 	ldx #lo(rtc_badnvram_msg)
d449 : a9d4             [ 2] 	lda #hi(rtc_badnvram_msg)
d44b : 80d6             [ 3] 	bra rtc_printerror
                             
                             
                             ;****************************************
                             ;* rtc_freezeupdate
                             ;* Stop time and date buffer updating
                             ;****************************************
d44d :                       rtc_freezeupdate
d44d : a20b             [ 2] 	ldx #RTC_REGB
d44f : a986             [ 2] 	lda #RTC_SET | RTC_DM | RTC_2412
d451 : 4cc7d3           [ 3] 	jmp rtc_write
                             
                             
                             ;****************************************
                             ;* rtc_resumeupdate
                             ;* Resume time and date buffer updating
                             ;****************************************
d454 :                       rtc_resumeupdate
d454 : a20b             [ 2] 	ldx #RTC_REGB
d456 : a906             [ 2] 	lda #RTC_DM | RTC_2412
d458 : 4cc7d3           [ 3] 	jmp rtc_write
                             
                             
                             ;****************************************
                             ;* rtc_setdatetime
                             ;* Set the date and time
                             ;****************************************
d45b :                       rtc_date_msg
d45b : 456e7465722064..      	db "Enter date dd/mm/yy : ",0
d472 :                       rtc_time_msg
d472 : 456e7465722074..      	db "Enter time hh/mm/ss : ",0
d489 :                       rtc_notset_msg
d489 : 4e6f7420736574..      	db "Not set",UTF_CR,0
d492 :                       rtc_setdatetime
d492 : 204dd4           [ 6] 	jsr rtc_freezeupdate
                             	; Message for get date
d495 : a25b             [ 2] 	ldx #lo(rtc_date_msg)
d497 : a9d4             [ 2] 	lda #hi(rtc_date_msg)
d499 : 20abc5           [ 6] 	jsr io_print_line
AS65 Assembler for R6502 [1.42].                                     Page   80
-------------------------------- bank\bank0.s --------------------------------

                             	; Input date to the scratch buffer
d49c : 38               [ 2] 	sec								; Echo
d49d : a200             [ 2] 	ldx #lo(scratch)				; Serial input buffer for th
d49f : a909             [ 2] 	lda #hi(scratch)
d4a1 : a00a             [ 2] 	ldy #10
d4a3 : 206fc5           [ 6] 	jsr io_read_line
d4a6 : c008             [ 2] 	cpy #8							; Must be 8 characters
d4a8 : d056             [ 4] 	bne rtc_dtnotset				; else don't set
d4aa : a200             [ 2] 	ldx #0							; Buffer is page aligned, pos 0=day
d4ac : a548             [ 3] 	lda buf_adr+1
d4ae : 201bd5           [ 6] 	jsr rtc_dtstringconvert
d4b1 : b04d             [ 4] 	bcs rtc_dtnotset
                             	; Ok now update the date from tmp_b,+1,+2
d4b3 : a207             [ 2] 	ldx #RTC_DAY
d4b5 : a543             [ 3] 	lda tmp_b
d4b7 : 20c7d3           [ 6] 	jsr rtc_write
d4ba : a208             [ 2] 	ldx #RTC_MTH
d4bc : a544             [ 3] 	lda tmp_b+1
d4be : 20c7d3           [ 6] 	jsr rtc_write
d4c1 : a209             [ 2] 	ldx #RTC_YR
d4c3 : a545             [ 3] 	lda tmp_b+2
d4c5 : 20c7d3           [ 6] 	jsr rtc_write
                             
                             	; Message for get time
d4c8 : a272             [ 2] 	ldx #lo(rtc_time_msg)
d4ca : a9d4             [ 2] 	lda #hi(rtc_time_msg)
d4cc : 20abc5           [ 6] 	jsr io_print_line
                             	; Input date to the scratch buffer
d4cf : 38               [ 2] 	sec								; Echo
d4d0 : a200             [ 2] 	ldx #lo(scratch)				; Serial input buffer for th
d4d2 : a909             [ 2] 	lda #hi(scratch)
d4d4 : a00a             [ 2] 	ldy #10
d4d6 : 206fc5           [ 6] 	jsr io_read_line
d4d9 : c008             [ 2] 	cpy #8							; Must be 8 characters
d4db : d023             [ 4] 	bne rtc_dtnotset				; else don't set
d4dd : a200             [ 2] 	ldx #0							; Buffer is page aligned, pos 0=hr
d4df : a548             [ 3] 	lda buf_adr+1
d4e1 : 201bd5           [ 6] 	jsr rtc_dtstringconvert
d4e4 : b01a             [ 4] 	bcs rtc_dtnotset
                             	; Ok now update the time from tmp_b,+1,+2
d4e6 : a204             [ 2] 	ldx #RTC_HR
d4e8 : a543             [ 3] 	lda tmp_b
d4ea : 20c7d3           [ 6] 	jsr rtc_write
d4ed : a202             [ 2] 	ldx #RTC_MIN
d4ef : a544             [ 3] 	lda tmp_b+1
d4f1 : 20c7d3           [ 6] 	jsr rtc_write
d4f4 : a200             [ 2] 	ldx #RTC_SEC
d4f6 : a545             [ 3] 	lda tmp_b+2
d4f8 : 20c7d3           [ 6] 	jsr rtc_write
d4fb : 2054d4           [ 6] 	jsr rtc_resumeupdate
                             	; Signify time set OK
d4fe : 18               [ 2] 	clc
d4ff : 60               [ 6] 	rts
d500 :                       rtc_dtnotset
                             	; Message for get date
d500 : a289             [ 2] 	ldx #lo(rtc_notset_msg)
d502 : a9d4             [ 2] 	lda #hi(rtc_notset_msg)
d504 : 20abc5           [ 6] 	jsr io_print_line
d507 : 2054d4           [ 6] 	jsr rtc_resumeupdate
                             	; Signify time not set
d50a : 38               [ 2] 	sec
d50b : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   81
-------------------------------- bank\bank0.s --------------------------------

                             
                             
                             ;****************************************
                             ;* rtc_ptrplus3
                             ;* Add 3 to tmp_v1 ptr, result in tmp_v1 + X,A
                             ;****************************************
d50c :                       rtc_ptrplus3
d50c : 18               [ 2] 	clc
d50d : a53f             [ 3] 	lda tmp_v1
d50f : 6903             [ 2] 	adc #3
d511 : 853f             [ 3] 	sta tmp_v1
d513 : aa               [ 2] 	tax
d514 : a540             [ 3] 	lda tmp_v1+1
d516 : 6900             [ 2] 	adc #0
d518 : 8540             [ 3] 	sta tmp_v1+1
d51a : 60               [ 6] 	rts
                             
                             
                             ;**************************************
                             ;* rtc_dtstringconvert
                             ;* Convert a PP:QQ:RR string
                             ;* Starting at X,A
                             ;****************************************
d51b :                       rtc_dtstringconvert
                             	; X,A is base of string pointer
d51b : 863f             [ 3] 	stx tmp_v1						
d51d : 8540             [ 3] 	sta tmp_v1+1
d51f : 2033c9           [ 6] 	jsr con_dec_to_a				; Convert day of month
d522 : b01c             [ 3] 	bcs rtc_dtbadstring
d524 : a585             [ 3] 	lda num_a						; Get converted number
d526 : 8543             [ 3] 	sta tmp_b						; Save day of month
                             
d528 : 200cd5           [ 6] 	jsr rtc_ptrplus3				; +3 to base for month
d52b : 2033c9           [ 6] 	jsr con_dec_to_a				; Convert month
d52e : b010             [ 3] 	bcs rtc_dtbadstring
d530 : a585             [ 3] 	lda num_a						; Get converted number
d532 : 8544             [ 3] 	sta tmp_b+1						; Save month
                             
d534 : 200cd5           [ 6] 	jsr rtc_ptrplus3				; +3 to base for month
d537 : 2033c9           [ 6] 	jsr con_dec_to_a				; Convert year
d53a : b004             [ 3] 	bcs rtc_dtbadstring
d53c : a585             [ 3] 	lda num_a						; Get converted number
d53e : 8545             [ 3] 	sta tmp_b+2						; Save year
d540 :                       rtc_dtbadstring
d540 : 60               [ 6] 	rts
                             
                             
                             ;**************************************
                             ;* rtc_gettimedate
                             ;* Get time and put in to 6 bytes in location X,A
                             ;* Order is : HMSDMY
                             ;**************************************
d541 :                       rtc_gettimedate
d541 : 863f             [ 3] 	stx tmp_v1
d543 : 8540             [ 3] 	sta tmp_v1+1
d545 : a000             [ 2] 	ldy #0
d547 : 204dd4           [ 6] 	jsr rtc_freezeupdate
d54a : a204             [ 2] 	ldx #RTC_HR
d54c : 20d1d3           [ 6] 	jsr rtc_read
d54f : 913f             [ 5] 	sta (tmp_v1),y
d551 : c8               [ 2] 	iny
d552 : a202             [ 2] 	ldx #RTC_MIN
AS65 Assembler for R6502 [1.42].                                     Page   82
-------------------------------- bank\bank0.s --------------------------------

d554 : 20d1d3           [ 6] 	jsr rtc_read
d557 : 913f             [ 5] 	sta (tmp_v1),y
d559 : c8               [ 2] 	iny
d55a : a200             [ 2] 	ldx #RTC_SEC
d55c : 20d1d3           [ 6] 	jsr rtc_read
d55f : 913f             [ 5] 	sta (tmp_v1),y
d561 : c8               [ 2] 	iny
d562 : a207             [ 2] 	ldx #RTC_DAY
d564 : 20d1d3           [ 6] 	jsr rtc_read
d567 : 913f             [ 5] 	sta (tmp_v1),y
d569 : c8               [ 2] 	iny
d56a : a208             [ 2] 	ldx #RTC_MTH
d56c : 20d1d3           [ 6] 	jsr rtc_read
d56f : 913f             [ 5] 	sta (tmp_v1),y
d571 : c8               [ 2] 	iny
d572 : a209             [ 2] 	ldx #RTC_YR
d574 : 20d1d3           [ 6] 	jsr rtc_read
d577 : 913f             [ 5] 	sta (tmp_v1),y
d579 : 4c54d4           [ 3] 	jmp rtc_resumeupdate
                             
                             ;**************************************
                             ;* rtc_nvvalid
                             ;* Validate nvram checksum
                             ;* C=1 means ERROR
                             ;* Simple 8 bit sum of all bytes should
                             ;* result in a zero. Partial sum carry
                             ;* is used.
                             ;* Uses A,X
                             ;**************************************
d57c :                       rtc_nvvalid
d57c : a20e             [ 2] 	ldx #14
d57e : a900             [ 2] 	lda #0
d580 : 853f             [ 3] 	sta tmp_v1
d582 :                       rtc_nvvalid_loop
d582 : 20d1d3           [ 6] 	jsr rtc_read
d585 : 18               [ 2] 	clc
d586 : 653f             [ 3] 	adc tmp_v1
d588 : 853f             [ 3] 	sta tmp_v1
d58a : e8               [ 2] 	inx
d58b : e040             [ 2] 	cpx #NV_RAMSZ+1
d58d : d0f3             [ 3] 	bne rtc_nvvalid_loop
d58f : a53f             [ 3] 	lda tmp_v1
                             	; A-1 will be C=1 if A>=1
d591 : c901             [ 2] 	cmp #1
d593 : 60               [ 6] 	rts
                             
                             ;**************************************
                             ;* rtc_nvwrite
                             ;* Write to nvram location X, value A
                             ;* Checksum (byte 127) is also updated
                             ;**************************************
d594 :                       rtc_nvwrite
                             	; Write to required nv location
d594 : 20c7d3           [ 6] 	jsr rtc_write
                             	; Zero out checksum location
d597 : a23f             [ 2] 	ldx #NV_RAMSZ
d599 : a900             [ 2] 	lda #0
d59b : 20c7d3           [ 6] 	jsr rtc_write
                             	; Get new checksum by calling validator
d59e : 207cd5           [ 6] 	jsr rtc_nvvalid
                             	; Calculate checksum by making 2s complement
d5a1 : 49ff             [ 2] 	eor #0xff
AS65 Assembler for R6502 [1.42].                                     Page   83
-------------------------------- bank\bank0.s --------------------------------

d5a3 : 18               [ 2] 	clc
d5a4 : 6901             [ 2] 	adc #1
                             	; Write new checksum
d5a6 : a23f             [ 2] 	ldx #NV_RAMSZ
d5a8 : 20c7d3           [ 6] 	jsr rtc_write
d5ab : 60               [ 6] 	rts
                             
                             ;**************************************
                             ;* rtc_nvread
                             ;* Read from nvram location X
                             ;* Value in A
                             ;* C=1 if checksum failed
                             ;**************************************
d5ac :                       rtc_nvread
                             	; Read nv location
d5ac : 20d1d3           [ 6] 	jsr rtc_read
                             	; Remember while validating checksum
d5af : 48               [ 3] 	pha
                             	; Validate checksum (C=0 if OK)
d5b0 : 207cd5           [ 6] 	jsr rtc_nvvalid
                             	; Retrieve the location read
d5b3 : 68               [ 4] 	pla
                             	; C=0 if OK and A is valid
d5b4 : 60               [ 6] 	rts
                             
d5b5 :                       mod_sz_rtc_e
                             
                             
                             	include "sound\sound.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SOUND.S
                             ;*  Sound driver module - routines to access the 
                             ;*  This sound chip was found in a number of popu
                             ;*  in the early to mid 80s, including my first c
                             ;*  the Oric-1, as well as the MSX range.  Interf
                             ;*  chip is through port A of VIA 2 because it ca
                             ;*  connected directly to the 6502 bus.  This mea
                             ;*  is a bit clunky to drive, but this is how the
                             ;*  did it, so even though I came up with this in
                             ;*  I guess I can't be too wrong with this approa
                             ;*  The AY doesn't only produce sound, it also ha
                             ;*  of 8 bit IO port - one of them I am using for
                             ;*
                             ;*  NOTE:	As part of the ROM banking strategy, th
                             ;*			lowest level routines have been factored out
                             ;*			to the 'kernel' which means they are present
                             ;*			in every code bank.
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code
                             
d5b5 :                       mod_sz_sound_s
AS65 Assembler for R6502 [1.42].                                     Page   84
-------------------------------- bank\bank0.s --------------------------------

                             
                             
                             ;****************************************
                             ;* snd_get_note
                             ;* Get a note from the music scale table
                             ;* Input : Y
                             ;* Output : A,X = Value hi,lo
                             ;* Regs affected : X
                             ;****************************************
d5b5 :                       snd_get_note
d5b5 : bedad5           [ 4] 	ldx snd_music_tab,y
d5b8 : b9dbd5           [ 4] 	lda snd_music_tab+1,y
d5bb : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* init_snd
                             ;* Initialise sound - after cia 1 has been initia
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d5bc :                       init_snd
d5bc : a200             [ 2] 	ldx #0x00
d5be :                       init_snd_regs
d5be : bccad5           [ 4] 	ldy snd_init_tab,x
d5c1 : 203dc6           [ 6] 	jsr snd_set				; Set X to Y
d5c4 : e8               [ 2] 	inx
d5c5 : e010             [ 2] 	cpx #16					; Done 16?
d5c7 : d0f5             [ 3] 	bne init_snd_regs		; Nope	
                             	
d5c9 : 60               [ 6] 	rts						; return from sub
                             
                             	; Register array initialisation values
                             	; Assuming 1.34Mhz input clock
d5ca :                       snd_init_tab
d5ca : 80                    	db 0x80				; R0 = Channel A Tone Low
d5cb : 00                    	db 0x00				; R1 = Channel A Tone High
d5cc : 00                    	db 0x00				; R2 = Channel B Tone Low
d5cd : 01                    	db 0x01				; R3 = Channel B Tone High
d5ce : 00                    	db 0x00				; R4 = Channel C Tone Low
d5cf : 02                    	db 0x02				; R5 = Channel C Tone High
d5d0 : 00                    	db 0x00				; R6 = Noise period
d5d1 : 3e                    	db 0b00111110		; R7 = Control : IOB input, IOA i
d5d2 : 1f                    	db 0x1f				; R8 = Channel A Vol
d5d3 : 1f                    	db 0x1f				; R9 = Channel B Vol
d5d4 : 1f                    	db 0x1f				; R10 = Channel C Vol
d5d5 : 00                    	db 0x00				; R11 = Envelope Period Low
d5d6 : 09                    	db 0x09				; R12 = Envelope Period High
d5d7 : 00                    	db 0b00000000		; R13 = Envelope Shape : 0000
d5d8 : 00                    	db 0x00				; R14 = IO Port A
d5d9 : 00                    	db 0x00				; R15 = IO Port B ; Initialise to 0
                             
d5da :                       snd_music_tab
d5da : 050a                  	dw 2565				; C		0
d5dc : 7509                  	dw 2421				; C#	1
d5de : ee08                  	dw 2286				; D		2
d5e0 : 6d08                  	dw 2157				; D#	3
d5e2 : f407                  	dw 2036				; E		4
d5e4 : 8207                  	dw 1922				; F		5
d5e6 : 1607                  	dw 1814				; F#	6
d5e8 : b006                  	dw 1712				; G		7
AS65 Assembler for R6502 [1.42].                                     Page   85
-------------------------------- bank\bank0.s --------------------------------

d5ea : 5006                  	dw 1616				; G#	8
d5ec : f505                  	dw 1525				; A		9
d5ee : a005                  	dw 1440				; A#	10
d5f0 : 4f05                  	dw 1359				; B		11
                             	
d5f2 : 0305                  	dw 1283				; C
d5f4 : bb04                  	dw 1211				; C#
d5f6 : 7704                  	dw 1143				; D
d5f8 : 3704                  	dw 1079				; D#
d5fa : fa03                  	dw 1018				; E
d5fc : c103                  	dw 961 				; F
d5fe : 8b03                  	dw 907 				; F#
d600 : 5803                  	dw 856 				; G
d602 : 2803                  	dw 808 				; G#
d604 : fb02                  	dw 763 				; A
d606 : d002                  	dw 720 				; A#
d608 : a702                  	dw 679 				; B
                             
d60a : 8102                  	dw 641				; C
d60c : 5d02                  	dw 605				; C#
d60e : 3b02                  	dw 571				; D
d610 : 1b02                  	dw 539				; D#
d612 : fd01                  	dw 509				; E
d614 : e001                  	dw 480				; F
d616 : c501                  	dw 453				; F#
d618 : ac01                  	dw 428				; G
d61a : 9401                  	dw 404				; G#
d61c : 7d01                  	dw 381				; A
d61e : 6801                  	dw 360				; A#
d620 : 5401                  	dw 340				; B
                             
d622 : 4101                  	dw 321				; C
d624 : 2f01                  	dw 303				; C#
d626 : 1e01                  	dw 286				; D
d628 : 0e01                  	dw 270				; D#
d62a : fe00                  	dw 254				; E
d62c : f000                  	dw 240				; F
d62e : e300                  	dw 227				; F#
d630 : d600                  	dw 214				; G
d632 : ca00                  	dw 202				; G#
d634 : bf00                  	dw 191				; A
d636 : b400                  	dw 180				; A#
d638 : aa00                  	dw 170				; B
                             
d63a : a000                  	dw 160				; C
d63c : 9700                  	dw 151				; C#
d63e : 8f00                  	dw 143				; D
d640 : 8700                  	dw 135				; D#
d642 : 7f00                  	dw 127				; E
d644 : 7800                  	dw 120				; F
d646 : 7100                  	dw 113				; F#
d648 : 6b00                  	dw 107				; G
d64a : 6500                  	dw 101				; G#
d64c : 5f00                  	dw 95 				; A
d64e : 5a00                  	dw 90 				; A#
d650 : 5500                  	dw 85 				; B
                             
d652 : 5000                  	dw 80				; C
d654 : 4c00                  	dw 76				; C#
d656 : 4700                  	dw 71				; D
d658 : 4300                  	dw 67				; D#
d65a : 4000                  	dw 64				; E
AS65 Assembler for R6502 [1.42].                                     Page   86
-------------------------------- bank\bank0.s --------------------------------

d65c : 3c00                  	dw 60				; F
d65e : 3900                  	dw 57				; F#
d660 : 3600                  	dw 54				; G
d662 : 3300                  	dw 51				; G#
d664 : 3000                  	dw 48				; A
d666 : 2d00                  	dw 45				; A#
d668 : 2a00                  	dw 42				; B
                             
d66a : 2800                  	dw 40				; C
d66c : 2600                  	dw 38				; C#
d66e : 2400                  	dw 36				; D
d670 : 2200                  	dw 34				; D#
d672 : 2000                  	dw 32				; E
d674 : 1e00                  	dw 30				; F
d676 : 1c00                  	dw 28				; F#
d678 : 1b00                  	dw 27				; G
d67a : 1900                  	dw 25				; G#
d67c : 1800                  	dw 24				; A
d67e : 1600                  	dw 22				; A#
d680 : 1500                  	dw 21				; B
                             
d682 :                       mod_sz_sound_e
                             
                             	include "vdp\vdp.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  VDP.S
                             ;*  This module implements the drivers of the VDP
                             ;*  a TMS9918a.  The VDP is interfaced to the 650
                             ;*  through a memory mapped IO (that's how the 65
                             ;*  There are only two bytes in the IO space that
                             ;*  and the 6502 needs to poke or read from these
                             ;*  delay to allow the VDP to detect and respond 
                             ;*  request.  It's interesting that delays are ne
                             ;*  MSX computer also used a TMS9918a but with Z8
                             ;*  CPU, which actually didn't need delays.  The 
                             ;*  a simple processor but a write instruction on
                             ;*  4 cycles, hence needing delays.
                             ;*  Considering it came out in the late 70s, the 
                             ;*  series of VDP are pretty impressive - 2 text 
                             ;*  a hires mode too ('a' variant).  Plus 32 hard
                             ;*  sprites and 15 colours - very good indeed. Al
                             ;*  uses its own memory so doesn't eat 6502 space
                             ;*  Downside to having its own memory is that it 
                             ;*  slow to do large updates e.g. scrolling.  Ok 
                             ;*  column screen can be scrolled and it looks ok
                             ;*  no way would I try to scroll a hires screen. 
                             ;*  why many games on the MSX didn't do smooth sc
                             ;*
                             ;*  NOTE:	As part of the ROM banking strategy, th
                             ;*			lowest level routines have been factored out
                             ;*			to the 'kernel' which means they are present
                             ;*			in every code bank.
                             ;*
                             ;************************************************
                             
AS65 Assembler for R6502 [1.42].                                     Page   87
-------------------------------- bank\bank0.s --------------------------------

                             
                             	; ROM code
                             	code
                             
d682 :                       mod_sz_vdp_s
                             
                             	include "vdp\font.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  FONT.S
                             ;*  This is the font definition, used to initiali
                             ;*  character set.  The normal char 1 is either a
                             ;*  but I have set the default to be a little spa
                             ;*  This character set is a combination of the MS
                             ;*  special characters outside of the normal ASCI
                             ;*  and Oric-1 for letters, numbers, punctuation 
                             ;*  Oric was my first computer hence the nostalgi
                             ;*
                             ;************************************************
                             
d682 : 00000000000000..      	align 256
                             	
d700 :                       vdp_font
                             ; char 0
d700 : 00                    	db %00000000
d701 : 00                    	db %00000000
d702 : 00                    	db %00000000
d703 : 00                    	db %00000000
d704 : 00                    	db %00000000
d705 : 00                    	db %00000000
d706 : 00                    	db %00000000
d707 : 00                    	db %00000000
                             ; char 1 standard
                             ;	db %00000000
                             ;	db %00100000
                             ;	db %01110000
                             ;	db %11111000
                             ;	db %01110000
                             ;	db %00100000
                             ;	db %00000000
                             ;	db %00000000
                             ; char 1 space invader
d708 : 18                    	db %00011000
d709 : 3c                    	db %00111100
d70a : 7e                    	db %01111110
d70b : db                    	db %11011011
d70c : ff                    	db %11111111
d70d : 24                    	db %00100100
d70e : 5a                    	db %01011010
d70f : a5                    	db %10100101
                             ; char 2
d710 : a8                    	db %10101000
d711 : 54                    	db %01010100
d712 : a8                    	db %10101000
d713 : 54                    	db %01010100
d714 : a8                    	db %10101000
AS65 Assembler for R6502 [1.42].                                     Page   88
-------------------------------- bank\bank0.s --------------------------------

d715 : 54                    	db %01010100
d716 : a8                    	db %10101000
d717 : 54                    	db %01010100
                             ; char 3
d718 : 20                    	db %00100000
d719 : 70                    	db %01110000
d71a : a8                    	db %10101000
d71b : 20                    	db %00100000
d71c : 20                    	db %00100000
d71d : 20                    	db %00100000
d71e : 20                    	db %00100000
d71f : 00                    	db %00000000
                             ; char 4
d720 : 20                    	db %00100000
d721 : 20                    	db %00100000
d722 : 20                    	db %00100000
d723 : 20                    	db %00100000
d724 : a8                    	db %10101000
d725 : 70                    	db %01110000
d726 : 20                    	db %00100000
d727 : 00                    	db %00000000
                             ; char 5
d728 : 00                    	db %00000000
d729 : 20                    	db %00100000
d72a : 40                    	db %01000000
d72b : f8                    	db %11111000
d72c : 40                    	db %01000000
d72d : 20                    	db %00100000
d72e : 00                    	db %00000000
d72f : 00                    	db %00000000
                             ; char 6
d730 : 00                    	db %00000000
d731 : 20                    	db %00100000
d732 : 10                    	db %00010000
d733 : f8                    	db %11111000
d734 : 10                    	db %00010000
d735 : 20                    	db %00100000
d736 : 00                    	db %00000000
d737 : 00                    	db %00000000
                             ; char 7
d738 : 60                    	db %01100000
d739 : 90                    	db %10010000
d73a : 90                    	db %10010000
d73b : 60                    	db %01100000
d73c : 00                    	db %00000000
d73d : 00                    	db %00000000
d73e : 00                    	db %00000000
d73f : 00                    	db %00000000
                             ; char 8
d740 : 20                    	db %00100000
d741 : 20                    	db %00100000
d742 : f8                    	db %11111000
d743 : 20                    	db %00100000
d744 : 20                    	db %00100000
d745 : 00                    	db %00000000
d746 : f8                    	db %11111000
d747 : 00                    	db %00000000
                             ; char 9
d748 : 00                    	db %00000000
d749 : 00                    	db %00000000
d74a : 00                    	db %00000000
d74b : 00                    	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   89
-------------------------------- bank\bank0.s --------------------------------

d74c : 00                    	db %00000000
d74d : 00                    	db %00000000
d74e : a8                    	db %10101000
d74f : 00                    	db %00000000
                             ; char 10
d750 : 00                    	db %00000000
d751 : 00                    	db %00000000
d752 : 08                    	db %00001000
d753 : 10                    	db %00010000
d754 : a0                    	db %10100000
d755 : 40                    	db %01000000
d756 : 00                    	db %00000000
d757 : 00                    	db %00000000
                             ; char 11
d758 : 30                    	db %00110000
d759 : 30                    	db %00110000
d75a : 30                    	db %00110000
d75b : f0                    	db %11110000
d75c : f0                    	db %11110000
d75d : 00                    	db %00000000
d75e : 00                    	db %00000000
d75f : 00                    	db %00000000
                             ; char 12
d760 : 00                    	db %00000000
d761 : 00                    	db %00000000
d762 : 00                    	db %00000000
d763 : f0                    	db %11110000
d764 : f0                    	db %11110000
d765 : 30                    	db %00110000
d766 : 30                    	db %00110000
d767 : 30                    	db %00110000
                             ; char 13
d768 : 00                    	db %00000000
d769 : 00                    	db %00000000
d76a : 00                    	db %00000000
d76b : 3c                    	db %00111100
d76c : 3c                    	db %00111100
d76d : 30                    	db %00110000
d76e : 30                    	db %00110000
d76f : 30                    	db %00110000
                             ; char 14
d770 : 30                    	db %00110000
d771 : 30                    	db %00110000
d772 : 30                    	db %00110000
d773 : 3c                    	db %00111100
d774 : 3c                    	db %00111100
d775 : 00                    	db %00000000
d776 : 00                    	db %00000000
d777 : 00                    	db %00000000
                             ; char 15
d778 : 30                    	db %00110000
d779 : 30                    	db %00110000
d77a : 30                    	db %00110000
d77b : fc                    	db %11111100
d77c : fc                    	db %11111100
d77d : 30                    	db %00110000
d77e : 30                    	db %00110000
d77f : 30                    	db %00110000
                             ; char 16
d780 : fc                    	db %11111100
d781 : fc                    	db %11111100
d782 : 00                    	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   90
-------------------------------- bank\bank0.s --------------------------------

d783 : 00                    	db %00000000
d784 : 00                    	db %00000000
d785 : 00                    	db %00000000
d786 : 00                    	db %00000000
d787 : 00                    	db %00000000
                             ; char 17
d788 : 00                    	db %00000000
d789 : 00                    	db %00000000
d78a : fc                    	db %11111100
d78b : fc                    	db %11111100
d78c : 00                    	db %00000000
d78d : 00                    	db %00000000
d78e : 00                    	db %00000000
d78f : 00                    	db %00000000
                             ; char 18
d790 : 00                    	db %00000000
d791 : 00                    	db %00000000
d792 : 00                    	db %00000000
d793 : fc                    	db %11111100
d794 : fc                    	db %11111100
d795 : 00                    	db %00000000
d796 : 00                    	db %00000000
d797 : 00                    	db %00000000
                             ; char 19
d798 : 00                    	db %00000000
d799 : 00                    	db %00000000
d79a : 00                    	db %00000000
d79b : 00                    	db %00000000
d79c : fc                    	db %11111100
d79d : fc                    	db %11111100
d79e : 00                    	db %00000000
d79f : 00                    	db %00000000
                             ; char 20
d7a0 : 00                    	db %00000000
d7a1 : 00                    	db %00000000
d7a2 : 00                    	db %00000000
d7a3 : 00                    	db %00000000
d7a4 : 00                    	db %00000000
d7a5 : 00                    	db %00000000
d7a6 : fc                    	db %11111100
d7a7 : fc                    	db %11111100
                             ; char 21
d7a8 : 30                    	db %00110000
d7a9 : 30                    	db %00110000
d7aa : 30                    	db %00110000
d7ab : 3c                    	db %00111100
d7ac : 3c                    	db %00111100
d7ad : 30                    	db %00110000
d7ae : 30                    	db %00110000
d7af : 30                    	db %00110000
                             ; char 22
d7b0 : 30                    	db %00110000
d7b1 : 30                    	db %00110000
d7b2 : 30                    	db %00110000
d7b3 : f0                    	db %11110000
d7b4 : f0                    	db %11110000
d7b5 : 30                    	db %00110000
d7b6 : 30                    	db %00110000
d7b7 : 30                    	db %00110000
                             ; char 23
d7b8 : 30                    	db %00110000
d7b9 : 30                    	db %00110000
AS65 Assembler for R6502 [1.42].                                     Page   91
-------------------------------- bank\bank0.s --------------------------------

d7ba : 30                    	db %00110000
d7bb : fc                    	db %11111100
d7bc : fc                    	db %11111100
d7bd : 00                    	db %00000000
d7be : 00                    	db %00000000
d7bf : 00                    	db %00000000
                             ; char 24
d7c0 : 00                    	db %00000000
d7c1 : 00                    	db %00000000
d7c2 : 00                    	db %00000000
d7c3 : fc                    	db %11111100
d7c4 : fc                    	db %11111100
d7c5 : 30                    	db %00110000
d7c6 : 30                    	db %00110000
d7c7 : 30                    	db %00110000
                             ; char 25
d7c8 : 30                    	db %00110000
d7c9 : 30                    	db %00110000
d7ca : 30                    	db %00110000
d7cb : 30                    	db %00110000
d7cc : 30                    	db %00110000
d7cd : 30                    	db %00110000
d7ce : 30                    	db %00110000
d7cf : 30                    	db %00110000
                             ; char 26
d7d0 : 08                    	db %00001000
d7d1 : 30                    	db %00110000
d7d2 : c0                    	db %11000000
d7d3 : 30                    	db %00110000
d7d4 : 08                    	db %00001000
d7d5 : 00                    	db %00000000
d7d6 : f8                    	db %11111000
d7d7 : 00                    	db %00000000
                             ; char 27
d7d8 : 80                    	db %10000000
d7d9 : 60                    	db %01100000
d7da : 18                    	db %00011000
d7db : 60                    	db %01100000
d7dc : 80                    	db %10000000
d7dd : 00                    	db %00000000
d7de : f8                    	db %11111000
d7df : 00                    	db %00000000
                             ; char 28
d7e0 : 00                    	db %00000000
d7e1 : 00                    	db %00000000
d7e2 : f8                    	db %11111000
d7e3 : 50                    	db %01010000
d7e4 : 50                    	db %01010000
d7e5 : 50                    	db %01010000
d7e6 : 98                    	db %10011000
d7e7 : 00                    	db %00000000
                             ; char 29
d7e8 : 10                    	db %00010000
d7e9 : 10                    	db %00010000
d7ea : f8                    	db %11111000
d7eb : 20                    	db %00100000
d7ec : f8                    	db %11111000
d7ed : 40                    	db %01000000
d7ee : 40                    	db %01000000
d7ef : 00                    	db %00000000
                             ; char 30
d7f0 : 30                    	db %00110000
AS65 Assembler for R6502 [1.42].                                     Page   92
-------------------------------- bank\bank0.s --------------------------------

d7f1 : 48                    	db %01001000
d7f2 : 40                    	db %01000000
d7f3 : e0                    	db %11100000
d7f4 : 40                    	db %01000000
d7f5 : 48                    	db %01001000
d7f6 : b0                    	db %10110000
d7f7 : 00                    	db %00000000
                             ; char 31
d7f8 : 00                    	db %00000000
d7f9 : 00                    	db %00000000
d7fa : 00                    	db %00000000
d7fb : 20                    	db %00100000
d7fc : 00                    	db %00000000
d7fd : 00                    	db %00000000
d7fe : 00                    	db %00000000
d7ff : 00                    	db %00000000
                             ; char 32
d800 : 00                    	db %00000000
d801 : 00                    	db %00000000
d802 : 00                    	db %00000000
d803 : 00                    	db %00000000
d804 : 00                    	db %00000000
d805 : 00                    	db %00000000
d806 : 00                    	db %00000000
d807 : 00                    	db %00000000
                             ; char 33
d808 : 20                    	db %00100000
d809 : 20                    	db %00100000
d80a : 20                    	db %00100000
d80b : 20                    	db %00100000
d80c : 20                    	db %00100000
d80d : 00                    	db %00000000
d80e : 20                    	db %00100000
d80f : 00                    	db %00000000
                             ; char 34
d810 : 50                    	db %01010000
d811 : 50                    	db %01010000
d812 : 50                    	db %01010000
d813 : 00                    	db %00000000
d814 : 00                    	db %00000000
d815 : 00                    	db %00000000
d816 : 00                    	db %00000000
d817 : 00                    	db %00000000
                             ; char 35
d818 : 50                    	db %01010000
d819 : 50                    	db %01010000
d81a : f8                    	db %11111000
d81b : 50                    	db %01010000
d81c : f8                    	db %11111000
d81d : 50                    	db %01010000
d81e : 50                    	db %01010000
d81f : 00                    	db %00000000
                             ; char 36
d820 : 20                    	db %00100000
d821 : 78                    	db %01111000
d822 : a0                    	db %10100000
d823 : 70                    	db %01110000
d824 : 28                    	db %00101000
d825 : f0                    	db %11110000
d826 : 20                    	db %00100000
d827 : 00                    	db %00000000
                             ; char 37
AS65 Assembler for R6502 [1.42].                                     Page   93
-------------------------------- bank\bank0.s --------------------------------

d828 : c0                    	db %11000000
d829 : c8                    	db %11001000
d82a : 10                    	db %00010000
d82b : 20                    	db %00100000
d82c : 40                    	db %01000000
d82d : 98                    	db %10011000
d82e : 18                    	db %00011000
d82f : 00                    	db %00000000
                             ; char 38
d830 : 40                    	db %01000000
d831 : a0                    	db %10100000
d832 : a0                    	db %10100000
d833 : 40                    	db %01000000
d834 : a8                    	db %10101000
d835 : 90                    	db %10010000
d836 : 68                    	db %01101000
d837 : 00                    	db %00000000
                             ; char 39
d838 : 20                    	db %00100000
d839 : 20                    	db %00100000
d83a : 20                    	db %00100000
d83b : 00                    	db %00000000
d83c : 00                    	db %00000000
d83d : 00                    	db %00000000
d83e : 00                    	db %00000000
d83f : 00                    	db %00000000
                             ; char 40
d840 : 20                    	db %00100000
d841 : 40                    	db %01000000
d842 : 80                    	db %10000000
d843 : 80                    	db %10000000
d844 : 80                    	db %10000000
d845 : 40                    	db %01000000
d846 : 20                    	db %00100000
d847 : 00                    	db %00000000
                             ; char 41
d848 : 20                    	db %00100000
d849 : 10                    	db %00010000
d84a : 08                    	db %00001000
d84b : 08                    	db %00001000
d84c : 08                    	db %00001000
d84d : 10                    	db %00010000
d84e : 20                    	db %00100000
d84f : 00                    	db %00000000
                             ; char 42
d850 : 20                    	db %00100000
d851 : a8                    	db %10101000
d852 : 70                    	db %01110000
d853 : 20                    	db %00100000
d854 : 70                    	db %01110000
d855 : a8                    	db %10101000
d856 : 20                    	db %00100000
d857 : 00                    	db %00000000
                             ; char 43
d858 : 00                    	db %00000000
d859 : 20                    	db %00100000
d85a : 20                    	db %00100000
d85b : f8                    	db %11111000
d85c : 20                    	db %00100000
d85d : 20                    	db %00100000
d85e : 00                    	db %00000000
d85f : 00                    	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   94
-------------------------------- bank\bank0.s --------------------------------

                             ; char 44
d860 : 00                    	db %00000000
d861 : 00                    	db %00000000
d862 : 00                    	db %00000000
d863 : 00                    	db %00000000
d864 : 00                    	db %00000000
d865 : 20                    	db %00100000
d866 : 20                    	db %00100000
d867 : 40                    	db %01000000
                             ; char 45
d868 : 00                    	db %00000000
d869 : 00                    	db %00000000
d86a : 00                    	db %00000000
d86b : f8                    	db %11111000
d86c : 00                    	db %00000000
d86d : 00                    	db %00000000
d86e : 00                    	db %00000000
d86f : 00                    	db %00000000
                             ; char 46
d870 : 00                    	db %00000000
d871 : 00                    	db %00000000
d872 : 00                    	db %00000000
d873 : 00                    	db %00000000
d874 : 00                    	db %00000000
d875 : 10                    	db %00010000
d876 : 00                    	db %00000000
d877 : 00                    	db %00000000
                             ; char 47
d878 : 00                    	db %00000000
d879 : 08                    	db %00001000
d87a : 10                    	db %00010000
d87b : 20                    	db %00100000
d87c : 40                    	db %01000000
d87d : 80                    	db %10000000
d87e : 00                    	db %00000000
d87f : 00                    	db %00000000
                             ; char 48
d880 : 70                    	db %01110000
d881 : 88                    	db %10001000
d882 : 98                    	db %10011000
d883 : a8                    	db %10101000
d884 : c8                    	db %11001000
d885 : 88                    	db %10001000
d886 : 70                    	db %01110000
d887 : 00                    	db %00000000
                             ; char 49
d888 : 20                    	db %00100000
d889 : 60                    	db %01100000
d88a : 20                    	db %00100000
d88b : 20                    	db %00100000
d88c : 20                    	db %00100000
d88d : 20                    	db %00100000
d88e : 70                    	db %01110000
d88f : 00                    	db %00000000
                             ; char 50
d890 : 70                    	db %01110000
d891 : 88                    	db %10001000
d892 : 08                    	db %00001000
d893 : 10                    	db %00010000
d894 : 20                    	db %00100000
d895 : 40                    	db %01000000
d896 : f8                    	db %11111000
AS65 Assembler for R6502 [1.42].                                     Page   95
-------------------------------- bank\bank0.s --------------------------------

d897 : 00                    	db %00000000
                             ; char 51
d898 : f8                    	db %11111000
d899 : 08                    	db %00001000
d89a : 10                    	db %00010000
d89b : 30                    	db %00110000
d89c : 08                    	db %00001000
d89d : 88                    	db %10001000
d89e : 70                    	db %01110000
d89f : 00                    	db %00000000
                             ; char 52
d8a0 : 10                    	db %00010000
d8a1 : 30                    	db %00110000
d8a2 : 50                    	db %01010000
d8a3 : 90                    	db %10010000
d8a4 : f8                    	db %11111000
d8a5 : 10                    	db %00010000
d8a6 : 10                    	db %00010000
d8a7 : 00                    	db %00000000
                             ; char 53
d8a8 : f8                    	db %11111000
d8a9 : 80                    	db %10000000
d8aa : f0                    	db %11110000
d8ab : 08                    	db %00001000
d8ac : 08                    	db %00001000
d8ad : 88                    	db %10001000
d8ae : 70                    	db %01110000
d8af : 00                    	db %00000000
                             ; char 54
d8b0 : 30                    	db %00110000
d8b1 : 40                    	db %01000000
d8b2 : 80                    	db %10000000
d8b3 : f0                    	db %11110000
d8b4 : 88                    	db %10001000
d8b5 : 88                    	db %10001000
d8b6 : 70                    	db %01110000
d8b7 : 00                    	db %00000000
                             ; char 55
d8b8 : f8                    	db %11111000
d8b9 : 08                    	db %00001000
d8ba : 10                    	db %00010000
d8bb : 20                    	db %00100000
d8bc : 40                    	db %01000000
d8bd : 40                    	db %01000000
d8be : 40                    	db %01000000
d8bf : 00                    	db %00000000
                             ; char 56
d8c0 : 70                    	db %01110000
d8c1 : 88                    	db %10001000
d8c2 : 88                    	db %10001000
d8c3 : 70                    	db %01110000
d8c4 : 88                    	db %10001000
d8c5 : 88                    	db %10001000
d8c6 : 70                    	db %01110000
d8c7 : 00                    	db %00000000
                             ; char 57
d8c8 : 70                    	db %01110000
d8c9 : 88                    	db %10001000
d8ca : 88                    	db %10001000
d8cb : 78                    	db %01111000
d8cc : 08                    	db %00001000
d8cd : 10                    	db %00010000
AS65 Assembler for R6502 [1.42].                                     Page   96
-------------------------------- bank\bank0.s --------------------------------

d8ce : 60                    	db %01100000
d8cf : 00                    	db %00000000
                             ; char 58
d8d0 : 00                    	db %00000000
d8d1 : 00                    	db %00000000
d8d2 : 20                    	db %00100000
d8d3 : 00                    	db %00000000
d8d4 : 00                    	db %00000000
d8d5 : 20                    	db %00100000
d8d6 : 00                    	db %00000000
d8d7 : 00                    	db %00000000
                             ; char 59
d8d8 : 00                    	db %00000000
d8d9 : 00                    	db %00000000
d8da : 20                    	db %00100000
d8db : 00                    	db %00000000
d8dc : 00                    	db %00000000
d8dd : 20                    	db %00100000
d8de : 20                    	db %00100000
d8df : 40                    	db %01000000
                             ; char 60
d8e0 : 10                    	db %00010000
d8e1 : 20                    	db %00100000
d8e2 : 40                    	db %01000000
d8e3 : 80                    	db %10000000
d8e4 : 40                    	db %01000000
d8e5 : 20                    	db %00100000
d8e6 : 10                    	db %00010000
d8e7 : 00                    	db %00000000
                             ; char 61
d8e8 : 00                    	db %00000000
d8e9 : 00                    	db %00000000
d8ea : f8                    	db %11111000
d8eb : 00                    	db %00000000
d8ec : f8                    	db %11111000
d8ed : 00                    	db %00000000
d8ee : 00                    	db %00000000
d8ef : 00                    	db %00000000
                             ; char 62
d8f0 : 40                    	db %01000000
d8f1 : 20                    	db %00100000
d8f2 : 10                    	db %00010000
d8f3 : 08                    	db %00001000
d8f4 : 10                    	db %00010000
d8f5 : 20                    	db %00100000
d8f6 : 40                    	db %01000000
d8f7 : 00                    	db %00000000
                             ; char 63
d8f8 : 70                    	db %01110000
d8f9 : 88                    	db %10001000
d8fa : 10                    	db %00010000
d8fb : 20                    	db %00100000
d8fc : 20                    	db %00100000
d8fd : 00                    	db %00000000
d8fe : 20                    	db %00100000
d8ff : 00                    	db %00000000
                             ; char 64
d900 : 70                    	db %01110000
d901 : 88                    	db %10001000
d902 : a8                    	db %10101000
d903 : b8                    	db %10111000
d904 : b0                    	db %10110000
AS65 Assembler for R6502 [1.42].                                     Page   97
-------------------------------- bank\bank0.s --------------------------------

d905 : 80                    	db %10000000
d906 : 78                    	db %01111000
d907 : 00                    	db %00000000
d908 :                       vdp_font_a
                             ; char 65
d908 : 20                    	db %00100000
d909 : 50                    	db %01010000
d90a : 88                    	db %10001000
d90b : 88                    	db %10001000
d90c : f8                    	db %11111000
d90d : 88                    	db %10001000
d90e : 88                    	db %10001000
d90f : 00                    	db %00000000
                             ; char 66
d910 : f0                    	db %11110000
d911 : 88                    	db %10001000
d912 : 88                    	db %10001000
d913 : f0                    	db %11110000
d914 : 88                    	db %10001000
d915 : 88                    	db %10001000
d916 : f0                    	db %11110000
d917 : 00                    	db %00000000
                             ; char 67
d918 : 70                    	db %01110000
d919 : 88                    	db %10001000
d91a : 80                    	db %10000000
d91b : 80                    	db %10000000
d91c : 80                    	db %10000000
d91d : 88                    	db %10001000
d91e : 70                    	db %01110000
d91f : 00                    	db %00000000
                             ; char 68
d920 : f0                    	db %11110000
d921 : 88                    	db %10001000
d922 : 88                    	db %10001000
d923 : 88                    	db %10001000
d924 : 88                    	db %10001000
d925 : 88                    	db %10001000
d926 : f0                    	db %11110000
d927 : 00                    	db %00000000
                             ; char 69
d928 : f8                    	db %11111000
d929 : 80                    	db %10000000
d92a : 80                    	db %10000000
d92b : f0                    	db %11110000
d92c : 80                    	db %10000000
d92d : 80                    	db %10000000
d92e : f8                    	db %11111000
d92f : 00                    	db %00000000
                             ; char 70
d930 : f8                    	db %11111000
d931 : 80                    	db %10000000
d932 : 80                    	db %10000000
d933 : f0                    	db %11110000
d934 : 80                    	db %10000000
d935 : 80                    	db %10000000
d936 : 80                    	db %10000000
d937 : 00                    	db %00000000
                             ; char 71
d938 : 78                    	db %01111000
d939 : 80                    	db %10000000
d93a : 80                    	db %10000000
AS65 Assembler for R6502 [1.42].                                     Page   98
-------------------------------- bank\bank0.s --------------------------------

d93b : 80                    	db %10000000
d93c : 98                    	db %10011000
d93d : 88                    	db %10001000
d93e : 78                    	db %01111000
d93f : 00                    	db %00000000
                             ; char 72
d940 : 88                    	db %10001000
d941 : 88                    	db %10001000
d942 : 88                    	db %10001000
d943 : f8                    	db %11111000
d944 : 88                    	db %10001000
d945 : 88                    	db %10001000
d946 : 88                    	db %10001000
d947 : 00                    	db %00000000
                             ; char 73
d948 : 70                    	db %01110000
d949 : 20                    	db %00100000
d94a : 20                    	db %00100000
d94b : 20                    	db %00100000
d94c : 20                    	db %00100000
d94d : 20                    	db %00100000
d94e : 70                    	db %01110000
d94f : 00                    	db %00000000
                             ; char 74
d950 : 08                    	db %00001000
d951 : 08                    	db %00001000
d952 : 08                    	db %00001000
d953 : 08                    	db %00001000
d954 : 08                    	db %00001000
d955 : 88                    	db %10001000
d956 : 70                    	db %01110000
d957 : 00                    	db %00000000
                             ; char 75
d958 : 88                    	db %10001000
d959 : 90                    	db %10010000
d95a : a0                    	db %10100000
d95b : c0                    	db %11000000
d95c : a0                    	db %10100000
d95d : 90                    	db %10010000
d95e : 88                    	db %10001000
d95f : 00                    	db %00000000
                             ; char 76
d960 : 80                    	db %10000000
d961 : 80                    	db %10000000
d962 : 80                    	db %10000000
d963 : 80                    	db %10000000
d964 : 80                    	db %10000000
d965 : 80                    	db %10000000
d966 : f8                    	db %11111000
d967 : 00                    	db %00000000
                             ; char 77
d968 : 88                    	db %10001000
d969 : d8                    	db %11011000
d96a : a8                    	db %10101000
d96b : a8                    	db %10101000
d96c : 88                    	db %10001000
d96d : 88                    	db %10001000
d96e : 88                    	db %10001000
d96f : 00                    	db %00000000
                             ; char 78
d970 : 88                    	db %10001000
d971 : 88                    	db %10001000
AS65 Assembler for R6502 [1.42].                                     Page   99
-------------------------------- bank\bank0.s --------------------------------

d972 : c8                    	db %11001000
d973 : a8                    	db %10101000
d974 : 98                    	db %10011000
d975 : 88                    	db %10001000
d976 : 88                    	db %10001000
d977 : 00                    	db %00000000
                             ; char 79
d978 : 70                    	db %01110000
d979 : 88                    	db %10001000
d97a : 88                    	db %10001000
d97b : 88                    	db %10001000
d97c : 88                    	db %10001000
d97d : 88                    	db %10001000
d97e : 70                    	db %01110000
d97f : 00                    	db %00000000
                             ; char 80
d980 : f0                    	db %11110000
d981 : 88                    	db %10001000
d982 : 88                    	db %10001000
d983 : f0                    	db %11110000
d984 : 80                    	db %10000000
d985 : 80                    	db %10000000
d986 : 80                    	db %10000000
d987 : 00                    	db %00000000
                             ; char 81
d988 : 70                    	db %01110000
d989 : 88                    	db %10001000
d98a : 88                    	db %10001000
d98b : 88                    	db %10001000
d98c : a8                    	db %10101000
d98d : 90                    	db %10010000
d98e : 68                    	db %01101000
d98f : 00                    	db %00000000
                             ; char 82
d990 : f0                    	db %11110000
d991 : 88                    	db %10001000
d992 : 88                    	db %10001000
d993 : f0                    	db %11110000
d994 : a0                    	db %10100000
d995 : 90                    	db %10010000
d996 : 88                    	db %10001000
d997 : 00                    	db %00000000
                             ; char 83
d998 : 70                    	db %01110000
d999 : 88                    	db %10001000
d99a : 80                    	db %10000000
d99b : 70                    	db %01110000
d99c : 08                    	db %00001000
d99d : 88                    	db %10001000
d99e : 70                    	db %01110000
d99f : 00                    	db %00000000
                             ; char 84
d9a0 : f8                    	db %11111000
d9a1 : 20                    	db %00100000
d9a2 : 20                    	db %00100000
d9a3 : 20                    	db %00100000
d9a4 : 20                    	db %00100000
d9a5 : 20                    	db %00100000
d9a6 : 20                    	db %00100000
d9a7 : 00                    	db %00000000
                             ; char 85
d9a8 : 88                    	db %10001000
AS65 Assembler for R6502 [1.42].                                     Page  100
-------------------------------- bank\bank0.s --------------------------------

d9a9 : 88                    	db %10001000
d9aa : 88                    	db %10001000
d9ab : 88                    	db %10001000
d9ac : 88                    	db %10001000
d9ad : 88                    	db %10001000
d9ae : 70                    	db %01110000
d9af : 00                    	db %00000000
                             ; char 86
d9b0 : 88                    	db %10001000
d9b1 : 88                    	db %10001000
d9b2 : 88                    	db %10001000
d9b3 : 88                    	db %10001000
d9b4 : 88                    	db %10001000
d9b5 : 50                    	db %01010000
d9b6 : 20                    	db %00100000
d9b7 : 00                    	db %00000000
                             ; char 87
d9b8 : 88                    	db %10001000
d9b9 : 88                    	db %10001000
d9ba : 88                    	db %10001000
d9bb : a8                    	db %10101000
d9bc : a8                    	db %10101000
d9bd : d8                    	db %11011000
d9be : 88                    	db %10001000
d9bf : 00                    	db %00000000
                             ; char 88
d9c0 : 88                    	db %10001000
d9c1 : 88                    	db %10001000
d9c2 : 50                    	db %01010000
d9c3 : 20                    	db %00100000
d9c4 : 50                    	db %01010000
d9c5 : 88                    	db %10001000
d9c6 : 88                    	db %10001000
d9c7 : 00                    	db %00000000
                             ; char 89
d9c8 : 88                    	db %10001000
d9c9 : 88                    	db %10001000
d9ca : 50                    	db %01010000
d9cb : 20                    	db %00100000
d9cc : 20                    	db %00100000
d9cd : 20                    	db %00100000
d9ce : 20                    	db %00100000
d9cf : 00                    	db %00000000
                             ; char 90
d9d0 : f8                    	db %11111000
d9d1 : 08                    	db %00001000
d9d2 : 10                    	db %00010000
d9d3 : 20                    	db %00100000
d9d4 : 40                    	db %01000000
d9d5 : 80                    	db %10000000
d9d6 : f8                    	db %11111000
d9d7 : 00                    	db %00000000
                             ; char 91
d9d8 : 78                    	db %01111000
d9d9 : 40                    	db %01000000
d9da : 40                    	db %01000000
d9db : 40                    	db %01000000
d9dc : 40                    	db %01000000
d9dd : 40                    	db %01000000
d9de : 78                    	db %01111000
d9df : 00                    	db %00000000
                             ; char 92
AS65 Assembler for R6502 [1.42].                                     Page  101
-------------------------------- bank\bank0.s --------------------------------

d9e0 : 00                    	db %00000000
d9e1 : 80                    	db %10000000
d9e2 : 40                    	db %01000000
d9e3 : 20                    	db %00100000
d9e4 : 10                    	db %00010000
d9e5 : 08                    	db %00001000
d9e6 : 00                    	db %00000000
d9e7 : 00                    	db %00000000
                             ; char 93
d9e8 : f0                    	db %11110000
d9e9 : 10                    	db %00010000
d9ea : 10                    	db %00010000
d9eb : 10                    	db %00010000
d9ec : 10                    	db %00010000
d9ed : 10                    	db %00010000
d9ee : f0                    	db %11110000
d9ef : 00                    	db %00000000
                             ; char 94
d9f0 : 20                    	db %00100000
d9f1 : 50                    	db %01010000
d9f2 : a8                    	db %10101000
d9f3 : 20                    	db %00100000
d9f4 : 20                    	db %00100000
d9f5 : 20                    	db %00100000
d9f6 : 20                    	db %00100000
d9f7 : 00                    	db %00000000
                             ; char 95
d9f8 : 00                    	db %00000000
d9f9 : 00                    	db %00000000
d9fa : 00                    	db %00000000
d9fb : 00                    	db %00000000
d9fc : 00                    	db %00000000
d9fd : 00                    	db %00000000
d9fe : f8                    	db %11111000
d9ff : 00                    	db %00000000
                             ; char 96
da00 : 38                    	db %00111000
da01 : 40                    	db %01000000
da02 : 40                    	db %01000000
da03 : 40                    	db %01000000
da04 : f0                    	db %11110000
da05 : 40                    	db %01000000
da06 : f8                    	db %11111000
da07 : 00                    	db %00000000
                             ; char 97
da08 : 00                    	db %00000000
da09 : 00                    	db %00000000
da0a : 70                    	db %01110000
da0b : 08                    	db %00001000
da0c : 78                    	db %01111000
da0d : 88                    	db %10001000
da0e : 78                    	db %01111000
da0f : 00                    	db %00000000
                             ; char 98
da10 : 80                    	db %10000000
da11 : 80                    	db %10000000
da12 : f0                    	db %11110000
da13 : 88                    	db %10001000
da14 : 88                    	db %10001000
da15 : 88                    	db %10001000
da16 : f0                    	db %11110000
da17 : 00                    	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page  102
-------------------------------- bank\bank0.s --------------------------------

                             ; char 99
da18 : 00                    	db %00000000
da19 : 00                    	db %00000000
da1a : 78                    	db %01111000
da1b : 80                    	db %10000000
da1c : 80                    	db %10000000
da1d : 80                    	db %10000000
da1e : 78                    	db %01111000
da1f : 00                    	db %00000000
                             ; char 100
da20 : 08                    	db %00001000
da21 : 08                    	db %00001000
da22 : 78                    	db %01111000
da23 : 88                    	db %10001000
da24 : 88                    	db %10001000
da25 : 88                    	db %10001000
da26 : 78                    	db %01111000
da27 : 00                    	db %00000000
                             ; char 101
da28 : 00                    	db %00000000
da29 : 00                    	db %00000000
da2a : 70                    	db %01110000
da2b : 88                    	db %10001000
da2c : f8                    	db %11111000
da2d : 80                    	db %10000000
da2e : 78                    	db %01111000
da2f : 00                    	db %00000000
                             ; char 102
da30 : 30                    	db %00110000
da31 : 48                    	db %01001000
da32 : 40                    	db %01000000
da33 : f0                    	db %11110000
da34 : 40                    	db %01000000
da35 : 40                    	db %01000000
da36 : 40                    	db %01000000
da37 : 00                    	db %00000000
                             ; char 103
da38 : 00                    	db %00000000
da39 : 00                    	db %00000000
da3a : 70                    	db %01110000
da3b : 88                    	db %10001000
da3c : 88                    	db %10001000
da3d : 78                    	db %01111000
da3e : 08                    	db %00001000
da3f : 70                    	db %01110000
                             ; char 104
da40 : 80                    	db %10000000
da41 : 80                    	db %10000000
da42 : f0                    	db %11110000
da43 : 88                    	db %10001000
da44 : 88                    	db %10001000
da45 : 88                    	db %10001000
da46 : 88                    	db %10001000
da47 : 00                    	db %00000000
                             ; char 105
da48 : 20                    	db %00100000
da49 : 00                    	db %00000000
da4a : 60                    	db %01100000
da4b : 20                    	db %00100000
da4c : 20                    	db %00100000
da4d : 20                    	db %00100000
da4e : 70                    	db %01110000
AS65 Assembler for R6502 [1.42].                                     Page  103
-------------------------------- bank\bank0.s --------------------------------

da4f : 00                    	db %00000000
                             ; char 106
da50 : 10                    	db %00010000
da51 : 00                    	db %00000000
da52 : 30                    	db %00110000
da53 : 10                    	db %00010000
da54 : 10                    	db %00010000
da55 : 10                    	db %00010000
da56 : 90                    	db %10010000
da57 : 60                    	db %01100000
                             ; char 107
da58 : 80                    	db %10000000
da59 : 80                    	db %10000000
da5a : 88                    	db %10001000
da5b : 90                    	db %10010000
da5c : e0                    	db %11100000
da5d : 90                    	db %10010000
da5e : 88                    	db %10001000
da5f : 00                    	db %00000000
                             ; char 108
da60 : 60                    	db %01100000
da61 : 20                    	db %00100000
da62 : 20                    	db %00100000
da63 : 20                    	db %00100000
da64 : 20                    	db %00100000
da65 : 20                    	db %00100000
da66 : 70                    	db %01110000
da67 : 00                    	db %00000000
                             ; char 109
da68 : 00                    	db %00000000
da69 : 00                    	db %00000000
da6a : d8                    	db %11011000
da6b : a8                    	db %10101000
da6c : a8                    	db %10101000
da6d : a8                    	db %10101000
da6e : 88                    	db %10001000
da6f : 00                    	db %00000000
                             ; char 110
da70 : 00                    	db %00000000
da71 : 00                    	db %00000000
da72 : f0                    	db %11110000
da73 : 88                    	db %10001000
da74 : 88                    	db %10001000
da75 : 88                    	db %10001000
da76 : 88                    	db %10001000
da77 : 00                    	db %00000000
                             ; char 111
da78 : 00                    	db %00000000
da79 : 00                    	db %00000000
da7a : 70                    	db %01110000
da7b : 88                    	db %10001000
da7c : 88                    	db %10001000
da7d : 88                    	db %10001000
da7e : 70                    	db %01110000
da7f : 00                    	db %00000000
                             ; char 112
da80 : 00                    	db %00000000
da81 : 00                    	db %00000000
da82 : f0                    	db %11110000
da83 : 88                    	db %10001000
da84 : 88                    	db %10001000
da85 : f0                    	db %11110000
AS65 Assembler for R6502 [1.42].                                     Page  104
-------------------------------- bank\bank0.s --------------------------------

da86 : 80                    	db %10000000
da87 : 80                    	db %10000000
                             ; char 113
da88 : 00                    	db %00000000
da89 : 00                    	db %00000000
da8a : 78                    	db %01111000
da8b : 88                    	db %10001000
da8c : 88                    	db %10001000
da8d : 78                    	db %01111000
da8e : 08                    	db %00001000
da8f : 08                    	db %00001000
                             ; char 114
da90 : 00                    	db %00000000
da91 : 00                    	db %00000000
da92 : b8                    	db %10111000
da93 : c0                    	db %11000000
da94 : 80                    	db %10000000
da95 : 80                    	db %10000000
da96 : 80                    	db %10000000
da97 : 00                    	db %00000000
                             ; char 115
da98 : 00                    	db %00000000
da99 : 00                    	db %00000000
da9a : 78                    	db %01111000
da9b : 80                    	db %10000000
da9c : 70                    	db %01110000
da9d : 08                    	db %00001000
da9e : f0                    	db %11110000
da9f : 00                    	db %00000000
                             ; char 116
daa0 : 40                    	db %01000000
daa1 : 40                    	db %01000000
daa2 : f0                    	db %11110000
daa3 : 40                    	db %01000000
daa4 : 40                    	db %01000000
daa5 : 48                    	db %01001000
daa6 : 30                    	db %00110000
daa7 : 00                    	db %00000000
                             ; char 117
daa8 : 00                    	db %00000000
daa9 : 00                    	db %00000000
daaa : 88                    	db %10001000
daab : 88                    	db %10001000
daac : 88                    	db %10001000
daad : 98                    	db %10011000
daae : 68                    	db %01101000
daaf : 00                    	db %00000000
                             ; char 118
dab0 : 00                    	db %00000000
dab1 : 00                    	db %00000000
dab2 : 88                    	db %10001000
dab3 : 88                    	db %10001000
dab4 : 88                    	db %10001000
dab5 : 50                    	db %01010000
dab6 : 20                    	db %00100000
dab7 : 00                    	db %00000000
                             ; char 119
dab8 : 00                    	db %00000000
dab9 : 00                    	db %00000000
daba : 88                    	db %10001000
dabb : 88                    	db %10001000
dabc : a8                    	db %10101000
AS65 Assembler for R6502 [1.42].                                     Page  105
-------------------------------- bank\bank0.s --------------------------------

dabd : a8                    	db %10101000
dabe : d8                    	db %11011000
dabf : 00                    	db %00000000
                             ; char 120
dac0 : 00                    	db %00000000
dac1 : 00                    	db %00000000
dac2 : 88                    	db %10001000
dac3 : 50                    	db %01010000
dac4 : 20                    	db %00100000
dac5 : 50                    	db %01010000
dac6 : 88                    	db %10001000
dac7 : 00                    	db %00000000
                             ; char 121
dac8 : 00                    	db %00000000
dac9 : 00                    	db %00000000
daca : 88                    	db %10001000
dacb : 88                    	db %10001000
dacc : 88                    	db %10001000
dacd : 78                    	db %01111000
dace : 08                    	db %00001000
dacf : 70                    	db %01110000
                             ; char 122
dad0 : 00                    	db %00000000
dad1 : 00                    	db %00000000
dad2 : f8                    	db %11111000
dad3 : 10                    	db %00010000
dad4 : 20                    	db %00100000
dad5 : 40                    	db %01000000
dad6 : f8                    	db %11111000
dad7 : 00                    	db %00000000
                             ; char 123
dad8 : 38                    	db %00111000
dad9 : 60                    	db %01100000
dada : 60                    	db %01100000
dadb : c0                    	db %11000000
dadc : 60                    	db %01100000
dadd : 60                    	db %01100000
dade : 38                    	db %00111000
dadf : 00                    	db %00000000
                             ; char 124
dae0 : 20                    	db %00100000
dae1 : 20                    	db %00100000
dae2 : 20                    	db %00100000
dae3 : 20                    	db %00100000
dae4 : 20                    	db %00100000
dae5 : 20                    	db %00100000
dae6 : 20                    	db %00100000
dae7 : 20                    	db %00100000
                             ; char 125
dae8 : e0                    	db %11100000
dae9 : 30                    	db %00110000
daea : 30                    	db %00110000
daeb : 18                    	db %00011000
daec : 30                    	db %00110000
daed : 30                    	db %00110000
daee : e0                    	db %11100000
daef : 00                    	db %00000000
                             ; char 126
daf0 : 00                    	db %00000000
daf1 : 00                    	db %00000000
daf2 : 40                    	db %01000000
daf3 : a8                    	db %10101000
AS65 Assembler for R6502 [1.42].                                     Page  106
-------------------------------- bank\bank0.s --------------------------------

daf4 : 10                    	db %00010000
daf5 : 00                    	db %00000000
daf6 : 00                    	db %00000000
daf7 : 00                    	db %00000000
                             ; char 127
daf8 : f8                    	db %11111000
daf9 : f8                    	db %11111000
dafa : f8                    	db %11111000
dafb : f8                    	db %11111000
dafc : f8                    	db %11111000
dafd : f8                    	db %11111000
dafe : f8                    	db %11111000
daff : 00                    	db %00000000
                             	
                             	
                             
                             
                             
                             ;****************************************
                             ;* vdp_init
                             ;* Initialise VDP
                             ;* Clears all of VRAM to zero
                             ;****************************************
db00 :                       vdp_init
db00 : 20e9db           [ 6] 	jsr clear_vram
db03 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* vdp_init_mode
                             ;* Initialise VDP  to required mode and addresses
                             ;* Input : Y = Offset in to VDP init table
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
db04 :                       vdp_init_mode
db04 : 78               [ 2] 	sei
db05 : be70dc           [ 4] 	ldx vdp_base_table+0,y		; Get delay
db08 : 8616             [ 3] 	stx vdp_delay
                             
db0a : a900             [ 2] 	lda	#0						; Do R0
db0c : be71dc           [ 4] 	ldx vdp_base_table+1,y		; Get R0 value
db0f : 20f0c5           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
db12 : a901             [ 2] 	lda	#1						; Do R1
db14 : be72dc           [ 4] 	ldx vdp_base_table+2,y		; Get R1 value
db17 : 20f0c5           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
db1a : be73dc           [ 4] 	ldx vdp_base_table+3,y		; Get name table low add
db1d : 8617             [ 3] 	stx vdp_base+vdp_addr_nme	; Save in vdp_base
db1f : be74dc           [ 4] 	ldx vdp_base_table+4,y		; Get name table high ad
db22 : 8618             [ 3] 	stx vdp_base+vdp_addr_nme+1	; Save in vdp_base
db24 : a902             [ 2] 	lda #2						; Do R2
db26 : be75dc           [ 4] 	ldx vdp_base_table+5,y		; Get R2 value
db29 : 20f0c5           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
db2c : be76dc           [ 4] 	ldx vdp_base_table+6,y		; Get col table low addr
db2f : 8619             [ 3] 	stx vdp_base+vdp_addr_col	; Save in vdp_base
db31 : be77dc           [ 4] 	ldx vdp_base_table+7,y		; Get col table high add
db34 : 861a             [ 3] 	stx vdp_base+vdp_addr_col+1	; Save in vdp_base
db36 : a903             [ 2] 	lda #3						; Do R3
db38 : be78dc           [ 4] 	ldx vdp_base_table+8,y		; Get R3 value
db3b : 20f0c5           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
AS65 Assembler for R6502 [1.42].                                     Page  107
-------------------------------- bank\bank0.s --------------------------------

                             
db3e : be79dc           [ 4] 	ldx vdp_base_table+9,y		; Get pat table low addr
db41 : 861b             [ 3] 	stx vdp_base+vdp_addr_pat	; Save in vdp_base
db43 : be7adc           [ 4] 	ldx vdp_base_table+10,y		; Get pat table high ad
db46 : 861c             [ 3] 	stx vdp_base+vdp_addr_pat+1	; Save in vdp_base
db48 : a904             [ 2] 	lda #4						; Do R4
db4a : be7bdc           [ 4] 	ldx vdp_base_table+11,y		; Get R4 value
db4d : 20f0c5           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
db50 : be7cdc           [ 4] 	ldx vdp_base_table+12,y		; Get spr att table low
db53 : 861d             [ 3] 	stx vdp_base+vdp_addr_spa	; Save in vdp_base
db55 : be7ddc           [ 4] 	ldx vdp_base_table+13,y		; Get spr att table hig
db58 : 861e             [ 3] 	stx vdp_base+vdp_addr_spa+1	; Save in vdp_base
db5a : a905             [ 2] 	lda #5						; Do R5
db5c : be7edc           [ 4] 	ldx vdp_base_table+14,y		; Get R5 value
db5f : 20f0c5           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
db62 : be7fdc           [ 4] 	ldx vdp_base_table+15,y		; Get spr pat table low
db65 : 861f             [ 3] 	stx vdp_base+vdp_addr_spp	; Save in vdp_base
db67 : be80dc           [ 4] 	ldx vdp_base_table+16,y		; Get spr pat table hig
db6a : 8620             [ 3] 	stx vdp_base+vdp_addr_spp+1	; Save in vdp_base
db6c : a906             [ 2] 	lda #6						; Do R6
db6e : be81dc           [ 4] 	ldx vdp_base_table+17,y		; Get R6 value
db71 : 20f0c5           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
db74 : a621             [ 3] 	ldx vdp_base+vdp_bord_col	; Get border colour
db76 : d005             [ 3] 	bne vdp_init_skip_table		; If not zero (i.e. NV 
db78 : be82dc           [ 4] 	ldx vdp_base_table+18,y		; Else get R7 value fro
db7b : 8621             [ 3] 	stx vdp_base+vdp_bord_col	; Save border colour t
db7d :                       vdp_init_skip_table
db7d : a907             [ 2] 	lda #7						; Do R7, X contains colour
db7f : 20f0c5           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             	
db82 : 58               [ 2] 	cli
                             
db83 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* vdp_set_txt_mode
                             ;* Set up text mode
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
db84 :                       vdp_set_txt_mode
db84 : a039             [ 2] 	ldy #vdp_base_table_txt-vdp_base_table
db86 : 2004db           [ 6] 	jsr vdp_init_mode
db89 : 4c2fdc           [ 3] 	jmp init_fonts
                             
                             	
                             ;****************************************
                             ;* vdp_set_g1_mode
                             ;* Set up G1 mode
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
db8c :                       vdp_set_g1_mode
db8c : a000             [ 2] 	ldy #vdp_base_table_g1-vdp_base_table
db8e : 2004db           [ 6] 	jsr vdp_init_mode
db91 : 4c2fdc           [ 3] 	jmp init_fonts
AS65 Assembler for R6502 [1.42].                                     Page  108
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;****************************************
                             ;* vdp_set_g2_mode
                             ;* Set up G2 mode
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
db94 :                       vdp_set_g2_mode
db94 : a013             [ 2] 	ldy #vdp_base_table_g2-vdp_base_table
db96 : 2004db           [ 6] 	jsr vdp_init_mode
db99 : 4c2fdc           [ 3] 	jmp init_fonts
                             
                             ;****************************************
                             ;* vdp_set_hires
                             ;* Set up HI mode
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
db9c :                       vdp_set_hires
db9c : a026             [ 2] 	ldy #vdp_base_table_hi-vdp_base_table
db9e : 2004db           [ 6] 	jsr vdp_init_mode
                             	
                             	; No fonts to init but pre-fill name table
                             	; to use all 3 character sets
dba1 : 78               [ 2] 	sei
                             
                             	; Point at name table
dba2 : a617             [ 3] 	ldx vdp_base+vdp_addr_nme
dba4 : a518             [ 3] 	lda vdp_base+vdp_addr_nme+1
dba6 : 20fdc5           [ 6] 	jsr vdp_wr_addr
                             	
                             	; set name for 3 pages (768)
dba9 : a200             [ 2] 	ldx #0
dbab : a003             [ 2] 	ldy #3
dbad :                       vdp_set_hires_fill_nme
dbad : 8a               [ 2] 	txa						; Name table is 0..255 for 3 pages
dbae : 2023c6           [ 6] 	jsr vdp_wr_vram
dbb1 : e8               [ 2] 	inx
dbb2 : d0f9             [ 3] 	bne vdp_set_hires_fill_nme
dbb4 : 88               [ 2] 	dey
dbb5 : d0f6             [ 3] 	bne vdp_set_hires_fill_nme
                             	
dbb7 : 58               [ 2] 	cli
                             	
dbb8 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* init_vdp_g1
                             ;* Initialise video processor graphics 1
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;***************************************
dbb9 :                       init_vdp_g1
dbb9 : 208cdb           [ 6] 	jsr vdp_set_g1_mode
dbbc : 203cdc           [ 6] 	jsr init_sprtpat_g1
dbbf : 20f6db           [ 6] 	jsr init_colours_g1
dbc2 : 201cdc           [ 6] 	jsr init_sprites_g1
dbc5 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  109
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;****************************************
                             ;* init_vdp_g2
                             ;* Initialise video processor graphics 2
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;***************************************
dbc6 :                       init_vdp_g2
dbc6 : 2094db           [ 6] 	jsr vdp_set_g2_mode
dbc9 : 203cdc           [ 6] 	jsr init_sprtpat_g1		; Same as G1
dbcc : 2009dc           [ 6] 	jsr init_colours_g2
dbcf : 201cdc           [ 6] 	jsr init_sprites_g1		; Same as G1
dbd2 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_vdp_hires
                             ;* Initialise video processor graphics 1
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;***************************************
dbd3 :                       init_vdp_hires
dbd3 : 209cdb           [ 6] 	jsr vdp_set_hires
dbd6 : 203cdc           [ 6] 	jsr init_sprtpat_g1
dbd9 : 4c1cdc           [ 3] 	jmp init_sprites_g1
                             
                             
                             ;****************************************
                             ;* init_vdp_txt
                             ;* Initialise video processor text mode
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;***************************************
dbdc :                       init_vdp_txt
dbdc : 4c84db           [ 3] 	jmp vdp_set_txt_mode
                             	
                             
                             ;****************************************
                             ;* fill_vram
                             ;* Fill a number of VRAM bytes with a value
                             ;* Input : X,Y = Fill length (lo,hi), A = Value
                             ;* Output : None
                             ;* Regs affected : All
                             ;* ASSUMES vdp_wr_vram already called
                             ;* Works for < 256 bytes as long as Y=1
                             ;* Else only use for WHOLE pages at a time so X m
                             ;* INTERRUPTS MUST HAVE BEEN DISABLED BY THE CALL
                             ;****************************************
dbdf :                       vdp_fill_vram
dbdf : 2023c6           [ 6] 	jsr vdp_wr_vram
dbe2 : ca               [ 2] 	dex
dbe3 : d0fa             [ 3] 	bne vdp_fill_vram
dbe5 : 88               [ 2] 	dey
dbe6 : d0f7             [ 3] 	bne vdp_fill_vram
dbe8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* clear_vram
                             ;* Set all 16k VDP vram to 0x00
                             ;* Input : None
AS65 Assembler for R6502 [1.42].                                     Page  110
-------------------------------- bank\bank0.s --------------------------------

                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
dbe9 :                       clear_vram
                             ;	sei
dbe9 : a200             [ 2] 	ldx #0x00			; Low byte of address
dbeb : a900             [ 2] 	lda #0x00			; High byte of address
dbed : 20fdc5           [ 6] 	jsr vdp_wr_addr		; Write address to VDP
                             
dbf0 : a040             [ 2] 	ldy #0x40			; 0x40 pages = 16k (X already zero)
dbf2 : 20dfdb           [ 6] 	jsr vdp_fill_vram
                             ;	cli
dbf5 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* init_colours_g1
                             ;* Initialise colour table for graphics 1
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
dbf6 :                       init_colours_g1
dbf6 : 78               [ 2] 	sei
dbf7 : a619             [ 3] 	ldx vdp_base+vdp_addr_col
dbf9 : a51a             [ 3] 	lda vdp_base+vdp_addr_col+1
dbfb : 20fdc5           [ 6] 	jsr vdp_wr_addr				; Set VDP address
                             	
dbfe : a220             [ 2] 	ldx #0x20					; 32 bytes to fill	
dc00 : a001             [ 2] 	ldy #0x01					; Only 1 pass through
dc02 : a521             [ 3] 	lda vdp_base+vdp_bord_col	; Border colour
dc04 : 20dfdb           [ 6] 	jsr vdp_fill_vram
dc07 : 58               [ 2] 	cli
dc08 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_colours_g2
                             ;* Initialise colour table for graphics 2
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
dc09 :                       init_colours_g2
dc09 : 78               [ 2] 	sei
dc0a : a619             [ 3] 	ldx vdp_base+vdp_addr_col
dc0c : a51a             [ 3] 	lda vdp_base+vdp_addr_col+1
dc0e : 20fdc5           [ 6] 	jsr vdp_wr_addr				; Set VDP address
                             	
dc11 : a200             [ 2] 	ldx #0x00					; 2048 bytes to fill	
dc13 : a008             [ 2] 	ldy #0x08					; 8 pass through
dc15 : a521             [ 3] 	lda vdp_base+vdp_bord_col	; Border colour
dc17 : 20dfdb           [ 6] 	jsr vdp_fill_vram
dc1a : 58               [ 2] 	cli
dc1b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_sprites_g1
                             ;* Initialise sprite attribute table for graphics
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
dc1c :                       init_sprites_g1
AS65 Assembler for R6502 [1.42].                                     Page  111
-------------------------------- bank\bank0.s --------------------------------

dc1c : 78               [ 2] 	sei
dc1d : a61d             [ 3] 	ldx vdp_base+vdp_addr_spa
dc1f : a51e             [ 3] 	lda vdp_base+vdp_addr_spa+1
dc21 : 20fdc5           [ 6] 	jsr vdp_wr_addr				; Set VDP address
                             	
dc24 : a280             [ 2] 	ldx #0x80					; 128 bytes of attribute to fill
dc26 : a001             [ 2] 	ldy #0x01					; Only 1 pass
dc28 : a9d0             [ 2] 	lda #0xd0					; Sprite terminator
dc2a : 20dfdb           [ 6] 	jsr vdp_fill_vram
dc2d : 58               [ 2] 	cli
dc2e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_fonts
                             ;* Initialise fonts 
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
dc2f :                       init_fonts
dc2f : 78               [ 2] 	sei
dc30 : a61b             [ 3] 	ldx vdp_base+vdp_addr_pat
dc32 : a51c             [ 3] 	lda vdp_base+vdp_addr_pat+1
dc34 : 20fdc5           [ 6] 	jsr vdp_wr_addr				; Write the address
dc37 : 2049dc           [ 6] 	jsr init_fonts_sub
dc3a : 58               [ 2] 	cli
dc3b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_sprtpat_g1
                             ;* Initialise fonts for sprites
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
dc3c :                       init_sprtpat_g1
dc3c : 78               [ 2] 	sei
dc3d : a61f             [ 3] 	ldx vdp_base+vdp_addr_spp
dc3f : a520             [ 3] 	lda vdp_base+vdp_addr_spp+1
dc41 : 20fdc5           [ 6] 	jsr vdp_wr_addr				; Write the address
dc44 : 2049dc           [ 6] 	jsr init_fonts_sub
dc47 : 58               [ 2] 	cli
dc48 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* init_fonts_sub
                             ;* Initialise fonts common subroutine
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;* INTERRUPTS MUST HAVE BEEN DISABLED BY CALLER!!
                             ;****************************************
dc49 :                       init_fonts_sub
dc49 : 6441             [ 3] 	stz tmp_a				; XOR with zero = no change
dc4b : a000             [ 2] 	ldy #0					; byte within page
dc4d :                       init_write_fonts
dc4d : a900             [ 2] 	lda #lo(vdp_font)		; Low byte of fonts source
dc4f : 853f             [ 3] 	sta tmp_v1
dc51 : a9d7             [ 2] 	lda #hi(vdp_font)		; High byte of fonts source
dc53 : 8540             [ 3] 	sta tmp_v1+1
dc55 : a204             [ 2] 	ldx #0x04				; 4 pages = 1024 bytes
dc57 :                       init_pattern
AS65 Assembler for R6502 [1.42].                                     Page  112
-------------------------------- bank\bank0.s --------------------------------

dc57 : 98               [ 2] 	tya
dc58 : b13f             [ 5] 	lda (tmp_v1),y			; Get byte from font table
dc5a : 4541             [ 3] 	eor tmp_a				; Invert if tmp_a is 0xff
dc5c : 2023c6           [ 6] 	jsr vdp_wr_vram			; Write the byte to VRAM
dc5f : c8               [ 2] 	iny
dc60 : d0f5             [ 3] 	bne init_pattern		; keep going for 1 page
dc62 : e640             [ 5] 	inc tmp_v1+1			; only need to increment high byt
dc64 : ca               [ 2] 	dex						; page counter
dc65 : d0f0             [ 3] 	bne init_pattern		; keep going for 4 pages
dc67 : a541             [ 3] 	lda tmp_a				; get the current eor mask
dc69 : 49ff             [ 2] 	eor	#0xff				; Invert the EOR mask
dc6b : 8541             [ 3] 	sta tmp_a				; And save for next go around
dc6d : d0de             [ 3] 	bne init_write_fonts
dc6f : 60               [ 6] 	rts
                             
                             ;**** BASE TABLES ****
dc70 :                       vdp_base_table
dc70 :                       vdp_base_table_g1
dc70 : 02                    	db	VDP_LONGDELAY	; Long delay
dc71 : 00                    	db	%00000000		; R0 - No-extvid
dc72 : e0                    	db	%11100000		; R1 - 16K,Disp-enable,Int-enable,
dc73 : 0010                  	dw	0x1000			; Name table address
dc75 : 04                    	db	0x1000>>10		; R2 Name table value
dc76 : 8013                  	dw	0x1380			; Colour table
dc78 : 4e                    	db	0x1380>>6		; R3 Colour table value
dc79 : 0000                  	dw	0x0000			; Pattern table
dc7b : 00                    	db	0x0000>>11		; R4 Pattern table value
dc7c : 0013                  	dw	0x1300			; Sprite attribute table
dc7e : 26                    	db	0x1300>>7		; R5 Sprite attribute table value
dc7f : 0008                  	dw	0x0800			; Sprite pattern table
dc81 : 01                    	db	0x0800>>11		; R6 Sprite pattern table value
dc82 : f4                    	db	0xf4			; R7 White f/gnd, blue background
                             
dc83 :                       vdp_base_table_g2
dc83 : 02                    	db	VDP_LONGDELAY	; Long delay
dc84 : 02                    	db	%00000010		; R0 - GR2HiRes,No-extvid
dc85 : e0                    	db	%11100000		; R1 - 16K,Disp-enable,Int-enable,
dc86 : 0038                  	dw	0x3800			; Name table address
dc88 : 0e                    	db	0x3800>>10		; R2 Name table value
dc89 : 0020                  	dw	0x2000			; Colour table
dc8b : 9f                    	db	0x9f			; R3 Colour table magic value 0x9f
dc8c : 0000                  	dw	0x0000			; Pattern table
dc8e : 00                    	db	0x0000>>11		; R4 Pattern table value
dc8f : 003b                  	dw	0x3b00			; Sprite attribute table
dc91 : 76                    	db	0x3b00>>7		; R5 Sprite attribute table value
dc92 : 0018                  	dw	0x1800			; Sprite pattern table
dc94 : 03                    	db	0x1800>>11		; R6 Sprite pattern table value
dc95 : fc                    	db	0xfc			; R7 White f/gnd, green background
                             
dc96 :                       vdp_base_table_hi
dc96 : 02                    	db	VDP_LONGDELAY	; Long delay
dc97 : 02                    	db	%00000010		; R0 - GR2HiRes,No-extvid
dc98 : e0                    	db	%11100000		; R1 - 16K,Disp-enable,Int-enable,
dc99 : 0038                  	dw	0x3800			; Name table
dc9b : 0e                    	db	0x3800>>10		; R2 Name table value
dc9c : 0020                  	dw	0x2000			; Colour table
dc9e : ff                    	db	0xff			; R3 Colour table value - always 0xff
dc9f : 0000                  	dw	0x0000			; Pattern table
dca1 : 03                    	db	0x03			; R4 Pattern table value - always 0x03
dca2 : 003b                  	dw	0x3b00			; Sprite attribute table
dca4 : 76                    	db	0x3b00>>7		; R5 Sprite attribute table value
dca5 : 0018                  	dw	0x1800			; Sprite pattern table
AS65 Assembler for R6502 [1.42].                                     Page  113
-------------------------------- bank\bank0.s --------------------------------

dca7 : 03                    	db	0x1800>>11		; R6 Sprite pattern table value
dca8 : f1                    	db	0xf1			; R7 White f/gnd, black background
                             
dca9 :                       vdp_base_table_txt
dca9 : 01                    	db	VDP_SHORTDELAY	; Short delay
dcaa : 00                    	db	%00000000		; R0 - No-extvid
dcab : f0                    	db	%11110000		; R1 - 16K,Disp-enable,Int-enable,
dcac : 0008                  	dw	0x0800			; Name table
dcae : 02                    	db	0x0800>>10		; R2 Name table value
dcaf : 0000                  	dw	0				; Colour table NA
dcb1 : 00                    	db	0				; R3 Colour table value
dcb2 : 0000                  	dw	0x0000			; Pattern table
dcb4 : 00                    	db	0x0000>>11		; R4 Pattern table value
dcb5 : 0000                  	dw	0				; Sprite attribute table NA
dcb7 : 00                    	db	0				; R5 Sprite attribute table value
dcb8 : 0000                  	dw	0				; Sprite pattern table NA
dcba : 00                    	db	0				; R6 Sprite pattern table value
dcbb : fd                    	db	0xfd			; R7 White f/gnd, magenta background
                             
dcbc :                       mod_sz_vdp_e
                             
                             	include "vdp\graph.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  GRAPH.S
                             ;*  This is the graphics module, to handle text a
                             ;*  graphics.  On startup, the BBC DIP settings d
                             ;*  whether the computer will go in to 32 or 40 c
                             ;*  screen mode.  The kernel code calls the right
                             ;*  initialisation code.
                             ;*  For text modes, this module keeps track of wh
                             ;*  next put a character, and also takes care of 
                             ;*  to the next line as well as scrolling the con
                             ;*  when the cursor has reached the bottom right.
                             ;*  module also enables text input which is echoe
                             ;*  screen, to allow interactive input and editin
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
dcbc :                       mod_sz_graph_s
                             
                             ;****************************************
                             ;* gr_init_screen_common
                             ;* Common screen initialisation code
                             ;* A = Blank character
                             ;****************************************
dcbc :                       gr_init_screen_common
                             	; Store blank char
dcbc : 8515             [ 3] 	sta vdp_blank
                             	; Save value for cursor
dcbe : 8514             [ 3] 	sta vdp_curval
                             	
                             	; VRAM address of screen data
AS65 Assembler for R6502 [1.42].                                     Page  114
-------------------------------- bank\bank0.s --------------------------------

dcc0 : a517             [ 3] 	lda vdp_base+vdp_addr_nme
dcc2 : 8523             [ 3] 	sta gr_scrngeom+gr_screen_start
dcc4 : a518             [ 3] 	lda vdp_base+vdp_addr_nme+1
dcc6 : 8524             [ 3] 	sta gr_scrngeom+gr_screen_start+1
                             
                             	; Top left cursor position 0,0
dcc8 : a200             [ 2] 	ldx #0
dcca : 862a             [ 3] 	stx gr_scrngeom+gr_cur_x
dccc : a000             [ 2] 	ldy #0
dcce : 842b             [ 3] 	sty gr_scrngeom+gr_cur_y
                             
                             	; Clear screen
dcd0 : 206cdd           [ 6] 	jsr gr_cls
                             
                             	; Cursor pointer in to screen
dcd3 : 20fadd           [ 6] 	jsr gr_set_cur	
                             	
dcd6 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_screen_32 g1 if A=1 else g2 if A=2
                             ;* initialise the screen in graphic mode 1/2
                             ;****************************************
dcd7 :                       gr_init_screen_32
dcd7 : c901             [ 2] 	cmp #1
dcd9 : d005             [ 3] 	bne gr_init_screen_skip_g1
dcdb : 20b9db           [ 6] 	jsr init_vdp_g1
dcde : 8003             [ 3] 	bra gr_init_screen_cont
                             
dce0 :                       gr_init_screen_skip_g1
dce0 : 20c6db           [ 6] 	jsr init_vdp_g2
                             
dce3 :                       gr_init_screen_cont	
                             	; Size of screen in bytes
dce3 : a900             [ 2] 	lda #lo(768)					
dce5 : 8525             [ 3] 	sta gr_scrngeom+gr_screen_size
dce7 : a903             [ 2] 	lda #hi(768)	
dce9 : 8526             [ 3] 	sta gr_scrngeom+gr_screen_size+1
                             
                             	; Width and height
dceb : a920             [ 2] 	lda #32
dced : 8527             [ 3] 	sta gr_scrngeom+gr_screen_w
dcef : a918             [ 2] 	lda #24
dcf1 : 8528             [ 3] 	sta gr_scrngeom+gr_screen_h
dcf3 : 6429             [ 3] 	stz gr_scrngeom+gr_cur_off		; No cursor offset
                             
dcf5 : a920             [ 2] 	lda #' '						; Blank is SPACE
dcf7 : 20bcdc           [ 6] 	jsr gr_init_screen_common
dcfa : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_screen_txt
                             ;* initialise the screen in text mode
                             ;****************************************
dcfb :                       gr_init_screen_txt
dcfb : 20dcdb           [ 6] 	jsr init_vdp_txt
                             
                             	; Size of screen in bytes
dcfe : a9c0             [ 2] 	lda #lo(960)					
dd00 : 8525             [ 3] 	sta gr_scrngeom+gr_screen_size
dd02 : a903             [ 2] 	lda #hi(960)	
dd04 : 8526             [ 3] 	sta gr_scrngeom+gr_screen_size+1
AS65 Assembler for R6502 [1.42].                                     Page  115
-------------------------------- bank\bank0.s --------------------------------

                             
                             	; Width and height
dd06 : a928             [ 2] 	lda #40
dd08 : 8527             [ 3] 	sta gr_scrngeom+gr_screen_w
dd0a : a918             [ 2] 	lda #24
dd0c : 8528             [ 3] 	sta gr_scrngeom+gr_screen_h
dd0e : 6429             [ 3] 	stz gr_scrngeom+gr_cur_off		; No cursor offset
                             
dd10 : a920             [ 2] 	lda #' '						; Blank is SPACE
dd12 : 20bcdc           [ 6] 	jsr gr_init_screen_common
                             
dd15 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_hires
                             ;* Input : A = Colour table fill value
                             ;* initialise the screen in hires mode
                             ;****************************************
dd16 :                       gr_init_hires
dd16 : 8530             [ 3] 	sta gr_scrngeom+gr_pixcol		; Save pixel colour
                             
dd18 : e612             [ 5] 	inc vdp_curoff					; Switch cursor off
                             	
dd1a : 20d3db           [ 6] 	jsr init_vdp_hires
                             
                             	; Size of screen in bytes
dd1d : a900             [ 2] 	lda #lo(6144)					
dd1f : 8525             [ 3] 	sta gr_scrngeom+gr_screen_size
dd21 : a918             [ 2] 	lda #hi(6144)	
dd23 : 8526             [ 3] 	sta gr_scrngeom+gr_screen_size+1
                             
                             	; Width and height
dd25 : a920             [ 2] 	lda #32
dd27 : 8527             [ 3] 	sta gr_scrngeom+gr_screen_w
dd29 : a9c0             [ 2] 	lda #192
dd2b : 8528             [ 3] 	sta gr_scrngeom+gr_screen_h
dd2d : a907             [ 2] 	lda #7
dd2f : 8529             [ 3] 	sta gr_scrngeom+gr_cur_off		; Cursor on bottom r
                             
                             	; default pixel mode and mask
dd31 : a901             [ 2] 	lda #1
dd33 : 852e             [ 3] 	sta gr_scrngeom+gr_pixmode
dd35 : a9ff             [ 2] 	lda #255
dd37 : 852f             [ 3] 	sta gr_scrngeom+gr_pixmask
                             	
dd39 : 78               [ 2] 	sei
                             	; point to colour table
dd3a : a619             [ 3] 	ldx vdp_base+vdp_addr_col
dd3c : a51a             [ 3] 	lda vdp_base+vdp_addr_col+1
dd3e : 20fdc5           [ 6] 	jsr vdp_wr_addr
                             	; set colour for 0x18 pages (6144) bytes
dd41 : a530             [ 3] 	lda gr_scrngeom+gr_pixcol		; Get the colour valu
dd43 : a200             [ 2] 	ldx #0							; And fill 18 pages
dd45 : a018             [ 2] 	ldy #0x18						
dd47 : 20dfdb           [ 6] 	jsr vdp_fill_vram
                             
dd4a : 58               [ 2] 	cli
                             	
                             	; Now point screen at pattern for HIRES
dd4b : a51b             [ 3] 	lda vdp_base+vdp_addr_pat
dd4d : 8517             [ 3] 	sta vdp_base+vdp_addr_nme
dd4f : a51c             [ 3] 	lda vdp_base+vdp_addr_pat+1
AS65 Assembler for R6502 [1.42].                                     Page  116
-------------------------------- bank\bank0.s --------------------------------

dd51 : 8518             [ 3] 	sta vdp_base+vdp_addr_nme+1
                             	
dd53 : a900             [ 2] 	lda #0							; Blank is ZERO
dd55 : 20bcdc           [ 6] 	jsr gr_init_screen_common
                             	
                             
dd58 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_screen
                             ;* A = Mode (0,1,2,>=0x10 for hires)
                             ;* initialise the screen in text mode
                             ;****************************************
dd59 :                       gr_init_screen
dd59 : 8522             [ 3] 	sta vdp_base+vdp_gmode
dd5b : c910             [ 2] 	cmp #0x10				; Hires mode?
dd5d : b00a             [ 3] 	bcs gr_init_screen_hires
dd5f : c900             [ 2] 	cmp #0
dd61 : d003             [ 3] 	bne gr_init_skip_txt
dd63 : 4cfbdc           [ 3] 	jmp gr_init_screen_txt
dd66 :                       gr_init_skip_txt
dd66 : 4cd7dc           [ 3] 	jmp gr_init_screen_32
dd69 :                       gr_init_screen_hires
dd69 : 4c16dd           [ 3] 	jmp gr_init_hires
                             
                             ;****************************************
                             ;* gr_cls
                             ;* Clear the screen
                             ;****************************************
dd6c :                       gr_cls
dd6c : 48               [ 3] 	pha
dd6d : da               [ 3] 	phx
dd6e : 5a               [ 3] 	phy
                             
                             	; Set VDP Address
dd6f : 78               [ 2] 	sei
dd70 : a623             [ 3] 	ldx gr_scrngeom+gr_screen_start
dd72 : a524             [ 3] 	lda gr_scrngeom+gr_screen_start+1
dd74 : 20fdc5           [ 6] 	jsr vdp_wr_addr
                             
                             	; X and Y count bytes to fill
dd77 : a200             [ 2] 	ldx #0
dd79 : a000             [ 2] 	ldy #0
dd7b : a515             [ 3] 	lda vdp_blank
dd7d :                       gr_cls_loop
dd7d : 2023c6           [ 6] 	jsr vdp_wr_vram
dd80 : e8               [ 2] 	inx
dd81 : d001             [ 3] 	bne gr_cls_skipy
dd83 : c8               [ 2] 	iny
dd84 :                       gr_cls_skipy
dd84 : e425             [ 3] 	cpx gr_scrngeom+gr_screen_size
dd86 : d0f5             [ 3] 	bne gr_cls_loop
dd88 : c426             [ 3] 	cpy gr_scrngeom+gr_screen_size+1
dd8a : d0f1             [ 3] 	bne gr_cls_loop
                             	
dd8c : 58               [ 2] 	cli
                             	
dd8d : 7a               [ 4] 	ply
dd8e : fa               [ 4] 	plx
dd8f : 68               [ 4] 	pla
                             	
dd90 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  117
-------------------------------- bank\bank0.s --------------------------------

                             	
                             ;****************************************
                             ;* gr_getXY_ptr
                             ;* Get VRAM address of screen from X,Y
                             ;* Input : X, Y = coords
                             ;* Output : X,Y = low and high VRAM address
                             ;* Regs affected : A
                             ;****************************************
dd91 :                       gr_getXY_ptr
                             	; 32 or 40 columns table selection
dd91 : a527             [ 3] 	lda gr_scrngeom+gr_screen_w
dd93 : c928             [ 2] 	cmp #40
dd95 : d011             [ 3] 	bne gr_set_skip_40
                             
<<<<<<< HEAD
dd97 : 18               [ 2] 	clc
dd98 : b9e0e2           [ 4] 	lda gr_offset_40lo, y
dd9b : 6523             [ 3] 	adc gr_scrngeom+gr_screen_start
dd9d : 8531             [ 3] 	sta gr_scrngeom+gr_geom_tmp
dd9f : b9f8e2           [ 4] 	lda gr_offset_40hi, y
dda2 : 6524             [ 3] 	adc gr_scrngeom+gr_screen_start+1
dda4 : 8532             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
dda6 : 8013             [ 3] 	bra gr_add_x_offset
=======
da97 : 18               [ 2] 	clc
da98 : b9e4df           [ 4] 	lda gr_offset_40lo, y
da9b : 6523             [ 3] 	adc gr_scrngeom+gr_screen_start
da9d : 8531             [ 3] 	sta gr_scrngeom+gr_geom_tmp
da9f : b9fcdf           [ 4] 	lda gr_offset_40hi, y
daa2 : 6524             [ 3] 	adc gr_scrngeom+gr_screen_start+1
daa4 : 8532             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
daa6 : 8013             [ 3] 	bra gr_add_x_offset
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
dda8 :                       gr_set_skip_40
                             	; 32 byte width window - but what if hi-res (bec
<<<<<<< HEAD
dda8 : a529             [ 3] 	lda gr_scrngeom+gr_cur_off
ddaa : d01a             [ 3] 	bne gr_calc_hires_ptr
ddac : 18               [ 2] 	clc
ddad : b910e3           [ 4] 	lda gr_offset_32lo, y
ddb0 : 6523             [ 3] 	adc gr_scrngeom+gr_screen_start
ddb2 : 8531             [ 3] 	sta gr_scrngeom+gr_geom_tmp
ddb4 : b928e3           [ 4] 	lda gr_offset_32hi, y
ddb7 : 6524             [ 3] 	adc gr_scrngeom+gr_screen_start+1
ddb9 : 8532             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
=======
daa8 : a529             [ 3] 	lda gr_scrngeom+gr_cur_off
daaa : d01a             [ 3] 	bne gr_calc_hires_ptr
daac : 18               [ 2] 	clc
daad : b914e0           [ 4] 	lda gr_offset_32lo, y
dab0 : 6523             [ 3] 	adc gr_scrngeom+gr_screen_start
dab2 : 8531             [ 3] 	sta gr_scrngeom+gr_geom_tmp
dab4 : b92ce0           [ 4] 	lda gr_offset_32hi, y
dab7 : 6524             [ 3] 	adc gr_scrngeom+gr_screen_start+1
dab9 : 8532             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
ddbb :                       gr_add_x_offset	
ddbb : 18               [ 2] 	clc
ddbc : 8a               [ 2] 	txa
ddbd : 6531             [ 3] 	adc gr_scrngeom+gr_geom_tmp
ddbf : aa               [ 2] 	tax								; vram addr lo in X
ddc0 : a532             [ 3] 	lda gr_scrngeom+gr_geom_tmp+1
ddc2 : 6900             [ 2] 	adc #0
ddc4 : a8               [ 2] 	tay								; vram addr hi in Y
ddc5 : 60               [ 6] 	rts
                             	
ddc6 :                       gr_calc_hires_ptr
                             	; Low byte = X&F8 | Y&07
ddc6 : 8a               [ 2] 	txa
ddc7 : 29f8             [ 2] 	and #0xf8
ddc9 : 8531             [ 3] 	sta gr_scrngeom+gr_geom_tmp
ddcb : 98               [ 2] 	tya
ddcc : 2907             [ 2] 	and #0x07
ddce : 0531             [ 3] 	ora gr_scrngeom+gr_geom_tmp
ddd0 : aa               [ 2] 	tax			; Low address in X
                             	; High byte = Y>>3
ddd1 : 98               [ 2] 	tya
ddd2 : 4a               [ 2] 	lsr a
ddd3 : 4a               [ 2] 	lsr a
ddd4 : 4a               [ 2] 	lsr a
ddd5 : a8               [ 2] 	tay			; High address in Y
ddd6 : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  118
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
                             ;* gr_plot
                             ;* Write a byte in the screen pos
                             ;* Input : X,Y = coord, A = Byte to put
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
ddd7 :                       gr_plot
ddd7 : 48               [ 3] 	pha					; Save byte to put
ddd8 : 2091dd           [ 6] 	jsr gr_getXY_ptr	; vram addr in x,y
dddb : 68               [ 4] 	pla					; Get byte to put
dddc : 2028c6           [ 6] 	jsr vdp_poke
dddf : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_put
                             ;* Write a byte in the current cursor position
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
dde0 :                       gr_put
dde0 : e612             [ 5] 	inc vdp_curoff		; Disable cusror
dde2 : 8514             [ 3] 	sta vdp_curval		; Update cursor value
                             	; Load cursor address
dde4 : a62c             [ 3] 	ldx gr_scrngeom+gr_cur_ptr
dde6 : a42d             [ 3] 	ldy gr_scrngeom+gr_cur_ptr+1
dde8 : 2028c6           [ 6] 	jsr vdp_poke
                             	; Reset cursor
ddeb : a901             [ 2] 	lda #1
dded : 8513             [ 3] 	sta vdp_curstat
ddef : c612             [ 5] 	dec vdp_curoff		; Allow cursor flashing
ddf1 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* gr_get
                             ;* Get the byte in the screen pos
                             ;* Input : X,Y = coord
                             ;* Output : X,Y = address, A = peeked byte
                             ;* Regs affected : All
                             ;****************************************
ddf2 :                       gr_get
ddf2 : 2091dd           [ 6] 	jsr gr_getXY_ptr	; vram addr in x,y
ddf5 : 98               [ 2] 	tya					; hi needs to be in A for peek
ddf6 : 2034c6           [ 6] 	jsr vdp_peek
ddf9 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_set_cur
                             ;* Set the cursor position
                             ;* Input : X, Y = position
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ddfa :                       gr_set_cur
ddfa : e612             [ 5] 	inc vdp_curoff				; Disable cursor
                             	
                             	; Save new cursor position
ddfc : 862a             [ 3] 	stx gr_scrngeom+gr_cur_x
ddfe : 842b             [ 3] 	sty gr_scrngeom+gr_cur_y
                             	
AS65 Assembler for R6502 [1.42].                                     Page  119
-------------------------------- bank\bank0.s --------------------------------

                             	; First restore what is under the cursor
de00 : a514             [ 3] 	lda vdp_curval
de02 : 20e0dd           [ 6] 	jsr gr_put
                             
                             	; Now calculate the new cursor vram address
de05 : a62a             [ 3] 	ldx gr_scrngeom+gr_cur_x
de07 : a42b             [ 3] 	ldy gr_scrngeom+gr_cur_y
de09 : 20f2dd           [ 6] 	jsr gr_get					; X,Y=address,A=vram contents
de0c : 862c             [ 3] 	stx gr_scrngeom+gr_cur_ptr
de0e : 842d             [ 3] 	sty gr_scrngeom+gr_cur_ptr+1
de10 : 8514             [ 3] 	sta vdp_curval
                             
de12 : c612             [ 5] 	dec vdp_curoff
                             	
de14 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* gr_hchar
                             ;* Plot a char to hires X,Y coordinates with char
                             ;* Input : X,Y = coord, A = Char code
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
de15 :                       gr_hchar
de15 : 8643             [ 3] 	stx tmp_b				; Save X coord
de17 : 8444             [ 3] 	sty tmp_b+1				; Save Y coord
                             	
                             	; Calculate font address of char code A in to tm
de19 : 853d             [ 3] 	sta tmp_c
de1b : 643e             [ 3] 	stz tmp_c+1
                             	; Multiply by 8
de1d : 063d             [ 5] 	asl tmp_c
de1f : 263e             [ 5] 	rol tmp_c+1
de21 : 063d             [ 5] 	asl tmp_c
de23 : 263e             [ 5] 	rol tmp_c+1
de25 : 063d             [ 5] 	asl tmp_c
de27 : 263e             [ 5] 	rol tmp_c+1
                             	; Add font ROM address
de29 : a900             [ 2] 	lda #lo(vdp_font)
de2b : 653d             [ 3] 	adc tmp_c
de2d : 853d             [ 3] 	sta tmp_c
de2f : a9d7             [ 2] 	lda #hi(vdp_font)
de31 : 653e             [ 3] 	adc tmp_c+1
de33 : 853e             [ 3] 	sta tmp_c+1
                             
                             	; Save 3LSB of x coord
de35 : 8a               [ 2] 	txa
de36 : 2907             [ 2] 	and #7
de38 : 8541             [ 3] 	sta tmp_a
                             	
                             	; Generate the shifted character for each line (
                             	; 16 bytes to store a 2x8 byte shifted image of 
de3a : a200             [ 2] 	ldx #0	
de3c :                       gr_hchar_shiftline
                             	; load up a line of font in to 16 bits, left jus
de3c : b23d             [ 5] 	lda (tmp_c)
de3e : e63d             [ 5] 	inc tmp_c
de40 : 748d             [ 4] 	stz ztmp_16+8,x
                             	; Get 3LSB of x coord in to Y = number of column
de42 : a441             [ 3] 	ldy tmp_a
de44 :                       gr_hchar_shiftcol
AS65 Assembler for R6502 [1.42].                                     Page  120
-------------------------------- bank\bank0.s --------------------------------

de44 : f006             [ 3] 	beq gr_hchar_shiftdone		; Branch on Y = 0
de46 : 4a               [ 2] 	lsr a
de47 : 768d             [ 6] 	ror ztmp_16+8,x
de49 : 88               [ 2] 	dey
de4a : 80f8             [ 3] 	bra gr_hchar_shiftcol
de4c :                       gr_hchar_shiftdone
de4c : 9585             [ 4] 	sta ztmp_16,x
de4e : e8               [ 2] 	inx
de4f : e008             [ 2] 	cpx #8						; Do 8 lines each 16 bits wide
de51 : d0e9             [ 3] 	bne gr_hchar_shiftline
                             
                             	; Ok we have a char image in dram ztmp_16, need 
                             
de53 : e612             [ 5] 	inc vdp_curoff				; Disable cursor
                             	
                             	; do 8 lines of left image
de55 : a200             [ 2] 	ldx #0
de57 :                       gr_hchar_getimage
de57 : da               [ 3] 	phx					; Save index
                             	; Get x,y coord and calc address in to tmp_v1
de58 : a643             [ 3] 	ldx tmp_b
de5a : a444             [ 3] 	ldy tmp_b+1
de5c : 2091dd           [ 6] 	jsr gr_getXY_ptr
de5f : 863f             [ 3] 	stx tmp_v1
de61 : 8440             [ 3] 	sty tmp_v1+1
                             
                             	; high need to be in A for peek
de63 : 98               [ 2] 	tya
de64 : 2034c6           [ 6] 	jsr vdp_peek		; Get image byte from vram
de67 : 853d             [ 3] 	sta tmp_c			; Save in temp c
de69 : fa               [ 4] 	plx					; Restore index but don't lose it
de6a : da               [ 3] 	phx
de6b : b585             [ 4] 	lda ztmp_16,x		; Get cached image
de6d : a42e             [ 3] 	ldy gr_scrngeom+gr_pixmode		; Get the mode to pl
de6f : f008             [ 3] 	beq gr_hchar_getimage_plot		; If erase then blat
de71 : 453d             [ 3] 	eor tmp_c			; First assume EOR with vram
de73 : c002             [ 2] 	cpy #2				; Is that the mode
de75 : f002             [ 3] 	beq gr_hchar_getimage_plot
de77 : 053d             [ 3] 	ora tmp_c			; Else OR VRAM with Image
de79 :                       gr_hchar_getimage_plot
                             	; Get vram address from tmp_v1
de79 : a63f             [ 3] 	ldx tmp_v1
de7b : a440             [ 3] 	ldy tmp_v1+1
de7d : 2028c6           [ 6] 	jsr vdp_poke		; Put image on
                             
de80 : a42e             [ 3] 	ldy gr_scrngeom+gr_pixmode
de82 : c002             [ 2] 	cpy #2
de84 : f010             [ 3] 	beq gr_hchar_skipcol
                             	; if not xor mode put in the right colour
                             	; add the x,y offset in to the colour table
de86 : 18               [ 2] 	clc
de87 : a519             [ 3] 	lda vdp_base+vdp_addr_col
de89 : 653f             [ 3] 	adc tmp_v1
de8b : aa               [ 2] 	tax
de8c : a51a             [ 3] 	lda vdp_base+vdp_addr_col+1
de8e : 6540             [ 3] 	adc tmp_v1+1
de90 : a8               [ 2] 	tay
de91 : a530             [ 3] 	lda gr_scrngeom+gr_pixcol
de93 : 2028c6           [ 6] 	jsr vdp_poke
                             
de96 :                       gr_hchar_skipcol
de96 : e644             [ 5] 	inc tmp_b+1			; Update y coord
AS65 Assembler for R6502 [1.42].                                     Page  121
-------------------------------- bank\bank0.s --------------------------------

de98 : fa               [ 4] 	plx					; Restore index
de99 : e8               [ 2] 	inx
de9a : e008             [ 2] 	cpx #8				; Done all of left side?
de9c : f006             [ 3] 	beq gr_hchar_prepright
de9e : e010             [ 2] 	cpx #16				; We've done all of right side?
dea0 : f016             [ 3] 	beq gr_hchar_imagedone
dea2 : d0b3             [ 3] 	bne gr_hchar_getimage	; Else keep going // alway
dea4 :                       gr_hchar_prepright
                             	; Done left but prepare to do right
                             	; X=8 which is the right side of the image cache
dea4 : a541             [ 3] 	lda tmp_a			; Check if anything on the right
dea6 : f010             [ 3] 	beq gr_hchar_imagedone	; If not, then don't do i
dea8 : 38               [ 2] 	sec					; Re-adjust y coord back to top
dea9 : a544             [ 3] 	lda tmp_b+1
deab : e908             [ 2] 	sbc #8
dead : 8544             [ 3] 	sta tmp_b+1
deaf : 18               [ 2] 	clc					; Move x coord across to RHS by adding 8
deb0 : a543             [ 3] 	lda tmp_b
deb2 : 6908             [ 2] 	adc #8
deb4 : 8543             [ 3] 	sta tmp_b
deb6 : 909f             [ 3] 	bcc gr_hchar_getimage	; Only do right if in boun
deb8 :                       gr_hchar_imagedone
deb8 : c612             [ 5] 	dec vdp_curoff				; Enable cursor
                             
deba : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_point
                             ;* Write a point to the X,Y coordinates
                             ;* Input : X,Y = coord
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
debb :                       gr_point
                             	; Save A and X for later
debb : da               [ 3] 	phx
                             
                             	; Get hires address from X,Y coordinates
debc : 2091dd           [ 6] 	jsr gr_getXY_ptr
debf : 863f             [ 3] 	stx tmp_v1
dec1 : 8440             [ 3] 	sty tmp_v1+1
                             
                             	; A is hi byte for peek
dec3 : 98               [ 2] 	tya
                             	
dec4 : 2034c6           [ 6] 	jsr vdp_peek
                             	; Save in temp
dec7 : 8543             [ 3] 	sta tmp_b
                             
                             	; Get X back and mask off 3 LSBs
dec9 : 68               [ 4] 	pla
deca : 2907             [ 2] 	and #0x07
                             	; Use this to find the bit number mask and save 
<<<<<<< HEAD
decc : aa               [ 2] 	tax
decd : bdfede           [ 4] 	lda gr_point_mask,x
ded0 : 8544             [ 3] 	sta tmp_b+1
=======
dbcc : aa               [ 2] 	tax
dbcd : bd02dc           [ 4] 	lda gr_point_mask,x
dbd0 : 8544             [ 3] 	sta tmp_b+1
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             	; Get the mode number in to X
ded2 : a62e             [ 3] 	ldx gr_scrngeom+gr_pixmode
                             	; load VRAM byte
ded4 : a543             [ 3] 	lda tmp_b
                             	; first assume that we want to set a bit - OR wi
ded6 : 0544             [ 3] 	ora tmp_b+1
AS65 Assembler for R6502 [1.42].                                     Page  122
-------------------------------- bank\bank0.s --------------------------------

                             	; if that is correct then done
ded8 : e001             [ 2] 	cpx #1
deda : f00a             [ 3] 	beq gr_point_done
                             	; now assume that actually we want to erase but 
dedc : 4544             [ 3] 	eor tmp_b+1
                             	; if that is correct then done
dede : e000             [ 2] 	cpx #0
dee0 : f004             [ 3] 	beq gr_point_done
                             	; else we want to really just do an eor of VRAM 
dee2 : a543             [ 3] 	lda tmp_b
dee4 : 4544             [ 3] 	eor tmp_b+1
                             	; so now we have the VRAM bit set properly in te
dee6 :                       gr_point_done
dee6 : a63f             [ 3] 	ldx tmp_v1
dee8 : a440             [ 3] 	ldy tmp_v1+1
deea : 2028c6           [ 6] 	jsr vdp_poke
                             
                             	; now put in the right colour
                             	; add the x,y offset in to the colour table
<<<<<<< HEAD
deed : 18               [ 2] 	clc
deee : a519             [ 3] 	lda vdp_base+vdp_addr_col
def0 : 653f             [ 3] 	adc tmp_v1
def2 : aa               [ 2] 	tax
def3 : a51a             [ 3] 	lda vdp_base+vdp_addr_col+1
def5 : 6540             [ 3] 	adc tmp_v1+1
def7 : a8               [ 2] 	tay
def8 : a530             [ 3] 	lda gr_scrngeom+gr_pixcol
defa : 2028c6           [ 6] 	jsr vdp_poke
                             
defd : 60               [ 6] 	rts
defe :                       gr_point_mask
defe : 8040201008040201      	db 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01
=======
dbed : a530             [ 3] 	lda gr_scrngeom+gr_pixcol		; If pixcol zero don'
dbef : f010             [ 4] 	beq gr_point_exit
dbf1 : 18               [ 2] 	clc
dbf2 : a519             [ 3] 	lda vdp_base+vdp_addr_col
dbf4 : 653f             [ 3] 	adc tmp_v1
dbf6 : aa               [ 2] 	tax
dbf7 : a51a             [ 3] 	lda vdp_base+vdp_addr_col+1
dbf9 : 6540             [ 3] 	adc tmp_v1+1
dbfb : a8               [ 2] 	tay
dbfc : a530             [ 3] 	lda gr_scrngeom+gr_pixcol
dbfe : 4c10c6           [ 3] 	jmp vdp_poke
dc01 :                       gr_point_exit
dc01 : 60               [ 6] 	rts
dc02 :                       gr_point_mask
dc02 : 8040201008040201      	db 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             
                             ;****************************************
                             ;* gr_box
                             ;* Draw a box from x0,y0 -> x1,y1
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
                             ;*			num_a+2 = x1
                             ;*			num_a+3 = y1
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
<<<<<<< HEAD
df06 :                       gr_box
df06 : a585             [ 3] 	lda num_a					; If x0,x1 in same byte column
df08 : 29f8             [ 2] 	and #0xf8					; then special handling
df0a : 8543             [ 3] 	sta tmp_b
df0c : a587             [ 3] 	lda num_a+2
df0e : 29f8             [ 2] 	and #0xf8
df10 : c543             [ 3] 	cmp tmp_b
df12 : f05f             [ 3] 	beq gr_box_tiny_width
                             	; x0, x1 in different byte columns
df14 : a585             [ 3] 	lda num_a					; Get lhs mask
df16 : 2907             [ 2] 	and #7
df18 : aa               [ 2] 	tax
df19 : bd01e0           [ 4] 	lda gr_box_lmask,x
df1c : 8543             [ 3] 	sta tmp_b
df1e : a685             [ 3] 	ldx num_a					; Do top left
df20 : a486             [ 3] 	ldy num_a+1
df22 : 20cfdf           [ 6] 	jsr gr_box_plot
df25 : a543             [ 3] 	lda tmp_b
AS65 Assembler for R6502 [1.42].                                     Page  123
-------------------------------- bank\bank0.s --------------------------------

df27 : a685             [ 3] 	ldx num_a					; Do bottom left
df29 : a488             [ 3] 	ldy num_a+3
df2b : 20cfdf           [ 6] 	jsr gr_box_plot
df2e : a587             [ 3] 	lda num_a+2					; Get rhs mask
df30 : 2907             [ 2] 	and #7
df32 : aa               [ 2] 	tax
df33 : bd09e0           [ 4] 	lda gr_box_rmask,x
df36 : 8543             [ 3] 	sta tmp_b
df38 : a687             [ 3] 	ldx num_a+2					; Do top right
df3a : a486             [ 3] 	ldy num_a+1
df3c : 20cfdf           [ 6] 	jsr gr_box_plot
df3f : a543             [ 3] 	lda tmp_b
df41 : a687             [ 3] 	ldx num_a+2					; Do bottom right
df43 : a488             [ 3] 	ldy num_a+3
df45 : 20cfdf           [ 6] 	jsr gr_box_plot
                             	; Do fast horz lines if x0,x1
                             	; are in different byte columns
df48 : a585             [ 3] 	lda num_a					; Byte align x0
df4a : 29f8             [ 2] 	and #0xf8
df4c : 8543             [ 3] 	sta tmp_b
df4e : a587             [ 3] 	lda num_a+2					; Byte align x1
df50 : 29f8             [ 2] 	and #0xf8
df52 : 8544             [ 3] 	sta tmp_b+1
df54 :                       gr_box_8line
df54 : a544             [ 3] 	lda tmp_b+1					; Move left 1 column
df56 : 38               [ 2] 	sec
df57 : e908             [ 2] 	sbc #8
df59 : 8544             [ 3] 	sta tmp_b+1
df5b : c543             [ 3] 	cmp tmp_b
df5d : f039             [ 3] 	beq gr_box_do_vert			; if columns same then done
df5f : a644             [ 3] 	ldx tmp_b+1					; Do top from right to left
df61 : a486             [ 3] 	ldy num_a+1
df63 : a9ff             [ 2] 	lda #0xff
df65 : 20cfdf           [ 6] 	jsr gr_box_plot
df68 : a644             [ 3] 	ldx tmp_b+1					; Do top from right to left
df6a : a488             [ 3] 	ldy num_a+3
df6c : a9ff             [ 2] 	lda #0xff
df6e : 20cfdf           [ 6] 	jsr gr_box_plot
df71 : 80e1             [ 3] 	bra gr_box_8line			; Looping
df73 :                       gr_box_tiny_width
df73 : a585             [ 3] 	lda num_a
df75 : 2907             [ 2] 	and #7
df77 : 48               [ 3] 	pha
df78 : a587             [ 3] 	lda num_a+2
df7a : 2907             [ 2] 	and #7
df7c : aa               [ 2] 	tax
df7d : bd09e0           [ 4] 	lda gr_box_rmask,x			; Get rhs mask
df80 : fa               [ 4] 	plx
df81 : 3d01e0           [ 4] 	and gr_box_lmask,x			; AND with lhs mask
df84 : 8543             [ 3] 	sta tmp_b					; This is the intra column mask
df86 : a685             [ 3] 	ldx num_a					; Plot top
df88 : a486             [ 3] 	ldy num_a+1
df8a : 20cfdf           [ 6] 	jsr gr_box_plot
df8d : a687             [ 3] 	ldx num_a+2					; Plot bottom
df8f : a488             [ 3] 	ldy num_a+3
df91 : c486             [ 3] 	cpy num_a+1					; but only if different from top
df93 : f039             [ 3] 	beq gr_box_done				; if top=bottom then finished
df95 : 20cfdf           [ 6] 	jsr gr_box_plot
df98 :                       gr_box_do_vert
                             	; Do the vertical sides of the box
df98 : a585             [ 3] 	lda num_a					; Find bit position of x0 (left)
df9a : 2907             [ 2] 	and #7
AS65 Assembler for R6502 [1.42].                                     Page  124
-------------------------------- bank\bank0.s --------------------------------

df9c : aa               [ 2] 	tax							; And get value to write
df9d : bdfede           [ 4] 	lda gr_point_mask,x
dfa0 : 8543             [ 3] 	sta tmp_b
                             	
dfa2 : a587             [ 3] 	lda num_a+2					; Find bit position of x1 (right
dfa4 : 2907             [ 2] 	and #7
dfa6 : aa               [ 2] 	tax							; And get value to write
dfa7 : bdfede           [ 4] 	lda gr_point_mask,x
dfaa : 8544             [ 3] 	sta tmp_b+1
                             
dfac : a486             [ 3] 	ldy num_a+1					; Get y0 coord and save
dfae : 8491             [ 3] 	sty num_tmp
dfb0 :                       gr_box_vert
dfb0 : e691             [ 5] 	inc num_tmp					; Increment y first
dfb2 : a491             [ 3] 	ldy num_tmp
dfb4 : c488             [ 3] 	cpy num_a+3					; if thisY>=y1 then done
dfb6 : b016             [ 3] 	bcs gr_box_vert_done
dfb8 : a685             [ 3] 	ldx num_a					; Do left side
dfba : a543             [ 3] 	lda tmp_b
dfbc : 20cfdf           [ 6] 	jsr gr_box_plot
dfbf : a687             [ 3] 	ldx num_a+2					; Do right line
dfc1 : e485             [ 3] 	cpx num_a					; Only if not same as lhs
dfc3 : f007             [ 3] 	beq gr_box_skip_rhs
dfc5 : a491             [ 3] 	ldy num_tmp
dfc7 : a544             [ 3] 	lda tmp_b+1
dfc9 : 20cfdf           [ 6] 	jsr gr_box_plot
dfcc :                       gr_box_skip_rhs
dfcc : 80e2             [ 3] 	bra gr_box_vert				; looping
dfce :                       gr_box_vert_done
dfce :                       gr_box_done
dfce : 60               [ 6] 	rts
=======
AS65 Assembler for R6502 [1.42].                                     Page  116
-------------------------------- bank\bank0.s --------------------------------

dc0a :                       gr_box
dc0a : a585             [ 3] 	lda num_a					; If x0,x1 in same byte column
dc0c : 29f8             [ 2] 	and #0xf8					; then special handling
dc0e : 8543             [ 3] 	sta tmp_b
dc10 : a587             [ 3] 	lda num_a+2
dc12 : 29f8             [ 2] 	and #0xf8
dc14 : c543             [ 3] 	cmp tmp_b
dc16 : f05f             [ 3] 	beq gr_box_tiny_width
                             	; x0, x1 in different byte columns
dc18 : a585             [ 3] 	lda num_a					; Get lhs mask
dc1a : 2907             [ 2] 	and #7
dc1c : aa               [ 2] 	tax
dc1d : bd05dd           [ 4] 	lda gr_box_lmask,x
dc20 : 8543             [ 3] 	sta tmp_b
dc22 : a685             [ 3] 	ldx num_a					; Do top left
dc24 : a486             [ 3] 	ldy num_a+1
dc26 : 20d3dc           [ 6] 	jsr gr_box_plot
dc29 : a543             [ 3] 	lda tmp_b
dc2b : a685             [ 3] 	ldx num_a					; Do bottom left
dc2d : a488             [ 3] 	ldy num_a+3
dc2f : 20d3dc           [ 6] 	jsr gr_box_plot
dc32 : a587             [ 3] 	lda num_a+2					; Get rhs mask
dc34 : 2907             [ 2] 	and #7
dc36 : aa               [ 2] 	tax
dc37 : bd0ddd           [ 4] 	lda gr_box_rmask,x
dc3a : 8543             [ 3] 	sta tmp_b
dc3c : a687             [ 3] 	ldx num_a+2					; Do top right
dc3e : a486             [ 3] 	ldy num_a+1
dc40 : 20d3dc           [ 6] 	jsr gr_box_plot
dc43 : a543             [ 3] 	lda tmp_b
dc45 : a687             [ 3] 	ldx num_a+2					; Do bottom right
dc47 : a488             [ 3] 	ldy num_a+3
dc49 : 20d3dc           [ 6] 	jsr gr_box_plot
                             	; Do fast horz lines if x0,x1
                             	; are in different byte columns
dc4c : a585             [ 3] 	lda num_a					; Byte align x0
dc4e : 29f8             [ 2] 	and #0xf8
dc50 : 8543             [ 3] 	sta tmp_b
dc52 : a587             [ 3] 	lda num_a+2					; Byte align x1
dc54 : 29f8             [ 2] 	and #0xf8
dc56 : 8544             [ 3] 	sta tmp_b+1
dc58 :                       gr_box_8line
dc58 : a544             [ 3] 	lda tmp_b+1					; Move left 1 column
dc5a : 38               [ 2] 	sec
dc5b : e908             [ 2] 	sbc #8
dc5d : 8544             [ 3] 	sta tmp_b+1
dc5f : c543             [ 3] 	cmp tmp_b
dc61 : f039             [ 3] 	beq gr_box_do_vert			; if columns same then done
dc63 : a644             [ 3] 	ldx tmp_b+1					; Do top from right to left
dc65 : a486             [ 3] 	ldy num_a+1
dc67 : a9ff             [ 2] 	lda #0xff
dc69 : 20d3dc           [ 6] 	jsr gr_box_plot
dc6c : a644             [ 3] 	ldx tmp_b+1					; Do top from right to left
dc6e : a488             [ 3] 	ldy num_a+3
dc70 : a9ff             [ 2] 	lda #0xff
dc72 : 20d3dc           [ 6] 	jsr gr_box_plot
dc75 : 80e1             [ 3] 	bra gr_box_8line			; Looping
dc77 :                       gr_box_tiny_width
dc77 : a585             [ 3] 	lda num_a
dc79 : 2907             [ 2] 	and #7
dc7b : 48               [ 3] 	pha
dc7c : a587             [ 3] 	lda num_a+2
AS65 Assembler for R6502 [1.42].                                     Page  117
-------------------------------- bank\bank0.s --------------------------------

dc7e : 2907             [ 2] 	and #7
dc80 : aa               [ 2] 	tax
dc81 : bd0ddd           [ 4] 	lda gr_box_rmask,x			; Get rhs mask
dc84 : fa               [ 4] 	plx
dc85 : 3d05dd           [ 4] 	and gr_box_lmask,x			; AND with lhs mask
dc88 : 8543             [ 3] 	sta tmp_b					; This is the intra column mask
dc8a : a685             [ 3] 	ldx num_a					; Plot top
dc8c : a486             [ 3] 	ldy num_a+1
dc8e : 20d3dc           [ 6] 	jsr gr_box_plot
dc91 : a687             [ 3] 	ldx num_a+2					; Plot bottom
dc93 : a488             [ 3] 	ldy num_a+3
dc95 : c486             [ 3] 	cpy num_a+1					; but only if different from top
dc97 : f039             [ 3] 	beq gr_box_done				; if top=bottom then finished
dc99 : 20d3dc           [ 6] 	jsr gr_box_plot
dc9c :                       gr_box_do_vert
                             	; Do the vertical sides of the box
dc9c : a585             [ 3] 	lda num_a					; Find bit position of x0 (left)
dc9e : 2907             [ 2] 	and #7
dca0 : aa               [ 2] 	tax							; And get value to write
dca1 : bd02dc           [ 4] 	lda gr_point_mask,x
dca4 : 8543             [ 3] 	sta tmp_b
                             	
dca6 : a587             [ 3] 	lda num_a+2					; Find bit position of x1 (right
dca8 : 2907             [ 2] 	and #7
dcaa : aa               [ 2] 	tax							; And get value to write
dcab : bd02dc           [ 4] 	lda gr_point_mask,x
dcae : 8544             [ 3] 	sta tmp_b+1
                             
dcb0 : a486             [ 3] 	ldy num_a+1					; Get y0 coord and save
dcb2 : 8491             [ 3] 	sty num_tmp
dcb4 :                       gr_box_vert
dcb4 : e691             [ 5] 	inc num_tmp					; Increment y first
dcb6 : a491             [ 3] 	ldy num_tmp
dcb8 : c488             [ 3] 	cpy num_a+3					; if thisY>=y1 then done
dcba : b016             [ 3] 	bcs gr_box_vert_done
dcbc : a685             [ 3] 	ldx num_a					; Do left side
dcbe : a543             [ 3] 	lda tmp_b
dcc0 : 20d3dc           [ 6] 	jsr gr_box_plot
dcc3 : a687             [ 3] 	ldx num_a+2					; Do right line
dcc5 : e485             [ 3] 	cpx num_a					; Only if not same as lhs
dcc7 : f007             [ 3] 	beq gr_box_skip_rhs
dcc9 : a491             [ 3] 	ldy num_tmp
dccb : a544             [ 3] 	lda tmp_b+1
dccd : 20d3dc           [ 6] 	jsr gr_box_plot
dcd0 :                       gr_box_skip_rhs
dcd0 : 80e2             [ 3] 	bra gr_box_vert				; looping
dcd2 :                       gr_box_vert_done
dcd2 :                       gr_box_done
dcd2 : 60               [ 6] 	rts
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             ; Box draw common draw routine
                             ; x,y is pixel coord
                             ; a is the value to write
<<<<<<< HEAD
dfcf :                       gr_box_plot
dfcf : 853d             [ 3] 	sta tmp_c					; Save mask to write
dfd1 : 8a               [ 2] 	txa
dfd2 : 98               [ 2] 	tya
dfd3 : 2091dd           [ 6] 	jsr gr_getXY_ptr
dfd6 : da               [ 3] 	phx
dfd7 : 98               [ 2] 	tya							; A=high byte for peek
dfd8 : 2034c6           [ 6] 	jsr vdp_peek				; Get current screen byte
dfdb : 853e             [ 3] 	sta tmp_c+1
dfdd : a62e             [ 3] 	ldx gr_scrngeom+gr_pixmode	; Use screen mode
dfdf : 053d             [ 3] 	ora tmp_c					; Assume mode 1 (or)
dfe1 : e001             [ 2] 	cpx #1						; Done if correct
dfe3 : f00a             [ 3] 	beq gr_box_write
dfe5 : 453d             [ 3] 	eor tmp_c					; Assume mode 0 (eor erases or)
dfe7 : e000             [ 2] 	cpx #0						; Done if correct
dfe9 : f004             [ 3] 	beq gr_box_write
dfeb : a53e             [ 3] 	lda tmp_c+1					; Else eor with source
dfed : 453d             [ 3] 	eor tmp_c
dfef :                       gr_box_write
dfef : fa               [ 4] 	plx							; Restore x, y is intact
dff0 : 2028c6           [ 6] 	jsr vdp_poke				; Poke the value
dff3 : 18               [ 2] 	clc							; Calculate the colour table offset
dff4 : 8a               [ 2] 	txa							; Low byte
dff5 : 6519             [ 3] 	adc vdp_base+vdp_addr_col
dff7 : aa               [ 2] 	tax
dff8 : 98               [ 2] 	tya							; High byte
dff9 : 651a             [ 3] 	adc vdp_base+vdp_addr_col+1
AS65 Assembler for R6502 [1.42].                                     Page  125
-------------------------------- bank\bank0.s --------------------------------

dffb : a8               [ 2] 	tay
dffc : a530             [ 3] 	lda gr_scrngeom+gr_pixcol	; Colour
dffe : 4c28c6           [ 3] 	jmp vdp_poke
                             
e001 :                       gr_box_lmask
e001 : ff7f3f1f0f070301      	db 0xff,0x7f,0x3f,0x1f,0x0f,0x07,0x03,0x01
e009 :                       gr_box_rmask
e009 : 80c0e0f0f8fcfeff      	db 0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff
=======
dcd3 :                       gr_box_plot
dcd3 : 853d             [ 3] 	sta tmp_c					; Save mask to write
dcd5 : 8a               [ 2] 	txa
dcd6 : 98               [ 2] 	tya
dcd7 : 2091da           [ 6] 	jsr gr_getXY_ptr
dcda : da               [ 3] 	phx
dcdb : 98               [ 2] 	tya							; A=high byte for peek
dcdc : 201cc6           [ 6] 	jsr vdp_peek				; Get current screen byte
dcdf : 853e             [ 3] 	sta tmp_c+1
AS65 Assembler for R6502 [1.42].                                     Page  118
-------------------------------- bank\bank0.s --------------------------------

dce1 : a62e             [ 3] 	ldx gr_scrngeom+gr_pixmode	; Use screen mode
dce3 : 053d             [ 3] 	ora tmp_c					; Assume mode 1 (or)
dce5 : e001             [ 2] 	cpx #1						; Done if correct
dce7 : f00a             [ 3] 	beq gr_box_write
dce9 : 453d             [ 3] 	eor tmp_c					; Assume mode 0 (eor erases or)
dceb : e000             [ 2] 	cpx #0						; Done if correct
dced : f004             [ 3] 	beq gr_box_write
dcef : a53e             [ 3] 	lda tmp_c+1					; Else eor with source
dcf1 : 453d             [ 3] 	eor tmp_c
dcf3 :                       gr_box_write
dcf3 : fa               [ 4] 	plx							; Restore x, y is intact
dcf4 : 2010c6           [ 6] 	jsr vdp_poke				; Poke the value
dcf7 : 18               [ 2] 	clc							; Calculate the colour table offset
dcf8 : 8a               [ 2] 	txa							; Low byte
dcf9 : 6519             [ 3] 	adc vdp_base+vdp_addr_col
dcfb : aa               [ 2] 	tax
dcfc : 98               [ 2] 	tya							; High byte
dcfd : 651a             [ 3] 	adc vdp_base+vdp_addr_col+1
dcff : a8               [ 2] 	tay
dd00 : a530             [ 3] 	lda gr_scrngeom+gr_pixcol	; Colour
dd02 : 4c10c6           [ 3] 	jmp vdp_poke
                             
dd05 :                       gr_box_lmask
dd05 : ff7f3f1f0f070301      	db 0xff,0x7f,0x3f,0x1f,0x0f,0x07,0x03,0x01
dd0d :                       gr_box_rmask
dd0d : 80c0e0f0f8fcfeff      	db 0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             	
                             ;****************************************
                             ;* gr_circle
                             ;* Draw a circle centre x0,y0, radius r
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
                             ;*			num_a+2 = r
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
<<<<<<< HEAD
e011 :                       gr_circle
=======
dd15 :                       gr_circle
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             ; Local definitions of temp space to make
                             ; the rest of the code easier to read
0085 =                       grc_x0 	= (num_a)
0086 =                       grc_y0 	= (num_a+1)
0087 =                       grc_r 	= (num_a+2)
0088 =                       grc_x 	= (num_a+3)
008a =                       grc_y	= (num_b+1)
008b =                       grc_d	= (num_b+2)
                             
                             	;x = radius
<<<<<<< HEAD
e011 : a587             [ 3] 	lda grc_r
e013 : 8588             [ 3] 	sta grc_x
                             	;y = 0
e015 : 648a             [ 3] 	stz grc_y
                             	;decision = 1 - x
e017 : a901             [ 2] 	lda #1
e019 : 38               [ 2] 	sec
e01a : e588             [ 3] 	sbc grc_x
e01c : 858b             [ 3] 	sta grc_d
e01e :                       gr_circle_plot
                             	;while(x >= y)
e01e : a588             [ 3] 	lda grc_x
e020 : c58a             [ 3] 	cmp grc_y
e022 : 9028             [ 3] 	bcc gr_circle_done
                             	;plot 8 points on current x,y
e024 : 204de0           [ 6] 	jsr gr_circle_points
                             	;y++
e027 : e68a             [ 5] 	inc grc_y
                             	;if d<=0
e029 : a58b             [ 3] 	lda grc_d
e02b : f013             [ 3] 	beq gr_circle_d_lte0
e02d : 3011             [ 3] 	bmi gr_circle_d_lte0
                             	;else
                             	;x--
e02f : c688             [ 5] 	dec grc_x
                             	;decision += 2 * (y - x) + 1
e031 : a58a             [ 3] 	lda grc_y
e033 : 38               [ 2] 	sec
e034 : e588             [ 3] 	sbc grc_x
e036 : 0a               [ 2] 	asl a
e037 : 18               [ 2] 	clc
e038 : 6901             [ 2] 	adc #1
AS65 Assembler for R6502 [1.42].                                     Page  126
-------------------------------- bank\bank0.s --------------------------------

e03a : 658b             [ 3] 	adc grc_d
e03c : 858b             [ 3] 	sta grc_d
e03e : 80de             [ 3] 	bra gr_circle_plot	
e040 :                       gr_circle_d_lte0
                             	;decision += 2 * y + 1
e040 : a58a             [ 3] 	lda grc_y
e042 : 0a               [ 2] 	asl a
e043 : 18               [ 2] 	clc
e044 : 6901             [ 2] 	adc #1
e046 : 658b             [ 3] 	adc grc_d
e048 : 858b             [ 3] 	sta grc_d
e04a : 80d2             [ 3] 	bra gr_circle_plot	
e04c :                       gr_circle_done
e04c : 60               [ 6] 	rts
e04d :                       gr_circle_points
                             ; Local names of temp storage
                             ; to make code easier to read
                             	;DrawPixel( x + x0,  yh + y0);
e04d : a588             [ 3] 	lda grc_x
e04f : 18               [ 2] 	clc
e050 : 6585             [ 3] 	adc grc_x0
e052 : aa               [ 2] 	tax
e053 : a58a             [ 3] 	lda grc_y
e055 : 18               [ 2] 	clc
e056 : 6586             [ 3] 	adc grc_y0
e058 : a8               [ 2] 	tay
e059 : 20bbde           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0,  xh + y0);
e05c : a58a             [ 3] 	lda grc_y
e05e : 18               [ 2] 	clc
e05f : 6585             [ 3] 	adc grc_x0
e061 : aa               [ 2] 	tax
e062 : a588             [ 3] 	lda grc_x
e064 : 18               [ 2] 	clc
e065 : 6586             [ 3] 	adc grc_y0
e067 : a8               [ 2] 	tay
e068 : 20bbde           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0,  yh + y0);
e06b : a585             [ 3] 	lda grc_x0
e06d : 38               [ 2] 	sec
e06e : e588             [ 3] 	sbc grc_x
e070 : aa               [ 2] 	tax
e071 : a58a             [ 3] 	lda grc_y
e073 : 18               [ 2] 	clc
e074 : 6586             [ 3] 	adc grc_y0
e076 : a8               [ 2] 	tay
e077 : 20bbde           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0,  xh + y0);
e07a : a585             [ 3] 	lda grc_x0
e07c : 38               [ 2] 	sec
e07d : e58a             [ 3] 	sbc grc_y
e07f : aa               [ 2] 	tax
e080 : a588             [ 3] 	lda grc_x
e082 : 18               [ 2] 	clc
e083 : 6586             [ 3] 	adc grc_y0
e085 : a8               [ 2] 	tay
e086 : 20bbde           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0, -yh + y0);
e089 : a585             [ 3] 	lda grc_x0
e08b : 38               [ 2] 	sec
e08c : e588             [ 3] 	sbc grc_x
e08e : aa               [ 2] 	tax
AS65 Assembler for R6502 [1.42].                                     Page  127
-------------------------------- bank\bank0.s --------------------------------

e08f : a586             [ 3] 	lda grc_y0
e091 : 38               [ 2] 	sec
e092 : e58a             [ 3] 	sbc grc_y
e094 : a8               [ 2] 	tay
e095 : 20bbde           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0, -xh + y0);
e098 : a585             [ 3] 	lda grc_x0
e09a : 38               [ 2] 	sec
e09b : e58a             [ 3] 	sbc grc_y
e09d : aa               [ 2] 	tax
e09e : a586             [ 3] 	lda grc_y0
e0a0 : 38               [ 2] 	sec
e0a1 : e588             [ 3] 	sbc grc_x
e0a3 : a8               [ 2] 	tay
e0a4 : 20bbde           [ 6] 	jsr gr_point
                             	;DrawPixel( x + x0, -yh + y0);
e0a7 : a588             [ 3] 	lda grc_x
e0a9 : 18               [ 2] 	clc
e0aa : 6585             [ 3] 	adc grc_x0
e0ac : aa               [ 2] 	tax
e0ad : a586             [ 3] 	lda grc_y0
e0af : 38               [ 2] 	sec
e0b0 : e58a             [ 3] 	sbc grc_y
e0b2 : a8               [ 2] 	tay
e0b3 : 20bbde           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0, -xh + y0);
e0b6 : a58a             [ 3] 	lda grc_y
e0b8 : 18               [ 2] 	clc
e0b9 : 6585             [ 3] 	adc grc_x0
e0bb : aa               [ 2] 	tax
e0bc : a586             [ 3] 	lda grc_y0
e0be : 38               [ 2] 	sec
e0bf : e588             [ 3] 	sbc grc_x
e0c1 : a8               [ 2] 	tay
e0c2 : 20bbde           [ 6] 	jsr gr_point
e0c5 : 60               [ 6] 	rts
=======
dd15 : a587             [ 3] 	lda grc_r
dd17 : 8588             [ 3] 	sta grc_x
                             	;y = 0
dd19 : 648a             [ 3] 	stz grc_y
                             	;decision = 1 - x
dd1b : a901             [ 2] 	lda #1
dd1d : 38               [ 2] 	sec
dd1e : e588             [ 3] 	sbc grc_x
dd20 : 858b             [ 3] 	sta grc_d
dd22 :                       gr_circle_plot
                             	;while(x >= y)
dd22 : a588             [ 3] 	lda grc_x
dd24 : c58a             [ 3] 	cmp grc_y
dd26 : 9028             [ 3] 	bcc gr_circle_done
AS65 Assembler for R6502 [1.42].                                     Page  119
-------------------------------- bank\bank0.s --------------------------------

                             	;plot 8 points on current x,y
dd28 : 2051dd           [ 6] 	jsr gr_circle_points
                             	;y++
dd2b : e68a             [ 5] 	inc grc_y
                             	;if d<=0
dd2d : a58b             [ 3] 	lda grc_d
dd2f : f013             [ 3] 	beq gr_circle_d_lte0
dd31 : 3011             [ 3] 	bmi gr_circle_d_lte0
                             	;else
                             	;x--
dd33 : c688             [ 5] 	dec grc_x
                             	;decision += 2 * (y - x) + 1
dd35 : a58a             [ 3] 	lda grc_y
dd37 : 38               [ 2] 	sec
dd38 : e588             [ 3] 	sbc grc_x
dd3a : 0a               [ 2] 	asl a
dd3b : 18               [ 2] 	clc
dd3c : 6901             [ 2] 	adc #1
dd3e : 658b             [ 3] 	adc grc_d
dd40 : 858b             [ 3] 	sta grc_d
dd42 : 80de             [ 3] 	bra gr_circle_plot	
dd44 :                       gr_circle_d_lte0
                             	;decision += 2 * y + 1
dd44 : a58a             [ 3] 	lda grc_y
dd46 : 0a               [ 2] 	asl a
dd47 : 18               [ 2] 	clc
dd48 : 6901             [ 2] 	adc #1
dd4a : 658b             [ 3] 	adc grc_d
dd4c : 858b             [ 3] 	sta grc_d
dd4e : 80d2             [ 3] 	bra gr_circle_plot	
dd50 :                       gr_circle_done
dd50 : 60               [ 6] 	rts
dd51 :                       gr_circle_points
                             ; Local names of temp storage
                             ; to make code easier to read
                             	;DrawPixel( x + x0,  yh + y0);
dd51 : a588             [ 3] 	lda grc_x
dd53 : 18               [ 2] 	clc
dd54 : 6585             [ 3] 	adc grc_x0
dd56 : aa               [ 2] 	tax
dd57 : a58a             [ 3] 	lda grc_y
dd59 : 18               [ 2] 	clc
dd5a : 6586             [ 3] 	adc grc_y0
dd5c : a8               [ 2] 	tay
dd5d : 20bbdb           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0,  xh + y0);
dd60 : a58a             [ 3] 	lda grc_y
dd62 : 18               [ 2] 	clc
dd63 : 6585             [ 3] 	adc grc_x0
dd65 : aa               [ 2] 	tax
dd66 : a588             [ 3] 	lda grc_x
dd68 : 18               [ 2] 	clc
dd69 : 6586             [ 3] 	adc grc_y0
dd6b : a8               [ 2] 	tay
dd6c : 20bbdb           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0,  yh + y0);
dd6f : a585             [ 3] 	lda grc_x0
dd71 : 38               [ 2] 	sec
dd72 : e588             [ 3] 	sbc grc_x
dd74 : aa               [ 2] 	tax
dd75 : a58a             [ 3] 	lda grc_y
dd77 : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  120
-------------------------------- bank\bank0.s --------------------------------

dd78 : 6586             [ 3] 	adc grc_y0
dd7a : a8               [ 2] 	tay
dd7b : 20bbdb           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0,  xh + y0);
dd7e : a585             [ 3] 	lda grc_x0
dd80 : 38               [ 2] 	sec
dd81 : e58a             [ 3] 	sbc grc_y
dd83 : aa               [ 2] 	tax
dd84 : a588             [ 3] 	lda grc_x
dd86 : 18               [ 2] 	clc
dd87 : 6586             [ 3] 	adc grc_y0
dd89 : a8               [ 2] 	tay
dd8a : 20bbdb           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0, -yh + y0);
dd8d : a585             [ 3] 	lda grc_x0
dd8f : 38               [ 2] 	sec
dd90 : e588             [ 3] 	sbc grc_x
dd92 : aa               [ 2] 	tax
dd93 : a586             [ 3] 	lda grc_y0
dd95 : 38               [ 2] 	sec
dd96 : e58a             [ 3] 	sbc grc_y
dd98 : a8               [ 2] 	tay
dd99 : 20bbdb           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0, -xh + y0);
dd9c : a585             [ 3] 	lda grc_x0
dd9e : 38               [ 2] 	sec
dd9f : e58a             [ 3] 	sbc grc_y
dda1 : aa               [ 2] 	tax
dda2 : a586             [ 3] 	lda grc_y0
dda4 : 38               [ 2] 	sec
dda5 : e588             [ 3] 	sbc grc_x
dda7 : a8               [ 2] 	tay
dda8 : 20bbdb           [ 6] 	jsr gr_point
                             	;DrawPixel( x + x0, -yh + y0);
ddab : a588             [ 3] 	lda grc_x
ddad : 18               [ 2] 	clc
ddae : 6585             [ 3] 	adc grc_x0
ddb0 : aa               [ 2] 	tax
ddb1 : a586             [ 3] 	lda grc_y0
ddb3 : 38               [ 2] 	sec
ddb4 : e58a             [ 3] 	sbc grc_y
ddb6 : a8               [ 2] 	tay
ddb7 : 20bbdb           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0, -xh + y0);
ddba : a58a             [ 3] 	lda grc_y
ddbc : 18               [ 2] 	clc
ddbd : 6585             [ 3] 	adc grc_x0
ddbf : aa               [ 2] 	tax
ddc0 : a586             [ 3] 	lda grc_y0
ddc2 : 38               [ 2] 	sec
ddc3 : e588             [ 3] 	sbc grc_x
ddc5 : a8               [ 2] 	tay
ddc6 : 20bbdb           [ 6] 	jsr gr_point
ddc9 : 60               [ 6] 	rts
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             	
                             	
                             ;****************************************
                             ;* gr_line
                             ;* Draw a line from x0,y0 -> x1,y1
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
<<<<<<< HEAD
=======
AS65 Assembler for R6502 [1.42].                                     Page  121
-------------------------------- bank\bank0.s --------------------------------

>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             ;*			num_a+2 = x1
                             ;*			num_a+3 = y1
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
<<<<<<< HEAD
e0c6 :                       gr_line
=======
ddca :                       gr_line
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             ; Local definitions of temp space to make
                             ; the rest of the code easier to read
0085 =                       grl_x0 	= (num_a)
0086 =                       grl_y0 	= (num_a+1)
0087 =                       grl_x1 	= (num_a+2)
0088 =                       grl_y1 	= (num_a+3)
008a =                       grl_dx	= (num_b+1)
008b =                       grl_dy	= (num_b+2)
008c =                       grl_xyyx= (num_b+3)
008d =                       grl_2dx	= (num_x)
008f =                       grl_2dy	= (num_x+2)
AS65 Assembler for R6502 [1.42].                                     Page  128
-------------------------------- bank\bank0.s --------------------------------

0091 =                       grl_2dxy= (num_tmp)
0093 =                       grl_inx	= (num_tmp+2)
0094 =                       grl_iny = (num_tmp+3)
0095 =                       grl_p	= (num_buf)
                             
<<<<<<< HEAD
e0c6 : 648c             [ 3] 	stz grl_xyyx				; Assume normal xy axis
=======
ddca : 648c             [ 3] 	stz grl_xyyx				; Assume normal xy axis
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             	
                             ;    int dx, dy, p, x, y;
                             	; check if abs(dy)>abs(dx) if so need to swap xy
                             	; num_b = abs(x), num_b+1 = abs(dy)
<<<<<<< HEAD
e0c8 : 38               [ 2] 	sec
e0c9 : a587             [ 3] 	lda grl_x1
e0cb : e585             [ 3] 	sbc grl_x0
e0cd : b003             [ 3] 	bcs gr_line_skip_dx_neg
e0cf : 49ff             [ 2] 	eor #0xff
e0d1 : 1a               [ 2] 	inc a
e0d2 :                       gr_line_skip_dx_neg
e0d2 : 858a             [ 3] 	sta grl_dx
e0d4 : 38               [ 2] 	sec
e0d5 : a588             [ 3] 	lda grl_y1
e0d7 : e586             [ 3] 	sbc grl_y0
e0d9 : b003             [ 3] 	bcs gr_line_skip_dy_neg
e0db : 49ff             [ 2] 	eor #0xff
e0dd : 1a               [ 2] 	inc a
e0de :                       gr_line_skip_dy_neg
e0de : 858b             [ 3] 	sta grl_dy
e0e0 : c58a             [ 3] 	cmp grl_dx
e0e2 : 901a             [ 3] 	bcc gr_line_skip_xy_swap
                             	; swap xy axes and also dx and dy
e0e4 : a585             [ 3] 	lda grl_x0					; swap x0 and y0
e0e6 : a686             [ 3] 	ldx grl_y0
e0e8 : 8586             [ 3] 	sta grl_y0
e0ea : 8685             [ 3] 	stx grl_x0
e0ec : a587             [ 3] 	lda grl_x1					; swap x1 and y1
e0ee : a688             [ 3] 	ldx grl_y1
e0f0 : 8588             [ 3] 	sta grl_y1
e0f2 : 8687             [ 3] 	stx grl_x1
e0f4 : a58a             [ 3] 	lda grl_dx					; swap dy and dx
e0f6 : a68b             [ 3] 	ldx grl_dy
e0f8 : 858b             [ 3] 	sta grl_dy
e0fa : 868a             [ 3] 	stx grl_dx
e0fc : e68c             [ 5] 	inc grl_xyyx				; set flag to Not Z to know abou
                             	
e0fe :                       gr_line_skip_xy_swap	
                             	; assume going from left to right
e0fe : a901             [ 2] 	lda #1
e100 : 8593             [ 3] 	sta grl_inx
e102 : a585             [ 3] 	lda grl_x0
e104 : c587             [ 3] 	cmp grl_x1
e106 : 9004             [ 3] 	bcc gr_line_skip_x_swap
e108 : a9ff             [ 2] 	lda #0xff					; make x increment negative
e10a : 8593             [ 3] 	sta grl_inx
                             	
e10c :                       gr_line_skip_x_swap
                             	; assume going from top to bottom
e10c : a901             [ 2] 	lda #1
e10e : 8594             [ 3] 	sta grl_iny
e110 : a586             [ 3] 	lda grl_y0
e112 : c588             [ 3] 	cmp grl_y1
e114 : 9004             [ 3] 	bcc gr_line_skip_y_up
e116 : a9ff             [ 2] 	lda #0xff					; make y increment negative
e118 : 8594             [ 3] 	sta grl_iny
AS65 Assembler for R6502 [1.42].                                     Page  129
-------------------------------- bank\bank0.s --------------------------------

                             
e11a :                       gr_line_skip_y_up
e11a : a58a             [ 3] 	lda grl_dx
e11c : 0a               [ 2] 	asl a
e11d : 858d             [ 3] 	sta grl_2dx					; 2*dx (word)
e11f : 648e             [ 3] 	stz grl_2dx+1
e121 : 268e             [ 5] 	rol grl_2dx+1
                             
e123 : a58b             [ 3] 	lda grl_dy
e125 : 0a               [ 2] 	asl a
e126 : 858f             [ 3] 	sta grl_2dy					; 2*dy (word)
e128 : 6490             [ 3] 	stz grl_2dy+1
e12a : 2690             [ 5] 	rol grl_2dy+1
                             	
                             ;    p=2*dy-dx;					; p (word)
e12c : 38               [ 2] 	sec
e12d : a58f             [ 3] 	lda grl_2dy
e12f : e58a             [ 3] 	sbc grl_dx
e131 : 8595             [ 3] 	sta grl_p
e133 : a590             [ 3] 	lda grl_2dy+1
e135 : e900             [ 2] 	sbc #0
e137 : 8596             [ 3] 	sta grl_p+1
                             	
                             ;   2*(dy-dx)					; num_tmp+2 = 2*(dy-dx)
e139 : 38               [ 2] 	sec
e13a : a58f             [ 3] 	lda grl_2dy
e13c : e58d             [ 3] 	sbc grl_2dx
e13e : 8591             [ 3] 	sta grl_2dxy
e140 : a590             [ 3] 	lda grl_2dy+1
e142 : e58e             [ 3] 	sbc grl_2dx+1
e144 : 8592             [ 3] 	sta grl_2dxy+1
                             
e146 :                       gr_line_pixel
                             	; plot the current pixel position
e146 : a685             [ 3] 	ldx grl_x0
e148 : a486             [ 3] 	ldy grl_y0
e14a : a58c             [ 3] 	lda grl_xyyx				; is xy swapped?
e14c : f004             [ 3] 	beq gr_skip_xy_swap2
e14e : a686             [ 3] 	ldx grl_y0
e150 : a485             [ 3] 	ldy grl_x0	
e152 :                       gr_skip_xy_swap2
e152 : 20bbde           [ 6] 	jsr gr_point
                             	
e155 : a585             [ 3] 	lda grl_x0					; Check if done
e157 : c587             [ 3] 	cmp grl_x1
e159 : f030             [ 3] 	beq gr_line_done
                             
                             	; check sign of p
e15b : a596             [ 3] 	lda grl_p+1
e15d : 3016             [ 3] 	bmi gr_line_neg_p
=======
ddcc : 38               [ 2] 	sec
ddcd : a587             [ 3] 	lda grl_x1
ddcf : e585             [ 3] 	sbc grl_x0
ddd1 : b003             [ 3] 	bcs gr_line_skip_dx_neg
ddd3 : 49ff             [ 2] 	eor #0xff
ddd5 : 1a               [ 2] 	inc a
ddd6 :                       gr_line_skip_dx_neg
ddd6 : 858a             [ 3] 	sta grl_dx
ddd8 : 38               [ 2] 	sec
ddd9 : a588             [ 3] 	lda grl_y1
dddb : e586             [ 3] 	sbc grl_y0
dddd : b003             [ 3] 	bcs gr_line_skip_dy_neg
dddf : 49ff             [ 2] 	eor #0xff
dde1 : 1a               [ 2] 	inc a
dde2 :                       gr_line_skip_dy_neg
dde2 : 858b             [ 3] 	sta grl_dy
dde4 : c58a             [ 3] 	cmp grl_dx
dde6 : 901a             [ 4] 	bcc gr_line_skip_xy_swap
                             	; swap xy axes and also dx and dy
dde8 : a585             [ 3] 	lda grl_x0					; swap x0 and y0
ddea : a686             [ 3] 	ldx grl_y0
ddec : 8586             [ 3] 	sta grl_y0
ddee : 8685             [ 3] 	stx grl_x0
ddf0 : a587             [ 3] 	lda grl_x1					; swap x1 and y1
ddf2 : a688             [ 3] 	ldx grl_y1
ddf4 : 8588             [ 3] 	sta grl_y1
ddf6 : 8687             [ 3] 	stx grl_x1
ddf8 : a58a             [ 3] 	lda grl_dx					; swap dy and dx
ddfa : a68b             [ 3] 	ldx grl_dy
ddfc : 858b             [ 3] 	sta grl_dy
ddfe : 868a             [ 3] 	stx grl_dx
de00 : e68c             [ 5] 	inc grl_xyyx				; set flag to Not Z to know abou
                             	
de02 :                       gr_line_skip_xy_swap	
AS65 Assembler for R6502 [1.42].                                     Page  122
-------------------------------- bank\bank0.s --------------------------------

                             	; assume going from left to right
de02 : a901             [ 2] 	lda #1
de04 : 8593             [ 3] 	sta grl_inx
de06 : a585             [ 3] 	lda grl_x0
de08 : c587             [ 3] 	cmp grl_x1
de0a : 9004             [ 3] 	bcc gr_line_skip_x_swap
de0c : a9ff             [ 2] 	lda #0xff					; make x increment negative
de0e : 8593             [ 3] 	sta grl_inx
                             	
de10 :                       gr_line_skip_x_swap
                             	; assume going from top to bottom
de10 : a901             [ 2] 	lda #1
de12 : 8594             [ 3] 	sta grl_iny
de14 : a586             [ 3] 	lda grl_y0
de16 : c588             [ 3] 	cmp grl_y1
de18 : 9004             [ 3] 	bcc gr_line_skip_y_up
de1a : a9ff             [ 2] 	lda #0xff					; make y increment negative
de1c : 8594             [ 3] 	sta grl_iny
                             
de1e :                       gr_line_skip_y_up
de1e : a58a             [ 3] 	lda grl_dx
de20 : 0a               [ 2] 	asl a
de21 : 858d             [ 3] 	sta grl_2dx					; 2*dx (word)
de23 : 648e             [ 3] 	stz grl_2dx+1
de25 : 268e             [ 5] 	rol grl_2dx+1
                             
de27 : a58b             [ 3] 	lda grl_dy
de29 : 0a               [ 2] 	asl a
de2a : 858f             [ 3] 	sta grl_2dy					; 2*dy (word)
de2c : 6490             [ 3] 	stz grl_2dy+1
de2e : 2690             [ 5] 	rol grl_2dy+1
                             	
                             ;    p=2*dy-dx;					; p (word)
de30 : 38               [ 2] 	sec
de31 : a58f             [ 3] 	lda grl_2dy
de33 : e58a             [ 3] 	sbc grl_dx
de35 : 8595             [ 3] 	sta grl_p
de37 : a590             [ 3] 	lda grl_2dy+1
de39 : e900             [ 2] 	sbc #0
de3b : 8596             [ 3] 	sta grl_p+1
                             	
                             ;   2*(dy-dx)					; num_tmp+2 = 2*(dy-dx)
de3d : 38               [ 2] 	sec
de3e : a58f             [ 3] 	lda grl_2dy
de40 : e58d             [ 3] 	sbc grl_2dx
de42 : 8591             [ 3] 	sta grl_2dxy
de44 : a590             [ 3] 	lda grl_2dy+1
de46 : e58e             [ 3] 	sbc grl_2dx+1
de48 : 8592             [ 3] 	sta grl_2dxy+1
                             
de4a :                       gr_line_pixel
                             	; plot the current pixel position
de4a : a685             [ 3] 	ldx grl_x0
de4c : a486             [ 3] 	ldy grl_y0
de4e : a58c             [ 3] 	lda grl_xyyx				; is xy swapped?
de50 : f004             [ 3] 	beq gr_skip_xy_swap2
de52 : a686             [ 3] 	ldx grl_y0
de54 : a485             [ 3] 	ldy grl_x0	
de56 :                       gr_skip_xy_swap2
de56 : 20bbdb           [ 6] 	jsr gr_point
                             	
de59 : a585             [ 3] 	lda grl_x0					; Check if done
AS65 Assembler for R6502 [1.42].                                     Page  123
-------------------------------- bank\bank0.s --------------------------------

de5b : c587             [ 3] 	cmp grl_x1
de5d : f030             [ 3] 	beq gr_line_done
                             
                             	; check sign of p
de5f : a596             [ 3] 	lda grl_p+1
de61 : 3016             [ 3] 	bmi gr_line_neg_p
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             	; if p >=0
                             	
                             	; y=y+increment
<<<<<<< HEAD
e15f : 18               [ 2] 	clc
e160 : a586             [ 3] 	lda grl_y0
e162 : 6594             [ 3] 	adc grl_iny
e164 : 8586             [ 3] 	sta grl_y0
=======
de63 : 18               [ 2] 	clc
de64 : a586             [ 3] 	lda grl_y0
de66 : 6594             [ 3] 	adc grl_iny
de68 : 8586             [ 3] 	sta grl_y0
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             	; p=p+2*dy-2*dx
                             	_addZPWord grl_p,grl_2dxy
                             
<<<<<<< HEAD
AS65 Assembler for R6502 [1.42].                                     Page  130
-------------------------------- bank\bank0.s --------------------------------

e173 : 800d             [ 3] 	bra gr_line_incx
                             
e175 :                       gr_line_neg_p
=======
de77 : 800d             [ 3] 	bra gr_line_incx
                             
de79 :                       gr_line_neg_p
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             	; if p < 0
                             	; p=p+2*dy
                             	_addZPWord grl_p,grl_2dy
                             
                             	
<<<<<<< HEAD
e182 :                       gr_line_incx
e182 : 18               [ 2] 	clc
e183 : a585             [ 3] 	lda grl_x0
e185 : 6593             [ 3] 	adc grl_inx
e187 : 8585             [ 3] 	sta grl_x0
e189 : 80bb             [ 3] 	bra gr_line_pixel
e18b :                       gr_line_done
e18b : 60               [ 6] 	rts
=======
de86 :                       gr_line_incx
de86 : 18               [ 2] 	clc
de87 : a585             [ 3] 	lda grl_x0
de89 : 6593             [ 3] 	adc grl_inx
de8b : 8585             [ 3] 	sta grl_x0
de8d : 80bb             [ 3] 	bra gr_line_pixel
de8f :                       gr_line_done
de8f : 60               [ 6] 	rts
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             	
                             
                             ;    while(x<x1)
                             ;    {
                             ;        if(p>=0)
                             ;        {
                             ;            putpixel(x,y,7);
                             ;            y=y+1;
                             ;            p=p+2*dy-2*dx;
                             ;        }
                             ;        else
                             ;        {
                             ;            putpixel(x,y,7);
                             ;            p=p+2*dy;
                             ;        }
                             ;        x=x+1;
                             ;    }
                             
                             
                             ;****************************************
                             ;* gr_scroll_up
                             ;* Scroll screen one line up
                             ;****************************************
<<<<<<< HEAD
e18c :                       gr_scroll_up
e18c : e612             [ 5] 	inc vdp_curoff
                             	
                             	; Get VDP Address of line + 1 line (source addr)
e18e : 18               [ 2] 	clc
e18f : a523             [ 3] 	lda gr_scrngeom+gr_screen_start
e191 : 6527             [ 3] 	adc gr_scrngeom+gr_screen_w
e193 : 853f             [ 3] 	sta tmp_v1
e195 : a524             [ 3] 	lda gr_scrngeom+gr_screen_start+1
e197 : 6900             [ 2] 	adc #0
e199 : 8540             [ 3] 	sta tmp_v1+1
                             	
                             	; Get destinaton address = first line of screen
e19b : a523             [ 3] 	lda gr_scrngeom+gr_screen_start
e19d : 8543             [ 3] 	sta tmp_b
e19f : a524             [ 3] 	lda gr_scrngeom+gr_screen_start+1
e1a1 : 8544             [ 3] 	sta tmp_b+1
                             	
e1a3 : a428             [ 3] 	ldy gr_scrngeom+gr_screen_h
e1a5 : 88               [ 2] 	dey
                             	
e1a6 : 78               [ 2] 	sei						; Stop IRQ as it messes with VDP
                             	; Only use vdp primitives inside sei,cli
AS65 Assembler for R6502 [1.42].                                     Page  131
-------------------------------- bank\bank0.s --------------------------------

                             
                             	; Restore what was underneath cursor
e1a7 : a62c             [ 3] 	ldx gr_scrngeom+gr_cur_ptr
e1a9 : a52d             [ 3] 	lda gr_scrngeom+gr_cur_ptr+1
e1ab : 20fdc5           [ 6] 	jsr vdp_wr_addr
e1ae : a514             [ 3] 	lda vdp_curval
e1b0 : 2023c6           [ 6] 	jsr vdp_wr_vram
                             
e1b3 :                       gr_scroll_cpy_ln
                             	; Set VDP with source address to read
e1b3 : a63f             [ 3] 	ldx tmp_v1
e1b5 : a540             [ 3] 	lda tmp_v1+1
e1b7 : 2014c6           [ 6] 	jsr vdp_rd_addr
                             
                             	; Read in a line worth of screen
e1ba : a627             [ 3] 	ldx gr_scrngeom+gr_screen_w
e1bc :                       gr_scroll_read_ln
e1bc : 201ec6           [ 6] 	jsr vdp_rd_vram
e1bf : 9d8009           [ 5] 	sta scratch+128,x			; +128 to avoid string corru
e1c2 : ca               [ 2] 	dex
e1c3 : d0f7             [ 3] 	bne gr_scroll_read_ln
                             
                             	; Set VDP with destinaton to write
e1c5 : a643             [ 3] 	ldx tmp_b
e1c7 : a544             [ 3] 	lda tmp_b+1
e1c9 : 20fdc5           [ 6] 	jsr vdp_wr_addr
                             	
                             	; Write out a line worth of screen
e1cc : a627             [ 3] 	ldx gr_scrngeom+gr_screen_w
e1ce :                       gr_scroll_write_ln
e1ce : bd8009           [ 4] 	lda scratch+128,x
e1d1 : 2023c6           [ 6] 	jsr vdp_wr_vram
e1d4 : ca               [ 2] 	dex
e1d5 : d0f7             [ 3] 	bne gr_scroll_write_ln
                             
                             	; Update source address
e1d7 : 18               [ 2] 	clc
e1d8 : a53f             [ 3] 	lda tmp_v1
e1da : 6527             [ 3] 	adc gr_scrngeom+gr_screen_w
e1dc : 853f             [ 3] 	sta tmp_v1
e1de : a540             [ 3] 	lda tmp_v1+1
e1e0 : 6900             [ 2] 	adc #0
e1e2 : 8540             [ 3] 	sta tmp_v1+1
                             	; Update destinaton address
e1e4 : 18               [ 2] 	clc
e1e5 : a543             [ 3] 	lda tmp_b
e1e7 : 6527             [ 3] 	adc gr_scrngeom+gr_screen_w
e1e9 : 8543             [ 3] 	sta tmp_b
e1eb : a544             [ 3] 	lda tmp_b+1
e1ed : 6900             [ 2] 	adc #0
e1ef : 8544             [ 3] 	sta tmp_b+1
                             
                             	; One line complete
e1f1 : 88               [ 2] 	dey
e1f2 : d0bf             [ 3] 	bne gr_scroll_cpy_ln
                             	
                             	; VDP is pointing at last line
                             	; Needs to be filled with blank
e1f4 : a515             [ 3] 	lda vdp_blank
e1f6 : 8514             [ 3] 	sta vdp_curval			; Also this is the cursor value
e1f8 : a627             [ 3] 	ldx gr_scrngeom+gr_screen_w
e1fa :                       gr_scroll_erase_ln
AS65 Assembler for R6502 [1.42].                                     Page  132
-------------------------------- bank\bank0.s --------------------------------

e1fa : 2023c6           [ 6] 	jsr vdp_wr_vram
e1fd : ca               [ 2] 	dex
e1fe : d0fa             [ 3] 	bne gr_scroll_erase_ln
                             
e200 : 58               [ 2] 	cli			; Enable IRQ
                             
e201 : c612             [ 5] 	dec vdp_curoff
                             
e203 : 60               [ 6] 	rts
=======
de90 :                       gr_scroll_up
de90 : e612             [ 5] 	inc vdp_curoff
                             	
                             	; Get VDP Address of line + 1 line (source addr)
de92 : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  124
-------------------------------- bank\bank0.s --------------------------------

de93 : a523             [ 3] 	lda gr_scrngeom+gr_screen_start
de95 : 6527             [ 3] 	adc gr_scrngeom+gr_screen_w
de97 : 853f             [ 3] 	sta tmp_v1
de99 : a524             [ 3] 	lda gr_scrngeom+gr_screen_start+1
de9b : 6900             [ 2] 	adc #0
de9d : 8540             [ 3] 	sta tmp_v1+1
                             	
                             	; Get destinaton address = first line of screen
de9f : a523             [ 3] 	lda gr_scrngeom+gr_screen_start
dea1 : 8543             [ 3] 	sta tmp_b
dea3 : a524             [ 3] 	lda gr_scrngeom+gr_screen_start+1
dea5 : 8544             [ 3] 	sta tmp_b+1
                             	
dea7 : a428             [ 3] 	ldy gr_scrngeom+gr_screen_h
dea9 : 88               [ 2] 	dey
                             	
deaa : 78               [ 2] 	sei						; Stop IRQ as it messes with VDP
                             	; Only use vdp primitives inside sei,cli
                             
                             	; Restore what was underneath cursor
deab : a62c             [ 3] 	ldx gr_scrngeom+gr_cur_ptr
dead : a52d             [ 3] 	lda gr_scrngeom+gr_cur_ptr+1
deaf : 20e5c5           [ 6] 	jsr vdp_wr_addr
deb2 : a514             [ 3] 	lda vdp_curval
deb4 : 200bc6           [ 6] 	jsr vdp_wr_vram
                             
deb7 :                       gr_scroll_cpy_ln
                             	; Set VDP with source address to read
deb7 : a63f             [ 3] 	ldx tmp_v1
deb9 : a540             [ 3] 	lda tmp_v1+1
debb : 20fcc5           [ 6] 	jsr vdp_rd_addr
                             
                             	; Read in a line worth of screen
debe : a627             [ 3] 	ldx gr_scrngeom+gr_screen_w
dec0 :                       gr_scroll_read_ln
dec0 : 2006c6           [ 6] 	jsr vdp_rd_vram
dec3 : 9d8009           [ 5] 	sta scratch+128,x			; +128 to avoid string corru
dec6 : ca               [ 2] 	dex
dec7 : d0f7             [ 3] 	bne gr_scroll_read_ln
                             
                             	; Set VDP with destinaton to write
dec9 : a643             [ 3] 	ldx tmp_b
decb : a544             [ 3] 	lda tmp_b+1
decd : 20e5c5           [ 6] 	jsr vdp_wr_addr
                             	
                             	; Write out a line worth of screen
ded0 : a627             [ 3] 	ldx gr_scrngeom+gr_screen_w
ded2 :                       gr_scroll_write_ln
ded2 : bd8009           [ 4] 	lda scratch+128,x
ded5 : 200bc6           [ 6] 	jsr vdp_wr_vram
ded8 : ca               [ 2] 	dex
ded9 : d0f7             [ 3] 	bne gr_scroll_write_ln
                             
                             	; Update source address
dedb : 18               [ 2] 	clc
dedc : a53f             [ 3] 	lda tmp_v1
dede : 6527             [ 3] 	adc gr_scrngeom+gr_screen_w
dee0 : 853f             [ 3] 	sta tmp_v1
dee2 : a540             [ 3] 	lda tmp_v1+1
dee4 : 6900             [ 2] 	adc #0
dee6 : 8540             [ 3] 	sta tmp_v1+1
                             	; Update destinaton address
AS65 Assembler for R6502 [1.42].                                     Page  125
-------------------------------- bank\bank0.s --------------------------------

dee8 : 18               [ 2] 	clc
dee9 : a543             [ 3] 	lda tmp_b
deeb : 6527             [ 3] 	adc gr_scrngeom+gr_screen_w
deed : 8543             [ 3] 	sta tmp_b
deef : a544             [ 3] 	lda tmp_b+1
def1 : 6900             [ 2] 	adc #0
def3 : 8544             [ 3] 	sta tmp_b+1
                             
                             	; One line complete
def5 : 88               [ 2] 	dey
def6 : d0bf             [ 3] 	bne gr_scroll_cpy_ln
                             	
                             	; VDP is pointing at last line
                             	; Needs to be filled with blank
def8 : a515             [ 3] 	lda vdp_blank
defa : 8514             [ 3] 	sta vdp_curval			; Also this is the cursor value
defc : a627             [ 3] 	ldx gr_scrngeom+gr_screen_w
defe :                       gr_scroll_erase_ln
defe : 200bc6           [ 6] 	jsr vdp_wr_vram
df01 : ca               [ 2] 	dex
df02 : d0fa             [ 4] 	bne gr_scroll_erase_ln
                             
df04 : 58               [ 2] 	cli			; Enable IRQ
                             
df05 : c612             [ 5] 	dec vdp_curoff
                             
df07 : 60               [ 6] 	rts
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             ;****************************************
                             ;* gr_cur_right
                             ;* Advance cursor position
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
<<<<<<< HEAD
e204 :                       gr_cur_right
                             	_pushAXY
                             
                             	; Load cursor x,y position
e207 : a62a             [ 3] 	ldx gr_scrngeom+gr_cur_x
e209 : a42b             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             
                             	; Move cursor right
e20b : e8               [ 2] 	inx
                             	; Check if reached past edge of line
e20c : e427             [ 3] 	cpx gr_scrngeom+gr_screen_w
e20e : d00f             [ 3] 	bne gr_adv_skip_nl
                             	; If got here then wrap to next line
e210 : a200             [ 2] 	ldx #0
e212 : c8               [ 2] 	iny
e213 : c428             [ 3] 	cpy gr_scrngeom+gr_screen_h
e215 : d008             [ 3] 	bne gr_adv_skip_nl
                             	; If got here then screen needs to scroll
e217 : 88               [ 2] 	dey					; First put y back in bound
e218 : da               [ 3] 	phx
e219 : 5a               [ 3] 	phy
e21a : 208ce1           [ 6] 	jsr gr_scroll_up
e21d : 7a               [ 4] 	ply
e21e : fa               [ 4] 	plx
e21f :                       gr_adv_skip_nl
e21f : 20fadd           [ 6] 	jsr gr_set_cur
                             	_pullAXY
                             
e225 : 60               [ 6] 	rts
=======
df08 :                       gr_cur_right
                             	_pushAXY
                             
                             	; Load cursor x,y position
df0b : a62a             [ 3] 	ldx gr_scrngeom+gr_cur_x
df0d : a42b             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             
                             	; Move cursor right
df0f : e8               [ 2] 	inx
                             	; Check if reached past edge of line
df10 : e427             [ 3] 	cpx gr_scrngeom+gr_screen_w
df12 : d00f             [ 3] 	bne gr_adv_skip_nl
                             	; If got here then wrap to next line
df14 : a200             [ 2] 	ldx #0
df16 : c8               [ 2] 	iny
df17 : c428             [ 3] 	cpy gr_scrngeom+gr_screen_h
df19 : d008             [ 3] 	bne gr_adv_skip_nl
                             	; If got here then screen needs to scroll
df1b : 88               [ 2] 	dey					; First put y back in bound
df1c : da               [ 3] 	phx
df1d : 5a               [ 3] 	phy
df1e : 2090de           [ 6] 	jsr gr_scroll_up
df21 : 7a               [ 4] 	ply
df22 : fa               [ 4] 	plx
df23 :                       gr_adv_skip_nl
df23 : 20fada           [ 6] 	jsr gr_set_cur
                             	_pullAXY
AS65 Assembler for R6502 [1.42].                                     Page  126
-------------------------------- bank\bank0.s --------------------------------

>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
df29 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_cur_left
                             ;* Advance cursor left
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
<<<<<<< HEAD
e226 :                       gr_cur_left
                             	_pushAXY
                             
                             	; Load cursor x,y position, load X last to check
e229 : a42b             [ 3] 	ldy gr_scrngeom+gr_cur_y
e22b : a62a             [ 3] 	ldx gr_scrngeom+gr_cur_x
=======
df2a :                       gr_cur_left
                             	_pushAXY
                             
                             	; Load cursor x,y position, load X last to check
df2d : a42b             [ 3] 	ldy gr_scrngeom+gr_cur_y
df2f : a62a             [ 3] 	ldx gr_scrngeom+gr_cur_x
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             	
                             	; Decrement screen pointer
AS65 Assembler for R6502 [1.42].                                     Page  133
-------------------------------- bank\bank0.s --------------------------------

                             	; Move cursor left
<<<<<<< HEAD
e22d : d007             [ 3] 	bne gr_cur_skip_at_left		; If already at the lef
e22f : c000             [ 2] 	cpy #0						; If already at the top left
e231 : f007             [ 3] 	beq gr_cur_skip_at_tl
e233 : 88               [ 2] 	dey
e234 : a627             [ 3] 	ldx gr_scrngeom+gr_screen_w
e236 :                       gr_cur_skip_at_left
e236 : ca               [ 2] 	dex
e237 : 20fadd           [ 6] 	jsr gr_set_cur
                             
e23a :                       gr_cur_skip_at_tl	
                             	_pullAXY
                             
e23d : 60               [ 6] 	rts
=======
df31 : d007             [ 3] 	bne gr_cur_skip_at_left		; If already at the lef
df33 : c000             [ 2] 	cpy #0						; If already at the top left
df35 : f007             [ 3] 	beq gr_cur_skip_at_tl
df37 : 88               [ 2] 	dey
df38 : a627             [ 3] 	ldx gr_scrngeom+gr_screen_w
df3a :                       gr_cur_skip_at_left
df3a : ca               [ 2] 	dex
df3b : 20fada           [ 6] 	jsr gr_set_cur
                             
df3e :                       gr_cur_skip_at_tl	
                             	_pullAXY
                             
df41 : 60               [ 6] 	rts
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             ;****************************************
                             ;* gr_cur_up
                             ;* Advance cursor up
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
<<<<<<< HEAD
e23e :                       gr_cur_up
                             	_pushAXY
                             
                             	; Load cursor x,y position, load Y last to check
e241 : a62a             [ 3] 	ldx gr_scrngeom+gr_cur_x
e243 : a42b             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             	
e245 : f004             [ 3] 	beq gr_cur_skip_at_top	; If already at the top, 
e247 : 88               [ 2] 	dey
e248 : 20fadd           [ 6] 	jsr gr_set_cur
                             	
e24b :                       gr_cur_skip_at_top	
                             	_pullAXY
                             
e24e : 60               [ 6] 	rts
=======
df42 :                       gr_cur_up
                             	_pushAXY
                             
                             	; Load cursor x,y position, load Y last to check
df45 : a62a             [ 3] 	ldx gr_scrngeom+gr_cur_x
df47 : a42b             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             	
df49 : f004             [ 3] 	beq gr_cur_skip_at_top	; If already at the top, 
df4b : 88               [ 2] 	dey
df4c : 20fada           [ 6] 	jsr gr_set_cur
                             	
df4f :                       gr_cur_skip_at_top	
                             	_pullAXY
                             
df52 : 60               [ 6] 	rts
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             ;****************************************
                             ;* gr_cur_down
                             ;* Advance cursor down
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
<<<<<<< HEAD
                             ;****************************************
e24f :                       gr_cur_down
                             	_pushAXY
                             
                             	; Load cursor x,y position
e252 : a62a             [ 3] 	ldx gr_scrngeom+gr_cur_x
e254 : a42b             [ 3] 	ldy gr_scrngeom+gr_cur_y
e256 : c8               [ 2] 	iny
e257 : c428             [ 3] 	cpy gr_scrngeom+gr_screen_h			; If already at  b
e259 : f003             [ 3] 	beq gr_cur_skip_at_bot				; then don't do anythi
                             	
e25b : 20fadd           [ 6] 	jsr gr_set_cur
                             
e25e :                       gr_cur_skip_at_bot
                             	_pullAXY
                             
e261 : 60               [ 6] 	rts
=======
AS65 Assembler for R6502 [1.42].                                     Page  127
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
df53 :                       gr_cur_down
                             	_pushAXY
                             
                             	; Load cursor x,y position
df56 : a62a             [ 3] 	ldx gr_scrngeom+gr_cur_x
df58 : a42b             [ 3] 	ldy gr_scrngeom+gr_cur_y
df5a : c8               [ 2] 	iny
df5b : c428             [ 3] 	cpy gr_scrngeom+gr_screen_h			; If already at  b
df5d : f003             [ 3] 	beq gr_cur_skip_at_bot				; then don't do anythi
                             	
df5f : 20fada           [ 6] 	jsr gr_set_cur
                             
df62 :                       gr_cur_skip_at_bot
                             	_pullAXY
                             
df65 : 60               [ 6] 	rts
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
AS65 Assembler for R6502 [1.42].                                     Page  134
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;****************************************
                             ;* gr_new_ln
                             ;* Carry out a new line
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
<<<<<<< HEAD
e262 :                       gr_new_ln
                             	_pushAXY
                             
                             	; X pos is zero, Y needs to increment
e265 : a200             [ 2] 	ldx #0
e267 : a42b             [ 3] 	ldy gr_scrngeom+gr_cur_y
e269 : c8               [ 2] 	iny
e26a : c428             [ 3] 	cpy gr_scrngeom+gr_screen_h
e26c : d008             [ 3] 	bne gr_nl_skip_nl
                             	; If got here then screen needs to scroll
e26e : 88               [ 2] 	dey
e26f : da               [ 3] 	phx
e270 : 5a               [ 3] 	phy
e271 : 208ce1           [ 6] 	jsr gr_scroll_up
e274 : 7a               [ 4] 	ply
e275 : fa               [ 4] 	plx
e276 :                       gr_nl_skip_nl
e276 : 20fadd           [ 6] 	jsr gr_set_cur
                             	_pullAXY
                             
e27c : 60               [ 6] 	rts
=======
df66 :                       gr_new_ln
                             	_pushAXY
                             
                             	; X pos is zero, Y needs to increment
df69 : a200             [ 2] 	ldx #0
df6b : a42b             [ 3] 	ldy gr_scrngeom+gr_cur_y
df6d : c8               [ 2] 	iny
df6e : c428             [ 3] 	cpy gr_scrngeom+gr_screen_h
df70 : d008             [ 3] 	bne gr_nl_skip_nl
                             	; If got here then screen needs to scroll
df72 : 88               [ 2] 	dey
df73 : da               [ 3] 	phx
df74 : 5a               [ 3] 	phy
df75 : 2090de           [ 6] 	jsr gr_scroll_up
df78 : 7a               [ 4] 	ply
df79 : fa               [ 4] 	plx
df7a :                       gr_nl_skip_nl
df7a : 20fada           [ 6] 	jsr gr_set_cur
                             	_pullAXY
                             
df80 : 60               [ 6] 	rts
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             	
                             ;****************************************
                             ;* gr_del
                             ;* Action del
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
<<<<<<< HEAD
e27d :                       gr_del
                             	_pushAXY
                             
e280 : 2026e2           [ 6] 	jsr gr_cur_left
e283 : a920             [ 2] 	lda #' '							; Put a space
e285 : 20e0dd           [ 6] 	jsr gr_put
                             	_pullAXY
                             
e28b : 60               [ 6] 	rts
=======
df81 :                       gr_del
                             	_pushAXY
                             
df84 : 202adf           [ 6] 	jsr gr_cur_left
df87 : a920             [ 2] 	lda #' '							; Put a space
df89 : 20e0da           [ 6] 	jsr gr_put
                             	_pullAXY
AS65 Assembler for R6502 [1.42].                                     Page  128
-------------------------------- bank\bank0.s --------------------------------

>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
df8f : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_get_key
                             ;* Waits for a key press, C=1 synchronous
                             ;* A = Key code
                             ;****************************************
<<<<<<< HEAD
e28c :                       gr_get_key
e28c : 2005d3           [ 6] 	jsr kb_get_key
e28f : b007             [ 3] 	bcs gr_key_no_key
e291 : c906             [ 2] 	cmp #UTF_ACK						; Copy key pressed?
e293 : d002             [ 3] 	bne gr_not_copy
e295 : a514             [ 3] 	lda vdp_curval						; If yes the get char under 
e297 :                       gr_not_copy
e297 : 18               [ 2] 	clc
e298 :                       gr_key_no_key
AS65 Assembler for R6502 [1.42].                                     Page  135
-------------------------------- bank\bank0.s --------------------------------

e298 : 60               [ 6] 	rts	
=======
df90 :                       gr_get_key
df90 : 2000d0           [ 6] 	jsr kb_get_key
df93 : b007             [ 3] 	bcs gr_key_no_key
df95 : c906             [ 2] 	cmp #UTF_ACK						; Copy key pressed?
df97 : d002             [ 3] 	bne gr_not_copy
df99 : a514             [ 3] 	lda vdp_curval						; If yes the get char under 
df9b :                       gr_not_copy
df9b : 18               [ 2] 	clc
df9c :                       gr_key_no_key
df9c : 60               [ 6] 	rts	
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             	
                             ;****************************************
                             ;* gr_put_byte
                             ;* Put a byte out
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
<<<<<<< HEAD
e299 :                       gr_put_byte
e299 : c97f             [ 2] 	cmp #UTF_DEL			; Del key
e29b : f004             [ 3] 	beq gr_process_special
e29d : c920             [ 2] 	cmp #32					; Special char?
e29f : b032             [ 3] 	bcs gr_pb_notspecial	; >=32 == carry clear
                             
e2a1 :                       gr_process_special
e2a1 : c90d             [ 2] 	cmp #UTF_CR				; New line?
e2a3 : d003             [ 3] 	bne gr_skip_new_ln
e2a5 : 4c62e2           [ 3] 	jmp gr_new_ln
e2a8 :                       gr_skip_new_ln
e2a8 : c97f             [ 2] 	cmp #UTF_DEL			; Delete?
e2aa : d003             [ 3] 	bne gr_skip_del
e2ac : 4c7de2           [ 3] 	jmp gr_del
e2af :                       gr_skip_del
e2af : c908             [ 2] 	cmp #CRSR_LEFT
e2b1 : d003             [ 3] 	bne gr_skip_left
e2b3 : 4c26e2           [ 3] 	jmp gr_cur_left
e2b6 :                       gr_skip_left
e2b6 : c909             [ 2] 	cmp #CRSR_RIGHT
e2b8 : d003             [ 3] 	bne gr_skip_right
e2ba : 4c04e2           [ 3] 	jmp gr_cur_right
e2bd :                       gr_skip_right
e2bd : c90b             [ 2] 	cmp #CRSR_UP
e2bf : d003             [ 3] 	bne gr_skip_up
e2c1 : 4c3ee2           [ 3] 	jmp gr_cur_up
e2c4 :                       gr_skip_up
e2c4 : c90a             [ 2] 	cmp #CRSR_DOWN
e2c6 : d003             [ 3] 	bne gr_skip_down
e2c8 : 4c4fe2           [ 3] 	jmp gr_cur_down
e2cb :                       gr_skip_down
e2cb : c90c             [ 2] 	cmp #UTF_FF
e2cd : d003             [ 3] 	bne gr_skip_cls
e2cf : 4c6cdd           [ 3] 	jmp gr_cls
e2d2 :                       gr_skip_cls
e2d2 : 60               [ 6] 	rts
                             
                             ;	Normal caracter processing here.
e2d3 :                       gr_pb_notspecial
=======
df9d :                       gr_put_byte
df9d : c97f             [ 2] 	cmp #UTF_DEL			; Del key
df9f : f004             [ 3] 	beq gr_process_special
dfa1 : c920             [ 2] 	cmp #32					; Special char?
dfa3 : b032             [ 3] 	bcs gr_pb_notspecial	; >=32 == carry clear
                             
dfa5 :                       gr_process_special
dfa5 : c90d             [ 2] 	cmp #UTF_CR				; New line?
dfa7 : d003             [ 3] 	bne gr_skip_new_ln
dfa9 : 4c66df           [ 3] 	jmp gr_new_ln
dfac :                       gr_skip_new_ln
dfac : c97f             [ 2] 	cmp #UTF_DEL			; Delete?
dfae : d003             [ 3] 	bne gr_skip_del
dfb0 : 4c81df           [ 3] 	jmp gr_del
dfb3 :                       gr_skip_del
dfb3 : c908             [ 2] 	cmp #CRSR_LEFT
dfb5 : d003             [ 3] 	bne gr_skip_left
dfb7 : 4c2adf           [ 3] 	jmp gr_cur_left
dfba :                       gr_skip_left
dfba : c909             [ 2] 	cmp #CRSR_RIGHT
dfbc : d003             [ 3] 	bne gr_skip_right
dfbe : 4c08df           [ 3] 	jmp gr_cur_right
dfc1 :                       gr_skip_right
dfc1 : c90b             [ 2] 	cmp #CRSR_UP
dfc3 : d003             [ 3] 	bne gr_skip_up
dfc5 : 4c42df           [ 3] 	jmp gr_cur_up
dfc8 :                       gr_skip_up
dfc8 : c90a             [ 2] 	cmp #CRSR_DOWN
dfca : d003             [ 3] 	bne gr_skip_down
dfcc : 4c53df           [ 3] 	jmp gr_cur_down
dfcf :                       gr_skip_down
dfcf : c90c             [ 2] 	cmp #UTF_FF
dfd1 : d003             [ 3] 	bne gr_skip_cls
dfd3 : 4c6cda           [ 3] 	jmp gr_cls
dfd6 :                       gr_skip_cls
AS65 Assembler for R6502 [1.42].                                     Page  129
-------------------------------- bank\bank0.s --------------------------------

dfd6 : 60               [ 6] 	rts
                             
                             ;	Normal caracter processing here.
dfd7 :                       gr_pb_notspecial
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             	_pushAXY
                             
                             	
                             	; Place in current position and move right
<<<<<<< HEAD
e2d6 : 20e0dd           [ 6] 	jsr gr_put
e2d9 : 2004e2           [ 6] 	jsr gr_cur_right
=======
dfda : 20e0da           [ 6] 	jsr gr_put
dfdd : 2008df           [ 6] 	jsr gr_cur_right
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             	_pullAXY
                             
                             	
<<<<<<< HEAD
e2df : 60               [ 6] 	rts
=======
dfe3 : 60               [ 6] 	rts
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
                             ;* These tables are to speed up calculating the 
                             ;* offset for plot commands, rather than using
AS65 Assembler for R6502 [1.42].                                     Page  136
-------------------------------- bank\bank0.s --------------------------------

                             ;* a series of left shifts and additions.
                             ;* Not sure if it is worth the 96 bytes :-O
<<<<<<< HEAD
e2e0 :                       gr_offset_40lo
e2e0 : 00285078              	db lo(0*40), lo(1*40), lo(2*40), lo(3*40)
e2e4 : a0c8f018              	db lo(4*40), lo(5*40), lo(6*40), lo(7*40)
e2e8 : 406890b8              	db lo(8*40), lo(9*40), lo(10*40), lo(11*40)
e2ec : e0083058              	db lo(12*40), lo(13*40), lo(14*40), lo(15*40)
e2f0 : 80a8d0f8              	db lo(16*40), lo(17*40), lo(18*40), lo(19*40)
e2f4 : 20487098              	db lo(20*40), lo(21*40), lo(22*40), lo(23*40)
e2f8 :                       gr_offset_40hi
e2f8 : 00000000              	db hi(0*40), hi(1*40), hi(2*40), hi(3*40)
e2fc : 00000001              	db hi(4*40), hi(5*40), hi(6*40), hi(7*40)
e300 : 01010101              	db hi(8*40), hi(9*40), hi(10*40), hi(11*40)
e304 : 01020202              	db hi(12*40), hi(13*40), hi(14*40), hi(15*40)
e308 : 02020202              	db hi(16*40), hi(17*40), hi(18*40), hi(19*40)
e30c : 03030303              	db hi(20*40), hi(21*40), hi(22*40), hi(23*40)
e310 :                       gr_offset_32lo
e310 : 00204060              	db lo(0*32), lo(1*32), lo(2*32), lo(3*32)
e314 : 80a0c0e0              	db lo(4*32), lo(5*32), lo(6*32), lo(7*32)
e318 : 00204060              	db lo(8*32), lo(9*32), lo(10*32), lo(11*32)
e31c : 80a0c0e0              	db lo(12*32), lo(13*32), lo(14*32), lo(15*32)
e320 : 00204060              	db lo(16*32), lo(17*32), lo(18*32), lo(19*32)
e324 : 80a0c0e0              	db lo(20*32), lo(21*32), lo(22*32), lo(23*32)
e328 :                       gr_offset_32hi
e328 : 00000000              	db hi(0*32), hi(1*32), hi(2*32), hi(3*32)
e32c : 00000000              	db hi(4*32), hi(5*32), hi(6*32), hi(7*32)
e330 : 01010101              	db hi(8*32), hi(9*32), hi(10*32), hi(11*32)
e334 : 01010101              	db hi(12*32), hi(13*32), hi(14*32), hi(15*32)
e338 : 02020202              	db hi(16*32), hi(17*32), hi(18*32), hi(19*32)
e33c : 02020202              	db hi(20*32), hi(21*32), hi(22*32), hi(23*32)
                             	
e340 :                       mod_sz_graph_e
                             
                             
                             	; End of Code
e340 :                       _code_end
e340 :                       _bank0_end
=======
dfe4 :                       gr_offset_40lo
dfe4 : 00285078              	db lo(0*40), lo(1*40), lo(2*40), lo(3*40)
dfe8 : a0c8f018              	db lo(4*40), lo(5*40), lo(6*40), lo(7*40)
dfec : 406890b8              	db lo(8*40), lo(9*40), lo(10*40), lo(11*40)
dff0 : e0083058              	db lo(12*40), lo(13*40), lo(14*40), lo(15*40)
dff4 : 80a8d0f8              	db lo(16*40), lo(17*40), lo(18*40), lo(19*40)
dff8 : 20487098              	db lo(20*40), lo(21*40), lo(22*40), lo(23*40)
dffc :                       gr_offset_40hi
dffc : 00000000              	db hi(0*40), hi(1*40), hi(2*40), hi(3*40)
e000 : 00000001              	db hi(4*40), hi(5*40), hi(6*40), hi(7*40)
e004 : 01010101              	db hi(8*40), hi(9*40), hi(10*40), hi(11*40)
e008 : 01020202              	db hi(12*40), hi(13*40), hi(14*40), hi(15*40)
e00c : 02020202              	db hi(16*40), hi(17*40), hi(18*40), hi(19*40)
e010 : 03030303              	db hi(20*40), hi(21*40), hi(22*40), hi(23*40)
e014 :                       gr_offset_32lo
e014 : 00204060              	db lo(0*32), lo(1*32), lo(2*32), lo(3*32)
e018 : 80a0c0e0              	db lo(4*32), lo(5*32), lo(6*32), lo(7*32)
e01c : 00204060              	db lo(8*32), lo(9*32), lo(10*32), lo(11*32)
e020 : 80a0c0e0              	db lo(12*32), lo(13*32), lo(14*32), lo(15*32)
e024 : 00204060              	db lo(16*32), lo(17*32), lo(18*32), lo(19*32)
e028 : 80a0c0e0              	db lo(20*32), lo(21*32), lo(22*32), lo(23*32)
e02c :                       gr_offset_32hi
e02c : 00000000              	db hi(0*32), hi(1*32), hi(2*32), hi(3*32)
e030 : 00000000              	db hi(4*32), hi(5*32), hi(6*32), hi(7*32)
e034 : 01010101              	db hi(8*32), hi(9*32), hi(10*32), hi(11*32)
e038 : 01010101              	db hi(12*32), hi(13*32), hi(14*32), hi(15*32)
e03c : 02020202              	db hi(16*32), hi(17*32), hi(18*32), hi(19*32)
e040 : 02020202              	db hi(20*32), hi(21*32), hi(22*32), hi(23*32)
                             	
e044 :                       mod_sz_graph_e
                             
                             
                             	; End of Code
e044 :                       _code_end
e044 :                       _bank0_end
>>>>>>> 17e390f07d4b2c6af368e42796b6bdaed80a3e2e
                             
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
