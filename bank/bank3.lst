AS65 Assembler for R6502 [1.42].                                     Page    1
-------------------------------- bank\bank3.s --------------------------------

2995 lines read, no errors in pass 1.
c000 =                       _bank0_start=0xc000
                             	include "kernel\kernel.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  KERNEL.S
                             ;*	The 'kernel' routine includes code and data wh
                             ;* 	be in every ROM bank.  In the auto-generated 
                             ;*  files, the kernel is added before the bank sp
                             ;*	code.  See bank0.s as an example.
                             ;*
                             ;************************************************
                             
                             ;* Include all definition and code files in the r
                             	include "inc\includes.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  INCLUDES.S
                             ;*  Main include file for key definitions and mac
                             ;*  Many of the settings here are exremely machin
                             ;*  Defines : IO block addresses, VIA port usage,
                             ;*  settings, useful macros, sound chip registers
                             ;*  VDP registers, ACIA registers.
                             ;*
                             ;************************************************
                             
                             ;* The IO block is at 0x04000 and decodes up to
                             ;* eight IO addresses, at 0x0080 intervals
                             ;* All eight are not used at the present time:
                             ;* - 0 : VIA 1 (Keyboard)
                             ;* - 1 : VIA 2 (Sound and SD card interface)
                             ;* - 2 : VDP (Video)
                             ;* - 3 : ACIA (Serial)
                             ;* - 4 : RTC (DS12887 real time clock + RAM)
0400 =                       IO_0		= 0x0400
0480 =                       IO_1		= 0x0480
0500 =                       IO_2		= 0x0500
0580 =                       IO_3		= 0x0580
0600 =                       IO_4		= 0x0600
0680 =                       IO_5		= 0x0680
0700 =                       IO_6		= 0x0700
0780 =                       IO_7		= 0x0780
                             
                             ;* VDP is accessed through IO_2
0500 =                       VDP_MODE0		= IO_2
0501 =                       VDP_MODE1		= IO_2+1
0501 =                       VDP_STATUS		= IO_2+1
0501 =                       VDP_ADDR		= IO_2+1
0500 =                       VDP_VRAM		= IO_2
0001 =                       VDP_SHORTDELAY	= 1
AS65 Assembler for R6502 [1.42].                                     Page    2
-------------------------------- bank\bank3.s --------------------------------

0002 =                       VDP_LONGDELAY 	= 2
0010 =                       VDP_FLASH		= 0x10				;* Must be a power of 2 *
                             
                             ;* This structure defines the key information
                             ;* kept about the VDP current mode
0000 =                       	struct vdp_addr_struct
0000 =                       	dw vdp_addr_nme				;* Address of name table
0002 =                       	dw vdp_addr_col				;* Address of colour table
0004 =                       	dw vdp_addr_pat				;* Address of pattern table
0006 =                       	dw vdp_addr_spa				;* Address of sprite pattern 
0008 =                       	dw vdp_addr_spp				;* Address of sprite position
000a =                       	db vdp_bord_col				;* Value of border colour
000b =                       	db vdp_gmode				;* Graphics mode 0,1,2 or 0x80 (
                             	end struct
                             
                             ;* Standard definitions of 6522 registers
                             ;* As found in the datasheets
0000 =                       PRB			= 0x00
0001 =                       PRA			= 0x01
0002 =                       DDRB		= 0x02
0003 =                       DDRA		= 0x03
0004 =                       T1CL		= 0x04
0005 =                       T1CH		= 0x05
0006 =                       T1LL		= 0x06
0007 =                       T1LH		= 0x07
0008 =                       T2CL		= 0x08
0009 =                       T2CH		= 0x09
000a =                       SR			= 0x0a
000b =                       ACR			= 0x0b
000c =                       PCR			= 0x0c
000d =                       IFR			= 0x0d
000e =                       IER			= 0x0e
000f =                       PRAH		= 0x0f
                             
0001 =                       IFR_CA2		= 0x01
0002 =                       IFR_CA1		= 0x02
                             
                             ;* AY-3-8910 definitions
                             ;* The sound chip is accessed through VIA 2
0481 =                       SND_ADBUS	= IO_1+PRA
0480 =                       SND_MODE	= IO_1+PRB
                             
0040 =                       SND_SELREAD			= 0x40
0002 =                       SND_SELWRITE		= 0x02
0042 =                       SND_SELSETADDR		= (SND_SELREAD|SND_SELWRITE)
00bd =                       SND_DESELECT_MASK	= (0xff-SND_SELREAD-SND_SELWRIT
                             
0000 =                       SND_REG_CHAPL	= 0x00
0001 =                       SND_REG_CHAPH	= 0x01
0002 =                       SND_REG_CHBPL	= 0x02
0003 =                       SND_REG_CHBPH	= 0x03
0004 =                       SND_REG_CHCPL	= 0x04
0005 =                       SND_REG_CHCPH	= 0x05
0006 =                       SND_REG_CHNP	= 0x06
0007 =                       SND_REG_CTL		= 0x07
0008 =                       SND_REG_CHAVOL	= 0x08
0009 =                       SND_REG_CHBVOL	= 0x09
000a =                       SND_REG_CHBVOL	= 0x0a
000b =                       SND_REG_ENVPL	= 0x0b
000c =                       SND_REG_ENVPH	= 0x0c
000d =                       SND_REG_ENVCYC	= 0x0d
                             
AS65 Assembler for R6502 [1.42].                                     Page    3
-------------------------------- bank\bank3.s --------------------------------

000e =                       SND_REG_IOA	= 0x0e
000f =                       SND_REG_IOB	= 0x0f
                             
                             ;* 6551 ACIA definitions
                             ;* As found in the datasheets
0580 =                       SER_DATA	= (IO_3+0)
0581 =                       SER_STATUS	= (IO_3+1)
0581 =                       SER_RESET	= (IO_3+1)
0582 =                       SER_CMD		= (IO_3+2)
0583 =                       SER_CTL		= (IO_3+3)
                             
0080 =                       SER_IRQ		= 0x80
0040 =                       SER_DSRB	= 0x40
0020 =                       SER_DCDB	= 0x20
0010 =                       SER_TDRE	= 0x10
0008 =                       SER_RDRF	= 0x08
0004 =                       SER_OVRN	= 0x04
0002 =                       SER_FE		= 0x02
0001 =                       SER_PE		= 0x01
0080 =                       SER_SBN		= 0x80
0040 =                       SER_WL1		= 0x40
0020 =                       SER_WL0		= 0x20
0060 =                       SER_WL		= (SER_WL1|SER_WL0)
0010 =                       SER_RCS		= 0x10
0008 =                       SER_SBR3	= 0x08
0004 =                       SER_SBR2	= 0x04
0002 =                       SER_SBR1	= 0x02
0001 =                       SER_SBR0	= 0x01
000f =                       SER_SBR		= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0)
000f =                       SER_19200B	= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0
000e =                       SER_9600B	= (SER_SBR3|SER_SBR2|SER_SBR1)
0080 =                       SER_PMC1	= 0x80
0040 =                       SER_PMC0	= 0x40
00c0 =                       SER_PMC		= (SER_PMC1|SER_PMC0)
0020 =                       SER_PME		= 0x20
0010 =                       SER_REM		= 0x10
0008 =                       SER_TIC1	= 0x08
0004 =                       SER_TIC0	= 0x04
000c =                       SER_TIC		= (SER_TIC1|SER_TIC0)
0002 =                       SER_IRD		= 0x02
0001 =                       SER_DTR		= 0x01
                             
                             ;* BBC keyboard definitions
                             ;* The keyboard is accessed through VIA 1
                             ;* Port A - all output
0001 =                       KB_ROWA		= 0x01
0002 =                       KB_ROWB		= 0x02
0004 =                       KB_ROWC		= 0x04
0008 =                       KB_COLA		= 0x08
0010 =                       KB_COLB		= 0x10
0020 =                       KB_COLC		= 0x20
0040 =                       KB_COLD		= 0x40
0080 =                       KB_EN		= 0x80
                             ;* Port B
0001 =                       KB_W		= 0x01			; Input - BBC keyboard hardware se
0002 =                       KB_LED0		= 0x02			; Output - led 0
0004 =                       KB_LED1		= 0x04			; Output - led 1
0008 =                       KB_LED2		= 0x08			; Output - led 2
0001 =                       KB_CAPSLK	= 0x01			; Id of Caps Lock - maps to Le
0002 =                       KB_SHIFTLK	= 0x02			; Id of Shift lock - maps to 
                             
0003 =                       KB_REP_TIM	= 3				; Number of VB periods for the 
AS65 Assembler for R6502 [1.42].                                     Page    4
-------------------------------- bank\bank3.s --------------------------------

0014 =                       KB_REP_DEL	= 20			; Number of VB periods before r
0002 =                       KB_DEBOUNCE	= 2				; Number of VB periods before 
                             
0003 =                       UTF_ETX		= 0x03			; Break character
0007 =                       UTF_BEL		= 0x07
0008 =                       CRSR_LEFT	= 0x08
0009 =                       CRSR_RIGHT	= 0x09
000a =                       CRSR_DOWN	= 0x0a
000b =                       CRSR_UP		= 0x0b
0006 =                       UTF_ACK		= 0x06			; Used for the copy key in this
000c =                       UTF_FF		= 0x0c
000d =                       UTF_CR		= 0x0d
001a =                       UTF_BRK		= 0x1a			; Debug - drop in to monitor
007f =                       UTF_DEL		= 0x7f
0020 =                       UTF_SPECIAL = 0x20
                             
                             ;* SD Card interface definitions
                             ;* The card is accessed through port B of VIA 2
0001 =                       SD_CLK		= 0x01			; Clock output to SD card
0004 =                       SD_CD		= 0x04			; Card detect input
0008 =                       SD_CS		= 0x08			; Card select output
0010 =                       SD_DI		= 0x10			; Data output from VIA to SD Card
0080 =                       SD_DO		= 0x80			; Data input to VIA from SD card
                             
0010 =                       SD_MOSI		= SD_DI
0080 =                       SD_MISO		= SD_DO
0480 =                       SD_REG		= IO_1+PRB
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
                             
                             ;* Memory management definitions
                             ;* Y1,Y0 = ROM bank selection CIA1 PORTB
0080 =                       MM_Y1					= 0x80
0040 =                       MM_Y0					= 0x40
                             ;* X1,X0 = RAM bank selection CIA1 PORTB
0020 =                       MM_X1					= 0x20
0010 =                       MM_X0					= 0x10
                             ;* DIS = ROM disable *CIA2* PORTB
0020 =                       MM_DIS					= 0x20
                             
                             ;* Number formats for conversion routines
0000 =                       NUM_ANY		= 0x00
0001 =                       NUM_DEC		= 0x01
0002 =                       NUM_HEX		= 0x02
0003 =                       NUM_BIN		= 0x03
                             
                             	
                             ;* SD Card Master Boot Record (MBR) definitions
                             ;* The MBR contains the essential information
                             ;* needed to access the data on the card
                             ;* MBR is usually sector 0, but not always
                             ;* however the card I am using does work ok.
0000 =                       MBR_Code				=	0x0000
0003 =                       MBR_OEMName				=	0x0003
000b =                       MBR_BytesPerSect		=	0x000b
000d =                       MBR_SectPerClust		=	0x000d
000e =                       MBR_ResvSect			=	0x000e
0010 =                       MBR_FATCopies			=	0x0010
0011 =                       MBR_RootEntries			=	0x0011
AS65 Assembler for R6502 [1.42].                                     Page    5
-------------------------------- bank\bank3.s --------------------------------

0013 =                       MBR_SmlSect				=	0x0013
0015 =                       MBR_MediaDesc			=	0x0015
0016 =                       MBR_SectPerFAT			=	0x0016
0018 =                       MBR_SectPerTrk			=	0x0018
001a =                       MBR_NumHeads			=	0x001a
001c =                       MBR_NumHidSect			=	0x001c
0020 =                       MBR_NumSect				=	0x0020
0024 =                       MBR_DrvNum				=	0x0024
0026 =                       MBR_ExtSig				=	0x0026
0027 =                       MBR_SerNo				=	0x0027
002b =                       MBR_VolName				=	0x002b
0036 =                       MBR_FATName				=	0x0036
003e =                       MBR_ExeCode				=	0x003e
01c6 =                       MBR_BootPart1			=	(0x01be+0x08)
01fe =                       MBR_ExeMark				=	0x01fe
                             
                             ;* FAT16 definitions - these are offsets
                             ;* in to a FAT table entry which is
                             ;* 32 bytes in length.
0000 =                       	struct FATFileDesc
0000 =                       	ds FAT_Name,8
0008 =                       	ds FAT_Ext,3
000b =                       	ds FAT_Attr,1
000c =                       	ds FAT_Resv,1
000d =                       	ds FAT_Createms,1
000e =                       	ds FAT_CreateTime,2
0010 =                       	ds FAT_CreateDate,2
0012 =                       	ds FAT_AccessDate,2
0014 =                       	ds FAT_EAIndex,2
0016 =                       	ds FAT_ModTime,2
0018 =                       	ds FAT_ModDate,2
001a =                       	ds FAT_FirstClust,2
001c =                       	ds FAT_FileSize,4
                             	end struct
                             
                             ;* Flag to mark file as a directory
0010 =                       FAT_Attr_Dir			=	0x10
                             
                             ;* The FileHandle stucture is key to
                             ;* accessing the file system
0000 =                       	struct FileHandle
0000 =                       	ds FH_Name, 13				; 8 name, 3 extension, 1 separ
000d =                       	ds FH_Attr, 1				; What kind of file ** keep str
000e =                       	ds FH_Size, 4				; File size
0012 =                       	ds FH_CurrClust, 2			; Current cluster
0014 =                       	ds FH_SectCounter, 1		; Sector counter to know w
0015 =                       	ds FH_CurrSec, 4			; Current sector
0019 =                        	ds FH_Pointer, 4			; Pointer in to file for nex
001d =                       	ds FH_DirSect, 4			; Parent directory sector
0021 =                       	ds FH_DirOffset, 2			; Offset of this entry in t
0023 =                       	ds FH_FirstClust, 2			; First cluster of file da
0025 =                       	ds FH_LastClust, 2			; Last cluster accessed
0027 =                       	ds FH_TimeDate, 5			; Time-Date created (ms, tim
002c =                       	ds FH_FileMode, 1			; File mode (0=read, else wr
002d =                       	ds FH_FSpecPtr, 2			; Pointer to file spec being
                             	end struct
                             
0001 =                       FS_BLK_FLG_LOAD		 	= 	0x01		; On next byte, load 
0002 =                       FS_BLK_FLG_FLUSH		=	0x02		; Block has changed, ne
                             	
0001 =                       FS_ERR_EOF				=	0x01
                             
AS65 Assembler for R6502 [1.42].                                     Page    6
-------------------------------- bank\bank3.s --------------------------------

                             
                             ;* USEFUL MACROS HERE
                             
                             ;* Software break to throw errors
                             ;* use like this : SWBRK XX
                             ;* Where XX is the error code
                             SWBRK macro sig
                             	brk
                             	db sig
                             	endm
                             
                             _pushAXY macro
                             	pha
                             	phx
                             	phy
                             	endm
                             
                             _pullAXY macro
                             	ply
                             	plx
                             	pla
                             	endm
                             
                             _println macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	_pullAXY
                             	endm
                             
                             _println_low macro msg
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	endm
                             
                             _printmsgA macro msg
                             	phx
                             	phy
                             	pha
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	pla
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printA macro
                             	phx
                             	phy
                             	pha
                             	jsr str_a_to_x
AS65 Assembler for R6502 [1.42].                                     Page    7
-------------------------------- bank\bank3.s --------------------------------

                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printCRLF macro
                             	pha
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printC macro ch
                             	pha
                             	lda #ch
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printCA macro
                             	pha
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _sendcmd macro cmd
                             	_pushAXY
                             	ldx #lo(cmd)
                             	lda #hi(cmd)
                             	jsr sd_sendcmd
                             	_pullAXY
                             	endm
                             
                             _incZPWord macro wordp
                             	inc wordp
                             	db	0xd0, 0x02
                             	inc wordp+1
                             	endm
                             
                             _decZPWord macro wordp
                             	pha
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	pla
                             	endm
                             
                             _decZPWordA macro wordp
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
AS65 Assembler for R6502 [1.42].                                     Page    8
-------------------------------- bank\bank3.s --------------------------------

                             	endm
                             
                             _cpyZPWord macro worda,wordb
                             	lda worda
                             	sta wordb
                             	lda worda+1
                             	sta wordb+1
                             	endm
                             	
                             _addZPWord macro worda, wordb
                             	clc
                             	lda worda
                             	adc wordb
                             	sta worda
                             	lda worda+1
                             	adc wordb+1
                             	sta worda+1
                             	endm
                             
                             _subZPWord macro worda, wordb
                             	sec
                             	lda worda
                             	sbc wordb
                             	sta worda
                             	lda worda+1
                             	sbc wordb+1
                             	sta worda+1
                             	endm
                             	
                             _adcZPWord macro worda,const
                             	clc
                             	lda worda
                             	adc #const
                             	sta worda
                             	lda worda+1
                             	adc #0
                             	sta worda+1
                             	endm
                             
                             _adcZPByte macro worda, byte
                             	clc
                             	lda worda
                             	adc byte
                             	sta worda
                             	db 0x90, 0x02		; bcc 2
                             	inc worda+1
                             	endm
                             
                             _sbcZPByte macro worda, byte
                             	sec
                             	lda worda
                             	sbc byte
                             	sta worda
                             	db 0xb0, 0x02		; bcs 2
                             	inc worda+1
                             	endm
                             
                             _bcc macro skip
                             	db 0x90, skip
                             	endm
                             
                             _bcs macro skip
AS65 Assembler for R6502 [1.42].                                     Page    9
-------------------------------- bank\bank3.s --------------------------------

                             	db 0xb0, skip
                             	endm
                             
                             _df_ost_peekType macro
                             	ldy df_parmtop
                             	lda df_rtstck-1,y
                             	endm
                             
                             	include "inc\graph.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  GRAPH.I
                             ;*  This is the definition file for graphics, spe
                             ;*  The graphics screen handling module.  It is j
                             ;*  structure definition - but this structure is 
                             ;*  record the important attributes of a text scr
                             ;*  Needed because there is both a 40 and 32 colu
                             ;*  supported by the VDP, and the screens are not
                             ;*  same location.
                             ;*
                             ;************************************************
                             
0000 =                       	struct gr_screen
0000 =                       	dw gr_screen_start			; Start of screen memory in
0002 =                       	dw gr_screen_size			; Number of bytes screen occ
0004 =                       	db gr_screen_w				; Number of columns
0005 =                       	db gr_screen_h				; Number of rows
0006 =                       	db gr_cur_off				; Y offset of cursor image from
0007 =                       	db gr_cur_x					; Current X position of cursor
0008 =                       	db gr_cur_y					; Current Y position of cursor
0009 =                       	dw gr_cur_ptr				; VDP address of cursor
000b =                       	db gr_pixmode				; Pixel plot mode (0=Erase, 1=P
000c =                       	db gr_pixmask				; Pixel plot mask
000d =                       	db gr_pixcol				; Pixel colour
000e =                       	dw gr_geom_tmp				; One word of temp storage for
                             	end struct
                             	include "io\io.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.I
                             ;*  Definitions file for the IO module.  The key 
                             ;*  used by the IO system is defined here.
                             ;*
                             ;************************************************
                             
                             ;* General IO structure allows the system to swap
                             ;* different IO devices by using indirect calls t
                             ;* the appropriate routines.
0000 =                       	struct io_struct
0000 =                       	ds	io_get_byte,	2			;* Address of get byte
AS65 Assembler for R6502 [1.42].                                     Page   10
-------------------------------- bank\bank3.s --------------------------------

0002 =                       	ds	io_put_byte,	2			;* Address of put byte
0004 =                       	ds	io_open_r,		2			;* Address of open file for r
0006 =                       	ds	io_open_w,		2			;* Address of open file for w
0008 =                       	ds	io_close_f,		2			;* Address of close file
000a =                       	ds	io_del_f,		2			;* Address of delete file
000c =                       	ds	io_ext1,		2			;* Address of extended function
000e =                       	ds	io_ext2,		2			;* Address of extended function
                             	end struct
                             	include "rtc\rtc.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTC.I
                             ;*  Definitions file for the RTC module.  The key
                             ;*  used by the real time clock is defined here.
                             ;*  It is a DS1288
                             ;*
                             ;************************************************
                             
0000 =                       RTC_SEC		= 0x00
0001 =                       RTC_SECA	= 0x01
0002 =                       RTC_MIN		= 0x02
0003 =                       RTC_MINA	= 0x03
0004 =                       RTC_HR		= 0x04
0005 =                       RTC_HRA		= 0x05
0006 =                       RTC_DOW		= 0x06
0007 =                       RTC_DAY		= 0x07
0008 =                       RTC_MTH		= 0x08
0009 =                       RTC_YR		= 0x09
000a =                       RTC_REGA	= 0x0a
000b =                       RTC_REGB	= 0x0b
000c =                       RTC_REGC	= 0x0c
000d =                       RTC_REGD	= 0x0d
                             
0080 =                       RTC_UIP		= 0x80
0040 =                       RTC_DV2		= 0x40
0020 =                       RTC_DV1		= 0x20
0010 =                       RTC_DV0		= 0x10
0080 =                       RTC_RS3		= 0x80
0040 =                       RTC_RS2		= 0x40
0020 =                       RTC_RS1		= 0x20
0010 =                       RTC_RS0		= 0x10
                             
0080 =                       RTC_SET		= 0x80
0040 =                       RTC_PIE		= 0x40
0020 =                       RTC_AIE		= 0x20
0010 =                       RTC_UIE		= 0x10
0080 =                       RTC_SQWE	= 0x80
0004 =                       RTC_DM		= 0x04
0002 =                       RTC_2412	= 0x02
0001 =                       RTC_DSE		= 0x01
                             
0080 =                       RTC_IRQF	= 0x80
0040 =                       RTC_PF		= 0x40
0020 =                       RTC_AF		= 0x20
0010 =                       RTC_UF		= 0x10
                             
AS65 Assembler for R6502 [1.42].                                     Page   11
-------------------------------- bank\bank3.s --------------------------------

0080 =                       RTC_VRT		= 0x80
                             
0600 =                       RTC_ADDR	= 0x600
0601 =                       RTC_DATA	= 0x601
                             
003f =                       NV_RAMSZ    = 63            ; Checksum byte in NV
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0c69 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
AS65 Assembler for R6502 [1.42].                                     Page   12
-------------------------------- bank\bank3.s --------------------------------

                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
0080 =                       DFST_STR	=	0x80
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
AS65 Assembler for R6502 [1.42].                                     Page   13
-------------------------------- bank\bank3.s --------------------------------

0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0c69 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
AS65 Assembler for R6502 [1.42].                                     Page   14
-------------------------------- bank\bank3.s --------------------------------

                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
AS65 Assembler for R6502 [1.42].                                     Page   15
-------------------------------- bank\bank3.s --------------------------------

0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
0080 =                       DFST_STR	=	0x80
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             	include "dflat\error.i"
                             ;************************************************
                             ;*
                             ;*	BBC128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  It issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page   16
-------------------------------- bank\bank3.s --------------------------------

                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_SYNTAX	=	1
0002 =                       DFERR_TYPEMISM	=	2
0003 =                       DFERR_DIM		=	3
0004 =                       DFERR_UNTIL		=	4
0005 =                       DFERR_NOPROC	=	5
0006 =                       DFERR_PROCPARM	=	6
0007 =                       DFERR_IMMEDIATE	=	7
0008 =                       DFERR_UNCLOSEDIF=	8
0009 =                       DFERR_NOIF		=	9
000a =                       DFERR_NEXTFOR	=	10
000b =                       DFERR_FNAME		=	11
000c =                       DFERR_STRLONG	=	12
000d =                       DFERR_BREAK		=	13
000e =                       DFERR_NODATA	=	14
000f =                       DFERR_WEND		=	15
0010 =                       DFERR_NOLINE	=	16
0011 =                       DFERR_RETURN	=	17
0012 =                       DFERR_ABORT		=	18
0013 =                       DFERR_QUANTITY	=	19
0014 =                       DFERR_NOORG		=	20
                             
                             
                             
                             	include "bank\bank.i"
c000 =                       bankjsr_nul_addr	=	0xc000
0000 =                       bankjsr_nul_bank	=	0x00
003f =                       ROM_ZMASK			=	0x3f
00cf =                       RAM_ZMASK			=	0xcf
                             
                             _bankjsr	macro	addr,bank
                             	; Save A
                             	sta tmp_bank1
                             	
                             	; Save current bank
                             	lda bank_num
                             	pha
                             	
                             	; Switch to new bank
                             	lda IO_0+PRB
                             	and #ROM_ZMASK
                             	ora #(bank^3) << 6			; Shift left 6 bits
                             	sta IO_0+PRB
                             
                             	; Restore A
                             	lda tmp_bank1
                             	; JSR to the routine
                             	jsr addr
                             	
                             	jmp _restore_bank
                             	; 62 clock cycles inc restore vs 6 for a near js
                             
                             	endm
                             	
                             _bankram macro bank
                             	pha
                             	lda IO_0+PRB
AS65 Assembler for R6502 [1.42].                                     Page   17
-------------------------------- bank\bank3.s --------------------------------

                             	and #RAM_ZMASK
                             	ora #bank << 4
                             	sta IO_0+PRB
                             	pla
                             	endm
                             	
                             _bankram_fast macro bank
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
                             	sta IO_0+PRB
                             	endm
                             	
                             
                             	include "kernel\zeropage.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ZEROPAGE.I
                             ;*  This module name is misleading it is not only
                             ;*  allocations, but also page 2, 3, 4, 5, 6, 7 a
                             ;*  Basically, this module defines:
                             ;*  - All zero page variables for system and dfla
                             ;*  - Page 1 is stack so no need to worry about t
                             ;*  - Page 2 is the serial IO buffer for the 6551
                             ;*  - Page 3 and 4 is a 512 buffer for SD card se
                             ;*  - Page 5 onwards is mainly for dflat working 
                             ;*    but also non-zero page storage for general 
                             ;*    system and scratch usage.
                             ;*  memstart is a handy label that indicates the 
                             ;*  location that we can store dflat programs fro
                             ;*  Zero page is a valuable asset as the 6502 can
                             ;*  this page one cycle quicker than the rest of 
                             ;*  and infact some addressing modes can only use
                             ;*  Due to the value of zero page, a lot of syste
                             ;*  dflat variables are put here.  But we don't h
                             ;*  luxury for single use variables - so you will
                             ;*  see a lot of temporary sounding names which a
                             ;*  have multiple used across the code base.
                             ;*
                             ;************************************************
                             
                             	; Zero page declarations
                             	bss
0000 =                       	org 0x0000
                             
0000 =                       tmp_bank1	ds	1		; Temp storage ONLY FOR USE BY BA
0001 =                       tmp_bank2	ds	1		; Temp storage ONLY FOR USE BY BA
                             
                             ; Interrupt routine addresses
0002 =                       int_nmi		 ds 2		; Master NMI handler
0004 =                       int_irq		 ds	2		; Master IRQ handler
0006 =                       int_brk		 ds	2		; Master BRK handler
0008 =                       int_uservdp	 ds	2		; Where to jump for VDP interr
000a =                       int_usercia0 ds	2		; Where to jump for CIA0 inter
000c =                       int_usercia1 ds	2		; Where to jump for CIA1 inter
                             
AS65 Assembler for R6502 [1.42].                                     Page   18
-------------------------------- bank\bank3.s --------------------------------

                             ; Serial FIFO buffer pointers
000e =                       ser_first	ds	1		; Pointer to first byte in buffer
000f =                       ser_last	ds	1		; Pointer to last byte in buffer
                             ; VDP parameters
0010 =                       vdp_int_cnt	ds  2		; VDP interrupt counter
0012 =                       vdp_curoff	ds	1		; Cursor off (0 = On)
0013 =                       vdp_curstat	ds	1		; Cursor status
0014 =                       vdp_curval	ds	1		; Cursor value on screen
0015 =                       vdp_blank	ds	1		; Screen blank value normally 32
0016 =                       vdp_delay	ds	1		; Delay counter for VRAM access
                             
                             ; vdp settings
0017 =                       vdp_base	ds	vdp_addr_struct
                             
                             ; Screen geometry
0023 =                       gr_scrngeom	ds	gr_screen
                             
                             ;Keyboard parameters
0033 =                       kb_raw  	ds	1		; Raw keyboard code
0034 =                       kb_last		ds	1		; Raw code of last key
0035 =                       kb_code 	ds	1		; Converted keyboard code
0036 =                       kb_stat		ds	1		; Keyboard status for caps and shi
0037 =                       kb_deb		ds	1		; VB periods since last KB spike
0038 =                       kb_rep		ds	1		; Keyboard repeat timer
0039 =                       kb_rep_tim 	ds	1		; Default repeat speed
003a =                       kb_rep_del 	ds	1		; Default repeat delay timing
003b =                       kb_debounce ds	1		; Default repeat debounce
003c =                       kb_pressed	ds	1		; Set by the interrupt handler i
                             
003d =                       tmp_c		ds	2		; Temp address c
003f =                       tmp_v1		ds	2		; VDP temp addresses
0041 =                       tmp_a		ds	2		; Temp storage a
0043 =                       tmp_b 		ds	2		; Temp address b
0045 =                       tmp_d		ds	2		; Temp storage d
                             
                             ; Raw input/output parameters
0047 =                       buf_adr		ds	2		; Line buffer address
0049 =                       buf_sz		ds	1		; Buffer size
004a =                       buf_ef		ds	1		; End file / line marker
                             
                             ; SD card driver parameters
004b =                       sd_status	ds	1		; SD card status
004c =                       sd_slo		ds	1		; Sector pointer low
004d =                       sd_shi		ds	1		; Sector pointer high
004e =                       sd_sect		ds	4		; SD Card sector address
0052 =                       sd_addr		ds	4		; SD Card byte address
                             
                             ; File system zp parameters
0056 =                       fh_handle	ds	FileHandle ; File handle parameters
                             
                             ; ** Integer function storage **
0085 =                       ztmp_16					; Start of 16 byte scratch area (all 
0085 =                       num_a		ds	4		; 4 byte primary accumulator
0089 =                       num_b		ds	4		; 4 byte secondary accumulator
008d =                       num_x		ds	4		; 4 byte x register
0091 =                       num_tmp		ds	4		; 4 byte temp space
0095 =                       num_buf		ds	8		; 8 byte string buffer
                             
                             ;
                             ; **** INTERPRETER ZERO PAGE ****
                             ;
009d =                       dflat_zp_s
AS65 Assembler for R6502 [1.42].                                     Page   19
-------------------------------- bank\bank3.s --------------------------------

009d =                       dflat_zp_save_s			; ZP save dflat from here
009d =                       df_checkkey	ds	1		; Key check interval counter
009e =                       df_checkmsk	ds	1		; Mask for check key
009f =                       errno		ds	1		; General error condition status
00a0 =                       df_immed	ds	1		; Immediate mode (0 = not immediat
00a1 =                       df_sp		ds	1		; Stack pointer after error to resto
00a2 =                       df_pc		ds	2		; PC after error to return to
00a4 =                       df_brkpc	ds	2		; PC pushed on the stack for BRK
00a6 =                       df_brkval	ds	1		; Byte after BRK instruction
00a7 =                       df_prgstrt	ds	2		; Start of program code
00a9 =                       df_prgend	ds	2		; End of program code
00ab =                       df_vntstrt	ds	2		; Variable name table start
00ad =                       df_vntend	ds	2		; Variable name table end
00af =                       df_vvtstrt	ds	2		; Variable value table start
00b1 =                       df_vvtend	ds	2		; Variable value table end
00b3 =                       df_varcnt	ds	1		; Variable counter
00b4 =                       df_starstrt	ds	2		; String and array table start
00b6 =                       df_starend	ds	2		; String and array table end
00b8 =                       df_rtstop	ds	1		; Runtime stack pointer
00b9 =                       df_parmtop	ds	1		; Top of parameter stack (grows 
00ba =                       df_strbuff	ds	1		; String expression buffer
00bb =                       df_stridx	ds	1		; Top of string buffer (grows dow
00bc =                       df_sevalptr	ds	2		; Pointer to next free char in 
                             
00be =                       df_linoff	ds	1		; Offset in to line buffer
00bf =                       df_tokoff	ds	1		; Offset in to tokenised buffer
00c0 =                       df_eolidx	ds	1		; End of line index (i.e length)
00c1 =                       df_nxtstidx	ds	1		; Offset to the next statement 
00c2 =                       df_curstidx	ds	1		; Offset to the start of curren
00c3 =                       df_symtab	ds	2		; Pointer to next free symtab ent
00c5 =                       df_symoff	ds	1		; Offset in to token table
00c6 =                       df_symini	ds	2		; Start of symtab
00c8 =                       df_currlin	ds	2		; Execution current line pointer
00ca =                       df_exeoff	ds	1		; Execution line buffer offset
00cb =                       df_nextlin	ds	2		; Next line to execute
00cd =                       df_procmode	ds	1		; Only used during tokenisation
00ce =                       df_procargs	ds	1		; Only used during tokenisation
00cf =                       df_procloc	ds	1		; Counts the number of local par
00d0 =                       df_procptr	ds	2		; Pointer to proc vvt slot
00d2 =                       df_lineptr	ds	2		; Pointer to line during searche
00d4 =                       df_lineidx	ds	1		; Pointer to line index during s
00d5 =                       df_ifnest	ds	1		; Global nested if counter
00d6 =                       df_currdat	ds	2		; Data current line pointer
00d8 =                       df_datoff	ds	1		; Data line buffer offset
00d9 =                       df_rnd		ds	2		; Random number seed
                             
00db =                       df_asmpc	ds	2		; Assembler program counter
00dd =                       df_asmopt	ds	1		; Assembler current option
00de =                       df_asmadmd	ds	1		; Addressing mode
00df =                       df_asmopcde	ds	1		; Current opcode
00e0 =                       df_asmoprnd	ds	2		; Current operand
00e2 =                       df_asmlen	ds	1		; Instruction length
                             
00e3 =                       dflat_zp_save_e			; Save up to this place
                             
                             ; Temp space for dflat
00e3 =                       df_tmpptra	ds	2		; Temp pointer a
00e5 =                       df_tmpptrb	ds	2		; Temp pointer b
00e7 =                       df_tmpptrc	ds	2		; Temp pointer c
00e9 =                       df_tmpptrd	ds	2		; Temp pointer d
00eb =                       df_tmpptre	ds	2		; Temp pointer e
                             
AS65 Assembler for R6502 [1.42].                                     Page   20
-------------------------------- bank\bank3.s --------------------------------

                             
                             ;***** END OF ZERO PAGE *****
00ed =                       _end_zero_page
                             
                             ;***** Page 1 is CPU stack ****
0100 =                       	org 0x0100
0100 =                       _cpu_stack
0100 =                       			ds	256		; All of page 1
                             
                             ;***** Page 2 and 3 is SD card buffer
0200 =                       	org 0x0200			; SD Card data buffer 512 bytes
0200 =                       sd_buf		ds	512
                             
                             ;***** Page 4,5,6,7 is IO space
0400 =                       	org 0x0400
0400 =                       			ds	1024	; 1 k area divided in to 8x128 byte de
                             
                             
                             ;***** Page 8 is serial buffer *****
0800 =                       	org 0x0800
0800 =                       ser_buf		ds	256		; Serial input / output line buf
                             
                             ;***** Scratch area, used by many things - do not
                             ; string and numeric expression evaluation, scree
0900 =                       	org 0x0900
0900 =                       scratch		ds	256
                             
                             ;***** Dflat space *****
0a00 =                       	org 0x0a00			; Page 9 = dflat space
0a00 =                       df_linbuff
0a00 =                       df_raw		ds	128		; untokenised input line
0a80 =                       df_tokbuff
0a80 =                       df_tok		ds 	128		; tokenised output line
                             
0b00 =                       	org 0x0b00			; Page 10 = fixed space for runtime
0b00 =                       df_rtstck				; operator stack grows up, runtime g
0b00 =                       df_rtspace	ds	256
                             
                             ;***** NON-ZERO PAGE VARIABLES *****
                             
                             ; Active IO device settings
0c00 =                       io_default	ds	1		; The default device number - es
                             ; Copy of jump tables to active device io routine
0c01 =                       io_block	ds	io_struct
                             
                             ; Copy of FAT16 directory
0c11 =                       fs_direntry	ds	FATFileDesc ; copy of dir entry - 
                             
                             ; Filesystem parameters
0c31 =                       fs_bootsect	ds	4		; Start of partition (usually 0
0c35 =                       fs_fatsect	ds	4		; Start of FAT tables
0c39 =                       fs_rootsect	ds	4		; Start of Root Directory
0c3d =                       fs_datasect	ds	4		; Start of Data Area
0c41 =                       fs_dirsect	ds	4		; Current directory sector numbe
0c45 =                       fs_dirclust	ds	2		; Current directory cluster num
                             
                             ; Working and scratch for filesystem - some data 
0c47 =                       fs_scratch	ds	32		; 32 bytes should be more than 
                             
                             ; Dflat top of memory+1 - normally initialised to
0c67 =                       df_memtop	ds	2
                             
AS65 Assembler for R6502 [1.42].                                     Page   21
-------------------------------- bank\bank3.s --------------------------------

                             ;***** THIS IS THE START OF FREE SPACE for DFLAT 
0c69 =                       mem_start
                             
                             
                             
                             
                             ;****************************************
                             ;*	Set 6502 default vectors	*
                             ;****************************************
                             	data				; Set vectors
fffa =                       	org 0xfffa			; Vectors lie at addresses
fffa : dfc6                  	fcw call_nmi_master	; 0xfffa : NMI Vector
fffc : deca                  	fcw init			; 0xfffc : Reset Vector
fffe : 1fc7                  	fcw call_irq_master	; 0xfffe : IRQ Vector
                             	
                             	; ROM code
                             	code				;  
c000 =                       	org 0xc000			; Start of ROM
                             
                             	; The bank number is hardwired and aligned to PB
c000 :                       bank_num
                             	if BANK0
                             	  db 192
                             	endif
                             	if BANK1
                             	  db 128
                             	endif
                             	if BANK2
                             	  db 64
                             	endif
                             	if BANK3
c000 : 00                    	  db 0
                             	endif
                             
c001 :                       _code_start
                             	; Restore current bank always at address c001
c001 :                       _OSVectors
                             	include "kernel\osvec.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  OSVEC.S
                             ;*  Simply this is a bunch of JMP XXXX the order 
                             ;*  will always be maintained.  This is to allow 
                             ;*  code programs to be able to rely on fixed loc
                             ;*  some key low-level functions.
                             ;*  Only low level functions are needed, the idea
                             ;*  as the assembler is part of the BASIC, one ca
                             ;*  level slow stuff using BASIC then switch to M
                             ;*  speed up.
                             ;*  This code goes straight after the bank number
                             ;*  Each JMP is at 0xc001+3*(vector #)
                             ;*
                             ;************************************************
                             
c001 : 4c48c5           [ 3] 	jmp	io_put_ch			; Vec 0
c004 : 4c45c5           [ 3] 	jmp io_get_ch			; Vec 1
AS65 Assembler for R6502 [1.42].                                     Page   22
-------------------------------- bank\bank3.s --------------------------------

c007 : 4cd8c5           [ 3] 	jmp vdp_wr_reg			; Vec 2
c00a : 4c10c6           [ 3] 	jmp vdp_poke			; Vec 3
c00d : 4c1cc6           [ 3] 	jmp vdp_peek			; Vec 4
c010 : 4c7dc6           [ 3] 	jmp snd_get_joy0		; Vec 5
c013 : 4c25c6           [ 3] 	jmp snd_set				; Vec 6
c016 : 4ce5c5           [ 3] 	jmp vdp_wr_addr			; Vec 7
c019 : 4cfcc5           [ 3] 	jmp	vdp_rd_addr			; Vec 8
c01c :                       _restore_bank
                             	; Save A
c01c : 8500             [ 3] 	sta tmp_bank1
                             	; Get old bank from stack
c01e : 68               [ 4] 	pla
c01f : 8501             [ 3] 	sta tmp_bank2
c021 : ad0004           [ 4] 	lda IO_0+PRB
c024 : 293f             [ 2] 	and #ROM_ZMASK
c026 : 0501             [ 3] 	ora tmp_bank2
c028 : 8d0004           [ 4] 	sta IO_0+PRB
                             	
                             	; Restore A
c02b : a500             [ 3] 	lda tmp_bank1
                             
c02d : 60               [ 6] 	rts
                             
                             	; include cross-bank functions (see extern.mak)
                             	include "bank\autogen.s"	
                             ; 
c02e :                       mod_sz_autogen_s 
c02e :                       _df_init 
                               _bankjsr $f1b3, 1 
                             
c046 :                       _df_pg_dflat 
                               _bankjsr $d764, 1 
                             
c05e :                       _fs_chdir_w 
                               _bankjsr $d4df, 2 
                             
c076 :                       _fs_mkdir_w 
                               _bankjsr $d572, 2 
                             
c08e :                       _fs_delete_w 
                               _bankjsr $d4a2, 2 
                             
c0a6 :                       _fs_close_w 
                               _bankjsr $d461, 2 
                             
c0be :                       _fs_get_byte_w 
                               _bankjsr $d185, 2 
                             
c0d6 :                       _fs_open_read_w 
                               _bankjsr $d34d, 2 
                             
c0ee :                       _fs_open_write_w 
                               _bankjsr $d411, 2 
                             
c106 :                       _fs_put_byte_w 
                               _bankjsr $d2da, 2 
                             
c11e :                       _fs_dir_find_entry_w 
                               _bankjsr $cfc8, 2 
                             
c136 :                       _fs_dir_entry_next_w 
                               _bankjsr $cffe, 2 
AS65 Assembler for R6502 [1.42].                                     Page   23
-------------------------------- bank\bank3.s --------------------------------

                             
c14e :                       _fs_dir_root_start_w 
                               _bankjsr $cf83, 2 
                             
c166 :                       _get_byte 
                               _bankjsr $cedb, 0 
                             
c17e :                       _put_byte 
                               _bankjsr $cef0, 0 
                             
c196 :                       _gr_get_key 
                               _bankjsr $df8c, 0 
                             
c1ae :                       _gr_put_byte 
                               _bankjsr $df99, 0 
                             
c1c6 :                       _gr_init_screen 
                               _bankjsr $da59, 0 
                             
c1de :                       _init_acia 
                               _bankjsr $cefd, 0 
                             
c1f6 :                       _init_cia0 
                               _bankjsr $ce88, 0 
                             
c20e :                       _init_cia1 
                               _bankjsr $ceb9, 0 
                             
c226 :                       _init_fs 
                               _bankjsr $ce60, 2 
                             
c23e :                       _init_sdcard 
                               _bankjsr $cb5a, 2 
                             
c256 :                       _init_snd 
                               _bankjsr $d2bc, 0 
                             
c26e :                       _init_keyboard 
                               _bankjsr $cf0f, 0 
                             
c286 :                       _kb_read_raw 
                               _bankjsr $cf1e, 0 
                             
c29e :                       _kb_read_dip 
                               _bankjsr $cf89, 0 
                             
c2b6 :                       _command_line 
                               _bankjsr $cb5a, 0 
                             
c2ce :                       _gr_cls 
                               _bankjsr $da6c, 0 
                             
c2e6 :                       _gr_init_hires 
                               _bankjsr $da16, 0 
                             
c2fe :                       _gr_line 
                               _bankjsr $ddc6, 0 
                             
c316 :                       _gr_box 
                               _bankjsr $dc06, 0 
                             
c32e :                       _gr_circle 
AS65 Assembler for R6502 [1.42].                                     Page   24
-------------------------------- bank\bank3.s --------------------------------

                               _bankjsr $dd11, 0 
                             
c346 :                       _gr_plot 
                               _bankjsr $dad7, 0 
                             
c35e :                       _gr_hchar 
                               _bankjsr $db15, 0 
                             
c376 :                       _gr_point 
                               _bankjsr $dbbb, 0 
                             
c38e :                       _gr_get 
                               _bankjsr $daf2, 0 
                             
c3a6 :                       _gr_set_cur 
                               _bankjsr $dafa, 0 
                             
c3be :                       _snd_get_note 
                               _bankjsr $d2b5, 0 
                             
c3d6 :                       _snd_get_joy0 
                               _bankjsr $c67d, 0 
                             
c3ee :                       _snd_set 
                               _bankjsr $c625, 0 
                             
c406 :                       _vdp_peek 
                               _bankjsr $c61c, 0 
                             
c41e :                       _vdp_poke 
                               _bankjsr $c610, 0 
                             
c436 :                       _vdp_init 
                               _bankjsr $d800, 0 
                             
c44e :                       _rtc_init 
                               _bankjsr $d0df, 0 
                             
c466 :                       _rtc_gettimedate 
                               _bankjsr $d246, 0 
                             
c47e :                       _rtc_setdatetime 
                               _bankjsr $d197, 0 
                             
c496 :                       _rtc_nvread 
                               _bankjsr $d2ac, 0 
                             
c4ae :                       _rtc_nvwrite 
                               _bankjsr $d294, 0 
                             
c4c6 :                       _fs_dir_fhandle_str 
                               _bankjsr $d586, 2 
                             
c4de :                       _sd_sendcmd17 
                               _bankjsr $cd32, 2 
                             
c4f6 :                       _sd_sendcmd24 
                               _bankjsr $cdab, 2 
                             
c50e :                       mod_sz_autogen_e 
                             
                             	
AS65 Assembler for R6502 [1.42].                                     Page   25
-------------------------------- bank\bank3.s --------------------------------

c50e :                       mod_sz_kernel_s
                             
                             ;* Include all common code in the right order
                             	include "io\io.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.S
                             ;*  General IO module.  Allows different IO devic
                             ;*  utilised transparently by the rest of the cod
                             ;*  Other code should use "io_" commands so that 
                             ;*  do not need to know what specific device is p
                             ;*  input and output capabilities.  On startup, t
                             ;*  examines the BBC DIP switch to decide whether
                             ;*  initialise the IO to serial through the ACIA 
                             ;*  the BBC keyboard for input with the VDP for o
                             ;*  Loading and saving files from the SD card is 
                             ;*  achieved by pointing to SD card get and put b
                             ;*  routines.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c50e :                       mod_sz_io_s
                             
                             ;****************************************
                             ;* io_init
                             ;* Initialise the default device and make active
                             ;* No keys pressed = serial (default)
                             ;* F0 pressed = KB/VDP
                             ;* F1 pressed = Serial
                             ;* Keyboard and screen or serial port
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c50e :                       io_init
c50e : a900             [ 2] 	lda #0				; Assume it's serial
c510 : 48               [ 3] 	pha
c511 : 209ec2           [ 6] 	jsr _kb_read_dip	; Check DIPs if 0xff then assum
c514 : 2910             [ 2] 	and #0x10
c516 : d00b             [ 3] 	bne io_init_set_default
c518 : 2086c2           [ 6] 	jsr _kb_read_raw	; Check pressed key
c51b : e081             [ 2] 	cpx #0x81			; f1 key pressed (i.e. boot up in se
c51d : f004             [ 3] 	beq io_init_set_default
                             	; Else set to KB/screen for IO
c51f : 68               [ 4] 	pla
c520 : a901             [ 2] 	lda #1
c522 : 48               [ 3] 	pha
c523 :                       io_init_set_default
c523 : 68               [ 4] 	pla
c524 : 8d000c           [ 4] 	sta io_default
c527 : 4c2ac5           [ 3] 	jmp io_set_default	; Activate the default device
                             
                             ;****************************************
                             ;* io_set_default, io_active_device
AS65 Assembler for R6502 [1.42].                                     Page   26
-------------------------------- bank\bank3.s --------------------------------

                             ;* Activate device based on default or A
                             ;* Input : A = Device number
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c52a :                       io_set_default			; Entry point for default
c52a : ad000c           [ 4] 	lda io_default
c52d :                       io_active_device		; Entry point for A set
c52d : 0a               [ 2] 	asl	a				; x16 the Block number
c52e : 0a               [ 2] 	asl a
c52f : 0a               [ 2] 	asl a
c530 : 0a               [ 2] 	asl a
c531 : a8               [ 2] 	tay
c532 : a200             [ 2] 	ldx #0
                             	; Copy device settings to io block
c534 :                       io_copy_data
c534 : b9a8c5           [ 4] 	lda io_devices,y
c537 : 9d010c           [ 5] 	sta io_block,x
c53a : c8               [ 2] 	iny
c53b : e8               [ 2] 	inx
c53c : e010             [ 2] 	cpx #io_struct
c53e : d0f4             [ 3] 	bne io_copy_data
                             	
c540 : a90d             [ 2] 	lda #UTF_CR		; Line terminator is CR
c542 : 854a             [ 3] 	sta buf_ef
c544 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* io_get_ch
                             ;* Get a char (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 0 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
c545 :                       io_get_ch
c545 : 6c010c           [ 6] 	jmp (io_block+io_get_byte)
                             	
                             
                             ;****************************************
                             ;* io_put_ch
                             ;* Put a char
                             ;* Input : A = char
                             ;* Regs affected : P, A
                             ;****************************************
c548 :                       io_put_ch
c548 : 6c030c           [ 6] 	jmp (io_block+io_put_byte)
                             	
                             ;****************************************
                             ;* io_open_read
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c54b :                       io_open_read
c54b : 6c050c           [ 6] 	jmp (io_block+io_open_r)
                             	
                             ;****************************************
                             ;* io_open_write
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
AS65 Assembler for R6502 [1.42].                                     Page   27
-------------------------------- bank\bank3.s --------------------------------

                             ;* Regs affected : All
                             ;****************************************
c54e :                       io_open_write
c54e : 6c070c           [ 6] 	jmp (io_block+io_open_w)
                             
                             ;****************************************
                             ;* io_close
                             ;* Close a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c551 :                       io_close
c551 : 6c090c           [ 6] 	jmp (io_block+io_close_f)
                             	
                             ;****************************************
                             ;* io_delete
                             ;* Delete a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c554 :                       io_delete
c554 : 6c0b0c           [ 6] 	jmp (io_block+io_del_f)
                             	
                             ;****************************************
                             ;* io_read_line
                             ;* Read a line, terminated by terminating char or
                             ;* Input : buf_(sz/ef) : Address, Max size, end m
                             ;*		    X,A = destination (uses buf_adr)
                             ;*		    Y=max line length
                             ;* Output : Y = Line length C = Buffer limit reac
                             ;* Regs affected : None
                             ;****************************************
c557 :                       io_read_line
c557 : 8647             [ 3] 	stx buf_adr			; Save pointer to storage
c559 : 8548             [ 3] 	sta buf_adr+1
c55b : 8449             [ 3] 	sty buf_sz			; Max length
c55d : 08               [ 3] 	php					; Save echo state
c55e : a000             [ 2] 	ldy #0x00			; Starting at first byte
c560 :                       io_get_line_byte
c560 : 38               [ 2] 	sec					; Getting bytes synchronously
c561 : 2045c5           [ 6] 	jsr io_get_ch		; Get a byte
c564 : b026             [ 3] 	bcs io_get_line_done; Got nothing then finish
c566 : 28               [ 4] 	plp					; Get echo state
c567 : 08               [ 3] 	php					; Instantly save it back
c568 : 900c             [ 3] 	bcc io_skip_echo	; Carry not set = don't echo
c56a : c97f             [ 2] 	cmp #UTF_DEL		; Delete?
c56c : d005             [ 3] 	bne io_do_echo
c56e : c000             [ 2] 	cpy #0				; Already at beginning?
c570 : f004             [ 3] 	beq io_skip_echo	; Don't echo delete
c572 : 88               [ 2] 	dey					; Else decrement length
c573 :                       io_do_echo
c573 : 2048c5           [ 6] 	jsr io_put_ch		; Echo it
c576 :                       io_skip_echo
c576 : c920             [ 2] 	cmp #UTF_SPECIAL	; Special character?
c578 : 9007             [ 3] 	bcc io_skip_special	; Skip if so (don't add to b
c57a : c97f             [ 2] 	cmp #UTF_DEL		; Don't proces DEL either
c57c : f003             [ 3] 	beq io_skip_special
c57e : 9147             [ 5] 	sta (buf_adr),y		; Save it
c580 : c8               [ 2] 	iny					; Increase length
c581 :                       io_skip_special
AS65 Assembler for R6502 [1.42].                                     Page   28
-------------------------------- bank\bank3.s --------------------------------

c581 : c54a             [ 3] 	cmp buf_ef			; Is it the terminating char?
c583 : f007             [ 3] 	beq io_get_line_done	; If yes then done
c585 : c449             [ 3] 	cpy buf_sz			; Reached the buffer max size?
c587 : d0d7             [ 3] 	bne io_get_line_byte	; No, get another byte
c589 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c58a : 38               [ 2] 	sec					; Yes, set carry flag
c58b : 60               [ 6] 	rts					; And done
c58c :                       io_get_line_done
c58c : a900             [ 2] 	lda #0
c58e : 9147             [ 5] 	sta (buf_adr),y		; Terminate with 0
c590 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c591 : 18               [ 2] 	clc					; Clear carry flag
c592 : 60               [ 6] 	rts					; Fin
                             
                             ;****************************************
                             ;* io_print_line
                             ;* Print a line (when data is not already in seri
                             ;* Input : X = Address Lo, A = Address Hi
                             ;* Output : Y=number chars output
                             ;* Regs affected : All
                             ;****************************************
c593 :                       io_print_line
c593 : 48               [ 3] 	pha
                             
c594 : 863d             [ 3] 	stx tmp_c					; Store the string pointer
c596 : 853e             [ 3] 	sta tmp_c+1					; lo and hi
c598 : a000             [ 2] 	ldy #0						; Start at the beginning!
c59a :                       io_print_line_byte
c59a : b13d             [ 5] 	lda (tmp_c),y				; Copy byte to
c59c : f006             [ 3] 	beq io_print_done			; If zero then done - print
c59e : 2048c5           [ 6] 	jsr io_put_ch				; Transmit
c5a1 : c8               [ 2] 	iny
c5a2 : d0f6             [ 3] 	bne io_print_line_byte		; Carry on until zero fo
c5a4 :                       io_print_done
c5a4 : 68               [ 4] 	pla
c5a5 : 60               [ 6] 	rts
                             
                             
                             ;*** Null operation just clc and return ***
c5a6 :                       io_null_op
c5a6 : 18               [ 2] 	clc
c5a7 : 60               [ 6] 	rts
                             	
                             ;* IO devices defined here
c5a8 :                       io_devices
                             ;* Device zero is the serial port
                             ;* only offers get and put
c5a8 :                       io_device0					; Serial device, input = Ser, outp
c5a8 : 66c1                  	dw	_get_byte			; io_get_ch
c5aa : 7ec1                  	dw	_put_byte			; io_put_ch
c5ac : a6c5                  	dw	io_null_op			; io_open_r
c5ae : a6c5                  	dw	io_null_op			; io_open_w
c5b0 : a6c5                  	dw	io_null_op			; io_close_f
c5b2 : a6c5                  	dw	io_null_op			; io_del_f
c5b4 : a6c5                  	dw	io_null_op			; io_ext1
c5b6 : a6c5                  	dw	io_null_op			; io_ext2
                             ;* Device one is keyboard / screen
                             ;* only offers get and put
c5b8 :                       io_device1					; Default device, input = screen e
c5b8 : 96c1                  	dw	_gr_get_key			; io_get_ch
c5ba : aec1                  	dw	_gr_put_byte		; io_put_ch
c5bc : a6c5                  	dw	io_null_op			; io_open_r
AS65 Assembler for R6502 [1.42].                                     Page   29
-------------------------------- bank\bank3.s --------------------------------

c5be : a6c5                  	dw	io_null_op			; io_open_w
c5c0 : a6c5                  	dw	io_null_op			; io_close_f
c5c2 : a6c5                  	dw	io_null_op			; io_del_f
c5c4 : a6c5                  	dw	io_null_op			; io_ext1
c5c6 : a6c5                  	dw	io_null_op			; io_ext2
                             ;* Device two is the file system on SD card
                             ;* Offers all IO functions
c5c8 :                       io_device2					; SD device, input = SD, output = 
c5c8 : bec0                  	dw	_fs_get_byte_w		; io_get_ch
c5ca : 06c1                  	dw	_fs_put_byte_w		; io_put_ch
c5cc : d6c0                  	dw	_fs_open_read_w		; io_open_r
c5ce : eec0                  	dw	_fs_open_write_w	; io_open_w
c5d0 : a6c0                  	dw	_fs_close_w			; io_close_f
c5d2 : 8ec0                  	dw	_fs_delete_w		; io_del_f
c5d4 : a6c5                  	dw	io_null_op			; io_ext1
c5d6 : a6c5                  	dw	io_null_op			; io_ext2
                             
c5d8 :                       mod_sz_io_e
                             
                             
                             	include "kernel\vdp-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  VDP-LOW.S
                             ;*  Low level VDP routines which will always be p
                             ;*  every ROM bank.  This is to ensure if IRQ nee
                             ;*  no slow bank switching is needed, but also to
                             ;*	OS vectored access to VDP routines for M/C fro
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* vdp_wr_reg
                             ;* Write to Register A the value X
                             ;* Input : A - Register Number, X - Data
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c5d8 :                       vdp_wr_reg
c5d8 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c5db : ea               [ 2] 	nop
c5dc : ea               [ 2] 	nop
c5dd : 0980             [ 2] 	ora #0x80
c5df : 8d0105           [ 4] 	sta VDP_MODE1
c5e2 : 4980             [ 2] 	eor #0x80
c5e4 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* vdp_wr_addr
                             ;* Write to address in X (low) and A (high) - for
                             ;* Input : A - Address high byte, X - Address low
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c5e5 :                       vdp_wr_addr
AS65 Assembler for R6502 [1.42].                                     Page   30
-------------------------------- bank\bank3.s --------------------------------

c5e5 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c5e8 : ea               [ 2] 	nop
c5e9 : ea               [ 2] 	nop
c5ea : 0940             [ 2] 	ora #0x40		; Required by VDP
c5ec : 8d0105           [ 4] 	sta VDP_MODE1
c5ef : 4940             [ 2] 	eor #0x40		; Undo that bit
c5f1 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* vdp_mem_wait
                             ;* Delay some time before a memory access,
                             ;* taking in to account mode 9918 needs up
                             ;* to 3.1uS for text mode, 8uS for graphics
                             ;* I and II
                             ;* @ 5.35Mhz	= 16 cycles for 3.1uS
                             ;*				= 43 cycles for 8uS
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c5f2 :                       vdp_mem_wait
c5f2 : da               [ 3] 	phx								; 3
c5f3 : a616             [ 3] 	ldx vdp_delay					; 3
c5f5 : f003             [ 3] 	beq vdp_mem_wait_end			; 3
c5f7 :                       vdp_mem_wait_loop
c5f7 : ca               [ 2] 	dex								; 2
c5f8 : d0fd             [ 3] 	bne	vdp_mem_wait_loop			; 3
c5fa :                       vdp_mem_wait_end
c5fa : fa               [ 4] 	plx								; 3
c5fb : 60               [ 6] 	rts								; 6
                             	
                             ;****************************************
                             ;* vdp_rd_addr
                             ;* Set read address 
                             ;* Input : A - high, X - low 
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c5fc :                       vdp_rd_addr
c5fc : 8e0105           [ 4] 	stx VDP_MODE1
                             ; These nops are needed for fast CPU
c5ff : ea               [ 2] 	nop
c600 : ea               [ 2] 	nop
c601 : 8d0105           [ 4] 	sta VDP_MODE1
c604 : 80ec             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_rd_vram
                             ;* Read VRAM byte, result in A
                             ;* Input : None
                             ;* Output : A - Byte from VRAM
                             ;* Regs affected : P
                             ;****************************************
c606 :                       vdp_rd_vram
c606 : ad0005           [ 4] 	lda VDP_VRAM
c609 : 80e7             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_wr_vram
                             ;* Write VRAM byte in A
AS65 Assembler for R6502 [1.42].                                     Page   31
-------------------------------- bank\bank3.s --------------------------------

                             ;* Input : A - Byte to write
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c60b :                       vdp_wr_vram
c60b : 8d0005           [ 4] 	sta VDP_VRAM
c60e : 80e2             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_poke
                             ;* Write VRAM byte in A, (YX)
                             ;* Input : A - Byte to write
                             ;*		   X = Low Address
                             ;*		   Y = High Address
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c610 :                       vdp_poke
c610 : 48               [ 3] 	pha
c611 : 98               [ 2] 	tya
c612 : 78               [ 2] 	sei
c613 : 20e5c5           [ 6] 	jsr vdp_wr_addr
c616 : 68               [ 4] 	pla
c617 : 200bc6           [ 6] 	jsr vdp_wr_vram
c61a : 58               [ 2] 	cli
c61b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* vdp_peek
                             ;* Get VRAM byte in (AX)
                             ;*		   X = Low Address
                             ;*		   A = High Address
                             ;* Output : A = byte read
                             ;* Regs affected : None
                             ;****************************************
c61c :                       vdp_peek
c61c : 78               [ 2] 	sei
c61d : 20fcc5           [ 6] 	jsr vdp_rd_addr
c620 : 2006c6           [ 6] 	jsr vdp_rd_vram
c623 : 58               [ 2] 	cli
c624 : 60               [ 6] 	rts
                             
                             	include "kernel\snd-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SND-LOW.S
                             ;*  Low level sound routines which will always be
                             ;*  in every ROM bank.  Mainly to provide fast OS
                             ;*	access to VDP routines for M/C from BASIC
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* snd_set
                             ;* Set AY register X to value Y
                             ;* Input : X = Reg no, Y = Value
AS65 Assembler for R6502 [1.42].                                     Page   32
-------------------------------- bank\bank3.s --------------------------------

                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c625 :                       snd_set
c625 : 48               [ 3] 	pha
                             
c626 : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c628 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c62b : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c62e : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c631 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c633 : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c635 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c638 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c63a : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             	
c63d : 8c8104           [ 4] 	sty SND_ADBUS			; Put Y on the sound bus (Y = va
c640 : 0902             [ 2] 	ora #SND_SELWRITE		; Select mode for writing dat
c642 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             	
c645 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c647 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c64a : 68               [ 4] 	pla
                             	
c64b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get
                             ;* Get AY register X to Y
                             ;* Input : X = Reg no
                             ;* Output : Y = Value
                             ;* Regs affected : None
                             ;****************************************
c64c :                       snd_get
c64c : 48               [ 3] 	pha
                             
c64d : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c64f : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c652 : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c655 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c658 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c65a : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c65c : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c65f : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c661 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c664 : a900             [ 2] 	lda #0x00				; Set Port A to input
c666 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c669 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c66c : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c66e : 0940             [ 2] 	ora #SND_SELREAD		; Select mode for reading data
c670 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c673 : ac8104           [ 4] 	ldy SND_ADBUS			; Get value in to Y
AS65 Assembler for R6502 [1.42].                                     Page   33
-------------------------------- bank\bank3.s --------------------------------

                             	
c676 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c678 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c67b : 68               [ 4] 	pla
                             	
c67c : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get_joy0
                             ;* Return value of joystick 0
                             ;* Input : None
                             ;* Output : Y = Value
                             ;* Regs affected : X
                             ;****************************************
c67d :                       snd_get_joy0
c67d : a20f             [ 2] 	ldx #SND_REG_IOB		; Joystick is plugged in to IO
c67f : 204cc6           [ 6] 	jsr snd_get				; Get IOB, result in Y
c682 : 60               [ 6] 	rts
                             
                             	include "kernel\main.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  MAIN.S
                             ;*  This is where the main user program is execut
                             ;*  the 'kernel' once the system is initialised a
                             ;*  Today, main does very little - first shows th
                             ;*  boot up message, and then passes control to d
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
c683 :                       main
                             
c683 :                       infinity
c683 : 2046c0           [ 6] 	jsr _df_pg_dflat
c686 : 4c83c6           [ 3] 	jmp infinity
                             
c689 :                       msg_hello_world
                             	;* build.s is generated by the assemble.bat file
                             	;* all it does is echo an assembler line to
                             	;* including the build date in the message.
                             	include "kernel\build.s"
c689 : 4275696c64203a..       db "Build : 20/07/2023\r" 
c69c : 3132384b204272..       db "128K Breadboard Computer\r" 
c6b5 : 42792040363530..       db "By @6502Nerd\r" 
c6c2 : 436f7079726967..       db "Copyright (c) 2022\r",0 
                             
                             
                             	include "kernel\irq.s"
                             	
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
AS65 Assembler for R6502 [1.42].                                     Page   34
-------------------------------- bank\bank3.s --------------------------------

                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IRQ.S
                             ;*	This is the IRQ handler - handles both the ver
                             ;*  blank interrupt from the VDP as well as softw
                             ;*  
                             ;*  As the handler has to be in every bank and it
                             ;*  accesses the VDP, then low level VDP routines
                             ;*  bundled in this file to ensure they are alway
                             ;*  without a bank switch being needed (which is 
                             ;************************************************
                             
                             ;* NMI handler installs to handle serial receive 
c6d6 :                       init_nmi
                             	; Core IRQ handler
c6d6 : a9e2             [ 2] 	lda #lo(nmi)
c6d8 : 8502             [ 3] 	sta int_nmi
c6da : a9c6             [ 2] 	lda #hi(nmi)
c6dc : 8503             [ 3] 	sta int_nmi+1
c6de : 60               [ 6] 	rts
                             
                             ;* Calls the master IRQ handler
c6df :                       call_nmi_master
c6df : 6c0200           [ 6] 	jmp (int_nmi)
                             
                             ;* Master NMI handler
                             ;* Only the 6551 uses this - fills the receive bu
c6e2 :                       nmi
c6e2 : 48               [ 3] 	pha
                             
c6e3 : ad8105           [ 4] 	lda SER_STATUS				; Read status register (clears
c6e6 : 100c             [ 3] 	bpl	nmi_fin					; If no interrupt don't do anyth
                             
c6e8 : 5a               [ 3] 	phy
c6e9 : ad8005           [ 4] 	lda SER_DATA				; Read the data register of 6551
c6ec : a40f             [ 3] 	ldy ser_last				; Put byte in last position of F
c6ee : 990008           [ 5] 	sta ser_buf,y
c6f1 : e60f             [ 5] 	inc ser_last				; Advance position of last
                             
c6f3 : 7a               [ 4] 	ply
c6f4 :                       nmi_fin
                             
c6f4 : 68               [ 4] 	pla
c6f5 : 40               [ 6] 	rti
                             
                             
                             ;* Obviously this can only be done with
                             ;* interrupts disabled!
c6f6 :                       init_irq
                             	; Core IRQ handler
c6f6 : a930             [ 2] 	lda #lo(irq)
c6f8 : 8504             [ 3] 	sta int_irq
c6fa : a9c7             [ 2] 	lda #hi(irq)
c6fc : 8505             [ 3] 	sta int_irq+1
                             	
                             	; Core BRK handler
c6fe : a95e             [ 2] 	lda #lo(irq_brk)
c700 : 8506             [ 3] 	sta int_brk
c702 : a9c7             [ 2] 	lda #hi(irq_brk)
AS65 Assembler for R6502 [1.42].                                     Page   35
-------------------------------- bank\bank3.s --------------------------------

c704 : 8507             [ 3] 	sta int_brk+1
                             
                             	; User handlers for VDP, PIA0, PIA1 interrupts
c706 : a92f             [ 2] 	lda #lo(null_handler)
c708 : 8508             [ 3] 	sta int_uservdp
c70a : a9c7             [ 2] 	lda #hi(null_handler)
c70c : 8509             [ 3] 	sta int_uservdp+1
                             
c70e : a92f             [ 2] 	lda #lo(null_handler)
c710 : 850a             [ 3] 	sta int_usercia0
c712 : a9c7             [ 2] 	lda #hi(null_handler)
c714 : 850b             [ 3] 	sta int_usercia0+1
                             
c716 : a92f             [ 2] 	lda #lo(null_handler)
c718 : 850c             [ 3] 	sta int_usercia1
c71a : a9c7             [ 2] 	lda #hi(null_handler)
c71c : 850d             [ 3] 	sta int_usercia1+1
                             
c71e : 60               [ 6] 	rts
                             
                             ;* Calls the master IRQ handler
c71f :                       call_irq_master
c71f : 6c0400           [ 6] 	jmp (int_irq)
                             	
                             ;* Calls the BRK handler
c722 :                       call_irq_brk
c722 : 6c0600           [ 6] 	jmp (int_brk)
                             
                             ;* Call the userVDP handler
c725 :                       call_irq_uservdp
c725 : 6c0800           [ 6] 	jmp (int_uservdp)
                             	
                             ;* Call the user CIA0 handler
c728 :                       call_irq_usercia0
c728 : 6c0a00           [ 6] 	jmp (int_usercia0)
                             
                             ;* Call the user CIA1 handler
c72b :                       call_irq_usercia1
c72b : 6c0c00           [ 6] 	jmp (int_usercia1)
                             	
                             ;* null interrupt
c72e :                       null_irq
c72e : 40               [ 6] 	rti
                             
                             ;* null handler
c72f :                       null_handler
c72f : 60               [ 6] 	rts
                             	
                             
                             ;* Master IRQ handler
c730 :                       irq
                             	_pushAXY
                             
                             
                             	; Check if IRQ or BRK
                             	; load P from stack in to A
c733 : ba               [ 2] 	tsx
c734 : bd0401           [ 4] 	lda 0x104,x
                             	; BRK bit set?
c737 : 2910             [ 2] 	and #0x10
c739 : d0e7             [ 3] 	bne call_irq_brk
                             	
AS65 Assembler for R6502 [1.42].                                     Page   36
-------------------------------- bank\bank3.s --------------------------------

c73b : 18               [ 2] 	clc						; Standard behaviour
                             	
                             	;* Try PIA1 first for rapid Timer handling
c73c : ad8d04           [ 4] 	lda IO_1 + IFR
c73f : 1003             [ 3] 	bpl irq_check_vdp
c741 : 202bc7           [ 6] 	jsr call_irq_usercia1	; Call user cia1 handler
                             
                             	;* Try VDP next
c744 :                       irq_check_vdp	
c744 : ad0105           [ 4] 	lda VDP_STATUS			; Read status register
c747 : 1009             [ 3] 	bpl	irq_check_cia0		; Skip if not VBLANK
c749 : 2025c7           [ 6] 	jsr call_irq_uservdp	; Call use VDP handler
c74c : 20abc7           [ 6] 	jsr int_vdp_handler		; Call  OS VDP handler
c74f : 2089c7           [ 6] 	jsr int_kb_handler		; Call OS cia0 handler (keyb
                             
                             	;* Try VIA0 last as it's keyboard (low speed)
c752 :                       irq_check_cia0
c752 : ad0d04           [ 4] 	lda IO_0 + IFR
c755 : 1003             [ 3] 	bpl irq_fin
c757 : 2028c7           [ 6] 	jsr call_irq_usercia0	; Call user cia0 handler
                             
c75a :                       irq_fin
                             	_pullAXY
                             
c75d : 40               [ 6] 	rti
                             	
                             ;* Handle BRK
c75e :                       irq_brk
                             	; Handle BRK
                             	; Get PCL,H minus 2 gives the BRK instruction ad
c75e : 38               [ 2] 	sec
c75f : bd0501           [ 4] 	lda 0x0105,x
c762 : e902             [ 2] 	sbc #2
c764 : 85a4             [ 3] 	sta df_brkpc
c766 : bd0601           [ 4] 	lda 0x0106,x
c769 : e900             [ 2] 	sbc #0
c76b : 85a5             [ 3] 	sta df_brkpc+1
                             	; Get the byte pointed to by old PC
                             	; which is 1 on from the BRK
c76d : a001             [ 2] 	ldy #1
c76f : b1a4             [ 5] 	lda (df_brkpc),y
c771 : 85a6             [ 3] 	sta df_brkval
c773 : 859f             [ 3] 	sta errno
                             	; now update the return address
c775 : a5a2             [ 3] 	lda df_pc
c777 : 9d0501           [ 5] 	sta 0x105,x
c77a : a5a3             [ 3] 	lda df_pc+1
c77c : 9d0601           [ 5] 	sta 0x106,x
                             	
                             	_pullAXY
                             
                             	; Save the registers in temp area
c782 : 8585             [ 3] 	sta num_a
c784 : 8686             [ 3] 	stx num_a+1
c786 : 8487             [ 3] 	sty num_a+2
                             	; when RTI occurs:
                             	;  will return to error handler
                             	;  df_brkval will contain signature
c788 : 40               [ 6] 	rti
                             	
                             ;****************************************
                             ;* int_kb_handler
AS65 Assembler for R6502 [1.42].                                     Page   37
-------------------------------- bank\bank3.s --------------------------------

                             ;* Keyboard interrupt handler
                             ;****************************************
c789 :                       int_kb_handler	
c789 : a537             [ 3] 	lda kb_deb				; If keyboard pressed is debounce 
c78b : d00d             [ 3] 	bne int_skip_scan		; If not zero, then don't che
c78d : ad0d04           [ 4] 	lda IO_0 + IFR			; Check status register CIA0
c790 : 2901             [ 2] 	and #IFR_CA2			; Keyboard pressed?
c792 : f00c             [ 3] 	beq int_keys_up
c794 :                       int_do_read
c794 : 853c             [ 3] 	sta kb_pressed			; Put non-zero in to this flag
c796 : a53b             [ 3] 	lda kb_debounce			; Set debounce
c798 : 8537             [ 3] 	sta kb_deb
c79a :                       int_skip_scan
c79a : a901             [ 2] 	lda #IFR_CA2			; Clear CA2
c79c : 8d0d04           [ 4] 	sta IO_0 + IFR
c79f : 60               [ 6] 	rts
c7a0 :                       int_keys_up					; No key pressed
c7a0 : 6433             [ 3] 	stz kb_raw				; Using 65c02 stz opcode
c7a2 : 6434             [ 3] 	stz kb_last
c7a4 : 6435             [ 3] 	stz kb_code
c7a6 : 6437             [ 3] 	stz kb_deb
c7a8 : 6438             [ 3] 	stz kb_rep
c7aa : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* int_vdp_handler
                             ;* VDP interrupt handler
                             ;****************************************
c7ab :                       int_vdp_handler
c7ab : 20d7c7           [ 6] 	jsr update_timers	; If it is then update system 
                             
c7ae : a512             [ 3] 	lda vdp_curoff		; Is cursor enabled?
c7b0 : d024             [ 3] 	bne int_vdp_fin		; Skip if not
                             
c7b2 : c613             [ 5] 	dec vdp_curstat		; Decrement VDP counter
c7b4 : a513             [ 3] 	lda vdp_curstat		; Check it
c7b6 : 297f             [ 2] 	and #0x7f			; If bottom 7 bits !=0
c7b8 : d01c             [ 3] 	bne int_vdp_fin		; No flashing to be done
c7ba : a513             [ 3] 	lda vdp_curstat		; Invert top bit (bottoms bits=
c7bc : 4990             [ 2] 	eor #0x80+VDP_FLASH	; Start counter again
c7be : 8513             [ 3] 	sta vdp_curstat		
                             
c7c0 : 18               [ 2] 	clc					; Add offset for cursor address in vram
c7c1 : a52c             [ 3] 	lda gr_scrngeom+gr_cur_ptr
c7c3 : 6529             [ 3] 	adc gr_scrngeom+gr_cur_off
c7c5 : aa               [ 2] 	tax
c7c6 : a52d             [ 3] 	lda gr_scrngeom+gr_cur_ptr+1
c7c8 : 6900             [ 2] 	adc #0
                             
c7ca : 20e5c5           [ 6] 	jsr vdp_wr_addr
                             	
c7cd : a513             [ 3] 	lda vdp_curstat
c7cf : 2980             [ 2] 	and #0x80
c7d1 : 4514             [ 3] 	eor vdp_curval		; EOR top bit with what is under
c7d3 : 200bc6           [ 6] 	jsr vdp_wr_vram
c7d6 :                       int_vdp_fin	
c7d6 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* update_timers
                             ;* Update 24 bit timer and debounce counters
AS65 Assembler for R6502 [1.42].                                     Page   38
-------------------------------- bank\bank3.s --------------------------------

                             ;****************************************
c7d7 :                       update_timers
c7d7 : e610             [ 5] 	inc vdp_int_cnt
c7d9 : d002             [ 3] 	bne inc_kb_timers
c7db : e611             [ 5] 	inc vdp_int_cnt+1
c7dd :                       inc_kb_timers
c7dd : a637             [ 3] 	ldx kb_deb			; Is debounce 0?
c7df : f002             [ 3] 	beq skip_kb_deb
c7e1 : c637             [ 5] 	dec kb_deb
c7e3 :                       skip_kb_deb
c7e3 : a638             [ 3] 	ldx kb_rep			; Is repeat timer 0?
c7e5 : f002             [ 3] 	beq skip_kb_rep
c7e7 : c638             [ 5] 	dec kb_rep
c7e9 :                       skip_kb_rep
c7e9 : 60               [ 6] 	rts
                             	
                             
                             	include "utils\misc.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  MISC.S
                             ;*  Miscellaneous module for commmon utility func
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* long_delay
                             ;* Long delay (X decremented every 0.125ms)
                             ;* Input : X = number of 0.125ms ticks to wait (m
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c7ea :                       long_delay
c7ea : 08               [ 3] 	php
                             	_pushAXY
                             
                             	
c7ee : a000             [ 2] 	ldy #0x00
c7f0 :                       long_delay_1
c7f0 : ea               [ 2] 	nop
c7f1 : ea               [ 2] 	nop
c7f2 : ea               [ 2] 	nop
c7f3 : ea               [ 2] 	nop
c7f4 : 88               [ 2] 	dey
c7f5 : d0f9             [ 3] 	bne long_delay_1
c7f7 : ca               [ 2] 	dex
c7f8 : d0f6             [ 3] 	bne long_delay_1
                             
                             	_pullAXY
                             
c7fd : 28               [ 4] 	plp
                             	
c7fe : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   39
-------------------------------- bank\bank3.s --------------------------------

                             
                             
                             	include "utils\utils.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  UTILS.S
                             ;*  This module implements various utility functi
                             ;*  converting from ASCII to binary form for numb
                             ;*  vice-versa to allow humans to actually be abl
                             ;*  and read numbers in their prefered form!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c7ff :                       utilPrintSPC
c7ff : 48               [ 3] 	pha
c800 : a920             [ 2] 	lda #' '
c802 : 2048c5           [ 6] 	jsr io_put_ch
c805 : 68               [ 4] 	pla
c806 : 60               [ 6] 	rts
                             
c807 :                       utilPrintCRLF
c807 : 48               [ 3] 	pha
c808 : a90d             [ 2] 	lda #UTF_CR
c80a : 2048c5           [ 6] 	jsr io_put_ch
c80d : 68               [ 4] 	pla
c80e : 60               [ 6] 	rts
                             
c80f :                       utilPrintA
c80f : 8545             [ 3] 	sta tmp_d
c811 : 48               [ 3] 	pha
c812 : 8a               [ 2] 	txa
c813 : 48               [ 3] 	pha
c814 : a545             [ 3] 	lda tmp_d
c816 : 2034c8           [ 6] 	jsr str_a_to_x
c819 : 2048c5           [ 6] 	jsr io_put_ch
c81c : 8a               [ 2] 	txa
c81d : 2048c5           [ 6] 	jsr io_put_ch
c820 : 68               [ 4] 	pla
c821 : aa               [ 2] 	tax
c822 : 68               [ 4] 	pla
c823 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* util_clr_mem
                             ;* Clear a block of main ram
                             ;* Input : X, A = Block start, Y = Block size
                             ;* Regs affected : P
                             ;****************************************
c824 :                       util_clr_mem
c824 : 48               [ 3] 	pha
c825 : 5a               [ 3] 	phy
c826 : 863f             [ 3] 	stx tmp_v1
c828 : 8540             [ 3] 	sta tmp_v1+1
AS65 Assembler for R6502 [1.42].                                     Page   40
-------------------------------- bank\bank3.s --------------------------------

c82a : a900             [ 2] 	lda #0
c82c :                       mem_clr_byte
c82c : 88               [ 2] 	dey
c82d : 913f             [ 5] 	sta (tmp_v1),y
c82f : d0fb             [ 3] 	bne mem_clr_byte
c831 : 7a               [ 4] 	ply
c832 : 68               [ 4] 	pla
c833 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* str_a_to_x
                             ;* Convert accumulator to hex string
                             ;* Input : A = Byte to convert
                             ;* Output : A = High Char, X = Low Char
                             ;* Regs affected : P
                             ;****************************************
c834 :                       str_a_to_x
c834 : 48               [ 3] 	pha					; Save the byte using later on
c835 : 290f             [ 2] 	and #0x0f			; Mask low nibble
c837 : 18               [ 2] 	clc
c838 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c83a : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c83c : 9002             [ 3] 	bcc skip_a_f_1		; skip a-f adjustment
c83e : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c840 :                       skip_a_f_1
c840 : aa               [ 2] 	tax					; Low char is in X
c841 : 68               [ 4] 	pla					; Get byte back
c842 : 4a               [ 2] 	lsr a				; Make high nibble low
c843 : 4a               [ 2] 	lsr a
c844 : 4a               [ 2] 	lsr a
c845 : 4a               [ 2] 	lsr a
c846 : 18               [ 2] 	clc
c847 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c849 : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c84b : 9002             [ 3] 	bcc skip_a_f_2		; skip a-f adjustment
c84d : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c84f :                       skip_a_f_2
                             
c84f : 18               [ 2] 	clc					; No error
c850 : 60               [ 6] 	rts					; A high nibble
                             
                             ;****************************************
                             ;* str_x_to_a
                             ;* Convert hex string to accumulator
                             ;* Input : A = High Char, X = Low Char
                             ;* Output : A = Value
                             ;* Regs affected : P
                             ;****************************************
c851 :                       str_x_to_a
c851 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c853 : 38               [ 2] 	sec					; Process high char in A
c854 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c856 : c90a             [ 2] 	cmp #10				; If A < 10 then
c858 : 9002             [ 3] 	bcc skip_x_f_1		; skip a-f adjustment
c85a : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c85c :                       skip_x_f_1
c85c : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c85e : b01d             [ 3] 	bcs	str_x_to_a_err	; Error if not
                             
c860 : 0a               [ 2] 	asl a				; This is the high nibble
c861 : 0a               [ 2] 	asl a
c862 : 0a               [ 2] 	asl a
AS65 Assembler for R6502 [1.42].                                     Page   41
-------------------------------- bank\bank3.s --------------------------------

c863 : 0a               [ 2] 	asl a
c864 : 48               [ 3] 	pha					; Save the high nibble
c865 : 8a               [ 2] 	txa					; Now process the low char in X
c866 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c868 : 38               [ 2] 	sec
c869 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c86b : c90a             [ 2] 	cmp #10				; If A < 10 then
c86d : 9002             [ 3] 	bcc skip_x_f_2		; skip a-f adjustment
c86f : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c871 :                       skip_x_f_2
c871 : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c873 : b007             [ 3] 	bcs	str_x_to_a_errl	; Error if not
                             
c875 : 8585             [ 3] 	sta num_a			; Store low nibble in temp
c877 : 68               [ 4] 	pla					; Get high nibble
c878 : 0585             [ 3] 	ora num_a			; OR with low nibble
                             
c87a : 18               [ 2] 	clc					; No error
c87b : 60               [ 6] 	rts					; A contains value
                             
c87c :                       str_x_to_a_errl
c87c : 68               [ 4] 	pla
c87d :                       str_x_to_a_err
                             	SWBRK CMD_ERR_VAL
                             
                             
                             ;****************************************
                             ;* con_n_to_a
                             ;* Convert numeric string to accumulator (unsigne
                             ;* Input : Pointer to string (X=L, A=H), Y = Sour
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* A = Source type detected
                             ;* Regs affected : CS = Error
                             ;****************************************
c87f :                       con_n_to_a
c87f : 8691             [ 3] 	stx num_tmp
c881 : 8592             [ 3] 	sta num_tmp+1
c883 : 6485             [ 3] 	stz num_a
c885 : 6486             [ 3] 	stz num_a+1
c887 : c000             [ 2] 	cpy #NUM_ANY
c889 : f014             [ 3] 	beq con_n_to_a_detect
c88b : 88               [ 2] 	dey
c88c : d003             [ 3] 	bne con_n_not_dec
c88e :                       con_dec_jmp
c88e : 4c22c9           [ 3] 	jmp con_dec_to_a_int
c891 :                       con_n_not_dec
c891 : 88               [ 2] 	dey
c892 : d003             [ 3] 	bne con_n_not_hex
c894 :                       con_hex_jmp
c894 : 4cb9c8           [ 3] 	jmp con_hex_to_a_int
c897 :                       con_n_not_hex
c897 : 88               [ 2] 	dey
c898 : d003             [ 3] 	bne con_n_err
c89a :                       con_bin_jmp
c89a : 4cf8c8           [ 3] 	jmp con_bin_to_a_int
c89d :                       con_n_err
c89d : 38               [ 2] 	sec
c89e : 60               [ 6] 	rts
c89f :                       con_n_to_a_detect
c89f : b291             [ 5] 	lda (num_tmp)
c8a1 : c930             [ 2] 	cmp #'0'
c8a3 : d0e9             [ 3] 	bne con_dec_jmp
AS65 Assembler for R6502 [1.42].                                     Page   42
-------------------------------- bank\bank3.s --------------------------------

c8a5 : a001             [ 2] 	ldy #1
c8a7 : b191             [ 5] 	lda (num_tmp),y
c8a9 : 0920             [ 2] 	ora #0x20
c8ab : c978             [ 2] 	cmp #'x'
c8ad : f0e5             [ 3] 	beq con_hex_jmp
c8af : c962             [ 2] 	cmp #'b'
c8b1 : f0e7             [ 3] 	beq con_bin_jmp
c8b3 : 80d9             [ 3] 	bra con_dec_jmp
                             
                             ;****************************************
                             ;* con_hex_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c8b5 :                       con_hex_to_a
c8b5 : 8691             [ 3] 	stx num_tmp
c8b7 : 8592             [ 3] 	sta num_tmp+1
c8b9 :                       con_hex_to_a_int
c8b9 : a205             [ 2] 	ldx #5			; > 4 digits will cause error
c8bb : a002             [ 2] 	ldy #2			; start at first digit
c8bd :                       con_hex_digit
c8bd : b191             [ 5] 	lda (num_tmp),y
c8bf : 0920             [ 2] 	ora #0x20					; Make alpha in to lower case
c8c1 : 38               [ 2] 	sec							; Process high char in A
c8c2 : e930             [ 2] 	sbc #'0'					; Convert to hex nibble
c8c4 : c90a             [ 2] 	cmp #10						; If A < 10 then
c8c6 : 9002             [ 3] 	bcc con_hex_skip_x_f_1		; skip a-f adjustment
c8c8 : e927             [ 2] 	sbc #0x27					; Sub 7 to get in to A-F range
c8ca :                       con_hex_skip_x_f_1
c8ca : c910             [ 2] 	cmp #0x10					; Nibble should be <= 0x0f
c8cc : b01c             [ 3] 	bcs	con_hex_done			; Potentially done if not
c8ce : 48               [ 3] 	pha
                             	; make room for lo nibble
c8cf : 0685             [ 5] 	asl num_a
c8d1 : 2686             [ 5] 	rol num_a+1
c8d3 : 0685             [ 5] 	asl num_a
c8d5 : 2686             [ 5] 	rol num_a+1
c8d7 : 0685             [ 5] 	asl num_a
c8d9 : 2686             [ 5] 	rol num_a+1
c8db : 0685             [ 5] 	asl num_a
c8dd : 2686             [ 5] 	rol num_a+1
                             	; save in low nibble
c8df : 68               [ 4] 	pla
c8e0 : 0585             [ 3] 	ora num_a
c8e2 : 8585             [ 3] 	sta num_a
c8e4 : c8               [ 2] 	iny
c8e5 : ca               [ 2] 	dex
c8e6 : d0d5             [ 3] 	bne con_hex_digit
                             	; if got to a 5th digit then error
c8e8 :                       con_hex_err
c8e8 : 38               [ 2] 	sec
c8e9 : 60               [ 6] 	rts
                             	; found a non-hex digit
c8ea :                       con_hex_done
                             	; if no digits processed then error
c8ea : c002             [ 2] 	cpy #2
c8ec : f0fa             [ 3] 	beq con_hex_err
                             	; move y to x for digits processed
c8ee : 98               [ 2] 	tya
c8ef : aa               [ 2] 	tax
AS65 Assembler for R6502 [1.42].                                     Page   43
-------------------------------- bank\bank3.s --------------------------------

c8f0 : a902             [ 2] 	lda #NUM_HEX
c8f2 : 18               [ 2] 	clc
c8f3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_bin_to_a
                             ;* Convert binary string to accumulator (unsigned
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c8f4 :                       con_bin_to_a
c8f4 : 8691             [ 3] 	stx num_tmp
c8f6 : 8592             [ 3] 	sta num_tmp+1
c8f8 :                       con_bin_to_a_int
c8f8 : a002             [ 2] 	ldy #2
c8fa : a211             [ 2] 	ldx #17						; Max 16 binary digits allowed
c8fc :                       con_bin_digit
c8fc : b191             [ 5] 	lda (num_tmp),y
c8fe : c930             [ 2] 	cmp #'0'
c900 : 9010             [ 3] 	bcc con_bin_done
c902 : c932             [ 2] 	cmp #'1'+1
c904 : b00c             [ 3] 	bcs con_bin_done
                             	; sets C if '1' else resets C
c906 : 69cf             [ 2] 	adc #0xff-'0'
                             	; shift in digit
c908 : 2685             [ 5] 	rol num_a
c90a : 2686             [ 5] 	rol num_a+1
c90c : c8               [ 2] 	iny
c90d : ca               [ 2] 	dex
c90e : d0ec             [ 4] 	bne con_bin_digit
                             	; on the 17th digit is too much, error
c910 : 800a             [ 3] 	bra con_bin_err
c912 :                       con_bin_done
                             	; didn't process any digit = error
c912 : c002             [ 2] 	cpy #2
c914 : f006             [ 3] 	beq con_bin_err
                             	; put digits processed in to X
c916 : 98               [ 2] 	tya
c917 : aa               [ 2] 	tax
c918 : a903             [ 2] 	lda #NUM_BIN
c91a : 18               [ 2] 	clc
c91b : 60               [ 6] 	rts
c91c :                       con_bin_err
c91c : 38               [ 2] 	sec
c91d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_d_to_a
                             ;* Convert decimal string to accumulator (SIGNED)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c91e :                       con_dec_to_a
c91e : 8691             [ 3] 	stx num_tmp
c920 : 8592             [ 3] 	sta num_tmp+1
c922 :                       con_dec_to_a_int
c922 : a000             [ 2] 	ldy #0
                             	; Detect if leading minus sign
c924 : b291             [ 5] 	lda (num_tmp)
c926 : c92d             [ 2] 	cmp #'-'
AS65 Assembler for R6502 [1.42].                                     Page   44
-------------------------------- bank\bank3.s --------------------------------

c928 : d001             [ 3] 	bne str_d_find_end
                             	; skip over minus if found
c92a : c8               [ 2] 	iny
c92b :                       str_d_find_end
c92b : b191             [ 5] 	lda (num_tmp),y
c92d : c930             [ 2] 	cmp #'0'
c92f : 9007             [ 3] 	bcc str_d_found_end
c931 : c93a             [ 2] 	cmp #'9'+1
c933 : b003             [ 3] 	bcs str_d_found_end
c935 : c8               [ 2] 	iny
c936 : 80f3             [ 3] 	bra str_d_find_end
c938 :                       str_d_found_end
c938 : c007             [ 2] 	cpy #6+1			; Biggest int is 6 chars
c93a : b052             [ 3] 	bcs str_d_error		; e.g. -32767 including minus
c93c : 8494             [ 3] 	sty num_tmp+3
c93e : 6493             [ 3] 	stz num_tmp+2
c940 : 6485             [ 3] 	stz num_a
c942 : 6486             [ 3] 	stz num_a+1
c944 :                       str_d_process_digit
c944 : 88               [ 2] 	dey
c945 : 3026             [ 3] 	bmi str_d_digits_done
                             
c947 : b191             [ 5] 	lda (num_tmp),y
                             
c949 : c92d             [ 2] 	cmp #'-'			; Got to minus sign?
c94b : f020             [ 3] 	beq str_d_digits_done ; also done
                             
c94d : 38               [ 2] 	sec
c94e : e930             [ 2] 	sbc #'0'
                             	; Convert digit to number
                             	; and then offset in to
                             	; look up table of powers
c950 : 18               [ 2] 	clc
c951 : 0a               [ 2] 	asl a
c952 : 6593             [ 3] 	adc num_tmp+2
                             	; X contains index to powers
c954 : aa               [ 2] 	tax
c955 : a585             [ 3] 	lda num_a
c957 : 7d90c9           [ 4] 	adc str_d_powers,x
c95a : 8585             [ 3] 	sta num_a
c95c : a586             [ 3] 	lda num_a+1
c95e : 7d91c9           [ 4] 	adc str_d_powers+1,x
c961 : 8586             [ 3] 	sta num_a+1
c963 : b029             [ 3] 	bcs str_d_error
                             	; Move to next power of 10 index
c965 : a593             [ 3] 	lda num_tmp+2
c967 : 6914             [ 2] 	adc #20
c969 : 8593             [ 3] 	sta num_tmp+2
c96b : 80d7             [ 3] 	bra str_d_process_digit
c96d :                       str_d_digits_done
                             	; check if minus
c96d : b291             [ 5] 	lda (num_tmp)
c96f : c92d             [ 2] 	cmp #'-'
c971 : d011             [ 3] 	bne str_d_skip_neg
c973 : a694             [ 3] 	ldx num_tmp+3		; Must have >= 2 chars
c975 : e002             [ 2] 	cpx #2				; else it's an error
c977 : 9015             [ 3] 	bcc str_d_error
c979 : a685             [ 3] 	ldx num_a
c97b : a586             [ 3] 	lda num_a+1
c97d : 20f4c9           [ 6] 	jsr twos_complement
c980 : 8685             [ 3] 	stx num_a
c982 : 8586             [ 3] 	sta num_a+1
AS65 Assembler for R6502 [1.42].                                     Page   45
-------------------------------- bank\bank3.s --------------------------------

c984 :                       str_d_skip_neg
c984 : a694             [ 3] 	ldx num_tmp+3
c986 : e001             [ 2] 	cpx #1				; must be at least 1 char
c988 : 9004             [ 3] 	bcc str_d_error
c98a : a901             [ 2] 	lda #NUM_DEC
c98c : 18               [ 2] 	clc
c98d : 60               [ 6] 	rts
c98e :                       str_d_error
c98e : 38               [ 2] 	sec
c98f : 60               [ 6] 	rts
                             
c990 :                       str_d_powers
c990 : 00000100020003..      	dw	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
c9a4 : 00000a0014001e..      	dw	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
c9b8 : 00006400c8002c..      	dw	0, 100, 200, 300, 400, 500, 600, 700, 800, 90
c9cc : 0000e803d007b8..      	dw	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 
c9e0 : 00001027204e30..      	dw	0, 10000, 20000, 30000, 40000, 50000, 60000, 
                             	
                             
                             ;****************************************
                             ;* twos_complement
                             ;* Twos complement of X,A (X=low)
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : X,A in 2's complement
                             ;* Regs affected : P
                             ;****************************************
c9f4 :                       twos_complement
c9f4 : 49ff             [ 2] 	eor #0xff
c9f6 : 48               [ 3] 	pha
c9f7 : 8a               [ 2] 	txa
c9f8 : 49ff             [ 2] 	eor #0xff
c9fa : aa               [ 2] 	tax
c9fb : 68               [ 4] 	pla
c9fc : e8               [ 2] 	inx
c9fd : d001             [ 4] 	bne twos_complement_skip_X
c9ff : 1a               [ 2] 	inc a
ca00 :                       twos_complement_skip_X
ca00 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* int_to_bcd
                             ;* Convert A,X (signed int) to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated
                             ;* Regs affected : None
                             ;****************************************
ca01 :                       int_to_bcd
ca01 : 08               [ 3] 	php
ca02 : 48               [ 3] 	pha
ca03 : da               [ 3] 	phx
                             
ca04 : 8691             [ 3] 	stx num_tmp
ca06 : 8592             [ 3] 	sta num_tmp+1
ca08 : c980             [ 2] 	cmp #0x80			; Negative?
ca0a : 9003             [ 3] 	bcc int_to_bcd_skip_neg
ca0c : 20f4c9           [ 6] 	jsr twos_complement
ca0f :                       int_to_bcd_skip_neg
ca0f : 6485             [ 3] 	stz num_a
ca11 : 6486             [ 3] 	stz num_a+1
ca13 : 6487             [ 3] 	stz num_a+2
ca15 : 6488             [ 3] 	stz num_a+3
AS65 Assembler for R6502 [1.42].                                     Page   46
-------------------------------- bank\bank3.s --------------------------------

ca17 : a210             [ 2] 	ldx #16
ca19 : f8               [ 2] 	sed
ca1a :                       int_to_bcd_bit
ca1a : 0691             [ 5] 	asl num_tmp
ca1c : 2692             [ 5] 	rol num_tmp+1
ca1e : a585             [ 3] 	lda num_a
ca20 : 6585             [ 3] 	adc num_a
ca22 : 8585             [ 3] 	sta num_a
ca24 : a586             [ 3] 	lda num_a+1
ca26 : 6586             [ 3] 	adc num_a+1
ca28 : 8586             [ 3] 	sta num_a+1
ca2a : a587             [ 3] 	lda num_a+2
ca2c : 6587             [ 3] 	adc num_a+2
ca2e : 8587             [ 3] 	sta num_a+2
ca30 : ca               [ 2] 	dex
ca31 : d0e7             [ 3] 	bne int_to_bcd_bit
                             	
ca33 : fa               [ 4] 	plx
ca34 : 68               [ 4] 	pla
ca35 : 28               [ 4] 	plp
ca36 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* word_to_bcd
                             ;* Convert A,X (unsighed word) to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated as BCD
                             ;* Regs affected : None
                             ;****************************************
ca37 :                       word_to_bcd
ca37 : 08               [ 3] 	php
ca38 : 48               [ 3] 	pha
ca39 : da               [ 3] 	phx
                             
ca3a : 8691             [ 3] 	stx num_tmp
ca3c : 8592             [ 3] 	sta num_tmp+1
ca3e : 6485             [ 3] 	stz num_a
ca40 : 6486             [ 3] 	stz num_a+1
ca42 : 6487             [ 3] 	stz num_a+2
ca44 : 6488             [ 3] 	stz num_a+3
ca46 : a210             [ 2] 	ldx #16			; 16 binary bits
ca48 : f8               [ 2] 	sed
ca49 :                       word_to_bcd_bit
ca49 : 0691             [ 5] 	asl num_tmp
ca4b : 2692             [ 5] 	rol num_tmp+1
ca4d : a585             [ 3] 	lda num_a
ca4f : 6585             [ 3] 	adc num_a
ca51 : 8585             [ 3] 	sta num_a
ca53 : a586             [ 3] 	lda num_a+1
ca55 : 6586             [ 3] 	adc num_a+1
ca57 : 8586             [ 3] 	sta num_a+1
ca59 : a587             [ 3] 	lda num_a+2
ca5b : 6587             [ 3] 	adc num_a+2
ca5d : 8587             [ 3] 	sta num_a+2
ca5f : ca               [ 2] 	dex
ca60 : d0e7             [ 3] 	bne word_to_bcd_bit
                             	
ca62 : fa               [ 4] 	plx
ca63 : 68               [ 4] 	pla
ca64 : 28               [ 4] 	plp
ca65 : 60               [ 6] 	rts
                             	
AS65 Assembler for R6502 [1.42].                                     Page   47
-------------------------------- bank\bank3.s --------------------------------

                             ;****************************************
                             ;* bcd_to_str
                             ;* Convert num_buf to chars
                             ;* Input : num_a in BCD format
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
ca66 :                       bcd_to_str
ca66 : 48               [ 3] 	pha
ca67 : da               [ 3] 	phx
ca68 : 5a               [ 3] 	phy
                             
ca69 : a205             [ 2] 	ldx #5						; Index in to string
ca6b : a000             [ 2] 	ldy #0						; Current BCD digit
ca6d :                       bcd_str
ca6d : b98500           [ 4] 	lda num_a,y
                             	; Convert 1s digit of byte
ca70 : 48               [ 3] 	pha
ca71 : 290f             [ 2] 	and #0xf
ca73 : 18               [ 2] 	clc
ca74 : 6930             [ 2] 	adc #0x30
ca76 : 9595             [ 4] 	sta num_buf,x
                             	; Convert 10s digit of byte
ca78 : 68               [ 4] 	pla
ca79 : 4a               [ 2] 	lsr a
ca7a : 4a               [ 2] 	lsr a
ca7b : 4a               [ 2] 	lsr a
ca7c : 4a               [ 2] 	lsr a
ca7d : 18               [ 2] 	clc
ca7e : 6930             [ 2] 	adc #0x30					; Convert to ASCII
ca80 : 9594             [ 4] 	sta num_buf-1,x
ca82 : ca               [ 2] 	dex
ca83 : ca               [ 2] 	dex
ca84 : c8               [ 2] 	iny
ca85 : c003             [ 2] 	cpy #3						; 3 BCD digits max
ca87 : d0e4             [ 3] 	bne bcd_str
                             
ca89 : 7a               [ 4] 	ply
ca8a : fa               [ 4] 	plx
ca8b : 68               [ 4] 	pla
ca8c : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* out_bcd
                             ;* Output a bcd string in num_buf
                             ;* Input : num_buf has the ASCII
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not, Y=digits p
                             ;* Regs affected : P
                             ;****************************************
ca8d :                       out_bcd
ca8d : 48               [ 3] 	pha
ca8e : da               [ 3] 	phx
ca8f : 08               [ 3] 	php
ca90 : a000             [ 2] 	ldy #0						; How many digits printed
ca92 : a200             [ 2] 	ldx #0						; Index in to string
ca94 :                       out_bcd_digit
ca94 : b595             [ 4] 	lda num_buf,x
ca96 : c000             [ 2] 	cpy #0						; If not in leading zero mode
ca98 : d008             [ 3] 	bne out_bcd_print			; No then go print
AS65 Assembler for R6502 [1.42].                                     Page   48
-------------------------------- bank\bank3.s --------------------------------

                             
ca9a : c930             [ 2] 	cmp #'0'					; else check if zero
ca9c : d004             [ 3] 	bne out_bcd_print			; No then go print
                             
ca9e : 28               [ 4] 	plp
ca9f : 08               [ 3] 	php
caa0 : 9004             [ 3] 	bcc out_bcd_next			; If C=0 go to next digit, el
caa2 :                       out_bcd_print
caa2 : c8               [ 2] 	iny
caa3 : 2048c5           [ 6] 	jsr io_put_ch
caa6 :                       out_bcd_next
caa6 : e8               [ 2] 	inx
caa7 : e006             [ 2] 	cpx #6
caa9 : d0e9             [ 3] 	bne out_bcd_digit
caab : c000             [ 2] 	cpy #0						; If nothing printed
caad : d006             [ 3] 	bne out_bcd_fin
caaf : a930             [ 2] 	lda #'0'					; Need to put out 1 zero
cab1 : 2048c5           [ 6] 	jsr io_put_ch
cab4 : c8               [ 2] 	iny
cab5 :                       out_bcd_fin
cab5 : 28               [ 4] 	plp
cab6 : fa               [ 4] 	plx
cab7 : 68               [ 4] 	pla
cab8 : 18               [ 2] 	clc
cab9 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* str_a_to_d
                             ;* Convert X,A to decimal string in sevalptr
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 keep leading zeros else not
                             ;* Output : sevalptr in ASCII max 6 digits
                             ;*          Y=length including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
caba :                       str_a_to_d
caba : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* print_a_to_d
                             ;* Convert X,A to decimal string
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII max 6 digits
                             ;*          Y=digits printed including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
cabb :                       print_a_to_d
cabb : 08               [ 3] 	php
cabc : c980             [ 2] 	cmp #0x80					; Check if sign bit is set
cabe : 9014             [ 3] 	bcc print_a_to_d_skip_neg	; Skip if not (postive
cac0 : 20f4c9           [ 6] 	jsr twos_complement			; Flip from 2s complement
cac3 : 2001ca           [ 6] 	jsr int_to_bcd				; Convert to BCD
cac6 : 2066ca           [ 6] 	jsr bcd_to_str				; Convert BCD to string
cac9 : a92d             [ 2] 	lda #'-'
cacb : 2048c5           [ 6] 	jsr io_put_ch
cace : 28               [ 4] 	plp							; Leading zeros preference
cacf : 208dca           [ 6] 	jsr out_bcd
cad2 : c8               [ 2] 	iny							; Account for sign
cad3 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   49
-------------------------------- bank\bank3.s --------------------------------

cad4 :                       print_a_to_d_skip_neg
cad4 : 2001ca           [ 6] 	jsr int_to_bcd				; Convert to BCD
cad7 : 2066ca           [ 6] 	jsr bcd_to_str				; Convert BCD to string
cada : 28               [ 4] 	plp							; Leading zeros preference
cadb : 4c8dca           [ 3] 	jmp out_bcd					; Print +ve string
                             	
                             
                             ;* Reset vector points here - 6502 starts here
cade :                       init
                             ;	jmp init_test
                             	; First clear ram
                             ;	sei					; No need as disabled on startup
cade : 4c39cb           [ 3] 	jmp init_ram		; jmp not jsr to ram initialiser
cae1 :                       init_2					; init_ram will jump back to here
cae1 : a2ff             [ 2] 	ldx #0xff			; Initialise stack pointer
cae3 : 9a               [ 2] 	txs
                             ;	cld					; No need as disabled on startup
                             	
cae4 : 20eaca           [ 6] 	jsr kernel_init
                             
cae7 : 4c83c6           [ 3] 	jmp main
                             
caea :                       kernel_init
caea : 20d6c6           [ 6] 	jsr init_nmi		; Initialise NMI handling
caed : 20f6c6           [ 6] 	jsr init_irq		; Initialise IRQ handling
caf0 : 20dec1           [ 6] 	jsr _init_acia		; initialise the serial chip
                             	
caf3 : 20f6c1           [ 6] 	jsr _init_cia0		; initialise cia 0
caf6 : 200ec2           [ 6] 	jsr _init_cia1		; initialise cia 1
                             
caf9 :                       kernel_test
caf9 : 2056c2           [ 6] 	jsr _init_snd		; initialise the sound chip
cafc : 206ec2           [ 6] 	jsr _init_keyboard	; initialise keyboard timer s
caff : 2036c4           [ 6] 	jsr _vdp_init		; initialise vdp
cb02 : a900             [ 2] 	lda #0				; Default = 40 column mode - put on st
cb04 : 48               [ 3] 	pha
cb05 : a20e             [ 2] 	ldx #0xe			; NV location for default text mode [
cb07 : 2096c4           [ 6] 	jsr _rtc_nvread		; Try to read location
cb0a : b00b             [ 3] 	bcs kernel_skip_nv	; If bad NV ram then skip try
cb0c : aa               [ 2] 	tax					; Save the mode temporarily
cb0d : 68               [ 4] 	pla					; Get the default mode from stack
cb0e : 8a               [ 2] 	txa					; And push the NV mode that was read
cb0f : 48               [ 3] 	pha
cb10 : a20f             [ 2] 	ldx #0xf			; NV location for the default colour
cb12 : 2096c4           [ 6] 	jsr _rtc_nvread		; Try to read location (assumed
cb15 : 8521             [ 3] 	sta vdp_base+vdp_bord_col	; Save it to the borde
cb17 :                       kernel_skip_nv	
cb17 : 68               [ 4] 	pla					; Get the mode (either default or the NV
cb18 : 20c6c1           [ 6] 	jsr _gr_init_screen
cb1b : 200ec5           [ 6] 	jsr io_init			; Set default input/output device
cb1e : 58               [ 2] 	cli					; irq interrupts enable
                             
                             	; Print the boot up message - requires IO and IR
                             	_println msg_hello_world
                             
                             
                             
cb2c : 204ec4           [ 6] 	jsr _rtc_init		; Initialise RTC - * AFTER INTERR
cb2f : 203ec2           [ 6] 	jsr _init_sdcard	; initialise the sd card interf
cb32 : 2026c2           [ 6] 	jsr _init_fs		; initialise the filesystem
cb35 : 202ec0           [ 6] 	jsr _df_init		; Initialise interpreter
                             
AS65 Assembler for R6502 [1.42].                                     Page   50
-------------------------------- bank\bank3.s --------------------------------

cb38 : 60               [ 6] 	rts
                             
                             	
                             ;* Initialises RAM, skipping pages 4-8 which are 
                             ;* Zeroes all addressable RAM in the default bank
cb39 :                       init_ram
cb39 : 6400             [ 3] 	stz 0x00			; Start at page 0
cb3b : 6401             [ 3] 	stz 0x01
cb3d : a002             [ 2] 	ldy #0x02			; But Y initially at 2 to not overwr
cb3f : a200             [ 2] 	ldx #0x00			; Page counter starts at zero
cb41 : a900             [ 2] 	lda #0				; Normal RAM filled with zero
cb43 :                       init_ram_1
cb43 : e004             [ 2] 	cpx	#4				; Page <4 is ok
cb45 : 9006             [ 3] 	bcc init_ram_fill
cb47 : e008             [ 2] 	cpx #8				; Page >=8 is ok
cb49 : b002             [ 3] 	bcs init_ram_fill
cb4b : 8002             [ 3] 	bra init_ram_skip
cb4d :                       init_ram_fill
cb4d : 9100             [ 5] 	sta (0x00),y		; Write initialisation value to RA
cb4f :                       init_ram_skip
cb4f : c8               [ 2] 	iny
cb50 : d0fb             [ 3] 	bne init_ram_fill	; Do a whole page
cb52 : e8               [ 2] 	inx					; Increment page counter
cb53 : 8601             [ 3] 	stx 0x01			; Save to address pointer
cb55 : d0ec             [ 3] 	bne init_ram_1		; Do all pages until page 0xff d
                             	
cb57 : 4ce1ca           [ 3] 	jmp init_2			; Carry on initialisation
                             
cb5a :                       mod_sz_kernel_e
                             
                             
                             
                             ; Bank specific code goes here
                             
                             	; End of Code
cb5a :                       _code_end
cb5a :                       _bank3_end
                             
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
