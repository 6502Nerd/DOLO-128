AS65 Assembler for R6502 [1.42].                                     Page    1
---------------------------------- bank1.s -----------------------------------

13606 lines read, no errors in pass 1.
c000 =                       _bank1_start=0xc000
                             	include "kernel\kernel.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  KERNEL.S
                             ;*	The 'kernel' routine includes code and data wh
                             ;* 	be in every ROM bank.  In the auto-generated 
                             ;*  files, the kernel is added before the bank sp
                             ;*	code.  See bank0.s as an example.
                             ;*
                             ;************************************************
                             
                             ;* Include all definition and code files in the r
                             	include "inc\includes.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  INCLUDES.S
                             ;*  Main include file for key definitions and mac
                             ;*  Many of the settings here are exremely machin
                             ;*  Defines : IO block addresses, VIA port usage,
                             ;*  settings, useful macros, sound chip registers
                             ;*  VDP registers, ACIA registers.
                             ;*
                             ;************************************************
                             
                             ;* The IO block is at 0x04000 and decodes up to
                             ;* eight IO addresses, at 0x0080 intervals
                             ;* All eight are not used at the present time:
                             ;* - 0 : VIA 1 (Keyboard)
                             ;* - 1 : VIA 2 (Sound and SD card interface)
                             ;* - 2 : VDP (Video)
                             ;* - 3 : ACIA (Serial)
                             ;* - 4 : RTC (DS12887 real time clock + RAM)
0400 =                       IO_0		= 0x0400
0480 =                       IO_1		= 0x0480
0500 =                       IO_2		= 0x0500
0580 =                       IO_3		= 0x0580
0600 =                       IO_4		= 0x0600
0680 =                       IO_5		= 0x0680
0700 =                       IO_6		= 0x0700
0780 =                       IO_7		= 0x0780
                             
                             ;* VDP is accessed through IO_2
0500 =                       VDP_MODE0		= IO_2
0501 =                       VDP_MODE1		= IO_2+1
0501 =                       VDP_STATUS		= IO_2+1
0501 =                       VDP_ADDR		= IO_2+1
0500 =                       VDP_VRAM		= IO_2
0001 =                       VDP_SHORTDELAY	= 1
AS65 Assembler for R6502 [1.42].                                     Page    2
---------------------------------- bank1.s -----------------------------------

0003 =                       VDP_LONGDELAY 	= 3
0010 =                       VDP_FLASH		= 0x10				;* Must be a power of 2 *
                             
                             ;* This structure defines the key information
                             ;* kept about the VDP current mode
0000 =                       	struct vdp_addr_struct
0000 =                       	dw vdp_addr_nme				;* Address of name table
0002 =                       	dw vdp_addr_col				;* Address of colour table
0004 =                       	dw vdp_addr_pat				;* Address of pattern table
0006 =                       	dw vdp_addr_spa				;* Address of sprite pattern 
0008 =                       	dw vdp_addr_spp				;* Address of sprite position
000a =                       	db vdp_bord_col				;* Value of border colour
000b =                       	db vdp_gmode				;* Graphics mode 0,1,2 or 0x80 (
                             	end struct
                             
                             ;* Standard definitions of 6522 registers
                             ;* As found in the datasheets
0000 =                       PRB			= 0x00
0001 =                       PRA			= 0x01
0002 =                       DDRB		= 0x02
0003 =                       DDRA		= 0x03
0004 =                       T1CL		= 0x04
0005 =                       T1CH		= 0x05
0006 =                       T1LL		= 0x06
0007 =                       T1LH		= 0x07
0008 =                       T2CL		= 0x08
0009 =                       T2CH		= 0x09
000a =                       SR			= 0x0a
000b =                       ACR			= 0x0b
000c =                       PCR			= 0x0c
000d =                       IFR			= 0x0d
000e =                       IER			= 0x0e
000f =                       PRAH		= 0x0f
                             
0001 =                       IFR_CA2		= 0x01
0002 =                       IFR_CA1		= 0x02
                             
                             ;* AY-3-8910 definitions
                             ;* The sound chip is accessed through VIA 2
0481 =                       SND_ADBUS	= IO_1+PRA
0480 =                       SND_MODE	= IO_1+PRB
                             
0040 =                       SND_SELREAD			= 0x40
0002 =                       SND_SELWRITE		= 0x02
0042 =                       SND_SELSETADDR		= (SND_SELREAD|SND_SELWRITE)
00bd =                       SND_DESELECT_MASK	= (0xff-SND_SELREAD-SND_SELWRIT
                             
0000 =                       SND_REG_CHAPL	= 0x00
0001 =                       SND_REG_CHAPH	= 0x01
0002 =                       SND_REG_CHBPL	= 0x02
0003 =                       SND_REG_CHBPH	= 0x03
0004 =                       SND_REG_CHCPL	= 0x04
0005 =                       SND_REG_CHCPH	= 0x05
0006 =                       SND_REG_CHNP	= 0x06
0007 =                       SND_REG_CTL		= 0x07
0008 =                       SND_REG_CHAVOL	= 0x08
0009 =                       SND_REG_CHBVOL	= 0x09
000a =                       SND_REG_CHBVOL	= 0x0a
000b =                       SND_REG_ENVPL	= 0x0b
000c =                       SND_REG_ENVPH	= 0x0c
000d =                       SND_REG_ENVCYC	= 0x0d
                             
AS65 Assembler for R6502 [1.42].                                     Page    3
---------------------------------- bank1.s -----------------------------------

000e =                       SND_REG_IOA	= 0x0e
000f =                       SND_REG_IOB	= 0x0f
                             
                             ;* 6551 ACIA definitions
                             ;* As found in the datasheets
0580 =                       SER_DATA	= (IO_3+0)
0581 =                       SER_STATUS	= (IO_3+1)
0581 =                       SER_RESET	= (IO_3+1)
0582 =                       SER_CMD		= (IO_3+2)
0583 =                       SER_CTL		= (IO_3+3)
                             
0080 =                       SER_IRQ		= 0x80
0040 =                       SER_DSRB	= 0x40
0020 =                       SER_DCDB	= 0x20
0010 =                       SER_TDRE	= 0x10
0008 =                       SER_RDRF	= 0x08
0004 =                       SER_OVRN	= 0x04
0002 =                       SER_FE		= 0x02
0001 =                       SER_PE		= 0x01
0080 =                       SER_SBN		= 0x80
0040 =                       SER_WL1		= 0x40
0020 =                       SER_WL0		= 0x20
0060 =                       SER_WL		= (SER_WL1|SER_WL0)
0010 =                       SER_RCS		= 0x10
0008 =                       SER_SBR3	= 0x08
0004 =                       SER_SBR2	= 0x04
0002 =                       SER_SBR1	= 0x02
0001 =                       SER_SBR0	= 0x01
000f =                       SER_SBR		= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0)
000f =                       SER_19200B	= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0
000e =                       SER_9600B	= (SER_SBR3|SER_SBR2|SER_SBR1)
0080 =                       SER_PMC1	= 0x80
0040 =                       SER_PMC0	= 0x40
00c0 =                       SER_PMC		= (SER_PMC1|SER_PMC0)
0020 =                       SER_PME		= 0x20
0010 =                       SER_REM		= 0x10
0008 =                       SER_TIC1	= 0x08
0004 =                       SER_TIC0	= 0x04
000c =                       SER_TIC		= (SER_TIC1|SER_TIC0)
0002 =                       SER_IRD		= 0x02
0001 =                       SER_DTR		= 0x01
                             
                             ;* BBC keyboard definitions
                             ;* The keyboard is accessed through VIA 1
                             ;* Port A - all output
0001 =                       KB_ROWA		= 0x01
0002 =                       KB_ROWB		= 0x02
0004 =                       KB_ROWC		= 0x04
0008 =                       KB_COLA		= 0x08
0010 =                       KB_COLB		= 0x10
0020 =                       KB_COLC		= 0x20
0040 =                       KB_COLD		= 0x40
0080 =                       KB_EN		= 0x80
                             ;* Port B
0001 =                       KB_W		= 0x01			; Input - BBC keyboard hardware se
0002 =                       KB_LED0		= 0x02			; Output - led 0
0004 =                       KB_LED1		= 0x04			; Output - led 1
0008 =                       KB_LED2		= 0x08			; Output - led 2
0001 =                       KB_CAPSLK	= 0x01			; Id of Caps Lock - maps to Le
0002 =                       KB_SHIFTLK	= 0x02			; Id of Shift lock - maps to 
                             
0003 =                       KB_REP_TIM	= 3				; Number of VB periods for the 
AS65 Assembler for R6502 [1.42].                                     Page    4
---------------------------------- bank1.s -----------------------------------

0014 =                       KB_REP_DEL	= 20			; Number of VB periods before r
0002 =                       KB_DEBOUNCE	= 2				; Number of VB periods before 
                             
0001 =                       UTF_SOH		= 0x01
0003 =                       UTF_ETX		= 0x03			; Break character
0007 =                       UTF_BEL		= 0x07
0008 =                       CRSR_LEFT	= 0x08
0009 =                       CRSR_RIGHT	= 0x09
000a =                       CRSR_DOWN	= 0x0a
000b =                       CRSR_UP		= 0x0b
0006 =                       UTF_ACK		= 0x06			; Used for the copy key in this
000c =                       UTF_FF		= 0x0c
000d =                       UTF_CR		= 0x0d
0015 =                       UTF_NACK	= 0x15
0017 =                       UTF_ETB		= 0x17
001a =                       UTF_BRK		= 0x1a			; Debug - drop in to monitor
007f =                       UTF_DEL		= 0x7f
0020 =                       UTF_SPECIAL = 0x20
                             
                             ;* SD Card interface definitions
                             ;* The card is accessed through port B of VIA 2
0001 =                       SD_CLK		= 0x01			; Clock output to SD card
0004 =                       SD_CD		= 0x04			; Card detect input
0008 =                       SD_CS		= 0x08			; Card select output
0010 =                       SD_DI		= 0x10			; Data output from VIA to SD Card
0080 =                       SD_DO		= 0x80			; Data input to VIA from SD card
                             
0010 =                       SD_MOSI		= SD_DI
0080 =                       SD_MISO		= SD_DO
0480 =                       SD_REG		= IO_1+PRB
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
                             
                             ;* Memory management definitions
                             ;* Y1,Y0 = ROM bank selection CIA1 PORTB
0080 =                       MM_Y1					= 0x80
0040 =                       MM_Y0					= 0x40
                             ;* X1,X0 = RAM bank selection CIA1 PORTB
0020 =                       MM_X1					= 0x20
0010 =                       MM_X0					= 0x10
                             ;* DIS = ROM disable *CIA2* PORTB
0020 =                       MM_DIS					= 0x20
                             
                             ;* Number formats for conversion routines
0000 =                       NUM_ANY		= 0x00
0001 =                       NUM_DEC		= 0x01
0002 =                       NUM_HEX		= 0x02
0003 =                       NUM_BIN		= 0x03
                             
                             	
                             ;* SD Card Master Boot Record (MBR) definitions
                             ;* The MBR contains the essential information
                             ;* needed to access the data on the card
                             ;* MBR is usually sector 0, but not always
                             ;* however the card I am using does work ok.
0000 =                       MBR_Code				=	0x0000
0003 =                       MBR_OEMName				=	0x0003
000b =                       MBR_BytesPerSect		=	0x000b
000d =                       MBR_SectPerClust		=	0x000d
AS65 Assembler for R6502 [1.42].                                     Page    5
---------------------------------- bank1.s -----------------------------------

000e =                       MBR_ResvSect			=	0x000e
0010 =                       MBR_FATCopies			=	0x0010
0011 =                       MBR_RootEntries			=	0x0011
0013 =                       MBR_SmlSect				=	0x0013
0015 =                       MBR_MediaDesc			=	0x0015
0016 =                       MBR_SectPerFAT			=	0x0016
0018 =                       MBR_SectPerTrk			=	0x0018
001a =                       MBR_NumHeads			=	0x001a
001c =                       MBR_NumHidSect			=	0x001c
0020 =                       MBR_NumSect				=	0x0020
0024 =                       MBR_DrvNum				=	0x0024
0026 =                       MBR_ExtSig				=	0x0026
0027 =                       MBR_SerNo				=	0x0027
002b =                       MBR_VolName				=	0x002b
0036 =                       MBR_FATName				=	0x0036
003e =                       MBR_ExeCode				=	0x003e
01c6 =                       MBR_BootPart1			=	(0x01be+0x08)
01fe =                       MBR_ExeMark				=	0x01fe
                             
                             ;* FAT16 definitions - these are offsets
                             ;* in to a FAT table entry which is
                             ;* 32 bytes in length.
0000 =                       	struct FATFileDesc
0000 =                       	ds FAT_Name,8
0008 =                       	ds FAT_Ext,3
000b =                       	ds FAT_Attr,1
000c =                       	ds FAT_Resv,1
000d =                       	ds FAT_Createms,1
000e =                       	ds FAT_CreateTime,2
0010 =                       	ds FAT_CreateDate,2
0012 =                       	ds FAT_AccessDate,2
0014 =                       	ds FAT_EAIndex,2
0016 =                       	ds FAT_ModTime,2
0018 =                       	ds FAT_ModDate,2
001a =                       	ds FAT_FirstClust,2
001c =                       	ds FAT_FileSize,4
                             	end struct
                             
                             ;* Flag to mark file as a directory
0010 =                       FAT_Attr_Dir			=	0x10
                             
                             ;* The FileHandle stucture is key to
                             ;* accessing the file system
0000 =                       	struct FileHandle
0000 =                       	ds FH_Name, 13				; 8 name, 3 extension, 1 separ
000d =                       	ds FH_Attr, 1				; What kind of file ** keep str
000e =                       	ds FH_Size, 4				; File size
0012 =                       	ds FH_CurrClust, 2			; Current cluster
0014 =                       	ds FH_SectCounter, 1		; Sector counter to know w
0015 =                       	ds FH_CurrSec, 4			; Current sector
0019 =                        	ds FH_Pointer, 4			; Pointer in to file for nex
001d =                       	ds FH_DirSect, 4			; Parent directory sector
0021 =                       	ds FH_DirOffset, 2			; Offset of this entry in t
0023 =                       	ds FH_FirstClust, 2			; First cluster of file da
0025 =                       	ds FH_LastClust, 2			; Last cluster accessed
0027 =                       	ds FH_TimeDate, 5			; Time-Date created (ms, tim
002c =                       	ds FH_FileMode, 1			; File mode (0=read, else wr
002d =                       	ds FH_FSpecPtr, 2			; Pointer to file spec being
                             	end struct
                             
0001 =                       FS_BLK_FLG_LOAD		 	= 	0x01		; On next byte, load 
0002 =                       FS_BLK_FLG_FLUSH		=	0x02		; Block has changed, ne
AS65 Assembler for R6502 [1.42].                                     Page    6
---------------------------------- bank1.s -----------------------------------

                             	
0001 =                       FS_ERR_EOF				=	0x01
                             
                             
                             ;* USEFUL MACROS HERE
                             
                             ;* Software break to throw errors
                             ;* use like this : SWBRK XX
                             ;* Where XX is the error code
                             SWBRK macro sig
                             	brk
                             	db sig
                             	endm
                             
                             _pushAXY macro
                             	pha
                             	phx
                             	phy
                             	endm
                             
                             _pullAXY macro
                             	ply
                             	plx
                             	pla
                             	endm
                             
                             _println macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	_pullAXY
                             	endm
                             
                             _println_low macro msg
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	endm
                             
                             _printmsgA macro msg
                             	phx
                             	phy
                             	pha
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	pla
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printA macro
                             	phx
AS65 Assembler for R6502 [1.42].                                     Page    7
---------------------------------- bank1.s -----------------------------------

                             	phy
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printCRLF macro
                             	pha
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printC macro ch
                             	pha
                             	lda #ch
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printCA macro
                             	pha
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _sendcmd macro cmd
                             	_pushAXY
                             	ldx #lo(cmd)
                             	lda #hi(cmd)
                             	jsr sd_sendcmd
                             	_pullAXY
                             	endm
                             
                             _incZPWord macro wordp
                             	inc wordp
                             	db	0xd0, 0x02
                             	inc wordp+1
                             	endm
                             
                             _decZPWord macro wordp
                             	pha
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	pla
                             	endm
                             
                             _decZPWordA macro wordp
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
AS65 Assembler for R6502 [1.42].                                     Page    8
---------------------------------- bank1.s -----------------------------------

                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	endm
                             
                             _cpyZPWord macro worda,wordb
                             	lda worda
                             	sta wordb
                             	lda worda+1
                             	sta wordb+1
                             	endm
                             	
                             _addZPWord macro worda, wordb
                             	clc
                             	lda worda
                             	adc wordb
                             	sta worda
                             	lda worda+1
                             	adc wordb+1
                             	sta worda+1
                             	endm
                             
                             _subZPWord macro worda, wordb
                             	sec
                             	lda worda
                             	sbc wordb
                             	sta worda
                             	lda worda+1
                             	sbc wordb+1
                             	sta worda+1
                             	endm
                             	
                             _adcZPWord macro worda,const
                             	clc
                             	lda worda
                             	adc #const
                             	sta worda
                             	lda worda+1
                             	adc #0
                             	sta worda+1
                             	endm
                             
                             _adcZPByte macro worda, byte
                             	clc
                             	lda worda
                             	adc byte
                             	sta worda
                             	db 0x90, 0x02		; bcc 2
                             	inc worda+1
                             	endm
                             
                             _sbcZPByte macro worda, byte
                             	sec
                             	lda worda
                             	sbc byte
                             	sta worda
                             	db 0xb0, 0x02		; bcs 2
                             	inc worda+1
                             	endm
                             
                             _bcc macro skip
                             	db 0x90, skip
AS65 Assembler for R6502 [1.42].                                     Page    9
---------------------------------- bank1.s -----------------------------------

                             	endm
                             
                             _bcs macro skip
                             	db 0xb0, skip
                             	endm
                             
                             _df_ost_peekType macro
                             	ldy df_parmtop
                             	lda df_rtstck-1,y
                             	endm
                             
                             	include "inc\graph.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  GRAPH.I
                             ;*  This is the definition file for graphics, spe
                             ;*  The graphics screen handling module.  It is j
                             ;*  structure definition - but this structure is 
                             ;*  record the important attributes of a text scr
                             ;*  Needed because there is both a 40 and 32 colu
                             ;*  supported by the VDP, and the screens are not
                             ;*  same location.
                             ;*
                             ;************************************************
                             
0000 =                       	struct gr_screen
0000 =                       	dw gr_screen_start			; Start of screen memory in
0002 =                       	dw gr_screen_size			; Number of bytes screen occ
0004 =                       	db gr_screen_w				; Number of columns
0005 =                       	db gr_screen_h				; Number of rows
0006 =                       	db gr_cur_off				; Y offset of cursor image from
0007 =                       	db gr_cur_x					; Current X position of cursor
0008 =                       	db gr_cur_y					; Current Y position of cursor
0009 =                       	dw gr_cur_ptr				; VDP address of cursor
000b =                       	db gr_pixmode				; Pixel plot mode (0=Erase, 1=P
000c =                       	db gr_pixmask				; Pixel plot mask
000d =                       	db gr_pixcol				; Pixel colour
000e =                       	dw gr_geom_tmp				; One word of temp storage for
                             	end struct
                             	include "io\io.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.I
                             ;*  Definitions file for the IO module.  The key 
                             ;*  used by the IO system is defined here.
                             ;*
                             ;************************************************
                             
                             ;* General IO structure allows the system to swap
                             ;* different IO devices by using indirect calls t
AS65 Assembler for R6502 [1.42].                                     Page   10
---------------------------------- bank1.s -----------------------------------

                             ;* the appropriate routines.
0000 =                       	struct io_struct
0000 =                       	ds	io_get_byte,	2			;* Address of get byte
0002 =                       	ds	io_put_byte,	2			;* Address of put byte
0004 =                       	ds	io_open_r,		2			;* Address of open file for r
0006 =                       	ds	io_open_w,		2			;* Address of open file for w
0008 =                       	ds	io_close_f,		2			;* Address of close file
000a =                       	ds	io_del_f,		2			;* Address of delete file
000c =                       	ds	io_ext1,		2			;* Address of extended function
000e =                       	ds	io_ext2,		2			;* Address of extended function
                             	end struct
                             	include "rtc\rtc.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTC.I
                             ;*  Definitions file for the RTC module.  The key
                             ;*  used by the real time clock is defined here.
                             ;*  It is a DS1288
                             ;*
                             ;************************************************
                             
0000 =                       RTC_SEC		= 0x00
0001 =                       RTC_SECA	= 0x01
0002 =                       RTC_MIN		= 0x02
0003 =                       RTC_MINA	= 0x03
0004 =                       RTC_HR		= 0x04
0005 =                       RTC_HRA		= 0x05
0006 =                       RTC_DOW		= 0x06
0007 =                       RTC_DAY		= 0x07
0008 =                       RTC_MTH		= 0x08
0009 =                       RTC_YR		= 0x09
000a =                       RTC_REGA	= 0x0a
000b =                       RTC_REGB	= 0x0b
000c =                       RTC_REGC	= 0x0c
000d =                       RTC_REGD	= 0x0d
                             
0080 =                       RTC_UIP		= 0x80
0040 =                       RTC_DV2		= 0x40
0020 =                       RTC_DV1		= 0x20
0010 =                       RTC_DV0		= 0x10
0080 =                       RTC_RS3		= 0x80
0040 =                       RTC_RS2		= 0x40
0020 =                       RTC_RS1		= 0x20
0010 =                       RTC_RS0		= 0x10
                             
0080 =                       RTC_SET		= 0x80
0040 =                       RTC_PIE		= 0x40
0020 =                       RTC_AIE		= 0x20
0010 =                       RTC_UIE		= 0x10
0080 =                       RTC_SQWE	= 0x80
0004 =                       RTC_DM		= 0x04
0002 =                       RTC_2412	= 0x02
0001 =                       RTC_DSE		= 0x01
                             
0080 =                       RTC_IRQF	= 0x80
0040 =                       RTC_PF		= 0x40
AS65 Assembler for R6502 [1.42].                                     Page   11
---------------------------------- bank1.s -----------------------------------

0020 =                       RTC_AF		= 0x20
0010 =                       RTC_UF		= 0x10
                             
0080 =                       RTC_VRT		= 0x80
                             
0600 =                       RTC_ADDR	= 0x600
0601 =                       RTC_DATA	= 0x601
                             
000e =                       NV_MODE     = 0x0e          ; Default boot up scr
000f =                       NV_COLOUR   = 0x0f          ; Default boot up col
                             
003f =                       NV_RAMSZ    = 63            ; Checksum byte in NV
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0ca9 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
AS65 Assembler for R6502 [1.42].                                     Page   12
---------------------------------- bank1.s -----------------------------------

000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_PTR	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0003 =                       DFST_INT	=	DFVVT_INT|DFVVT_BYT
0004 =                       DFST_STR	=	DFVVT_STR
00ff =                       DFST_PTR	=	0xff
AS65 Assembler for R6502 [1.42].                                     Page   13
---------------------------------- bank1.s -----------------------------------

                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0ca9 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
AS65 Assembler for R6502 [1.42].                                     Page   14
---------------------------------- bank1.s -----------------------------------

                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_PTR	=	0x80
                             
                             ;* Flags indicating the meaning of a token
AS65 Assembler for R6502 [1.42].                                     Page   15
---------------------------------- bank1.s -----------------------------------

                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0003 =                       DFST_INT	=	DFVVT_INT|DFVVT_BYT
0004 =                       DFST_STR	=	DFVVT_STR
00ff =                       DFST_PTR	=	0xff
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             	include "dflat\error.i"
                             ;************************************************
                             ;*
                             ;*	BBC128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.I
AS65 Assembler for R6502 [1.42].                                     Page   16
---------------------------------- bank1.s -----------------------------------

                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  It issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_SYNTAX	=	1
0002 =                       DFERR_TYPEMISM	=	2
0003 =                       DFERR_DIM		=	3
0004 =                       DFERR_UNTIL		=	4
0005 =                       DFERR_NOPROC	=	5
0006 =                       DFERR_PROCPARM	=	6
0007 =                       DFERR_IMMEDIATE	=	7
0008 =                       DFERR_UNCLOSEDIF=	8
0009 =                       DFERR_NOIF		=	9
000a =                       DFERR_NEXTFOR	=	10
000b =                       DFERR_FNAME		=	11
000c =                       DFERR_STRLONG	=	12
000d =                       DFERR_BREAK		=	13
000e =                       DFERR_NODATA	=	14
000f =                       DFERR_WEND		=	15
0010 =                       DFERR_NOLINE	=	16
0011 =                       DFERR_RETURN	=	17
0012 =                       DFERR_ABORT		=	18
0013 =                       DFERR_QUANTITY	=	19
0014 =                       DFERR_NOORG		=	20
                             
                             
                             
                             	include "bank\bank.i"
c000 =                       bankjsr_nul_addr	=	0xc000
0000 =                       bankjsr_nul_bank	=	0x00
003f =                       ROM_ZMASK			=	0x3f
00cf =                       RAM_ZMASK			=	0xcf
                             
                             _bankjsr	macro	addr,bank
                             	; Save A
                             	sta tmp_bank1
                             	
                             	; Save current bank
                             	lda bank_num
                             	pha
                             	
                             	; Switch to new bank
                             	lda IO_0+PRB
                             	and #ROM_ZMASK
                             	ora #(bank^3) << 6			; Shift left 6 bits
                             	sta IO_0+PRB
                             
                             	; Restore A
                             	lda tmp_bank1
                             	; JSR to the routine
                             	jsr addr
                             	
AS65 Assembler for R6502 [1.42].                                     Page   17
---------------------------------- bank1.s -----------------------------------

                             	jmp _restore_bank
                             	; 62 clock cycles inc restore vs 6 for a near js
                             
                             	endm
                             	
                             _bankram macro bank
                             	pha
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
                             	sta IO_0+PRB
                             	pla
                             	endm
                             	
                             _bankram_fast macro bank
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
                             	sta IO_0+PRB
                             	endm
                             	
                             
                             	include "kernel\zeropage.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ZEROPAGE.I
                             ;*  This module name is misleading it is not only
                             ;*  allocations, but also page 2, 3, 4, 5, 6, 7 a
                             ;*  Basically, this module defines:
                             ;*  - All zero page variables for system and dfla
                             ;*  - Page 1 is stack so no need to worry about t
                             ;*  - Page 2 is the serial IO buffer for the 6551
                             ;*  - Page 3 and 4 is a 512 buffer for SD card se
                             ;*  - Page 5 onwards is mainly for dflat working 
                             ;*    but also non-zero page storage for general 
                             ;*    system and scratch usage.
                             ;*  memstart is a handy label that indicates the 
                             ;*  location that we can store dflat programs fro
                             ;*  Zero page is a valuable asset as the 6502 can
                             ;*  this page one cycle quicker than the rest of 
                             ;*  and infact some addressing modes can only use
                             ;*  Due to the value of zero page, a lot of syste
                             ;*  dflat variables are put here.  But we don't h
                             ;*  luxury for single use variables - so you will
                             ;*  see a lot of temporary sounding names which a
                             ;*  have multiple used across the code base.
                             ;*
                             ;************************************************
                             
                             	; Zero page declarations
                             	bss
0000 =                       	org 0x0000
                             
0000 =                       tmp_bank1	ds	1		; Temp storage ONLY FOR USE BY BA
0001 =                       tmp_bank2	ds	1		; Temp storage ONLY FOR USE BY BA
                             
AS65 Assembler for R6502 [1.42].                                     Page   18
---------------------------------- bank1.s -----------------------------------

                             ; Interrupt routine addresses
0002 =                       int_nmi		 ds 2		; Master NMI handler
0004 =                       int_irq		 ds	2		; Master IRQ handler
0006 =                       int_brk		 ds	2		; Master BRK handler
0008 =                       int_uservdp	 ds	2		; Where to jump for VDP interr
000a =                       int_usercia0 ds	2		; Where to jump for CIA0 inter
000c =                       int_usercia1 ds	2		; Where to jump for CIA1 inter
                             
                             ; Serial FIFO buffer pointers
000e =                       ser_first	ds	1		; Pointer to first byte in buffer
000f =                       ser_last	ds	1		; Pointer to last byte in buffer
                             ; VDP parameters
0010 =                       vdp_int_cnt	ds  2		; VDP interrupt counter
0012 =                       vdp_curoff	ds	1		; Cursor off (0 = On)
0013 =                       vdp_curstat	ds	1		; Cursor status
0014 =                       vdp_curval	ds	1		; Cursor value on screen
0015 =                       vdp_blank	ds	1		; Screen blank value normally 32
0016 =                       vdp_delay	ds	1		; Delay counter for VRAM access
                             
                             ; vdp settings
0017 =                       vdp_base	ds	vdp_addr_struct
                             
                             ; Screen geometry
0023 =                       gr_scrngeom	ds	gr_screen
                             
                             ;Keyboard parameters
0033 =                       kb_raw  	ds	1		; Raw keyboard code
0034 =                       kb_last		ds	1		; Raw code of last key
0035 =                       kb_code 	ds	1		; Converted keyboard code
0036 =                       kb_stat		ds	1		; Keyboard status for caps and shi
0037 =                       kb_deb		ds	1		; VB periods since last KB spike
0038 =                       kb_rep		ds	1		; Keyboard repeat timer
0039 =                       kb_rep_tim 	ds	1		; Default repeat speed
003a =                       kb_rep_del 	ds	1		; Default repeat delay timing
003b =                       kb_debounce ds	1		; Default repeat debounce
003c =                       kb_pressed	ds	1		; Set by the interrupt handler i
                             
003d =                       tmp_c		ds	2		; Temp address c
003f =                       tmp_v1		ds	2		; VDP temp addresses
0041 =                       tmp_a		ds	2		; Temp storage a
0043 =                       tmp_b 		ds	2		; Temp address b
0045 =                       tmp_d		ds	2		; Temp storage d
                             
                             ; Raw input/output parameters
0047 =                       buf_adr		ds	2		; Line buffer address
0049 =                       buf_sz		ds	1		; Buffer size
004a =                       buf_ef		ds	1		; End file / line marker
                             
                             ; SD card driver parameters
004b =                       sd_status	ds	1		; SD card status
004c =                       sd_slo		ds	1		; Sector pointer low
004d =                       sd_shi		ds	1		; Sector pointer high
004e =                       sd_sect		ds	4		; SD Card sector address
0052 =                       sd_addr		ds	4		; SD Card byte address
                             
                             ; File system zp parameters
0056 =                       fh_handle	ds	FileHandle ; File handle parameters
                             
                             ; ** Integer function storage **
0085 =                       ztmp_16					; Start of 16 byte scratch area (all 
0085 =                       num_a		ds	4		; 4 byte primary accumulator
0089 =                       num_b		ds	4		; 4 byte secondary accumulator
AS65 Assembler for R6502 [1.42].                                     Page   19
---------------------------------- bank1.s -----------------------------------

008d =                       num_x		ds	4		; 4 byte x register
0091 =                       num_tmp		ds	4		; 4 byte temp space
0095 =                       num_buf		ds	8		; 8 byte string buffer
                             
                             ;
                             ; **** INTERPRETER ZERO PAGE ****
                             ;
009d =                       dflat_zp_s
009d =                       dflat_zp_save_s			; ZP save dflat from here
009d =                       df_checkkey	ds	1		; Key check interval counter
009e =                       df_checkmsk	ds	1		; Mask for check key
009f =                       errno		ds	1		; General error condition status
00a0 =                       df_immed	ds	1		; Immediate mode (0 = not immediat
00a1 =                       df_sp		ds	1		; Stack pointer after error to resto
00a2 =                       df_pc		ds	2		; PC after error to return to
00a4 =                       df_brkpc	ds	2		; PC pushed on the stack for BRK
00a6 =                       df_brkval	ds	1		; Byte after BRK instruction
00a7 =                       df_prgstrt	ds	2		; Start of program code
00a9 =                       df_prgend	ds	2		; End of program code
00ab =                       df_vntstrt	ds	2		; Variable name table start
00ad =                       df_vntend	ds	2		; Variable name table end
00af =                       df_vvtstrt	ds	2		; Variable value table start
00b1 =                       df_vvtend	ds	2		; Variable value table end
00b3 =                       df_varcnt	ds	1		; Variable counter
00b4 =                       df_starstrt	ds	2		; String and array table start
00b6 =                       df_starend	ds	2		; String and array table end
00b8 =                       df_rtstop	ds	1		; Runtime stack pointer
00b9 =                       df_parmtop	ds	1		; Top of parameter stack (grows 
00ba =                       df_strbuff	ds	1		; String expression buffer
00bb =                       df_stridx	ds	1		; Top of string buffer (grows dow
00bc =                       df_sevalptr	ds	2		; Pointer to next free char in 
                             
00be =                       df_linoff	ds	1		; Offset in to line buffer
00bf =                       df_tokoff	ds	1		; Offset in to tokenised buffer
00c0 =                       df_eolidx	ds	1		; End of line index (i.e length)
00c1 =                       df_nxtstidx	ds	1		; Offset to the next statement 
00c2 =                       df_curstidx	ds	1		; Offset to the start of curren
00c3 =                       df_symtab	ds	2		; Pointer to next free symtab ent
00c5 =                       df_symoff	ds	1		; Offset in to token table
00c6 =                       df_symini	ds	2		; Start of symtab
00c8 =                       df_currlin	ds	2		; Execution current line pointer
00ca =                       df_exeoff	ds	1		; Execution line buffer offset
00cb =                       df_nextlin	ds	2		; Next line to execute
00cd =                       df_procmode	ds	1		; Only used during tokenisation
00ce =                       df_procargs	ds	1		; Only used during tokenisation
00cf =                       df_procloc	ds	1		; Counts the number of local par
00d0 =                       df_procptr	ds	2		; Pointer to proc vvt slot
00d2 =                       df_lineptr	ds	2		; Pointer to line during searche
00d4 =                       df_lineidx	ds	1		; Pointer to line index during s
00d5 =                       df_ifnest	ds	1		; Global nested if counter
00d6 =                       df_currdat	ds	2		; Data current line pointer
00d8 =                       df_datoff	ds	1		; Data line buffer offset
00d9 =                       df_rnd		ds	2		; Random number seed
                             
00db =                       df_asmpc	ds	2		; Assembler program counter
00dd =                       df_asmopt	ds	1		; Assembler current option
00de =                       df_asmadmd	ds	1		; Addressing mode
00df =                       df_asmopcde	ds	1		; Current opcode
00e0 =                       df_asmoprnd	ds	2		; Current operand
00e2 =                       df_asmlen	ds	1		; Instruction length
                             
00e3 =                       dflat_zp_save_e			; Save up to this place
AS65 Assembler for R6502 [1.42].                                     Page   20
---------------------------------- bank1.s -----------------------------------

                             
                             ; Temp space for dflat
00e3 =                       df_tmpptra	ds	2		; Temp pointer a
00e5 =                       df_tmpptrb	ds	2		; Temp pointer b
00e7 =                       df_tmpptrc	ds	2		; Temp pointer c
00e9 =                       df_tmpptrd	ds	2		; Temp pointer d
00eb =                       df_tmpptre	ds	2		; Temp pointer e
                             
                             
                             ;***** END OF ZERO PAGE *****
00ed =                       _end_zero_page
                             
                             ;***** Page 1 is CPU stack ****
0100 =                       	org 0x0100
0100 =                       _cpu_stack
0100 =                       			ds	256		; All of page 1
                             
                             ;***** Page 2 and 3 is SD card buffer
0200 =                       	org 0x0200			; SD Card data buffer 512 bytes
0200 =                       sd_buf		ds	512
                             
                             ;***** Page 4,5,6,7 is IO space
0400 =                       	org 0x0400
0400 =                       			ds	1024	; 1 k area divided in to 8x128 byte de
                             
                             
                             ;***** Page 8 is serial buffer *****
0800 =                       	org 0x0800
0800 =                       ser_buf		ds	256		; Serial input / output line buf
                             
                             ;***** Scratch area, used by many things - do not
                             ; string and numeric expression evaluation, scree
0900 =                       	org 0x0900
0900 =                       scratch		ds	256
                             
                             ;***** Dflat space *****
0a00 =                       	org 0x0a00			; Page 9 = dflat space
0a00 =                       df_linbuff
0a00 =                       df_raw		ds	128		; untokenised input line
0a80 =                       df_tokbuff
0a80 =                       df_tok		ds 	128		; tokenised output line
                             
0b00 =                       	org 0x0b00			; Page 10 = fixed space for runtime
0b00 =                       df_rtstck				; operator stack grows up, runtime g
0b00 =                       df_rtspace	ds	256
                             
                             ;***** NON-ZERO PAGE VARIABLES *****
                             
                             ; Active IO device settings
0c00 =                       io_default	ds	1		; The default device number - es
                             ; Copy of jump tables to active device io routine
0c01 =                       io_block	ds	io_struct
                             
                             ; Copy of FAT16 directory
0c11 =                       fs_direntry	ds	FATFileDesc ; copy of dir entry - 
                             
                             ; Filesystem parameters
0c31 =                       fs_bootsect	ds	4		; Start of partition (usually 0
0c35 =                       fs_fatsect	ds	4		; Start of FAT tables
0c39 =                       fs_rootsect	ds	4		; Start of Root Directory
0c3d =                       fs_datasect	ds	4		; Start of Data Area
0c41 =                       fs_dirsect	ds	4		; Current directory sector numbe
AS65 Assembler for R6502 [1.42].                                     Page   21
---------------------------------- bank1.s -----------------------------------

0c45 =                       fs_dirclust	ds	2		; Current directory cluster num
                             
                             ; Working and scratch for filesystem - some data 
0c47 =                       fs_scratch	ds	32		; 32 bytes should be more than 
                             
                             ; Self-modifying code or code that needs to run w
0c67 =                       ram_code	ds  64		; 64 bytes of RAM code space
                             
                             ; Dflat top of memory+1 - normally initialised to
0ca7 =                       df_memtop	ds	2
                             
                             ;***** THIS IS THE START OF FREE SPACE for DFLAT 
0ca9 =                       mem_start
                             
                             
                             
                             
                             ;****************************************
                             ;*	Set 6502 default vectors	*
                             ;****************************************
                             	data				; Set vectors
fffa =                       	org 0xfffa			; Vectors lie at addresses
fffa : 63c7                  	fcw call_nmi_master	; 0xfffa : NMI Vector
fffc : 6bcb                  	fcw init			; 0xfffc : Reset Vector
fffe : c3c7                  	fcw call_irq_master	; 0xfffe : IRQ Vector
                             	
                             	; ROM code
                             	code				;  
c000 =                       	org 0xc000			; Start of ROM
                             
                             	; The bank number is hardwired and aligned to PB
c000 :                       bank_num
                             	if BANK0
                             	  db 192
                             	endif
                             	if BANK1
c000 : 80                    	  db 128
                             	endif
                             	if BANK2
                             	  db 64
                             	endif
                             	if BANK3
                             	  db 0
                             	endif
                             
c001 :                       _code_start
                             	; Restore current bank always at address c001
c001 :                       _OSVectors
                             	include "kernel\osvec.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  OSVEC.S
                             ;*  Simply this is a bunch of JMP XXXX the order 
                             ;*  will always be maintained.  This is to allow 
                             ;*  code programs to be able to rely on fixed loc
                             ;*  some key low-level functions.
AS65 Assembler for R6502 [1.42].                                     Page   22
---------------------------------- bank1.s -----------------------------------

                             ;*  Only low level functions are needed, the idea
                             ;*  as the assembler is part of the BASIC, one ca
                             ;*  level slow stuff using BASIC then switch to M
                             ;*  speed up.
                             ;*  This code goes straight after the bank number
                             ;*  Each JMP is at 0xc001+3*(vector #)
                             ;*
                             ;************************************************
                             
c001 : 4cc0c5           [ 3] 	jmp	io_put_ch			; Vec 0
c004 : 4cbdc5           [ 3] 	jmp io_get_ch			; Vec 1
c007 : 4c50c6           [ 3] 	jmp vdp_wr_reg			; Vec 2
c00a : 4c8ac6           [ 3] 	jmp vdp_poke			; Vec 3
c00d : 4c97c6           [ 3] 	jmp vdp_peek			; Vec 4
c010 : 4cf9c6           [ 3] 	jmp snd_get_joy0		; Vec 5
c013 : 4ca1c6           [ 3] 	jmp snd_set				; Vec 6
c016 : 4c5dc6           [ 3] 	jmp vdp_wr_addr			; Vec 7
c019 : 4c75c6           [ 3] 	jmp	vdp_rd_addr			; Vec 8
c01c :                       _restore_bank
                             	; Save A
c01c : 8500             [ 3] 	sta tmp_bank1
                             	; Get old bank from stack
c01e : 68               [ 4] 	pla
c01f : 8501             [ 3] 	sta tmp_bank2
c021 : ad0004           [ 4] 	lda IO_0+PRB
c024 : 293f             [ 2] 	and #ROM_ZMASK
c026 : 0501             [ 3] 	ora tmp_bank2
c028 : 8d0004           [ 4] 	sta IO_0+PRB
                             	
                             	; Restore A
c02b : a500             [ 3] 	lda tmp_bank1
                             
c02d : 60               [ 6] 	rts
                             
                             	; include cross-bank functions (see extern.mak)
                             	include "bank\autogen.s"	
                             ;
c02e :                       mod_sz_autogen_s
c02e :                       _df_init
                              _bankjsr $f30f, 1
                             
c046 :                       _df_pg_dflat
                              _bankjsr $d825, 1
                             
c05e :                       _fs_chdir_w
                              _bankjsr $d59b, 2
                             
c076 :                       _fs_mkdir_w
                              _bankjsr $d62e, 2
                             
c08e :                       _fs_delete_w
                              _bankjsr $d537, 2
                             
c0a6 :                       _fs_close_w
                              _bankjsr $d4f6, 2
                             
c0be :                       _fs_get_byte_w
                              _bankjsr $d213, 2
                             
c0d6 :                       _fs_open_read_w
                              _bankjsr $d3e2, 2
                             
AS65 Assembler for R6502 [1.42].                                     Page   23
---------------------------------- bank1.s -----------------------------------

c0ee :                       _fs_open_write_w
                              _bankjsr $d4a6, 2
                             
c106 :                       _fs_put_byte_w
                              _bankjsr $d36f, 2
                             
c11e :                       _fs_dir_find_entry_w
                              _bankjsr $d056, 2
                             
c136 :                       _fs_dir_entry_next_w
                              _bankjsr $d08c, 2
                             
c14e :                       _fs_dir_root_start_w
                              _bankjsr $d011, 2
                             
c166 :                       _get_byte
                              _bankjsr $d25b, 0
                             
c17e :                       _put_byte
                              _bankjsr $d270, 0
                             
c196 :                       _gr_get_key
                              _bankjsr $e390, 0
                             
c1ae :                       _gr_put_byte
                              _bankjsr $e39d, 0
                             
c1c6 :                       _gr_init_screen
                              _bankjsr $de59, 0
                             
c1de :                       _init_acia
                              _bankjsr $d27d, 0
                             
c1f6 :                       _init_cia0
                              _bankjsr $d208, 0
                             
c20e :                       _init_cia1
                              _bankjsr $d239, 0
                             
c226 :                       _init_fs
                              _bankjsr $ceee, 2
                             
c23e :                       _init_sdcard
                              _bankjsr $cbe8, 2
                             
c256 :                       _init_snd
                              _bankjsr $d646, 0
                             
c26e :                       _init_keyboard
                              _bankjsr $d28f, 0
                             
c286 :                       _kb_read_raw
                              _bankjsr $d29e, 0
                             
c29e :                       _kb_read_dip
                              _bankjsr $d309, 0
                             
c2b6 :                       _command_line
                              _bankjsr $cbf1, 0
                             
c2ce :                       _gr_cls
                              _bankjsr $de6c, 0
AS65 Assembler for R6502 [1.42].                                     Page   24
---------------------------------- bank1.s -----------------------------------

                             
c2e6 :                       _gr_init_hires
                              _bankjsr $de16, 0
                             
c2fe :                       _gr_line
                              _bankjsr $e1ca, 0
                             
c316 :                       _gr_box
                              _bankjsr $e00a, 0
                             
c32e :                       _gr_circle
                              _bankjsr $e115, 0
                             
c346 :                       _gr_plot
                              _bankjsr $ded7, 0
                             
c35e :                       _gr_hchar
                              _bankjsr $df15, 0
                             
c376 :                       _gr_point
                              _bankjsr $dfbb, 0
                             
c38e :                       _gr_get
                              _bankjsr $def2, 0
                             
c3a6 :                       _gr_set_cur
                              _bankjsr $defa, 0
                             
c3be :                       _snd_get_note
                              _bankjsr $d63f, 0
                             
c3d6 :                       _snd_get_joy0
                              _bankjsr $c6f9, 0
                             
c3ee :                       _snd_set
                              _bankjsr $c6a1, 0
                             
c406 :                       _vdp_peek
                              _bankjsr $c697, 0
                             
c41e :                       _vdp_poke
                              _bankjsr $c68a, 0
                             
c436 :                       _vdp_init
                              _bankjsr $dc00, 0
                             
c44e :                       _rtc_init
                              _bankjsr $d465, 0
                             
c466 :                       _rtc_gettimedate
                              _bankjsr $d5cb, 0
                             
c47e :                       _rtc_setdatetime
                              _bankjsr $d51c, 0
                             
c496 :                       _rtc_nvread
                              _bankjsr $d636, 0
                             
c4ae :                       _rtc_nvwrite
                              _bankjsr $d61e, 0
                             
c4c6 :                       _fs_dir_fhandle_str
AS65 Assembler for R6502 [1.42].                                     Page   25
---------------------------------- bank1.s -----------------------------------

                              _bankjsr $d642, 2
                             
c4de :                       _sd_sendcmd17
                              _bankjsr $cdc0, 2
                             
c4f6 :                       _sd_sendcmd24
                              _bankjsr $ce39, 2
                             
c50e :                       _cmd_immediate
                              _bankjsr $cbe8, 0
                             
c526 :                       _PT3INIT
                              _bankjsr $e009, 3
                             
c53e :                       _PT3START
                              _bankjsr $e000, 3
                             
c556 :                       _PT3PAUSE
                              _bankjsr $e003, 3
                             
c56e :                       _PT3RESUME
                              _bankjsr $e006, 3
                             
c586 :                       mod_sz_autogen_e
                             
                             	
c586 :                       mod_sz_kernel_s
                             
                             ;* Include all common code in the right order
                             	include "io\io.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.S
                             ;*  General IO module.  Allows different IO devic
                             ;*  utilised transparently by the rest of the cod
                             ;*  Other code should use "io_" commands so that 
                             ;*  do not need to know what specific device is p
                             ;*  input and output capabilities.  On startup, t
                             ;*  examines the BBC DIP switch to decide whether
                             ;*  initialise the IO to serial through the ACIA 
                             ;*  the BBC keyboard for input with the VDP for o
                             ;*  Loading and saving files from the SD card is 
                             ;*  achieved by pointing to SD card get and put b
                             ;*  routines.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c586 :                       mod_sz_io_s
                             
                             ;****************************************
                             ;* io_init
                             ;* Initialise the default device and make active
                             ;* No keys pressed = serial (default)
AS65 Assembler for R6502 [1.42].                                     Page   26
---------------------------------- bank1.s -----------------------------------

                             ;* F0 pressed = KB/VDP
                             ;* F1 pressed = Serial
                             ;* Keyboard and screen or serial port
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c586 :                       io_init
c586 : a900             [ 2] 	lda #0				; Assume it's serial
c588 : 48               [ 3] 	pha
c589 : 209ec2           [ 6] 	jsr _kb_read_dip	; Check DIPs if 0xff then assum
c58c : 2910             [ 2] 	and #0x10
c58e : d00b             [ 3] 	bne io_init_set_default
c590 : 2086c2           [ 6] 	jsr _kb_read_raw	; Check pressed key
c593 : e081             [ 2] 	cpx #0x81			; f1 key pressed (i.e. boot up in se
c595 : f004             [ 3] 	beq io_init_set_default
                             	; Else set to KB/screen for IO
c597 : 68               [ 4] 	pla
c598 : a901             [ 2] 	lda #1
c59a : 48               [ 3] 	pha
c59b :                       io_init_set_default
c59b : 68               [ 4] 	pla
c59c : 8d000c           [ 4] 	sta io_default
c59f : 4ca2c5           [ 3] 	jmp io_set_default	; Activate the default device
                             
                             ;****************************************
                             ;* io_set_default, io_active_device
                             ;* Activate device based on default or A
                             ;* Input : A = Device number
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c5a2 :                       io_set_default			; Entry point for default
c5a2 : ad000c           [ 4] 	lda io_default
c5a5 :                       io_active_device		; Entry point for A set
c5a5 : 0a               [ 2] 	asl	a				; x16 the Block number
c5a6 : 0a               [ 2] 	asl a
c5a7 : 0a               [ 2] 	asl a
c5a8 : 0a               [ 2] 	asl a
c5a9 : a8               [ 2] 	tay
c5aa : a200             [ 2] 	ldx #0
                             	; Copy device settings to io block
c5ac :                       io_copy_data
c5ac : b920c6           [ 4] 	lda io_devices,y
c5af : 9d010c           [ 5] 	sta io_block,x
c5b2 : c8               [ 2] 	iny
c5b3 : e8               [ 2] 	inx
c5b4 : e010             [ 2] 	cpx #io_struct
c5b6 : d0f4             [ 3] 	bne io_copy_data
                             	
c5b8 : a90d             [ 2] 	lda #UTF_CR		; Line terminator is CR
c5ba : 854a             [ 3] 	sta buf_ef
c5bc : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* io_get_ch
                             ;* Get a char (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 0 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
c5bd :                       io_get_ch
c5bd : 6c010c           [ 6] 	jmp (io_block+io_get_byte)
AS65 Assembler for R6502 [1.42].                                     Page   27
---------------------------------- bank1.s -----------------------------------

                             	
                             
                             ;****************************************
                             ;* io_put_ch
                             ;* Put a char
                             ;* Input : A = char
                             ;* Regs affected : P, A
                             ;****************************************
c5c0 :                       io_put_ch
c5c0 : 6c030c           [ 6] 	jmp (io_block+io_put_byte)
                             	
                             ;****************************************
                             ;* io_open_read
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c5c3 :                       io_open_read
c5c3 : 6c050c           [ 6] 	jmp (io_block+io_open_r)
                             	
                             ;****************************************
                             ;* io_open_write
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c5c6 :                       io_open_write
c5c6 : 6c070c           [ 6] 	jmp (io_block+io_open_w)
                             
                             ;****************************************
                             ;* io_close
                             ;* Close a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c5c9 :                       io_close
c5c9 : 6c090c           [ 6] 	jmp (io_block+io_close_f)
                             	
                             ;****************************************
                             ;* io_delete
                             ;* Delete a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c5cc :                       io_delete
c5cc : 6c0b0c           [ 6] 	jmp (io_block+io_del_f)
                             	
                             ;****************************************
                             ;* io_read_line
                             ;* Read a line, terminated by terminating char or
                             ;* Input : buf_(sz/ef) : Address, Max size, end m
                             ;*		    X,A = destination (uses buf_adr)
                             ;*		    Y=max line length
                             ;* Output : Y = Line length C = Buffer limit reac
                             ;* Regs affected : None
                             ;****************************************
c5cf :                       io_read_line
c5cf : 8647             [ 3] 	stx buf_adr			; Save pointer to storage
AS65 Assembler for R6502 [1.42].                                     Page   28
---------------------------------- bank1.s -----------------------------------

c5d1 : 8548             [ 3] 	sta buf_adr+1
c5d3 : 8449             [ 3] 	sty buf_sz			; Max length
c5d5 : 08               [ 3] 	php					; Save echo state
c5d6 : a000             [ 2] 	ldy #0x00			; Starting at first byte
c5d8 :                       io_get_line_byte
c5d8 : 38               [ 2] 	sec					; Getting bytes synchronously
c5d9 : 20bdc5           [ 6] 	jsr io_get_ch		; Get a byte
c5dc : b026             [ 4] 	bcs io_get_line_done; Got nothing then finish
c5de : 28               [ 4] 	plp					; Get echo state
c5df : 08               [ 3] 	php					; Instantly save it back
c5e0 : 900c             [ 3] 	bcc io_skip_echo	; Carry not set = don't echo
c5e2 : c97f             [ 2] 	cmp #UTF_DEL		; Delete?
c5e4 : d005             [ 3] 	bne io_do_echo
c5e6 : c000             [ 2] 	cpy #0				; Already at beginning?
c5e8 : f004             [ 3] 	beq io_skip_echo	; Don't echo delete
c5ea : 88               [ 2] 	dey					; Else decrement length
c5eb :                       io_do_echo
c5eb : 20c0c5           [ 6] 	jsr io_put_ch		; Echo it
c5ee :                       io_skip_echo
c5ee : c920             [ 2] 	cmp #UTF_SPECIAL	; Special character?
c5f0 : 9007             [ 3] 	bcc io_skip_special	; Skip if so (don't add to b
c5f2 : c97f             [ 2] 	cmp #UTF_DEL		; Don't proces DEL either
c5f4 : f003             [ 3] 	beq io_skip_special
c5f6 : 9147             [ 5] 	sta (buf_adr),y		; Save it
c5f8 : c8               [ 2] 	iny					; Increase length
c5f9 :                       io_skip_special
c5f9 : c54a             [ 3] 	cmp buf_ef			; Is it the terminating char?
c5fb : f007             [ 4] 	beq io_get_line_done	; If yes then done
c5fd : c449             [ 3] 	cpy buf_sz			; Reached the buffer max size?
c5ff : d0d7             [ 3] 	bne io_get_line_byte	; No, get another byte
c601 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c602 : 38               [ 2] 	sec					; Yes, set carry flag
c603 : 60               [ 6] 	rts					; And done
c604 :                       io_get_line_done
c604 : a900             [ 2] 	lda #0
c606 : 9147             [ 5] 	sta (buf_adr),y		; Terminate with 0
c608 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c609 : 18               [ 2] 	clc					; Clear carry flag
c60a : 60               [ 6] 	rts					; Fin
                             
                             ;****************************************
                             ;* io_print_line
                             ;* Print a line (when data is not already in seri
                             ;* Input : X = Address Lo, A = Address Hi
                             ;* Output : Y=number chars output
                             ;* Regs affected : All
                             ;****************************************
c60b :                       io_print_line
c60b : 48               [ 3] 	pha
                             
c60c : 863d             [ 3] 	stx tmp_c					; Store the string pointer
c60e : 853e             [ 3] 	sta tmp_c+1					; lo and hi
c610 : a000             [ 2] 	ldy #0						; Start at the beginning!
c612 :                       io_print_line_byte
c612 : b13d             [ 5] 	lda (tmp_c),y				; Copy byte to
c614 : f006             [ 3] 	beq io_print_done			; If zero then done - print
c616 : 20c0c5           [ 6] 	jsr io_put_ch				; Transmit
c619 : c8               [ 2] 	iny
c61a : d0f6             [ 3] 	bne io_print_line_byte		; Carry on until zero fo
c61c :                       io_print_done
c61c : 68               [ 4] 	pla
c61d : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   29
---------------------------------- bank1.s -----------------------------------

                             
                             
                             ;*** Null operation just clc and return ***
c61e :                       io_null_op
c61e : 18               [ 2] 	clc
c61f : 60               [ 6] 	rts
                             	
                             ;* IO devices defined here
c620 :                       io_devices
                             ;* Device zero is the serial port
                             ;* only offers get and put
c620 :                       io_device0					; Serial device, input = Ser, outp
c620 : 66c1                  	dw	_get_byte			; io_get_ch
c622 : 7ec1                  	dw	_put_byte			; io_put_ch
c624 : 1ec6                  	dw	io_null_op			; io_open_r
c626 : 1ec6                  	dw	io_null_op			; io_open_w
c628 : 1ec6                  	dw	io_null_op			; io_close_f
c62a : 1ec6                  	dw	io_null_op			; io_del_f
c62c : 1ec6                  	dw	io_null_op			; io_ext1
c62e : 1ec6                  	dw	io_null_op			; io_ext2
                             ;* Device one is keyboard / screen
                             ;* only offers get and put
c630 :                       io_device1					; Default device, input = screen e
c630 : 96c1                  	dw	_gr_get_key			; io_get_ch
c632 : aec1                  	dw	_gr_put_byte		; io_put_ch
c634 : 1ec6                  	dw	io_null_op			; io_open_r
c636 : 1ec6                  	dw	io_null_op			; io_open_w
c638 : 1ec6                  	dw	io_null_op			; io_close_f
c63a : 1ec6                  	dw	io_null_op			; io_del_f
c63c : 1ec6                  	dw	io_null_op			; io_ext1
c63e : 1ec6                  	dw	io_null_op			; io_ext2
                             ;* Device two is the file system on SD card
                             ;* Offers all IO functions
c640 :                       io_device2					; SD device, input = SD, output = 
c640 : bec0                  	dw	_fs_get_byte_w		; io_get_ch
c642 : 06c1                  	dw	_fs_put_byte_w		; io_put_ch
c644 : d6c0                  	dw	_fs_open_read_w		; io_open_r
c646 : eec0                  	dw	_fs_open_write_w	; io_open_w
c648 : a6c0                  	dw	_fs_close_w			; io_close_f
c64a : 8ec0                  	dw	_fs_delete_w		; io_del_f
c64c : 1ec6                  	dw	io_null_op			; io_ext1
c64e : 1ec6                  	dw	io_null_op			; io_ext2
                             
c650 :                       mod_sz_io_e
                             
                             
                             	include "kernel\vdp-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  VDP-LOW.S
                             ;*  Low level VDP routines which will always be p
                             ;*  every ROM bank.  This is to ensure if IRQ nee
                             ;*  no slow bank switching is needed, but also to
                             ;*	OS vectored access to VDP routines for M/C fro
                             ;*
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page   30
---------------------------------- bank1.s -----------------------------------

                             
                             ;****************************************
                             ;* vdp_wr_reg
                             ;* Write to Register A the value X
                             ;* Input : A - Register Number, X - Data
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c650 :                       vdp_wr_reg
c650 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c653 : ea               [ 2] 	nop
c654 : ea               [ 2] 	nop
c655 : 0980             [ 2] 	ora #0x80
c657 : 8d0105           [ 4] 	sta VDP_MODE1
c65a : 4980             [ 2] 	eor #0x80
c65c : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* vdp_wr_addr
                             ;* Write to address in X (low) and A (high) - for
                             ;* Input : A - Address high byte, X - Address low
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c65d :                       vdp_wr_addr
c65d : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c660 : ea               [ 2] 	nop
c661 : ea               [ 2] 	nop
c662 : ea               [ 2] 	nop
c663 : 0940             [ 2] 	ora #0x40		; Required by VDP
c665 : 8d0105           [ 4] 	sta VDP_MODE1
c668 : 4940             [ 2] 	eor #0x40		; Undo that bit
c66a : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* vdp_mem_wait
                             ;* Delay some time before a memory access,
                             ;* taking in to account mode 9918 needs up
                             ;* to 3.1uS for text mode, 8uS for graphics
                             ;* I and II
                             ;* @ 5.35Mhz	= 16 cycles for 3.1uS
                             ;*				= 43 cycles for 8uS
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c66b :                       vdp_mem_wait
c66b : da               [ 3] 	phx								; 3
c66c : a616             [ 3] 	ldx vdp_delay					; 3
c66e : f003             [ 3] 	beq vdp_mem_wait_end			; 3
c670 :                       vdp_mem_wait_loop
c670 : ca               [ 2] 	dex								; 2
c671 : d0fd             [ 3] 	bne	vdp_mem_wait_loop			; 3
c673 :                       vdp_mem_wait_end
c673 : fa               [ 4] 	plx								; 3
c674 : 60               [ 6] 	rts								; 6
                             	
                             ;****************************************
                             ;* vdp_rd_addr
AS65 Assembler for R6502 [1.42].                                     Page   31
---------------------------------- bank1.s -----------------------------------

                             ;* Set read address 
                             ;* Input : A - high, X - low 
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c675 :                       vdp_rd_addr
c675 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; These nops are needed for fast CPU
c678 : ea               [ 2] 	nop
c679 : ea               [ 2] 	nop
c67a : ea               [ 2] 	nop
c67b : 8d0105           [ 4] 	sta VDP_MODE1
c67e : 80eb             [ 3] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_rd_vram
                             ;* Read VRAM byte, result in A
                             ;* Input : None
                             ;* Output : A - Byte from VRAM
                             ;* Regs affected : P
                             ;****************************************
c680 :                       vdp_rd_vram
c680 : ad0005           [ 4] 	lda VDP_VRAM
c683 : 80e6             [ 3] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_wr_vram
                             ;* Write VRAM byte in A
                             ;* Input : A - Byte to write
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c685 :                       vdp_wr_vram
c685 : 8d0005           [ 4] 	sta VDP_VRAM
c688 : 80e1             [ 3] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_poke
                             ;* Write VRAM byte in A, (YX)
                             ;* Input : A - Byte to write
                             ;*		   X = Low Address
                             ;*		   Y = High Address
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c68a :                       vdp_poke
c68a : 08               [ 3] 	php
c68b : 48               [ 3] 	pha
c68c : 98               [ 2] 	tya
c68d : 78               [ 2] 	sei
c68e : 205dc6           [ 6] 	jsr vdp_wr_addr
c691 : 68               [ 4] 	pla
c692 : 2085c6           [ 6] 	jsr vdp_wr_vram
c695 : 28               [ 4] 	plp
c696 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* vdp_peek
                             ;* Get VRAM byte in (AX)
                             ;*		   X = Low Address
                             ;*		   A = High Address
                             ;* Output : A = byte read
AS65 Assembler for R6502 [1.42].                                     Page   32
---------------------------------- bank1.s -----------------------------------

                             ;* Regs affected : None
                             ;****************************************
c697 :                       vdp_peek
c697 : 08               [ 3] 	php
c698 : 78               [ 2] 	sei
c699 : 2075c6           [ 6] 	jsr vdp_rd_addr
c69c : 2080c6           [ 6] 	jsr vdp_rd_vram
c69f : 28               [ 4] 	plp
c6a0 : 60               [ 6] 	rts
                             
                             	include "kernel\snd-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SND-LOW.S
                             ;*  Low level sound routines which will always be
                             ;*  in every ROM bank.  Mainly to provide fast OS
                             ;*	access to VDP routines for M/C from BASIC
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* snd_set
                             ;* Set AY register X to value Y
                             ;* Input : X = Reg no, Y = Value
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c6a1 :                       snd_set
c6a1 : 48               [ 3] 	pha
                             
c6a2 : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c6a4 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c6a7 : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c6aa : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c6ad : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6af : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c6b1 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c6b4 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6b6 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             	
c6b9 : 8c8104           [ 4] 	sty SND_ADBUS			; Put Y on the sound bus (Y = va
c6bc : 0902             [ 2] 	ora #SND_SELWRITE		; Select mode for writing dat
c6be : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             	
c6c1 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6c3 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c6c6 : 68               [ 4] 	pla
                             	
c6c7 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get
AS65 Assembler for R6502 [1.42].                                     Page   33
---------------------------------- bank1.s -----------------------------------

                             ;* Get AY register X to Y
                             ;* Input : X = Reg no
                             ;* Output : Y = Value
                             ;* Regs affected : None
                             ;****************************************
c6c8 :                       snd_get
c6c8 : 48               [ 3] 	pha
                             
c6c9 : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c6cb : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c6ce : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c6d1 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c6d4 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6d6 : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c6d8 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c6db : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6dd : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c6e0 : a900             [ 2] 	lda #0x00				; Set Port A to input
c6e2 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c6e5 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c6e8 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6ea : 0940             [ 2] 	ora #SND_SELREAD		; Select mode for reading data
c6ec : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c6ef : ac8104           [ 4] 	ldy SND_ADBUS			; Get value in to Y
                             	
c6f2 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6f4 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c6f7 : 68               [ 4] 	pla
                             	
c6f8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get_joy0
                             ;* Return value of joystick 0
                             ;* Input : None
                             ;* Output : Y = Value
                             ;* Regs affected : X
                             ;****************************************
c6f9 :                       snd_get_joy0
c6f9 : a20f             [ 2] 	ldx #SND_REG_IOB		; Joystick is plugged in to IO
c6fb : 20c8c6           [ 6] 	jsr snd_get				; Get IOB, result in Y
c6fe : 60               [ 6] 	rts
                             
                             	include "kernel\main.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  MAIN.S
                             ;*  This is where the main user program is execut
                             ;*  the 'kernel' once the system is initialised a
AS65 Assembler for R6502 [1.42].                                     Page   34
---------------------------------- bank1.s -----------------------------------

                             ;*  Today, main does very little - first shows th
                             ;*  boot up message, and then passes control to d
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
c6ff :                       main
                             
c6ff :                       infinity
c6ff : 2046c0           [ 6] 	jsr _df_pg_dflat
c702 : 4cffc6           [ 3] 	jmp infinity
                             
c705 :                       msg_hello_world
                             	;* build.s is generated by the assemble.bat file
                             	;* all it does is echo an assembler line to
                             	;* including the build date in the message.
                             	include "kernel\build.s"
c705 : 4275696c64203a..       db "Build : 23-01-2025\r"
c718 : 3132384b204272..       db "128K Breadboard Computer\r"
c731 : 42792040363530..       db "By @6502Nerd\r"
c73e : 436f7079726967..       db "Copyright (c) 2025\r",0
                             
                             
                             	include "kernel\irq.s"
                             	
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IRQ.S
                             ;*	This is the IRQ handler - handles both the ver
                             ;*  blank interrupt from the VDP as well as softw
                             ;*  
                             ;*  As the handler has to be in every bank and it
                             ;*  accesses the VDP, then low level VDP routines
                             ;*  bundled in this file to ensure they are alway
                             ;*  without a bank switch being needed (which is 
                             ;************************************************
                             
                             ;* NMI handler installs to handle serial receive 
c752 :                       init_nmi
                             	; Core IRQ handler
c752 : a963             [ 2] 	lda #lo(nmi)
c754 : 8502             [ 3] 	sta int_nmi
c756 : a9c7             [ 2] 	lda #hi(nmi)
c758 : 8503             [ 3] 	sta int_nmi+1
                             
c75a : a9d3             [ 2] 	lda #lo(null_handler)
c75c : 850c             [ 3] 	sta int_usercia1
c75e : a9c7             [ 2] 	lda #hi(null_handler)
c760 : 850d             [ 3] 	sta int_usercia1+1
                             
c762 : 60               [ 6] 	rts
                             
                             ;* Calls the master IRQ handler
c763 :                       call_nmi_master
AS65 Assembler for R6502 [1.42].                                     Page   35
---------------------------------- bank1.s -----------------------------------

                             ;	jmp (int_nmi)
                             
                             ;* Master NMI handler
                             ;* 6551 uses this - fills the receive buffer
                             ;* VIA 2 uses this- user interrupt
c763 :                       nmi
c763 : 48               [ 3] 	pha
                             
c764 : ad8105           [ 4] 	lda SER_STATUS				; Read status register (clears
c767 : 100c             [ 3] 	bpl	nmi_skip_acia			; If no interrupt don't do a
                             
c769 : 5a               [ 3] 	phy
c76a : ad8005           [ 4] 	lda SER_DATA				; Read the data register of 6551
c76d : a40f             [ 3] 	ldy ser_last				; Put byte in last position of F
c76f : 990008           [ 5] 	sta ser_buf,y
c772 : e60f             [ 5] 	inc ser_last				; Advance position of last
                             
c774 : 7a               [ 4] 	ply
c775 :                       nmi_skip_acia
                             	;* Try PIA1 first for rapid Timer handling
c775 : ad8d04           [ 4] 	lda IO_1 + IFR
c778 : 1026             [ 3] 	bpl nmi_fin
c77a : 5a               [ 3] 	phy
c77b : da               [ 3] 	phx
                             	; Reset interrupt by reading T1C-L
c77c : ad8404           [ 4] 	lda IO_1+T1CL
                             	; Swtich to RAM bank 2 don't touch anything else
c77f : ad0004           [ 4] 	lda IO_0+PRB
c782 : 48               [ 3] 	pha                     ; Remember the bank #
c783 : 29cf             [ 2] 	and #0b11001111
c785 : 0920             [ 2] 	ora #0b00100000
c787 : 8d0004           [ 4] 	sta IO_0+PRB
                             	; Switch out ROM for RAM
c78a : ad8004           [ 4] 	lda IO_1+PRB                    ; Get current RO
c78d : 48               [ 3] 	pha
c78e : 29df             [ 2] 	and #(0xff ^ MM_DIS)            ; Switch off ROM
c790 : 8d8004           [ 4] 	sta IO_1+PRB                    ; Update port to
c793 : 20cfc7           [ 6] 	jsr call_irq_usercia1			; Call user cia1 handler
                             	; Restore ROM
c796 : 68               [ 4] 	pla                             ; Get original p
c797 : 8d8004           [ 4] 	sta IO_1+PRB                    ; Update port to
                             	; Restore RAM bank
c79a : 68               [ 4] 	pla                             ; Get original p
c79b : 8d0004           [ 4] 	sta IO_0+PRB                    ; Update port to
c79e : fa               [ 4] 	plx
c79f : 7a               [ 4] 	ply
c7a0 :                       nmi_fin
c7a0 : 68               [ 4] 	pla
c7a1 : 40               [ 6] 	rti
                             
                             
                             ;* Obviously this can only be done with
                             ;* interrupts disabled!
c7a2 :                       init_irq
                             	; Core IRQ handler
c7a2 : a9d4             [ 2] 	lda #lo(irq)
c7a4 : 8504             [ 3] 	sta int_irq
c7a6 : a9c7             [ 2] 	lda #hi(irq)
c7a8 : 8505             [ 3] 	sta int_irq+1
                             	
                             	; Core BRK handler
c7aa : a9fa             [ 2] 	lda #lo(irq_brk)
AS65 Assembler for R6502 [1.42].                                     Page   36
---------------------------------- bank1.s -----------------------------------

c7ac : 8506             [ 3] 	sta int_brk
c7ae : a9c7             [ 2] 	lda #hi(irq_brk)
c7b0 : 8507             [ 3] 	sta int_brk+1
                             
                             	; User handlers for VDP, PIA0 interrupts
c7b2 : a9d3             [ 2] 	lda #lo(null_handler)
c7b4 : 8508             [ 3] 	sta int_uservdp
c7b6 : a9c7             [ 2] 	lda #hi(null_handler)
c7b8 : 8509             [ 3] 	sta int_uservdp+1
                             
c7ba : a9d3             [ 2] 	lda #lo(null_handler)
c7bc : 850a             [ 3] 	sta int_usercia0
c7be : a9c7             [ 2] 	lda #hi(null_handler)
c7c0 : 850b             [ 3] 	sta int_usercia0+1
                             
c7c2 : 60               [ 6] 	rts
                             
                             ;* Calls the master IRQ handler
c7c3 :                       call_irq_master
c7c3 : 6c0400           [ 6] 	jmp (int_irq)
                             	
                             ;* Calls the BRK handler
c7c6 :                       call_irq_brk
c7c6 : 6c0600           [ 6] 	jmp (int_brk)
                             
                             ;* Call the userVDP handler
c7c9 :                       call_irq_uservdp
c7c9 : 6c0800           [ 6] 	jmp (int_uservdp)
                             	
                             ;* Call the user CIA0 handler
c7cc :                       call_irq_usercia0
c7cc : 6c0a00           [ 6] 	jmp (int_usercia0)
                             
                             ;* Call the user CIA1 handler
c7cf :                       call_irq_usercia1
c7cf : 6c0c00           [ 6] 	jmp (int_usercia1)
                             	
                             ;* null interrupt
c7d2 :                       null_irq
c7d2 : 40               [ 6] 	rti
                             
                             ;* null handler
c7d3 :                       null_handler
c7d3 : 60               [ 6] 	rts
                             	
                             
                             ;* Master IRQ handler
c7d4 :                       irq
                             	_pushAXY
                             
                             
                             	; Check if IRQ or BRK
                             	; load P from stack in to A
c7d7 : ba               [ 2] 	tsx
c7d8 : bd0401           [ 4] 	lda 0x104,x
                             	; BRK bit set?
c7db : 2910             [ 2] 	and #0x10
c7dd : d0e7             [ 3] 	bne call_irq_brk
                             	
c7df : 18               [ 2] 	clc						; Standard behaviour
                             	
                             	;* Try VDP next
AS65 Assembler for R6502 [1.42].                                     Page   37
---------------------------------- bank1.s -----------------------------------

c7e0 :                       irq_check_vdp	
c7e0 : ad0105           [ 4] 	lda VDP_STATUS			; Read status register
c7e3 : 1009             [ 3] 	bpl	irq_check_cia0		; Skip if not VBLANK
c7e5 : 20c9c7           [ 6] 	jsr call_irq_uservdp	; Call use VDP handler
c7e8 : 2047c8           [ 6] 	jsr int_vdp_handler		; Call  OS VDP handler
c7eb : 2025c8           [ 6] 	jsr int_kb_handler		; Call OS cia0 handler (keyb
                             
                             	;* Try VIA0 last as it's keyboard (low speed)
c7ee :                       irq_check_cia0
c7ee : ad0d04           [ 4] 	lda IO_0 + IFR
c7f1 : 1003             [ 3] 	bpl irq_fin
c7f3 : 20ccc7           [ 6] 	jsr call_irq_usercia0	; Call user cia0 handler
                             
c7f6 :                       irq_fin
                             	_pullAXY
                             
c7f9 : 40               [ 6] 	rti
                             	
                             ;* Handle BRK
c7fa :                       irq_brk
                             	; Handle BRK
                             	; Get PCL,H minus 2 gives the BRK instruction ad
c7fa : 38               [ 2] 	sec
c7fb : bd0501           [ 4] 	lda 0x0105,x
c7fe : e902             [ 2] 	sbc #2
c800 : 85a4             [ 3] 	sta df_brkpc
c802 : bd0601           [ 4] 	lda 0x0106,x
c805 : e900             [ 2] 	sbc #0
c807 : 85a5             [ 3] 	sta df_brkpc+1
                             	; Get the byte pointed to by old PC
                             	; which is 1 on from the BRK
c809 : a001             [ 2] 	ldy #1
c80b : b1a4             [ 5] 	lda (df_brkpc),y
c80d : 85a6             [ 3] 	sta df_brkval
c80f : 859f             [ 3] 	sta errno
                             	; now update the return address
c811 : a5a2             [ 3] 	lda df_pc
c813 : 9d0501           [ 5] 	sta 0x105,x
c816 : a5a3             [ 3] 	lda df_pc+1
c818 : 9d0601           [ 5] 	sta 0x106,x
                             	
                             	_pullAXY
                             
                             	; Save the registers in temp area
c81e : 8585             [ 3] 	sta num_a
c820 : 8686             [ 3] 	stx num_a+1
c822 : 8487             [ 3] 	sty num_a+2
                             	; when RTI occurs:
                             	;  will return to error handler
                             	;  df_brkval will contain signature
c824 : 40               [ 6] 	rti
                             	
                             ;****************************************
                             ;* int_kb_handler
                             ;* Keyboard interrupt handler
                             ;****************************************
c825 :                       int_kb_handler	
c825 : a537             [ 3] 	lda kb_deb				; If keyboard pressed is debounce 
c827 : d00d             [ 3] 	bne int_skip_scan		; If not zero, then don't che
c829 : ad0d04           [ 4] 	lda IO_0 + IFR			; Check status register CIA0
c82c : 2901             [ 2] 	and #IFR_CA2			; Keyboard pressed?
c82e : f00c             [ 3] 	beq int_keys_up
AS65 Assembler for R6502 [1.42].                                     Page   38
---------------------------------- bank1.s -----------------------------------

c830 :                       int_do_read
c830 : 853c             [ 3] 	sta kb_pressed			; Put non-zero in to this flag
c832 : a53b             [ 3] 	lda kb_debounce			; Set debounce
c834 : 8537             [ 3] 	sta kb_deb
c836 :                       int_skip_scan
c836 : a901             [ 2] 	lda #IFR_CA2			; Clear CA2
c838 : 8d0d04           [ 4] 	sta IO_0 + IFR
c83b : 60               [ 6] 	rts
c83c :                       int_keys_up					; No key pressed
c83c : 6433             [ 3] 	stz kb_raw				; Using 65c02 stz opcode
c83e : 6434             [ 3] 	stz kb_last
c840 : 6435             [ 3] 	stz kb_code
c842 : 6437             [ 3] 	stz kb_deb
c844 : 6438             [ 3] 	stz kb_rep
c846 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* int_vdp_handler
                             ;* VDP interrupt handler
                             ;****************************************
c847 :                       int_vdp_handler
c847 : 2073c8           [ 6] 	jsr update_timers	; If it is then update system 
                             
c84a : a512             [ 3] 	lda vdp_curoff		; Is cursor enabled?
c84c : d024             [ 3] 	bne int_vdp_fin		; Skip if not
                             
c84e : c613             [ 5] 	dec vdp_curstat		; Decrement VDP counter
c850 : a513             [ 3] 	lda vdp_curstat		; Check it
c852 : 297f             [ 2] 	and #0x7f			; If bottom 7 bits !=0
c854 : d01c             [ 3] 	bne int_vdp_fin		; No flashing to be done
c856 : a513             [ 3] 	lda vdp_curstat		; Invert top bit (bottoms bits=
c858 : 4990             [ 2] 	eor #0x80+VDP_FLASH	; Start counter again
c85a : 8513             [ 3] 	sta vdp_curstat		
                             
c85c : 18               [ 2] 	clc					; Add offset for cursor address in vram
c85d : a52c             [ 3] 	lda gr_scrngeom+gr_cur_ptr
c85f : 6529             [ 3] 	adc gr_scrngeom+gr_cur_off
c861 : aa               [ 2] 	tax
c862 : a52d             [ 3] 	lda gr_scrngeom+gr_cur_ptr+1
c864 : 6900             [ 2] 	adc #0
                             
c866 : 205dc6           [ 6] 	jsr vdp_wr_addr
                             	
c869 : a513             [ 3] 	lda vdp_curstat
c86b : 2980             [ 2] 	and #0x80
c86d : 4514             [ 3] 	eor vdp_curval		; EOR top bit with what is under
c86f : 2085c6           [ 6] 	jsr vdp_wr_vram
c872 :                       int_vdp_fin	
c872 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* update_timers
                             ;* Update 24 bit timer and debounce counters
                             ;****************************************
c873 :                       update_timers
c873 : e610             [ 5] 	inc vdp_int_cnt
c875 : d002             [ 3] 	bne inc_kb_timers
c877 : e611             [ 5] 	inc vdp_int_cnt+1
c879 :                       inc_kb_timers
c879 : a637             [ 3] 	ldx kb_deb			; Is debounce 0?
c87b : f002             [ 3] 	beq skip_kb_deb
AS65 Assembler for R6502 [1.42].                                     Page   39
---------------------------------- bank1.s -----------------------------------

c87d : c637             [ 5] 	dec kb_deb
c87f :                       skip_kb_deb
c87f : a638             [ 3] 	ldx kb_rep			; Is repeat timer 0?
c881 : f002             [ 3] 	beq skip_kb_rep
c883 : c638             [ 5] 	dec kb_rep
c885 :                       skip_kb_rep
c885 : 60               [ 6] 	rts
                             	
                             
                             	include "utils\misc.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  MISC.S
                             ;*  Miscellaneous module for commmon utility func
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* long_delay
                             ;* Long delay (X decremented every 0.125ms)
                             ;* Input : X = number of 0.125ms ticks to wait (m
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c886 :                       long_delay
c886 : 08               [ 3] 	php
                             	_pushAXY
                             
                             	
c88a : a000             [ 2] 	ldy #0x00
c88c :                       long_delay_1
c88c : ea               [ 2] 	nop
c88d : ea               [ 2] 	nop
c88e : ea               [ 2] 	nop
c88f : ea               [ 2] 	nop
c890 : 88               [ 2] 	dey
c891 : d0f9             [ 3] 	bne long_delay_1
c893 : ca               [ 2] 	dex
c894 : d0f6             [ 3] 	bne long_delay_1
                             
                             	_pullAXY
                             
c899 : 28               [ 4] 	plp
                             	
c89a : 60               [ 6] 	rts
                             
                             
                             	include "utils\utils.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
AS65 Assembler for R6502 [1.42].                                     Page   40
---------------------------------- bank1.s -----------------------------------

                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  UTILS.S
                             ;*  This module implements various utility functi
                             ;*  converting from ASCII to binary form for numb
                             ;*  vice-versa to allow humans to actually be abl
                             ;*  and read numbers in their prefered form!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c89b :                       utilPrintSPC
c89b : 48               [ 3] 	pha
c89c : a920             [ 2] 	lda #' '
c89e : 20c0c5           [ 6] 	jsr io_put_ch
c8a1 : 68               [ 4] 	pla
c8a2 : 60               [ 6] 	rts
                             
c8a3 :                       utilPrintCRLF
c8a3 : 48               [ 3] 	pha
c8a4 : a90d             [ 2] 	lda #UTF_CR
c8a6 : 20c0c5           [ 6] 	jsr io_put_ch
c8a9 : 68               [ 4] 	pla
c8aa : 60               [ 6] 	rts
                             
c8ab :                       utilPrintA
c8ab : 8545             [ 3] 	sta tmp_d
c8ad : 48               [ 3] 	pha
c8ae : 8a               [ 2] 	txa
c8af : 48               [ 3] 	pha
c8b0 : a545             [ 3] 	lda tmp_d
c8b2 : 20d0c8           [ 6] 	jsr str_a_to_x
c8b5 : 20c0c5           [ 6] 	jsr io_put_ch
c8b8 : 8a               [ 2] 	txa
c8b9 : 20c0c5           [ 6] 	jsr io_put_ch
c8bc : 68               [ 4] 	pla
c8bd : aa               [ 2] 	tax
c8be : 68               [ 4] 	pla
c8bf : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* util_clr_mem
                             ;* Clear a block of main ram
                             ;* Input : X, A = Block start, Y = Block size
                             ;* Regs affected : P
                             ;****************************************
c8c0 :                       util_clr_mem
c8c0 : 48               [ 3] 	pha
c8c1 : 5a               [ 3] 	phy
c8c2 : 863f             [ 3] 	stx tmp_v1
c8c4 : 8540             [ 3] 	sta tmp_v1+1
c8c6 : a900             [ 2] 	lda #0
c8c8 :                       mem_clr_byte
c8c8 : 88               [ 2] 	dey
c8c9 : 913f             [ 5] 	sta (tmp_v1),y
c8cb : d0fb             [ 3] 	bne mem_clr_byte
c8cd : 7a               [ 4] 	ply
c8ce : 68               [ 4] 	pla
c8cf : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   41
---------------------------------- bank1.s -----------------------------------

                             
                             ;****************************************
                             ;* str_a_to_x
                             ;* Convert accumulator to hex string
                             ;* Input : A = Byte to convert
                             ;* Output : A = High Char, X = Low Char
                             ;* Regs affected : P
                             ;****************************************
c8d0 :                       str_a_to_x
c8d0 : 48               [ 3] 	pha					; Save the byte using later on
c8d1 : 290f             [ 2] 	and #0x0f			; Mask low nibble
c8d3 : 18               [ 2] 	clc
c8d4 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c8d6 : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c8d8 : 9002             [ 3] 	bcc skip_a_f_1		; skip a-f adjustment
c8da : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c8dc :                       skip_a_f_1
c8dc : aa               [ 2] 	tax					; Low char is in X
c8dd : 68               [ 4] 	pla					; Get byte back
c8de : 4a               [ 2] 	lsr a				; Make high nibble low
c8df : 4a               [ 2] 	lsr a
c8e0 : 4a               [ 2] 	lsr a
c8e1 : 4a               [ 2] 	lsr a
c8e2 : 18               [ 2] 	clc
c8e3 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c8e5 : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c8e7 : 9002             [ 3] 	bcc skip_a_f_2		; skip a-f adjustment
c8e9 : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c8eb :                       skip_a_f_2
                             
c8eb : 18               [ 2] 	clc					; No error
c8ec : 60               [ 6] 	rts					; A high nibble
                             
                             ;****************************************
                             ;* str_x_to_a
                             ;* Convert hex string to accumulator
                             ;* Input : A = High Char, X = Low Char
                             ;* Output : A = Value
                             ;* Regs affected : P
                             ;****************************************
c8ed :                       str_x_to_a
c8ed : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c8ef : 38               [ 2] 	sec					; Process high char in A
c8f0 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c8f2 : c90a             [ 2] 	cmp #10				; If A < 10 then
c8f4 : 9002             [ 3] 	bcc skip_x_f_1		; skip a-f adjustment
c8f6 : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c8f8 :                       skip_x_f_1
c8f8 : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c8fa : b01d             [ 4] 	bcs	str_x_to_a_err	; Error if not
                             
c8fc : 0a               [ 2] 	asl a				; This is the high nibble
c8fd : 0a               [ 2] 	asl a
c8fe : 0a               [ 2] 	asl a
c8ff : 0a               [ 2] 	asl a
c900 : 48               [ 3] 	pha					; Save the high nibble
c901 : 8a               [ 2] 	txa					; Now process the low char in X
c902 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c904 : 38               [ 2] 	sec
c905 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c907 : c90a             [ 2] 	cmp #10				; If A < 10 then
c909 : 9002             [ 3] 	bcc skip_x_f_2		; skip a-f adjustment
AS65 Assembler for R6502 [1.42].                                     Page   42
---------------------------------- bank1.s -----------------------------------

c90b : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c90d :                       skip_x_f_2
c90d : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c90f : b007             [ 3] 	bcs	str_x_to_a_errl	; Error if not
                             
c911 : 8585             [ 3] 	sta num_a			; Store low nibble in temp
c913 : 68               [ 4] 	pla					; Get high nibble
c914 : 0585             [ 3] 	ora num_a			; OR with low nibble
                             
c916 : 18               [ 2] 	clc					; No error
c917 : 60               [ 6] 	rts					; A contains value
                             
c918 :                       str_x_to_a_errl
c918 : 68               [ 4] 	pla
c919 :                       str_x_to_a_err
                             	SWBRK CMD_ERR_VAL
                             
                             
                             ;****************************************
                             ;* con_n_to_a
                             ;* Convert numeric string to accumulator (unsigne
                             ;* Input : Pointer to string (X=L, A=H), Y = Sour
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* A = Source type detected
                             ;* Regs affected : CS = Error
                             ;****************************************
c91b :                       con_n_to_a
c91b : 8691             [ 3] 	stx num_tmp
c91d : 8592             [ 3] 	sta num_tmp+1
c91f : 6485             [ 3] 	stz num_a
c921 : 6486             [ 3] 	stz num_a+1
c923 : c000             [ 2] 	cpy #NUM_ANY
c925 : f014             [ 3] 	beq con_n_to_a_detect
c927 : 88               [ 2] 	dey
c928 : d003             [ 3] 	bne con_n_not_dec
c92a :                       con_dec_jmp
c92a : 4cbec9           [ 3] 	jmp con_dec_to_a_int
c92d :                       con_n_not_dec
c92d : 88               [ 2] 	dey
c92e : d003             [ 3] 	bne con_n_not_hex
c930 :                       con_hex_jmp
c930 : 4c55c9           [ 3] 	jmp con_hex_to_a_int
c933 :                       con_n_not_hex
c933 : 88               [ 2] 	dey
c934 : d003             [ 3] 	bne con_n_err
c936 :                       con_bin_jmp
c936 : 4c94c9           [ 3] 	jmp con_bin_to_a_int
c939 :                       con_n_err
c939 : 38               [ 2] 	sec
c93a : 60               [ 6] 	rts
c93b :                       con_n_to_a_detect
c93b : b291             [ 5] 	lda (num_tmp)
c93d : c930             [ 2] 	cmp #'0'
c93f : d0e9             [ 3] 	bne con_dec_jmp
c941 : a001             [ 2] 	ldy #1
c943 : b191             [ 5] 	lda (num_tmp),y
c945 : 0920             [ 2] 	ora #0x20
c947 : c978             [ 2] 	cmp #'x'
c949 : f0e5             [ 3] 	beq con_hex_jmp
c94b : c962             [ 2] 	cmp #'b'
c94d : f0e7             [ 3] 	beq con_bin_jmp
c94f : 80d9             [ 3] 	bra con_dec_jmp
AS65 Assembler for R6502 [1.42].                                     Page   43
---------------------------------- bank1.s -----------------------------------

                             
                             ;****************************************
                             ;* con_hex_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c951 :                       con_hex_to_a
c951 : 8691             [ 3] 	stx num_tmp
c953 : 8592             [ 3] 	sta num_tmp+1
c955 :                       con_hex_to_a_int
c955 : a205             [ 2] 	ldx #5			; > 4 digits will cause error
c957 : a002             [ 2] 	ldy #2			; start at first digit
c959 :                       con_hex_digit
c959 : b191             [ 5] 	lda (num_tmp),y
c95b : 0920             [ 2] 	ora #0x20					; Make alpha in to lower case
c95d : 38               [ 2] 	sec							; Process high char in A
c95e : e930             [ 2] 	sbc #'0'					; Convert to hex nibble
c960 : c90a             [ 2] 	cmp #10						; If A < 10 then
c962 : 9002             [ 3] 	bcc con_hex_skip_x_f_1		; skip a-f adjustment
c964 : e927             [ 2] 	sbc #0x27					; Sub 7 to get in to A-F range
c966 :                       con_hex_skip_x_f_1
c966 : c910             [ 2] 	cmp #0x10					; Nibble should be <= 0x0f
c968 : b01c             [ 3] 	bcs	con_hex_done			; Potentially done if not
c96a : 48               [ 3] 	pha
                             	; make room for lo nibble
c96b : 0685             [ 5] 	asl num_a
c96d : 2686             [ 5] 	rol num_a+1
c96f : 0685             [ 5] 	asl num_a
c971 : 2686             [ 5] 	rol num_a+1
c973 : 0685             [ 5] 	asl num_a
c975 : 2686             [ 5] 	rol num_a+1
c977 : 0685             [ 5] 	asl num_a
c979 : 2686             [ 5] 	rol num_a+1
                             	; save in low nibble
c97b : 68               [ 4] 	pla
c97c : 0585             [ 3] 	ora num_a
c97e : 8585             [ 3] 	sta num_a
c980 : c8               [ 2] 	iny
c981 : ca               [ 2] 	dex
c982 : d0d5             [ 3] 	bne con_hex_digit
                             	; if got to a 5th digit then error
c984 :                       con_hex_err
c984 : 38               [ 2] 	sec
c985 : 60               [ 6] 	rts
                             	; found a non-hex digit
c986 :                       con_hex_done
                             	; if no digits processed then error
c986 : c002             [ 2] 	cpy #2
c988 : f0fa             [ 3] 	beq con_hex_err
                             	; move y to x for digits processed
c98a : 98               [ 2] 	tya
c98b : aa               [ 2] 	tax
c98c : a902             [ 2] 	lda #NUM_HEX
c98e : 18               [ 2] 	clc
c98f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_bin_to_a
                             ;* Convert binary string to accumulator (unsigned
                             ;* Input : Pointer to string (X=L, A=H)
AS65 Assembler for R6502 [1.42].                                     Page   44
---------------------------------- bank1.s -----------------------------------

                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c990 :                       con_bin_to_a
c990 : 8691             [ 3] 	stx num_tmp
c992 : 8592             [ 3] 	sta num_tmp+1
c994 :                       con_bin_to_a_int
c994 : a002             [ 2] 	ldy #2
c996 : a211             [ 2] 	ldx #17						; Max 16 binary digits allowed
c998 :                       con_bin_digit
c998 : b191             [ 5] 	lda (num_tmp),y
c99a : c930             [ 2] 	cmp #'0'
c99c : 9010             [ 3] 	bcc con_bin_done
c99e : c932             [ 2] 	cmp #'1'+1
c9a0 : b00c             [ 3] 	bcs con_bin_done
                             	; sets C if '1' else resets C
c9a2 : 69cf             [ 2] 	adc #0xff-'0'
                             	; shift in digit
c9a4 : 2685             [ 5] 	rol num_a
c9a6 : 2686             [ 5] 	rol num_a+1
c9a8 : c8               [ 2] 	iny
c9a9 : ca               [ 2] 	dex
c9aa : d0ec             [ 3] 	bne con_bin_digit
                             	; on the 17th digit is too much, error
c9ac : 800a             [ 3] 	bra con_bin_err
c9ae :                       con_bin_done
                             	; didn't process any digit = error
c9ae : c002             [ 2] 	cpy #2
c9b0 : f006             [ 3] 	beq con_bin_err
                             	; put digits processed in to X
c9b2 : 98               [ 2] 	tya
c9b3 : aa               [ 2] 	tax
c9b4 : a903             [ 2] 	lda #NUM_BIN
c9b6 : 18               [ 2] 	clc
c9b7 : 60               [ 6] 	rts
c9b8 :                       con_bin_err
c9b8 : 38               [ 2] 	sec
c9b9 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_d_to_a
                             ;* Convert decimal string to accumulator (SIGNED)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c9ba :                       con_dec_to_a
c9ba : 8691             [ 3] 	stx num_tmp
c9bc : 8592             [ 3] 	sta num_tmp+1
c9be :                       con_dec_to_a_int
c9be : a000             [ 2] 	ldy #0
                             	; Detect if leading minus sign
c9c0 : b291             [ 5] 	lda (num_tmp)
c9c2 : c92d             [ 2] 	cmp #'-'
c9c4 : d001             [ 3] 	bne str_d_find_end
                             	; skip over minus if found
c9c6 : c8               [ 2] 	iny
c9c7 :                       str_d_find_end
c9c7 : b191             [ 5] 	lda (num_tmp),y
c9c9 : c930             [ 2] 	cmp #'0'
c9cb : 9007             [ 3] 	bcc str_d_found_end
c9cd : c93a             [ 2] 	cmp #'9'+1
AS65 Assembler for R6502 [1.42].                                     Page   45
---------------------------------- bank1.s -----------------------------------

c9cf : b003             [ 3] 	bcs str_d_found_end
c9d1 : c8               [ 2] 	iny
c9d2 : 80f3             [ 3] 	bra str_d_find_end
c9d4 :                       str_d_found_end
c9d4 : c007             [ 2] 	cpy #6+1			; Biggest int is 6 chars
c9d6 : b052             [ 4] 	bcs str_d_error		; e.g. -32767 including minus
c9d8 : 8494             [ 3] 	sty num_tmp+3
c9da : 6493             [ 3] 	stz num_tmp+2
c9dc : 6485             [ 3] 	stz num_a
c9de : 6486             [ 3] 	stz num_a+1
c9e0 :                       str_d_process_digit
c9e0 : 88               [ 2] 	dey
c9e1 : 3026             [ 4] 	bmi str_d_digits_done
                             
c9e3 : b191             [ 5] 	lda (num_tmp),y
                             
c9e5 : c92d             [ 2] 	cmp #'-'			; Got to minus sign?
c9e7 : f020             [ 4] 	beq str_d_digits_done ; also done
                             
c9e9 : 38               [ 2] 	sec
c9ea : e930             [ 2] 	sbc #'0'
                             	; Convert digit to number
                             	; and then offset in to
                             	; look up table of powers
c9ec : 18               [ 2] 	clc
c9ed : 0a               [ 2] 	asl a
c9ee : 6593             [ 3] 	adc num_tmp+2
                             	; X contains index to powers
c9f0 : aa               [ 2] 	tax
c9f1 : a585             [ 3] 	lda num_a
c9f3 : 7d2cca           [ 4] 	adc str_d_powers,x
c9f6 : 8585             [ 3] 	sta num_a
c9f8 : a586             [ 3] 	lda num_a+1
c9fa : 7d2dca           [ 4] 	adc str_d_powers+1,x
c9fd : 8586             [ 3] 	sta num_a+1
c9ff : b029             [ 4] 	bcs str_d_error
                             	; Move to next power of 10 index
ca01 : a593             [ 3] 	lda num_tmp+2
ca03 : 6914             [ 2] 	adc #20
ca05 : 8593             [ 3] 	sta num_tmp+2
ca07 : 80d7             [ 4] 	bra str_d_process_digit
ca09 :                       str_d_digits_done
                             	; check if minus
ca09 : b291             [ 5] 	lda (num_tmp)
ca0b : c92d             [ 2] 	cmp #'-'
ca0d : d011             [ 3] 	bne str_d_skip_neg
ca0f : a694             [ 3] 	ldx num_tmp+3		; Must have >= 2 chars
ca11 : e002             [ 2] 	cpx #2				; else it's an error
ca13 : 9015             [ 3] 	bcc str_d_error
ca15 : a685             [ 3] 	ldx num_a
ca17 : a586             [ 3] 	lda num_a+1
ca19 : 2090ca           [ 6] 	jsr twos_complement
ca1c : 8685             [ 3] 	stx num_a
ca1e : 8586             [ 3] 	sta num_a+1
ca20 :                       str_d_skip_neg
ca20 : a694             [ 3] 	ldx num_tmp+3
ca22 : e001             [ 2] 	cpx #1				; must be at least 1 char
ca24 : 9004             [ 3] 	bcc str_d_error
ca26 : a901             [ 2] 	lda #NUM_DEC
ca28 : 18               [ 2] 	clc
ca29 : 60               [ 6] 	rts
ca2a :                       str_d_error
AS65 Assembler for R6502 [1.42].                                     Page   46
---------------------------------- bank1.s -----------------------------------

ca2a : 38               [ 2] 	sec
ca2b : 60               [ 6] 	rts
                             
ca2c :                       str_d_powers
ca2c : 00000100020003..      	dw	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
ca40 : 00000a0014001e..      	dw	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
ca54 : 00006400c8002c..      	dw	0, 100, 200, 300, 400, 500, 600, 700, 800, 90
ca68 : 0000e803d007b8..      	dw	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 
ca7c : 00001027204e30..      	dw	0, 10000, 20000, 30000, 40000, 50000, 60000, 
                             	
                             
                             ;****************************************
                             ;* twos_complement
                             ;* Twos complement of X,A (X=low)
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : X,A in 2's complement
                             ;* Regs affected : P
                             ;****************************************
ca90 :                       twos_complement
ca90 : 49ff             [ 2] 	eor #0xff
ca92 : 48               [ 3] 	pha
ca93 : 8a               [ 2] 	txa
ca94 : 49ff             [ 2] 	eor #0xff
ca96 : aa               [ 2] 	tax
ca97 : 68               [ 4] 	pla
ca98 : e8               [ 2] 	inx
ca99 : d001             [ 3] 	bne twos_complement_skip_X
ca9b : 1a               [ 2] 	inc a
ca9c :                       twos_complement_skip_X
ca9c : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* int_to_bcd
                             ;* Convert A,X (signed int) to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated
                             ;* Regs affected : None
                             ;****************************************
ca9d :                       int_to_bcd
ca9d : 08               [ 3] 	php
ca9e : 48               [ 3] 	pha
ca9f : da               [ 3] 	phx
                             
caa0 : 8691             [ 3] 	stx num_tmp
caa2 : 8592             [ 3] 	sta num_tmp+1
caa4 : c980             [ 2] 	cmp #0x80			; Negative?
caa6 : 9003             [ 3] 	bcc int_to_bcd_skip_neg
caa8 : 2090ca           [ 6] 	jsr twos_complement
caab :                       int_to_bcd_skip_neg
caab : 6485             [ 3] 	stz num_a
caad : 6486             [ 3] 	stz num_a+1
caaf : 6487             [ 3] 	stz num_a+2
cab1 : 6488             [ 3] 	stz num_a+3
cab3 : a210             [ 2] 	ldx #16
cab5 : f8               [ 2] 	sed
cab6 :                       int_to_bcd_bit
cab6 : 0691             [ 5] 	asl num_tmp
cab8 : 2692             [ 5] 	rol num_tmp+1
caba : a585             [ 3] 	lda num_a
cabc : 6585             [ 3] 	adc num_a
cabe : 8585             [ 3] 	sta num_a
AS65 Assembler for R6502 [1.42].                                     Page   47
---------------------------------- bank1.s -----------------------------------

cac0 : a586             [ 3] 	lda num_a+1
cac2 : 6586             [ 3] 	adc num_a+1
cac4 : 8586             [ 3] 	sta num_a+1
cac6 : a587             [ 3] 	lda num_a+2
cac8 : 6587             [ 3] 	adc num_a+2
caca : 8587             [ 3] 	sta num_a+2
cacc : ca               [ 2] 	dex
cacd : d0e7             [ 3] 	bne int_to_bcd_bit
                             	
cacf : fa               [ 4] 	plx
cad0 : 68               [ 4] 	pla
cad1 : 28               [ 4] 	plp
cad2 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* word_to_bcd
                             ;* Convert A,X (unsighed word) to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated as BCD
                             ;* Regs affected : None
                             ;****************************************
cad3 :                       word_to_bcd
cad3 : 08               [ 3] 	php
cad4 : 48               [ 3] 	pha
cad5 : da               [ 3] 	phx
                             
cad6 : 8691             [ 3] 	stx num_tmp
cad8 : 8592             [ 3] 	sta num_tmp+1
cada : 6485             [ 3] 	stz num_a
cadc : 6486             [ 3] 	stz num_a+1
cade : 6487             [ 3] 	stz num_a+2
cae0 : 6488             [ 3] 	stz num_a+3
cae2 : a210             [ 2] 	ldx #16			; 16 binary bits
cae4 : f8               [ 2] 	sed
cae5 :                       word_to_bcd_bit
cae5 : 0691             [ 5] 	asl num_tmp
cae7 : 2692             [ 5] 	rol num_tmp+1
cae9 : a585             [ 3] 	lda num_a
caeb : 6585             [ 3] 	adc num_a
caed : 8585             [ 3] 	sta num_a
caef : a586             [ 3] 	lda num_a+1
caf1 : 6586             [ 3] 	adc num_a+1
caf3 : 8586             [ 3] 	sta num_a+1
caf5 : a587             [ 3] 	lda num_a+2
caf7 : 6587             [ 3] 	adc num_a+2
caf9 : 8587             [ 3] 	sta num_a+2
cafb : ca               [ 2] 	dex
cafc : d0e7             [ 3] 	bne word_to_bcd_bit
                             	
cafe : fa               [ 4] 	plx
caff : 68               [ 4] 	pla
cb00 : 28               [ 4] 	plp
cb01 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* int_to_str_ch
                             ;* Helper routine to stuff decimal char in to num
                             ;* Input : A=BCD digit, Y=num_buf index, C=insert
                             ;* Output : num_buf in ASCII, A=ASCII digit
                             ;* Regs affected : C cleared if non-zero
                             ;****************************************
cb02 :                       int_to_str_ch
AS65 Assembler for R6502 [1.42].                                     Page   48
---------------------------------- bank1.s -----------------------------------

cb02 : 290f             [ 2] 	and #0xf
cb04 : 0930             [ 2] 	ora #0x30					; Convert to ascii
cb06 : 4930             [ 2] 	eor #0x30					; Check if zero digit
cb08 : d005             [ 3] 	bne int_to_str_nz			; If not zero definitely sto
cb0a : b003             [ 3] 	bcs int_to_str_nz			; Also if C=1
cb0c : 4930             [ 2] 	eor #0x30					; Restore A
cb0e : 60               [ 6] 	rts							; Return without storing anything
cb0f :                       int_to_str_nz
cb0f : 4930             [ 2] 	eor #0x30					; Restore A
cb11 : 999500           [ 5] 	sta num_buf,y
cb14 : c8               [ 2] 	iny
cb15 : 38               [ 2] 	sec							; Set C as a non-zero encountered
cb16 :                       int_to_str_ch_fin
cb16 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* int_to_str
                             ;* Convert int to string
                             ;* Input : in X,A (low,high), C=leading zeros wan
                             ;* Output : num_buf in ASCII 6 digits + zero term
                             ;* Regs affected : P
                             ;****************************************
cb17 :                       int_to_str
                             	_pushAXY
                             
cb1a : a000             [ 2] 	ldy #0						; first pos of num_buf
cb1c : 0900             [ 2] 	ora #0						; Test A for sign bit
cb1e : 08               [ 3] 	php							; Remember C bit of P
cb1f : 100a             [ 3] 	bpl int_to_str_skip_neg		; Skip if not (postive 
cb21 : 2090ca           [ 6] 	jsr twos_complement			; Flip X,A from 2s complem
cb24 : 48               [ 3] 	pha							; Remember A
cb25 : a92d             [ 2] 	lda #'-'					; Put in negative sign
cb27 : 8595             [ 3] 	sta num_buf
cb29 : c8               [ 2] 	iny							; Start at second buffer pos
cb2a : 68               [ 4] 	pla							; Restore A
cb2b :                       int_to_str_skip_neg
cb2b : 20d3ca           [ 6]  	jsr word_to_bcd				; Convert X,A to BCD
cb2e : a202             [ 2] 	ldx #2						; Start at BCD high byte
cb30 :                       int_str
cb30 : 28               [ 4] 	plp							; Get C but immediately
cb31 : 08               [ 3] 	php							; Save C (due to loop check later)
cb32 : b585             [ 4] 	lda num_a,x					; Get BCD digit
cb34 : 859c             [ 3] 	sta num_buf+7				; Save A it for the units later
cb36 : 4a               [ 2] 	lsr a						; Tens - shift to lower nibble
cb37 : 4a               [ 2] 	lsr a
cb38 : 4a               [ 2] 	lsr a
cb39 : 4a               [ 2] 	lsr a
cb3a : 28               [ 4] 	plp							; Get C
cb3b : 2002cb           [ 6] 	jsr int_to_str_ch			; Put ASCII code in num_buf
cb3e : a59c             [ 3] 	lda num_buf+7				; Get A for the units
cb40 : 2002cb           [ 6] 	jsr int_to_str_ch			; Put ASCII code in num_buf
cb43 : 08               [ 3] 	php							; Save C
cb44 : ca               [ 2] 	dex
cb45 : 10e9             [ 3] 	bpl int_str
cb47 : 28               [ 4] 	plp							; Check C
cb48 : b005             [ 3] 	bcs	int_to_str_fin			; If set then something pri
cb4a : a930             [ 2] 	lda #'0'					; Stuff a zero
cb4c : 8595             [ 3] 	sta num_buf					; Must be in first position..
cb4e : c8               [ 2] 	iny
cb4f :                       int_to_str_fin
cb4f : a900             [ 2] 	lda #0						; Terminator
cb51 : 999500           [ 5] 	sta num_buf,y
AS65 Assembler for R6502 [1.42].                                     Page   49
---------------------------------- bank1.s -----------------------------------

cb54 : c8               [ 2] 	iny
                             	_pullAXY
                             
cb58 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* bcd_to_str
                             ;* Convert num_buf to chars
                             ;* Input : num_a in BCD format
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
                             ;bcd_to_str
                             ;	pha
                             ;	phx
                             ;	phy
                             ;
                             ;	ldx #5						; Index in to string
                             ;	ldy #0						; Current BCD digit
                             ;bcd_str
                             ;	lda num_a,y
                             ;	; Convert 1s digit of byte
                             ;	pha
                             ;	and #0xf
                             ;	clc
                             ;	adc #0x30
                             ;	sta num_buf,x
                             ;	; Convert 10s digit of byte
                             ;	pla
                             ;	lsr a
                             ;	lsr a
                             ;	lsr a
                             ;	lsr a
                             ;	clc
                             ;	adc #0x30					; Convert to ASCII
                             ;	sta num_buf-1,x
                             ;	dex
                             ;	dex
                             ;	iny
                             ;	cpy #3						; 3 BCD digits max
                             ;	bne bcd_str
                             ;
                             ;	ply
                             ;	plx
                             ;	pla
                             ;	rts
                             	
                             ;****************************************
                             ;* out_bcd
                             ;* Output a bcd string in num_buf
                             ;* Input : num_buf has the ASCII
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not, Y=digits p
                             ;* Regs affected : P
                             ;****************************************
                             ;out_bcd
                             ;	pha
                             ;	phx
                             ;	php
AS65 Assembler for R6502 [1.42].                                     Page   50
---------------------------------- bank1.s -----------------------------------

                             ;	ldy #0						; How many digits printed
                             ;	ldx #0						; Index in to string
                             ;out_bcd_digit
                             ;	lda num_buf,x
                             ;	cpy #0						; If not in leading zero mode
                             ;	bne out_bcd_print			; No then go print
                             ;
                             ;	cmp #'0'					; else check if zero
                             ;	bne out_bcd_print			; No then go print
                             ;
                             ;	plp
                             ;	php
                             ;	bcc out_bcd_next			; If C=0 go to next digit, e
                             ;out_bcd_print
                             ;	iny
                             ;	jsr io_put_ch
                             ;out_bcd_next
                             ;	inx
                             ;	cpx #6
                             ;	bne out_bcd_digit
                             ;	cpy #0						; If nothing printed
                             ;	bne out_bcd_fin
                             ;	lda #'0'					; Need to put out 1 zero
                             ;	jsr io_put_ch
                             ;	iny
                             ;out_bcd_fin
                             ;	plp
                             ;	plx
                             ;	pla
                             ;	clc
                             ;	rts
                             	
                             ;****************************************
                             ;* str_a_to_d
                             ;* Convert X,A to decimal string in sevalptr
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 keep leading zeros else not
                             ;* Output : sevalptr in ASCII max 6 digits
                             ;*          Y=length including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
cb59 :                       str_a_to_d
cb59 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* print_a_to_d
                             ;* Convert X,A to decimal string
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII max 6 digits
                             ;*          Y=digits printed including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
cb5a :                       print_a_to_d
cb5a : 2017cb           [ 6] 	jsr int_to_str
cb5d : a000             [ 2] 	ldy #0
cb5f :                       print_a_to_d_ch
cb5f : b99500           [ 4] 	lda num_buf,y
cb62 : f006             [ 3] 	beq print_a_to_d_fin
cb64 : 20c0c5           [ 6] 	jsr io_put_ch
AS65 Assembler for R6502 [1.42].                                     Page   51
---------------------------------- bank1.s -----------------------------------

cb67 : c8               [ 2] 	iny
cb68 : d0f5             [ 3] 	bne print_a_to_d_ch
cb6a :                       print_a_to_d_fin
cb6a : 60               [ 6] 	rts
                             	
                             
                             ;* Reset vector points here - 6502 starts here
cb6b :                       init
                             ;	jmp init_test
                             	; First clear ram
                             ;	sei					; No need as disabled on startup
                             ;	cld					; No need as disabled on startup
cb6b : a2ff             [ 2] 	ldx #0xff			; Initialise stack pointer
cb6d : 9a               [ 2] 	txs
cb6e : 4cc9cb           [ 3] 	jmp init_ram		; jmp not jsr to ram initialiser
cb71 :                       init_2					; init_ram will jump back to here
                             	
cb71 : 2077cb           [ 6] 	jsr kernel_init
                             
cb74 : 4cffc6           [ 3] 	jmp main
                             
cb77 :                       kernel_init
cb77 : 2052c7           [ 6] 	jsr init_nmi		; Initialise NMI handling
cb7a : 20a2c7           [ 6] 	jsr init_irq		; Initialise IRQ handling
cb7d : 20dec1           [ 6] 	jsr _init_acia		; initialise the serial chip
                             	
cb80 : 20f6c1           [ 6] 	jsr _init_cia0		; initialise cia 0
cb83 : 200ec2           [ 6] 	jsr _init_cia1		; initialise cia 1
cb86 : 2026c5           [ 6] 	jsr _PT3INIT		; Load PT3 player code into shadow
cb89 :                       kernel_test
cb89 : 2056c2           [ 6] 	jsr _init_snd		; initialise the sound chip
cb8c : 206ec2           [ 6] 	jsr _init_keyboard	; initialise keyboard timer s
cb8f : 2036c4           [ 6] 	jsr _vdp_init		; initialise vdp
cb92 : a900             [ 2] 	lda #0				; Default = 40 column mode - put on st
cb94 : 48               [ 3] 	pha
cb95 : a20e             [ 2] 	ldx #NV_MODE		; NV location for default text mod
cb97 : 2096c4           [ 6] 	jsr _rtc_nvread		; Try to read location
cb9a : b00b             [ 3] 	bcs kernel_skip_nv	; If bad NV ram then skip try
cb9c : aa               [ 2] 	tax					; Save the mode temporarily
cb9d : 68               [ 4] 	pla					; Get the default mode from stack
cb9e : 8a               [ 2] 	txa					; And push the NV mode that was read
cb9f : 48               [ 3] 	pha
cba0 : a20f             [ 2] 	ldx #NV_COLOUR		; NV location for the default co
cba2 : 2096c4           [ 6] 	jsr _rtc_nvread		; Try to read location (assumed
cba5 : 8521             [ 3] 	sta vdp_base+vdp_bord_col	; Save it to the borde
cba7 :                       kernel_skip_nv	
cba7 : 68               [ 4] 	pla					; Get the mode (either default or the NV
cba8 : 20c6c1           [ 6] 	jsr _gr_init_screen
cbab : 2086c5           [ 6] 	jsr io_init			; Set default input/output device
cbae : 58               [ 2] 	cli					; irq interrupts enable
                             
                             	; Print the boot up message - requires IO and IR
                             	_println msg_hello_world
                             
                             
                             
cbbc : 204ec4           [ 6] 	jsr _rtc_init		; Initialise RTC - * AFTER INTERR
cbbf : 203ec2           [ 6] 	jsr _init_sdcard	; initialise the sd card interf
cbc2 : 2026c2           [ 6] 	jsr _init_fs		; initialise the filesystem
cbc5 : 202ec0           [ 6] 	jsr _df_init		; Initialise interpreter
                             
cbc8 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   52
---------------------------------- bank1.s -----------------------------------

                             
                             	
                             ;* Initialises RAM, skipping pages 4-8 which are 
                             ;* Zeroes all addressable RAM in the default bank
cbc9 :                       init_ram
cbc9 : 6400             [ 3] 	stz 0x00			; Start at page 0
cbcb : 6401             [ 3] 	stz 0x01
cbcd : a002             [ 2] 	ldy #0x02			; But Y initially at 2 to not overwr
cbcf : a200             [ 2] 	ldx #0x00			; Page counter starts at zero
cbd1 : a900             [ 2] 	lda #0				; Normal RAM filled with zero
cbd3 :                       init_ram_1
cbd3 : e005             [ 2] 	cpx	#5				; Page <5 is ok (zeroes out VIA0 and 1
cbd5 : 9004             [ 3] 	bcc init_ram_fill
cbd7 : e008             [ 2] 	cpx #8				; Page >=8 is ok
cbd9 : 9005             [ 3] 	bcc init_ram_skip	; But >=5 and <8 do not initia
cbdb :                       init_ram_fill
cbdb : 9100             [ 5] 	sta (0x00),y		; Write initialisation value to RA
cbdd : c8               [ 2] 	iny
cbde : d0fb             [ 3] 	bne init_ram_fill	; Do a whole page
cbe0 :                       init_ram_skip
cbe0 : e8               [ 2] 	inx					; Increment page counter
cbe1 : 8601             [ 3] 	stx 0x01			; Save to address pointer
cbe3 : d0ee             [ 3] 	bne init_ram_1		; Do all pages until page 0xff d
                             	
cbe5 : 4c71cb           [ 3] 	jmp init_2			; Carry on initialisation
                             
cbe8 :                       mod_sz_kernel_e
                             
                             
                             	
                             ; Bank specific code goes here
                             	include "utils\intmath.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  INTMATH.S
                             ;*  Core module for integer maths supported by df
                             ;*  Now supports signed integers in 2s complement
                             ;*  Uses the intmath registers: num_a, num_b, num
                             ;*  Most inputs are through num_a and num_b, with
                             ;*  num_a
                             ;*  Operations: add, sub, swap, 8 bit mult, mult,
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* Add : A + B result in A
                             ;****************************************
cbe8 :                       int_add
cbe8 : 18               [ 2] 	clc
cbe9 : a585             [ 3] 	lda num_a
cbeb : 6589             [ 3] 	adc num_b
cbed : 8585             [ 3] 	sta num_a
cbef : a586             [ 3] 	lda num_a+1
AS65 Assembler for R6502 [1.42].                                     Page   53
---------------------------------- bank1.s -----------------------------------

cbf1 : 658a             [ 3] 	adc num_b+1
cbf3 : 8586             [ 3] 	sta num_a+1
cbf5 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Sub : A - B result in A
                             ;****************************************
cbf6 :                       int_sub
cbf6 : 38               [ 2] 	sec
cbf7 : a585             [ 3] 	lda num_a
cbf9 : e589             [ 3] 	sbc num_b
cbfb : 8585             [ 3] 	sta num_a
cbfd : a586             [ 3] 	lda num_a+1
cbff : 658a             [ 3] 	adc num_b+1
cc01 : 8586             [ 3] 	sta num_a+1
cc03 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Swp : A <-> B 
                             ;****************************************
cc04 :                       int_swp
cc04 : a585             [ 3] 	lda num_a
cc06 : a689             [ 3] 	ldx num_b
cc08 : 8589             [ 3] 	sta num_b
cc0a : 8685             [ 3] 	stx num_a
cc0c : a586             [ 3] 	lda num_a+1
cc0e : a68a             [ 3] 	ldx num_b+1
cc10 : 858a             [ 3] 	sta num_b+1
cc12 : 8686             [ 3] 	stx num_a+1
cc14 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Mult : A * B result in A
                             ;* B assumed to be an 8 bit quantity 
                             ;****************************************
cc15 :                       int_fast_mult
                             	_cpyZPWord num_a,num_tmp
                             
cc1d : 6485             [ 3] 	stz num_a
cc1f : 6486             [ 3] 	stz num_a+1
cc21 : a008             [ 2] 	ldy #8
cc23 :                       int_fast_mult_cycle
cc23 : 4689             [ 5] 	lsr num_b
cc25 : 900d             [ 3] 	bcc int_fast_mult_next
cc27 : 18               [ 2] 	clc
cc28 : a585             [ 3] 	lda num_a
cc2a : 6591             [ 3] 	adc num_tmp
cc2c : 8585             [ 3] 	sta num_a
cc2e : a586             [ 3] 	lda num_a+1
cc30 : 6592             [ 3] 	adc num_tmp+1
cc32 : 8586             [ 3] 	sta num_a+1
cc34 :                       int_fast_mult_next
cc34 : 0691             [ 5] 	asl num_tmp
cc36 : 2692             [ 5] 	rol num_tmp+1
cc38 : 88               [ 2] 	dey
cc39 : d0e8             [ 3] 	bne int_fast_mult_cycle
cc3b : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Mult : A * B result in A
                             ;****************************************
cc3c :                       int_mult
AS65 Assembler for R6502 [1.42].                                     Page   54
---------------------------------- bank1.s -----------------------------------

                             	_cpyZPWord num_a,num_tmp
                             
cc44 : 6485             [ 3] 	stz num_a
cc46 : 6486             [ 3] 	stz num_a+1
cc48 : a010             [ 2] 	ldy #16
cc4a :                       int_mult_cycle
cc4a : 468a             [ 5] 	lsr num_b+1
cc4c : 6689             [ 5] 	ror num_b
cc4e : 900d             [ 3] 	bcc int_mult_next
cc50 : 18               [ 2] 	clc
cc51 : a585             [ 3] 	lda num_a
cc53 : 6591             [ 3] 	adc num_tmp
cc55 : 8585             [ 3] 	sta num_a
cc57 : a586             [ 3] 	lda num_a+1
cc59 : 6592             [ 3] 	adc num_tmp+1
cc5b : 8586             [ 3] 	sta num_a+1
cc5d :                       int_mult_next
cc5d : 0691             [ 5] 	asl num_tmp
cc5f : 2692             [ 5] 	rol num_tmp+1
cc61 : 88               [ 2] 	dey
cc62 : d0e6             [ 3] 	bne int_mult_cycle
cc64 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Div : A / B result in A, remainder X
                             ;****************************************
cc65 :                       int_div
                             	; adjust signs
cc65 : 6491             [ 3] 	stz num_tmp				; Assume all +ve
cc67 : a586             [ 3] 	lda num_a+1				; Check A hi
cc69 : 100f             [ 3] 	bpl int_div_skip_negA
cc6b : e691             [ 5] 	inc num_tmp				; Record sign flip
cc6d : 38               [ 2] 	sec						; 2's complement A
cc6e : a900             [ 2] 	lda #0					; by 0-A
cc70 : e585             [ 3] 	sbc num_a				; A is now +ve
cc72 : 8585             [ 3] 	sta num_a
cc74 : a900             [ 2] 	lda #0
cc76 : e586             [ 3] 	sbc num_a+1
cc78 : 8586             [ 3] 	sta num_a+1	
cc7a :                       int_div_skip_negA
cc7a : a58a             [ 3] 	lda num_b+1				; Check B hi
cc7c : 100f             [ 3] 	bpl int_div_skip_negB
cc7e : e691             [ 5] 	inc num_tmp				; Record sign flip
cc80 : 38               [ 2] 	sec						; 2's complement B
cc81 : a900             [ 2] 	lda #0					; by 0-B
cc83 : e589             [ 3] 	sbc num_b				; B is now +ve
cc85 : 8589             [ 3] 	sta num_b
cc87 : a900             [ 2] 	lda #0
cc89 : e58a             [ 3] 	sbc num_b+1
cc8b : 858a             [ 3] 	sta num_b+1
cc8d :                       int_div_skip_negB			; num_tmp bit 0=1 for result 
                             	; x is the remainder
cc8d : 648d             [ 3] 	stz num_x
cc8f : 648e             [ 3] 	stz num_x+1
                             	; 16 bit division
cc91 : a010             [ 2] 	ldy #16
cc93 :                       int_div_cycle
                             	; shift a left 1 bit
cc93 : 0685             [ 5] 	asl num_a
cc95 : 2686             [ 5] 	rol num_a+1
                             	; shift in to remainder
cc97 : 268d             [ 5] 	rol num_x
AS65 Assembler for R6502 [1.42].                                     Page   55
---------------------------------- bank1.s -----------------------------------

cc99 : 268e             [ 5] 	rol num_x+1
                             	; try and subtract b from remainder
cc9b : 38               [ 2] 	sec
cc9c : a58d             [ 3] 	lda num_x
cc9e : e589             [ 3] 	sbc num_b
cca0 : aa               [ 2] 	tax
cca1 : a58e             [ 3] 	lda num_x+1
cca3 : e58a             [ 3] 	sbc num_b+1
cca5 : 9006             [ 3] 	bcc int_div_skip
                             	; so b did fit in to remainder, save it
cca7 : 868d             [ 3] 	stx num_x
cca9 : 858e             [ 3] 	sta num_x+1
ccab : e685             [ 5] 	inc num_a
ccad :                       int_div_skip
                             	; carry on for 16 bits
ccad : 88               [ 2] 	dey
ccae : d0e3             [ 3] 	bne int_div_cycle
                             	; result in a, remainder in x
                             	; check num_tmp bit 0
ccb0 : a591             [ 3] 	lda num_tmp
ccb2 : 2901             [ 2] 	and #1
ccb4 : f00d             [ 3] 	beq int_div_noflip
ccb6 : 38               [ 2] 	sec						; 2's complement A
ccb7 : a900             [ 2] 	lda #0					; by 0-A
ccb9 : e585             [ 3] 	sbc num_a				; A is now +ve
ccbb : 8585             [ 3] 	sta num_a
ccbd : a900             [ 2] 	lda #0
ccbf : e586             [ 3] 	sbc num_a+1
ccc1 : 8586             [ 3] 	sta num_a+1	
ccc3 :                       int_div_noflip
ccc3 : 60               [ 6] 	rts
                             	
                             
                             	include "dflat\dflat.s"
                             ;************************************************
                             ;*
                             ;*	BBC128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  DFLAT.S
                             ;*  This is the main controller code file for dfl
                             ;*  This file includes all the required dflat sou
                             ;*  needed:
                             ;*  - error.s is the error handling module
                             ;*  - var.s is the variable handling module
                             ;*  - tokenise.s is the tokenisation module
                             ;*  - progedit.s is the program editing module
                             ;*  - runtime.s is the runtime module
                             ;*  - stack.s is the stack handling module
                             ;*  The above modules include further source file
                             ;*  needed.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
ccc4 :                       mod_sz_dflat_s
                             
AS65 Assembler for R6502 [1.42].                                     Page   56
---------------------------------- bank1.s -----------------------------------

                             ;	include "dflat/error.s"  ** included in the mai
                             	include "dflat/var.s"
                             ;************************************************
                             ;*
                             ;*	BBC128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  VAR.S
                             ;*  This module handles all the variable manageme
                             ;*  When a new variable is detected during tokeni
                             ;*  is added to the variable tables.  Any subsequ
                             ;*  that variable is tokenised as an index in to 
                             ;*  table.  There are two variable tables:
                             ;*  Variable name table (VNT) keeps track of vari
                             ;*  Variable value table (VVT) maintains variable
                             ;*  including type, dimension (if array) and of c
                             ;*  actual values.  For an array, the value is a 
                             ;*  memory grabbed using the 'malloc' function (s
                             ;*  This approach to variable managemet is direct
                             ;*  Atari 8 bit.  The disadvantage is that during
                             ;*  session you may end up having a much larger v
                             ;*  table than you need.  Why?  Well because say 
                             ;*  a as a new variable, but then later change it
                             ;*  In this case a remains in the variable tables
                             ;*  only ever adds to the table!  However it is e
                             ;*  solved - when you save and then reload from n
                             ;*  program, the variable table is built up as th
                             ;*  is loaded.
                             ;*  The VNT grows DOWN from the top of free memor
                             ;*  the VVT growing UP from just below the VNT.
                             ;*	This means that the VVT for a variable will al
                             ;*	found in a fixed place in the VVT table and me
                             ;*	For the VNT (names) it grows from vvstart at l
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code  
                             
ccc4 :                       mod_sz_var_s
                             
                             
                             ;****************************************
                             ;* Find a variable
                             ;* CC if found, A has index
                             ;****************************************
ccc4 :                       df_var_find
                             	; start at the beginning of the vnt table
                             	; vars are stored in reverse order
                             	_cpyZPWord df_vntstrt,df_tmpptrb
                             
                             	; start at end of VVT
                             	_cpyZPWord df_vvtend,df_tmpptra
                             
ccd4 :                       df_var_match_vnt
                             	; If reached top of VVT then not found
ccd4 : a5e3             [ 3] 	lda df_tmpptra
ccd6 : c5af             [ 3] 	cmp df_vvtstrt
AS65 Assembler for R6502 [1.42].                                     Page   57
---------------------------------- bank1.s -----------------------------------

ccd8 : d006             [ 3] 	bne df_var_match_vnt_do
ccda : a5e4             [ 3] 	lda df_tmpptra+1
ccdc : c5b0             [ 3] 	cmp df_vvtstrt+1
ccde : f042             [ 4] 	beq df_var_find_no_vnt
cce0 :                       df_var_match_vnt_do
                             	; match each char in buffer with vnt
cce0 : a4be             [ 3] 	ldy df_linoff
cce2 : a200             [ 2] 	ldx #0
cce4 :                       df_var_match_vnt_sym
cce4 : b9000a           [ 4] 	lda df_linbuff,y
cce7 : c1e5             [ 6] 	cmp (df_tmpptrb,x)
cce9 : d017             [ 4] 	bne df_var_vnt_sym_nomatch
                             	; if single char match then increment
                             	; source and search
cceb : c8               [ 2] 	iny
                             	_incZPWord df_tmpptrb
                             
                             	; if more chars in vnt entry then continue
ccf2 : a1e5             [ 6] 	lda (df_tmpptrb,x)
ccf4 : d0ee             [ 3] 	bne df_var_match_vnt_sym
                             	; if no more chars in vnt entry but
                             	; but chars in buffer then try next vnt
ccf6 : b9000a           [ 4] 	lda df_linbuff,y
                             	; check for valid alpha-numeric
ccf9 : 20a2ce           [ 6] 	jsr df_tk_isalphanum
                             	; if there is a valid alpha-num then no match
ccfc : b004             [ 4] 	bcs df_var_vnt_sym_nomatch
                             	; else check type
ccfe :                       df_var_check_type
                             	; if not alpha-num then check for type
                             	; string or int postfix didn't match with VNT
                             ;	cmp #'%'
                             ;	beq df_var_vnt_sym_nomatch
ccfe : c924             [ 2] 	cmp #'$'
                             	; ok, all good got a match
cd00 : d025             [ 3] 	bne df_var_find_true
cd02 :                       df_var_vnt_sym_nomatch
                             	; find the zero terminator
cd02 : a1e5             [ 6] 	lda (df_tmpptrb,x)
cd04 : f009             [ 3] 	beq	df_var_vnt_entry_end
                             	_incZPWord df_tmpptrb
                             
cd0c : 4c02cd           [ 3] 	jmp df_var_vnt_sym_nomatch
cd0f :                       df_var_vnt_entry_end
                             	; skip over zero terminator
                             	_incZPWord df_tmpptrb
                             
                             	; update vvt address pointer
cd15 : 18               [ 2] 	clc
cd16 : a5e3             [ 3] 	lda df_tmpptra
cd18 : 6908             [ 2] 	adc #8
cd1a : 85e3             [ 3] 	sta df_tmpptra
                             	_bcc 2
                             
cd1e : e6e4             [ 5] 	inc df_tmpptra+1
cd20 : d0b2             [ 4] 	bne df_var_match_vnt		; Always - high byte is no
                             
                             	; if at end of vnt then no matches found
cd22 :                       df_var_find_no_vnt
cd22 : a900             [ 2] 	lda #0
cd24 : aa               [ 2] 	tax
cd25 : 38               [ 2] 	sec
AS65 Assembler for R6502 [1.42].                                     Page   58
---------------------------------- bank1.s -----------------------------------

cd26 : 60               [ 6] 	rts
                             
cd27 :                       df_var_find_true
                             	; Get slot address into x,a
cd27 : a6e3             [ 3] 	ldx df_tmpptra
cd29 : a5e4             [ 3] 	lda df_tmpptra+1
                             	
                             	; Consume characters found in source
cd2b : 84be             [ 3] 	sty df_linoff
cd2d : 18               [ 2] 	clc
cd2e : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* Insert a variable name in to vnt
                             ;* X = number of bytes to make room
                             ;* Space allocated is;
                             ;*	8 bytes for the new VVT entry
                             ;*  X bytes for the new VNT entry
                             ;* df_vntstrt is new var name entry
                             ;* df_vvtend is new vvt entry
                             ;****************************************
cd2f :                       df_var_insert_space
                             	; *** REMEMBER TO DO A SPACE CHECK EVENTUALLY! *
                             
                             	; adjust down the VNT start by VVT size (for ext
                             	; put it in tmpptrb
cd2f : 38               [ 2] 	sec
cd30 : a5ab             [ 3] 	lda df_vntstrt
cd32 : e908             [ 2] 	sbc #DFVVT_SZ
cd34 : 85ab             [ 3] 	sta df_vntstrt
cd36 : a5ac             [ 3] 	lda df_vntstrt+1
cd38 : e900             [ 2] 	sbc #0
cd3a : 85ac             [ 3] 	sta df_vntstrt+1
                             	
                             	; adjust VNT end by VVT size (for extra VVT entr
                             	; and put it in tmpptrc
cd3c : 38               [ 2] 	sec
cd3d : a5ad             [ 3] 	lda df_vntend
cd3f : e908             [ 2] 	sbc #DFVVT_SZ
cd41 : 85ad             [ 3] 	sta df_vntend
cd43 : a5ae             [ 3] 	lda df_vntend+1
cd45 : e900             [ 2] 	sbc #0
cd47 : 85ae             [ 3] 	sta df_vntend+1
                             
                             	; Set copy point to new start of VNT
                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
                             
                             	; Now move all bytes from old VNT (higher up) to
cd51 :                       df_var_move_byte
                             	; When pointer = vntend then done
cd51 : a5e3             [ 3] 	lda df_tmpptra
cd53 : c5ad             [ 3] 	cmp df_vntend
cd55 : d006             [ 3] 	bne df_var_move_byte_do
cd57 : a5e4             [ 3] 	lda df_tmpptra+1
cd59 : c5ae             [ 3] 	cmp df_vntend+1
cd5b : f011             [ 3] 	beq df_var_move_byte_fin
cd5d :                       df_var_move_byte_do
                             	; First the source byte VVT size higher in memor
cd5d : a008             [ 2] 	ldy #DFVVT_SZ
cd5f : b1e3             [ 5] 	lda (df_tmpptra),y
AS65 Assembler for R6502 [1.42].                                     Page   59
---------------------------------- bank1.s -----------------------------------

                             	; And copy to new position lower in memory
cd61 : a000             [ 2] 	ldy #0
cd63 : 91e3             [ 5] 	sta (df_tmpptra),y
                             	; Increment memory pointer
                             	_incZPWord df_tmpptra
                             
cd6b : 4c51cd           [ 3] 	jmp df_var_move_byte		; Always as C is not touch
cd6e :                       df_var_move_byte_fin
                             	
                             	; Now subtract X bytes from VNT start to accommo
cd6e : 8645             [ 3] 	stx tmp_d
cd70 : 38               [ 2] 	sec
cd71 : a5ab             [ 3] 	lda df_vntstrt
cd73 : e545             [ 3] 	sbc tmp_d
cd75 : 85ab             [ 3] 	sta df_vntstrt
cd77 : a5ac             [ 3] 	lda df_vntstrt+1
cd79 : e900             [ 2] 	sbc #0
cd7b : 85ac             [ 3] 	sta df_vntstrt+1
                             
                             	; VVT end is the same as VNT end
                             	_cpyZPWord df_vntend,df_vvtend
                             
                             
                             	; Copy done increment variable count
cd85 : e6b3             [ 5] 	inc df_varcnt
cd87 : 18               [ 2] 	clc
cd88 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* Iterate through a valid variable name
                             ;* starts with alpha, then any number of
                             ;* alphanums.
                             ;****************************************
cd89 :                       df_var_countlen
                             	; count alpha nums
cd89 : c8               [ 2] 	iny
cd8a : e8               [ 2] 	inx
cd8b : b9000a           [ 4] 	lda df_linbuff,y
                             	; first char has to be alpha, rest can be alpha-
cd8e : e000             [ 2] 	cpx #0
cd90 : d006             [ 3] 	bne df_var_countlen_alphanum
cd92 : 2095ce           [ 6] 	jsr df_tk_isalpha
cd95 : 4c9bcd           [ 3] 	jmp df_var_countlen_loop
cd98 :                       df_var_countlen_alphanum
cd98 : 20a2ce           [ 6] 	jsr df_tk_isalphanum
cd9b :                       df_var_countlen_loop
cd9b : b0ec             [ 3] 	bcs df_var_countlen
cd9d : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* Analyse variable name
                             ;* Return type in A
                             ;* NOT C = It is a variable
                             ;* C = It is not a variable
                             ;* X = Length including pre-fixes
                             ;* Y = Offset to next char after var name
                             ;****************************************
cd9e :                       df_var_analyse
                             	; start at the current buffer position
cd9e : a4be             [ 3] 	ldy df_linoff
AS65 Assembler for R6502 [1.42].                                     Page   60
---------------------------------- bank1.s -----------------------------------

                             	
                             	; actual number of alpha nums = -1 to start
cda0 : a2ff             [ 2] 	ldx #-1
                             
                             	; Default type is INT
cda2 : a901             [ 2] 	lda #DFVVT_INT
cda4 : 85e3             [ 3] 	sta df_tmpptra
                             	
                             	; check for PROC prefix
cda6 : b9000a           [ 4] 	lda df_linbuff,y
cda9 : c95f             [ 2] 	cmp #'_'
                             	; if it is not proc then get the name
cdab : d011             [ 3] 	bne df_var_not_proc
                             	; analyse for proc variable names
                             	; else set type to PROC
cdad : a940             [ 2] 	lda #DFVVT_PROC
cdaf : 85e3             [ 3] 	sta df_tmpptra
cdb1 : 2089cd           [ 6] 	jsr df_var_countlen
                             	; Length must be >=1
cdb4 : e001             [ 2] 	cpx #1
cdb6 : 9004             [ 3] 	bcc df_var_analyse_fatal_err
                             	; Next char has to be '('
cdb8 : c928             [ 2] 	cmp #'('
cdba : f022             [ 3] 	beq df_var_finalise_len
cdbc :                       df_var_analyse_fatal_err
                             	SWBRK DFERR_SYNTAX
                             
                             	; Analyse for non-proc variable names
cdbe :                       df_var_not_proc
                             	; go back on pos on index as loop always does in
cdbe : 88               [ 2] 	dey
cdbf : 2089cd           [ 6] 	jsr df_var_countlen
cdc2 : e000             [ 2] 	cpx #0
cdc4 : d002             [ 3] 	bne df_var_analyse_chk_post
                             	; if zero alphanums error but not fatal
cdc6 : 38               [ 2] 	sec
cdc7 : 60               [ 6] 	rts
                             	; check for post qualifiers e.g. $
cdc8 :                       df_var_analyse_chk_post
                             	; first see if the char is $
                             	; but cannot already have PROC prefix
                             ;	cmp #'%'
                             ;	bne df_var_analyse_chk_dollar
                             ; Set to INT type although it is the default alre
                             ;	lda #DFVVT_INT
                             ;	sta df_tmpptra
                             	; advance the buffer index
                             ;	iny
                             ;	bne df_var_analyse_chk_arry
cdc8 :                       df_var_analyse_chk_dollar
                             	; now see if the char is $
                             	; but cannot already have PROC prefix
cdc8 : c924             [ 2] 	cmp #'$'
cdca : d005             [ 3] 	bne df_var_analyse_chk_arry
                             	; Set to STRING type
cdcc : a904             [ 2] 	lda #DFVVT_STR
cdce : 85e3             [ 3] 	sta df_tmpptra
                             	; advance the buffer index
cdd0 : c8               [ 2] 	iny
cdd1 :                       df_var_analyse_chk_arry
                             	; Check for array type vs PROC
cdd1 : b9000a           [ 4] 	lda df_linbuff,y
AS65 Assembler for R6502 [1.42].                                     Page   61
---------------------------------- bank1.s -----------------------------------

cdd4 : c95b             [ 2] 	cmp #'['
cdd6 : d006             [ 3] 	bne df_var_finalise_len
cdd8 : a5e3             [ 3] 	lda df_tmpptra
cdda : 0980             [ 2] 	ora #DFVVT_PTR
cddc : 85e3             [ 3] 	sta df_tmpptra
cdde :                       df_var_finalise_len
                             	; Ok got everything
                             	; calculate length from y
                             	; y is next char after var name
cdde : 98               [ 2] 	tya
cddf : 38               [ 2] 	sec
cde0 : e5be             [ 3] 	sbc df_linoff			; where we started
                             	; put len in X
cde2 : aa               [ 2] 	tax
                             	; put type in A
cde3 : a5e3             [ 3] 	lda df_tmpptra
cde5 : 18               [ 2] 	clc
cde6 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* Find or create a variable
                             ;* If found then type needs to match mask
                             ;* Not a fatal error because could be part
                             ;* of a trial of different parsing options
                             ;****************************************
cde7 :                       df_var_findcreate
                             	; save mask
cde7 : 48               [ 3] 	pha
cde8 : 20c4cc           [ 6] 	jsr df_var_find
cdeb : b013             [ 4] 	bcs df_var_findcreate_create
                             	; restore mask to check for 0 then push
cded : 68               [ 4] 	pla
cdee : 48               [ 3] 	pha
                             	; don't check mask if zero
cdef : f008             [ 3] 	beq df_var_findcreate_found
                             	; restore mask
cdf1 : 68               [ 4] 	pla
cdf2 : a000             [ 2] 	ldy #DFVVT_TYPE
cdf4 : 31e3             [ 5] 	and (df_tmpptra),y
                             	; but if mask is non zero then this must be non 
cdf6 : f019             [ 4] 	beq df_var_findcreate_err
cdf8 : 48               [ 3] 	pha		; Dummy push to match the pla
cdf9 :                       df_var_findcreate_found
                             	; discard mask
cdf9 : 68               [ 4] 	pla	
                             	; put slot address in x,a
cdfa : a6e3             [ 3] 	ldx df_tmpptra
cdfc : a5e4             [ 3] 	lda df_tmpptra+1
cdfe : 18               [ 2] 	clc
cdff : 60               [ 6] 	rts
                             	
                             	;* If no existing variable found, add one to VNT
ce00 :                       df_var_findcreate_create
                             	; find type (A) and length (X)
ce00 : 209ecd           [ 6] 	jsr df_var_analyse
                             	; keep A temporarily
ce03 : 85e3             [ 3] 	sta df_tmpptra
                             	; if not a variable then return with C=1
ce05 : b009             [ 3] 	bcs df_var_findcreate_errp
                             	; check if mask needs to be applied
ce07 : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page   62
---------------------------------- bank1.s -----------------------------------

ce08 : f009             [ 3] 	beq df_var_analyse_ok
                             	; else mask and check
ce0a : 25e3             [ 3] 	and df_tmpptra
                             	; mask match is ok
ce0c : d005             [ 3] 	bne df_var_analyse_ok
                             	; else return not found
ce0e : f001             [ 3] 	beq df_var_findcreate_err
ce10 :                       df_var_findcreate_errp
ce10 : 68               [ 4] 	pla
ce11 :                       df_var_findcreate_err
ce11 : 38               [ 2] 	sec
ce12 : 60               [ 6] 	rts
                             
ce13 :                       df_var_analyse_ok
                             	; extra space for zero terminator
ce13 : e8               [ 2] 	inx
                             	; save data in reverse order to when needed
                             	; by the initialise section x,a (var name sz, ty
                             	; insert space of X bytes
ce14 : a5e3             [ 3] 	lda df_tmpptra
ce16 : 48               [ 3] 	pha
ce17 : 8a               [ 2] 	txa
ce18 : 48               [ 3] 	pha
                             	
ce19 : 202fcd           [ 6] 	jsr df_var_insert_space
ce1c : 9002             [ 3] 	bcc df_var_initialise_var
                             	; error inserting space
                             	SWBRK DFERR_OK
                             
                             	
ce20 :                       df_var_initialise_var
ce20 : 68               [ 4] 	pla
ce21 : 85e7             [ 3] 	sta df_tmpptrc				; var name size + 1
                             
ce23 : 68               [ 4] 	pla							; type
ce24 : a000             [ 2] 	ldy #DFVVT_TYPE
ce26 : 91b1             [ 5] 	sta (df_vvtend),y			; put type in vvt slot
ce28 : a900             [ 2] 	lda #0						; zero the rest
ce2a : a007             [ 2] 	ldy #7
ce2c :                       df_var_zero_vnt
ce2c : 91b1             [ 5] 	sta (df_vvtend),y
ce2e : 88               [ 2] 	dey
ce2f : d0fb             [ 3] 	bne df_var_zero_vnt			; Don't zero out the type
                             
ce31 : c6e7             [ 5] 	dec df_tmpptrc				; 1 less to copy variable name
                             
ce33 : a6be             [ 3] 	ldx df_linoff				; Start at var name beginning, 
                             	; copy variable name to vnt slot
ce35 :                       df_var_findcreate_copy
ce35 : bd000a           [ 4] 	lda df_linbuff,x
ce38 : 91ab             [ 5] 	sta (df_vntstrt),y
ce3a : e8               [ 2] 	inx
ce3b : c8               [ 2] 	iny
ce3c : c6e7             [ 5] 	dec df_tmpptrc
ce3e : d0f5             [ 3] 	bne df_var_findcreate_copy
                             	; put in zero terminator
ce40 : a900             [ 2] 	lda #0
ce42 : 91ab             [ 5] 	sta (df_vntstrt),y
                             
ce44 : 86be             [ 3] 	stx df_linoff				; Update line pointer
                             
                             	; Return address of slot in X,A
AS65 Assembler for R6502 [1.42].                                     Page   63
---------------------------------- bank1.s -----------------------------------

ce46 : a6b1             [ 3] 	ldx df_vvtend
ce48 : a5b2             [ 3] 	lda df_vvtend+1
                             	
ce4a : 18               [ 2] 	clc
ce4b : 60               [ 6] 	rts
                             	
ce4c :                       mod_sz_var_e
                             
                             	include "dflat/tokenise.s"
                             ;************************************************
                             ;*
                             ;*	BBC128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TOKENISE.S
                             ;*  Controlling module for tokenisation.  Basical
                             ;*  module is given a raw input buffer, which it 
                             ;*  attempt to tokenise fully.  Any syntax errors
                             ;*  thrown at the first point of detection.  If a
                             ;*  well, the parsed input will be in a tokenised
                             ;*  which can be executed in immediate mode or sa
                             ;*  line number order to memory.
                             ;*  dflat syntax is very simple - every statement
                             ;*  with a keyword.  The only exception is assign
                             ;*  procedure invocation - but even these scenari
                             ;*  tokenised so during runtime we just execute t
                             ;*  The raw buffer is consumed one byte at a time
                             ;*  tokenised buffer is written one byte at a tim
                             ;*  syntax means there is no need to undo reads o
                             ;*  or tokenised buffer.  The only refinement is 
                             ;*  allowed to peek a character in the raw buffer
                             ;*  consuming it.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
ce4c :                       mod_sz_tokenise_s
                             
                             
                             ;****************************************
                             ;* df_tk_peek_buf
                             ;* Return next char in A but no change to pointer
                             ;****************************************
ce4c :                       df_tk_peek_buf
ce4c : a4be             [ 3] 	ldy df_linoff
ce4e : b9000a           [ 4] 	lda df_linbuff,y
ce51 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_get_buf
                             ;* Return next char in A and inc pointer
                             ;* Don't advance if null char found and Z=1
                             ;****************************************
ce52 :                       df_tk_get_buf
ce52 : a4be             [ 3] 	ldy df_linoff
ce54 : b9000a           [ 4] 	lda df_linbuff,y
ce57 : f003             [ 3] 	beq df_tk_get_buf_null
AS65 Assembler for R6502 [1.42].                                     Page   64
---------------------------------- bank1.s -----------------------------------

ce59 : c8               [ 2] 	iny
ce5a : 84be             [ 3] 	sty df_linoff
ce5c :                       df_tk_get_buf_null
ce5c : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_put_tok
                             ;* Put A in token buffer and inc pointer
                             ;* C=Clear on exit
                             ;****************************************
ce5d :                       df_tk_put_tok
ce5d : a4bf             [ 3] 	ldy df_tokoff
ce5f : 99800a           [ 5] 	sta df_tokbuff,y
ce62 : c8               [ 2] 	iny
ce63 : 3004             [ 3] 	bmi df_tk_put_overflow
ce65 : 84bf             [ 3] 	sty df_tokoff
ce67 : 18               [ 2] 	clc
ce68 : 60               [ 6] 	rts
ce69 :                       df_tk_put_overflow
                             	SWBRK DFERR_STRLONG
                             
                             
                             ;****************************************
                             ;* df_tk_isdigit
                             ;* Check char in A for number 0-9
                             ;* Return: CC = False, CS = True
                             ;****************************************
ce6b :                       df_tk_isdigit
ce6b : c93a             [ 2] 	cmp #'9'+1
ce6d : b005             [ 3] 	bcs df_tk_isdigit_false
ce6f : c930             [ 2] 	cmp #'0'
ce71 : 9001             [ 3] 	bcc df_tk_isdigit_false
ce73 : 60               [ 6] 	rts						; C must be 1
ce74 :                       df_tk_isdigit_false
ce74 : 18               [ 2] 	clc
ce75 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isbin
                             ;* Check char in A for binary digit
                             ;* Return: CC = False, CS = True
                             ;****************************************
ce76 :                       df_tk_isbin
ce76 : c930             [ 2] 	cmp #'0'
ce78 : f005             [ 3] 	beq df_tk_isbin_true	; C=1
ce7a : c931             [ 2] 	cmp #'1'
ce7c : f001             [ 3] 	beq df_tk_isbin_true	; C=1
ce7e : 18               [ 2] 	clc
ce7f :                       df_tk_isbin_true
ce7f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_ishex
                             ;* Check char in A for number 0-9, A-F, a-f
                             ;* Return: CC = False, CS = True
                             ;****************************************
ce80 :                       df_tk_ishex
ce80 : 48               [ 3] 	pha
ce81 : 206bce           [ 6] 	jsr df_tk_isdigit
ce84 : b00a             [ 3] 	bcs df_tk_ishex_truep
ce86 : 0920             [ 2] 	ora #0x20
ce88 : c967             [ 2] 	cmp #'f'+1
AS65 Assembler for R6502 [1.42].                                     Page   65
---------------------------------- bank1.s -----------------------------------

ce8a : b006             [ 3] 	bcs df_tk_ishex_false
ce8c : c961             [ 2] 	cmp #'a'
ce8e : 9002             [ 3] 	bcc df_tk_ishex_false
                             	; C must be 1 here
ce90 :                       df_tk_ishex_truep
ce90 : 68               [ 4] 	pla
ce91 : 60               [ 6] 	rts
ce92 :                       df_tk_ishex_false
ce92 :                       df_tk_isalpha_false
ce92 : 18               [ 2] 	clc
ce93 : 68               [ 4] 	pla
ce94 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isalpha
                             ;* Check next char in A alpha a-z, A-Z
                             ;* Return: CC = False, CS = True
                             ;****************************************
ce95 :                       df_tk_isalpha
ce95 : 48               [ 3] 	pha
ce96 : 0920             [ 2] 	ora #0x20					; Convert to lower case for checki
ce98 : c97b             [ 2] 	cmp #'z'+1
ce9a : b0f6             [ 3] 	bcs df_tk_isalpha_false
ce9c : c961             [ 2] 	cmp #'a'
ce9e : 90f2             [ 3] 	bcc df_tk_isalpha_false
                             	; C must be 1 here
cea0 : 68               [ 4] 	pla
cea1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isalphanum
                             ;* Check next char A for a-z,A-Z,0-9
                             ;* Return: CC = False, CS = True
                             ;****************************************
cea2 :                       df_tk_isalphanum
cea2 : 2095ce           [ 6] 	jsr df_tk_isalpha
cea5 : 90c4             [ 3] 	bcc df_tk_isdigit
cea7 :                       df_tk_rts1				; branch to this RTS where possible
cea7 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isproc
                             ;* Check next char A for _
                             ;* Return: CC = False, CS = True
                             ;****************************************
cea8 :                       df_tk_isproc
cea8 : c95f             [ 2] 	cmp #'_'
ceaa : f001             [ 3] 	beq df_tk_isproc_true	; C=1
ceac : 18               [ 2] 	clc
cead :                       df_tk_isproc_true
cead : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_skip_ws
                             ;* Skip ws in linbuff
                             ;* Return: linoff updated to next non-ws, A = cha
                             ;****************************************
ceae :                       df_tk_skip_ws
ceae :                       df_tk_ws_loop1
ceae : 204cce           [ 6] 	jsr df_tk_peek_buf
ceb1 : 20c9ce           [ 6] 	jsr df_tk_isws
ceb4 : 90f1             [ 3] 	bcc df_tk_rts1
AS65 Assembler for R6502 [1.42].                                     Page   66
---------------------------------- bank1.s -----------------------------------

ceb6 : e6be             [ 5] 	inc df_linoff
ceb8 : 205dce           [ 6] 	jsr df_tk_put_tok
cebb : 90f1             [ 3] 	bcc df_tk_skip_ws		; Always as put_tok clears C
                             
                             ;****************************************
                             ;* df_tk_strip_ws
                             ;* Strip ws in linbuff
                             ;* Return: linoff updated to next non-ws, A = cha
                             ;****************************************
cebd :                       df_tk_strip_ws
cebd : 204cce           [ 6] 	jsr df_tk_peek_buf
cec0 : 20c9ce           [ 6] 	jsr df_tk_isws
cec3 : 90e2             [ 3] 	bcc df_tk_rts1
cec5 : e6be             [ 5] 	inc df_linoff
cec7 : d0f4             [ 3] 	bne df_tk_strip_ws		; Always as linoff is not ze
                             
                             ;****************************************
                             ;* df_tk_isws
                             ;* Check char is ws (only space is counted)
                             ;* Return: CC = False, CS = True
                             ;****************************************
cec9 :                       df_tk_isws
cec9 : c920             [ 2] 	cmp #' '
cecb : d001             [ 3] 	bne df_tk_isws_false
                             	; C must be 1 here
cecd : 60               [ 6] 	rts
cece :                       df_tk_isws_false
cece :                       df_tk_expectok
cece : 18               [ 2] 	clc
cecf : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* CC = found, CS = Error
                             ;****************************************
ced0 :                       df_tk_expect
ced0 : 48               [ 3] 	pha
                             	; skip ws
ced1 : 20aece           [ 6] 	jsr df_tk_skip_ws
                             	; peek the buffer
ced4 : 68               [ 4] 	pla
ced5 : a4be             [ 3] 	ldy df_linoff
ced7 : d9000a           [ 4] 	cmp df_linbuff,y
                             	; if expected char then ok
ceda : f0f2             [ 3] 	beq df_tk_expectok
                             	; else error
cedc :                       df_tk_num_err
cedc :                       df_tk_char_err
cedc : 38               [ 2] 	sec
cedd : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* Tokenises the character as well
                             ;* CC = found, CS = Error
                             ;****************************************
cede :                       df_tk_expect_tok
cede : 20d0ce           [ 6] 	jsr df_tk_expect
cee1 : b0c4             [ 3] 	bcs df_tk_rts1
cee3 : 2052ce           [ 6] 	jsr df_tk_get_buf
AS65 Assembler for R6502 [1.42].                                     Page   67
---------------------------------- bank1.s -----------------------------------

cee6 : 4c5dce           [ 3] 	jmp df_tk_put_tok
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* Tokenises the character as well
                             ;* FATAL IF NOT FOUND
                             ;****************************************
cee9 :                       df_tk_expect_tok_err
cee9 : 20dece           [ 6] 	jsr df_tk_expect_tok
ceec : 90b9             [ 3] 	bcc df_tk_rts1
ceee :                       df_tk_expect_tok_fatal
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Tokenise a constant number
                             ;****************************************
cef0 :                       df_tk_num
                             	; X,A = address, linbuff must be on page boundar
cef0 : 18               [ 2] 	clc
cef1 : a900             [ 2] 	lda #lo(df_linbuff)
cef3 : 65be             [ 3] 	adc df_linoff
cef5 : aa               [ 2] 	tax
cef6 : a90a             [ 2] 	lda #hi(df_linbuff)
cef8 : 6900             [ 2] 	adc #0
cefa : a000             [ 2] 	ldy #0				; any numeric format
cefc : 201bc9           [ 6] 	jsr con_n_to_a
ceff : b0db             [ 3] 	bcs df_tk_num_err
                             	; A = format
                             	; X = how many digits processed
                             	; Jump over that many chars
cf01 : a8               [ 2] 	tay
cf02 : 18               [ 2] 	clc
cf03 : 8a               [ 2] 	txa
cf04 : 65be             [ 3] 	adc df_linoff
cf06 : 85be             [ 3] 	sta df_linoff
                             	; Now tokenise an integer (always 2 bytes, but t
cf08 : 98               [ 2] 	tya
cf09 : c901             [ 2] 	cmp #NUM_DEC
cf0b : d004             [ 3] 	bne df_tk_num_hexbin
cf0d : a909             [ 2] 	lda #DFTK_INTDEC	; decimal always an int
cf0f : d016             [ 3] 	bne df_tk_num_put
cf11 :                       df_tk_num_hexbin
cf11 : c902             [ 2] 	cmp #NUM_HEX
cf13 : d00a             [ 3] 	bne df_tk_num_bin
cf15 : a906             [ 2] 	lda #DFTK_BYTHEX	; Assume BYT
cf17 : e005             [ 2] 	cpx #5				; If >4 chars then INT
cf19 : 900c             [ 3] 	bcc df_tk_num_put
cf1b : a90a             [ 2] 	lda #DFTK_INTHEX
cf1d : d008             [ 3] 	bne df_tk_num_put
cf1f :                       df_tk_num_bin
cf1f : a907             [ 2] 	lda #DFTK_BYTBIN	; Assume BYT
cf21 : e00b             [ 2] 	cpx #11				; If >10 chars then INT
cf23 : 9002             [ 3] 	bcc df_tk_num_put
cf25 : a90b             [ 2] 	lda #DFTK_INTBIN
cf27 :                       df_tk_num_put
cf27 : 205dce           [ 6] 	jsr df_tk_put_tok	; Save number type (DEC,HEX,BI
cf2a : a585             [ 3] 	lda num_a
cf2c : 205dce           [ 6] 	jsr df_tk_put_tok
cf2f : a586             [ 3] 	lda num_a+1
cf31 : 4c5dce           [ 3] 	jmp df_tk_put_tok
AS65 Assembler for R6502 [1.42].                                     Page   68
---------------------------------- bank1.s -----------------------------------

                             
                             ;****************************************
                             ;* Tokenise a constant char
                             ;****************************************
cf34 :                       df_tk_char
                             	; skip the first quote
cf34 : 2052ce           [ 6] 	jsr df_tk_get_buf
                             	; put in the token
cf37 : a900             [ 2] 	lda #DFTK_CHR
cf39 : 205dce           [ 6] 	jsr df_tk_put_tok
                             	; get the char value and save
cf3c : 2052ce           [ 6] 	jsr df_tk_get_buf
cf3f : 205dce           [ 6] 	jsr df_tk_put_tok
                             	; always put two bytes in, even for a BYTE type
cf42 : a900             [ 2] 	lda #0
cf44 : 205dce           [ 6] 	jsr df_tk_put_tok
                             	; next byte must be single quote
cf47 : 2052ce           [ 6] 	jsr df_tk_get_buf
cf4a : c927             [ 2] 	cmp #0x27
cf4c : d08e             [ 4] 	bne df_tk_char_err
cf4e : 18               [ 2] 	clc
cf4f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise a constant string
                             ;****************************************
cf50 :                       df_tk_str
                             	; skip the first quote
cf50 : 2052ce           [ 6] 	jsr df_tk_get_buf
                             	; put in the token
cf53 : a910             [ 2] 	lda #DFTK_STRLIT
cf55 : 205dce           [ 6] 	jsr df_tk_put_tok
cf58 :                       df_tk_str_ch
                             	; copy string chars in to token buffer
                             	; until another quote or end of line
cf58 : 2052ce           [ 6] 	jsr df_tk_get_buf
cf5b : c900             [ 2] 	cmp #0
cf5d : f011             [ 3] 	beq df_tk_str_err
cf5f : c922             [ 2] 	cmp #0x22
cf61 : f006             [ 3] 	beq df_tk_str_don
cf63 : 205dce           [ 6] 	jsr df_tk_put_tok
cf66 : 4c58cf           [ 3] 	jmp df_tk_str_ch
cf69 :                       df_tk_str_don
                             	; zero terminated strings
cf69 : a900             [ 2] 	lda #0
cf6b : 4c5dce           [ 3] 	jmp df_tk_put_tok
cf6e :                       df_tk_var_noarry
cf6e : 18               [ 2] 	clc
cf6f : 60               [ 6] 	rts
cf70 :                       df_tk_str_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Tokenise a constant (num, string, char)
                             ;****************************************
cf72 :                       df_tk_const
cf72 : 20aece           [ 6] 	jsr df_tk_skip_ws
                             	; Check what constant it is
cf75 : 204cce           [ 6] 	jsr df_tk_peek_buf
                             	; Minus symbol could be start of a number
cf78 : c92d             [ 2] 	cmp #'-'
AS65 Assembler for R6502 [1.42].                                     Page   69
---------------------------------- bank1.s -----------------------------------

cf7a : f005             [ 3] 	beq df_tk_const_try_num
cf7c : 206bce           [ 6] 	jsr df_tk_isdigit
cf7f : 9003             [ 3] 	bcc df_tk_const_try_str
cf81 :                       df_tk_const_try_num
cf81 : 4cf0ce           [ 3] 	jmp df_tk_num
cf84 :                       df_tk_const_try_str
                             	; check for double quote
cf84 : c922             [ 2] 	cmp #0x22
cf86 : d003             [ 3] 	bne df_tk_const_try_char
cf88 : 4c50cf           [ 3] 	jmp df_tk_str
cf8b :                       df_tk_const_try_char
                             	; check for single apostrophe
cf8b : c927             [ 2] 	cmp #0x27
cf8d : d003             [ 3] 	bne df_tk_const_err
cf8f : 4c34cf           [ 3] 	jmp df_tk_char
cf92 :                       df_tk_const_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Tokenise a variable - A = mask
                             ;* Return : A = variable index
                             ;****************************************
cf94 :                       df_tk_var
                             	; Find or create variable, address in X,A
cf94 : 20e7cd           [ 6] 	jsr df_var_findcreate
cf97 : 9001             [ 3] 	bcc df_tk_var_cont
cf99 : 60               [ 6] 	rts
cf9a :                       df_tk_var_cont
                             	; Save X,A for later
cf9a : 48               [ 3] 	pha
cf9b : 8a               [ 2] 	txa
cf9c : 48               [ 3] 	pha
                             	; Put VAR escape in token buffer
cf9d : a911             [ 2] 	lda #DFTK_VAR
cf9f : 205dce           [ 6] 	jsr df_tk_put_tok
                             	; Get variable address and put in token buffer
cfa2 : 68               [ 4] 	pla
cfa3 : 205dce           [ 6] 	jsr df_tk_put_tok
cfa6 : 68               [ 4] 	pla
cfa7 : 205dce           [ 6] 	jsr df_tk_put_tok
                             	; count of any array indices
cfaa :                       df_tk_var_ck
                             	; check if array procesing needed
cfaa : a95b             [ 2] 	lda #'['
cfac : 20dece           [ 6] 	jsr df_tk_expect_tok
cfaf : b0bd             [ 3] 	bcs df_tk_var_noarry
                             	; process numeric expression in bracket
cfb1 : 4c5bd0           [ 3] 	jmp df_tk_narry
                             
                             
                             ;****************************************
                             ;* Tokenise a parameter in proc definition
                             ;* Return : A = variable index
                             ;****************************************
cfb4 :                       df_tk_parm
                             	; if preceeding with non-local qualifier DFTK_VA
cfb4 : 204cce           [ 6] 	jsr df_tk_peek_buf
cfb7 : c926             [ 2] 	cmp #DFTK_VARPARM
cfb9 : d006             [ 3] 	bne df_tk_parm_skip_var
                             	; get the qualifier and put in token buffer
cfbb : 2052ce           [ 6] 	jsr df_tk_get_buf
AS65 Assembler for R6502 [1.42].                                     Page   70
---------------------------------- bank1.s -----------------------------------

cfbe : 205dce           [ 6] 	jsr df_tk_put_tok
cfc1 :                       df_tk_parm_skip_var
                             	; don't have a certain type of var
cfc1 : a900             [ 2] 	lda #0
cfc3 : 4c94cf           [ 3] 	jmp df_tk_var
                             
                             
                             ;****************************************
                             ;* Tokenise a variable to localise
                             ;* Return : A,X = variable index
                             ;****************************************
cfc6 :                       df_tk_localvar
                             	; Find or create variable, index in A
cfc6 : 20e7cd           [ 6] 	jsr df_var_findcreate
cfc9 : 9001             [ 3] 	bcc df_tk_localvar_cont
cfcb : 60               [ 6] 	rts
cfcc :                       df_tk_localvar_cont
                             	; Save variable address for later
cfcc : 48               [ 3] 	pha
cfcd : 8a               [ 2] 	txa
cfce : 48               [ 3] 	pha
                             	; Put VAR escape in token buffer
cfcf : a911             [ 2] 	lda #DFTK_VAR
cfd1 : 205dce           [ 6] 	jsr df_tk_put_tok
                             	; Get variable index and put in token buffer
cfd4 : 68               [ 4] 	pla
cfd5 : 205dce           [ 6] 	jsr df_tk_put_tok
cfd8 : 68               [ 4] 	pla
cfd9 : 4c5dce           [ 3] 	jmp df_tk_put_tok
                             
                             ;****************************************
                             ;* Tokenise array variable
                             ;* Return : A = variable index
                             ;****************************************
cfdc :                       df_tk_arrvar
                             	; Like a local var at first
cfdc : 20c6cf           [ 6] 	jsr df_tk_localvar
                             	; but must be array
cfdf : a95b             [ 2] 	lda #'['
cfe1 : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
                             	; process numeric expression in bracket
cfe4 : 4c5bd0           [ 3] 	jmp df_tk_narry
                             
                             ;****************************************
                             ;* Tokenise call or def of proc
                             ;* Mode : A = 0 means def, else call
                             ;****************************************
cfe7 :                       df_tk_proc
cfe7 : 85cd             [ 3] 	sta df_procmode
cfe9 : 20aece           [ 6] 	jsr df_tk_skip_ws
                             	; Find or create proc, index in A
cfec : a940             [ 2] 	lda #DFVVT_PROC
cfee : 20e7cd           [ 6] 	jsr df_var_findcreate
cff1 : b066             [ 4] 	bcs df_tk_proc_err
                             
                             	; Save variable address for later
cff3 : 86d0             [ 3] 	stx df_procptr
cff5 : 85d1             [ 3] 	sta df_procptr+1
                             
                             	; Put PROC escape in token buffer
cff7 : a912             [ 2] 	lda #DFTK_PROC
cff9 : 205dce           [ 6] 	jsr df_tk_put_tok
AS65 Assembler for R6502 [1.42].                                     Page   71
---------------------------------- bank1.s -----------------------------------

                             	; Get variable address and put in token buffer
cffc : a5d0             [ 3] 	lda df_procptr
cffe : 205dce           [ 6] 	jsr df_tk_put_tok
d001 : a5d1             [ 3] 	lda df_procptr+1
d003 : 205dce           [ 6] 	jsr df_tk_put_tok
                             
                             	; initially assume no args
d006 : a900             [ 2] 	lda #0
d008 : 85ce             [ 3] 	sta df_procargs
                             
                             	; Must have an open bracket
d00a : a928             [ 2] 	lda #'('
d00c : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
                             	; if immediately followed by close bracket then 
d00f : 204cce           [ 6] 	jsr df_tk_peek_buf
d012 : c929             [ 2] 	cmp #')'
d014 : f030             [ 3] 	beq df_tk_proc_noparm
                             	; else tokenise parm variables
d016 :                       df_tk_proc_parms
d016 : 20aece           [ 6] 	jsr df_tk_skip_ws
                             	; call appropriate routine for mode
d019 : a5cd             [ 3] 	lda df_procmode
d01b : d006             [ 3] 	bne df_tk_proc_call
                             	; tokenise parameter variable in def mode
d01d : 20b4cf           [ 6] 	jsr df_tk_parm
d020 : 4c2cd0           [ 3] 	jmp df_tk_proc_skip_call
d023 :                       df_tk_proc_call
                             	; tokenise expression in call mode
                             	;**CHECK**
d023 : a5ce             [ 3] 	lda df_procargs	; procargs could be impacted ins
d025 : 48               [ 3] 	pha
d026 : 20dbd0           [ 6] 	jsr df_tk_expression
d029 : 68               [ 4] 	pla
d02a : 85ce             [ 3] 	sta df_procargs
d02c :                       df_tk_proc_skip_call
d02c : b02a             [ 3] 	bcs df_tk_proc_errp
                             	; increment number of args
d02e : e6ce             [ 5] 	inc df_procargs
                             	; what is next non ws char
d030 : 20aece           [ 6] 	jsr df_tk_skip_ws
d033 : c92c             [ 2] 	cmp #','
d035 : f006             [ 3] 	beq df_tk_proc_comma
d037 : c929             [ 2] 	cmp #')'
d039 : d01d             [ 3] 	bne df_tk_proc_errp
d03b : f009             [ 3] 	beq df_tk_proc_noparm
                             	; comma found, more parms to process
d03d :                       df_tk_proc_comma
d03d : 2052ce           [ 6] 	jsr df_tk_get_buf
d040 : 205dce           [ 6] 	jsr df_tk_put_tok
d043 : 4c16d0           [ 3] 	jmp df_tk_proc_parms
d046 :                       df_tk_proc_noparm
                             	; consume the close bracket
d046 : 2052ce           [ 6] 	jsr df_tk_get_buf
d049 : 205dce           [ 6] 	jsr df_tk_put_tok
                             
                             	; update arg count if def mode
d04c : a6cd             [ 3] 	ldx df_procmode
d04e : d006             [ 3] 	bne df_tk_proc_skip_args
                             	; use address of proc
                             	; put arg count in dim2
d050 : a004             [ 2] 	ldy #DFVVT_DIM2
d052 : a5ce             [ 3] 	lda df_procargs
AS65 Assembler for R6502 [1.42].                                     Page   72
---------------------------------- bank1.s -----------------------------------

d054 : 91d0             [ 5] 	sta (df_procptr),y
d056 :                       df_tk_proc_skip_args
d056 : 18               [ 2] 	clc
d057 : 60               [ 6] 	rts
d058 :                       df_tk_proc_errp
d058 : 68               [ 4] 	pla
d059 :                       df_tk_proc_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse array index
                             ;****************************************
d05b :                       df_tk_narry
                             	; if array open bracket encountered
                             	; then tokenise a numeric expression
d05b : 20dbd0           [ 6] 	jsr df_tk_expression
                             	; If a comma is next, then another expression
d05e : a92c             [ 2] 	lda #','
d060 : 20dece           [ 6] 	jsr df_tk_expect_tok
d063 : b003             [ 3] 	bcs df_tk_narry_end
d065 : 20dbd0           [ 6] 	jsr df_tk_expression
d068 :                       df_tk_narry_end
                             	; after the second dimension, must be close sq b
d068 : a95d             [ 2] 	lda #']'
d06a : 4ce9ce           [ 3] 	jmp df_tk_expect_tok_err
                             
                             ;****************************************
                             ;* Parse bracket
                             ;****************************************
d06d :                       df_tk_nbrkt
                             	; if  open bracket encountered
                             	; then tokenise a numeric expression
d06d : 20dbd0           [ 6] 	jsr df_tk_expression
d070 : a929             [ 2] 	lda #')'
d072 : 4ce9ce           [ 3] 	jmp df_tk_expect_tok_err
                             
                             ;****************************************
                             ;* Parse call to numeric proc
                             ;****************************************
d075 :                       df_tk_nterm_proc
                             	; call mode
d075 : a901             [ 2] 	lda #1
d077 : 4ce7cf           [ 3] 	jmp df_tk_proc
                             
                             ;****************************************
                             ;* Parse numeric term
                             ;****************************************
d07a :                       df_tk_nterm
                             	; skip any ws first, copying in to tokbuff
                             	; A containts the non-ws char
d07a : 20aece           [ 6] 	jsr df_tk_skip_ws
d07d : c900             [ 2] 	cmp #0
d07f : f004             [ 3] 	beq df_tk_nterm_done
d081 : c93a             [ 2] 	cmp #':'
d083 : d002             [ 3] 	bne df_tk_nterm_cont
d085 :                       df_tk_nterm_done
d085 :                       df_tk_nop_false
d085 : 38               [ 2] 	sec
d086 : 60               [ 6] 	rts
d087 :                       df_tk_nterm_cont
                             	; if open bracket then process it
AS65 Assembler for R6502 [1.42].                                     Page   73
---------------------------------- bank1.s -----------------------------------

d087 : c928             [ 2] 	cmp #'('
d089 : d009             [ 3] 	bne df_tk_nterm_tryfn
                             	; get the bracket and put in token buffer
d08b : 2052ce           [ 6] 	jsr df_tk_get_buf
d08e : 205dce           [ 6] 	jsr df_tk_put_tok
                             	; go process the open bracket
d091 : 4c6dd0           [ 3] 	jmp df_tk_nbrkt
d094 :                       df_tk_nterm_tryfn
d094 : 48               [ 3] 	pha
                             	; try decoding a built-in function
d095 : a902             [ 2] 	lda #DFTK_FN
d097 : 20ced1           [ 6] 	jsr df_tk_matchtok
d09a : b00e             [ 3] 	bcs df_tk_nterm_try_proc
                             	; pull old A in to Y but don't use
d09c : 68               [ 4] 	pla
d09d : a8               [ 2] 	tay
                             	; restore A and put the token with MSB set
d09e : 8a               [ 2] 	txa
d09f : 0980             [ 2] 	ora #0x80
d0a1 : 205dce           [ 6] 	jsr df_tk_put_tok
d0a4 : 20a0d1           [ 6] 	jsr df_tk_exec_parser
d0a7 : b01b             [ 3] 	bcs df_tk_nterm_err
d0a9 : 60               [ 6] 	rts
d0aa :                       df_tk_nterm_try_proc
d0aa : 68               [ 4] 	pla
                             	; if it's not a func then try proc
d0ab : 20a8ce           [ 6] 	jsr df_tk_isproc
d0ae : 9006             [ 3] 	bcc df_tk_nterm_try_var
d0b0 : 2075d0           [ 6] 	jsr df_tk_nterm_proc
d0b3 : b00f             [ 3] 	bcs df_tk_nterm_err
d0b5 : 60               [ 6] 	rts
d0b6 :                       df_tk_nterm_try_var
                             	; Non-zero mask means var must be this type
d0b6 : a900             [ 2] 	lda #0
d0b8 : 2094cf           [ 6] 	jsr df_tk_var
d0bb : b001             [ 3] 	bcs df_tk_nterm_try_const
d0bd : 60               [ 6] 	rts
d0be :                       df_tk_nterm_try_const
                             	; Try decoding a constant
d0be : 2072cf           [ 6] 	jsr df_tk_const
d0c1 : b001             [ 3] 	bcs df_tk_nterm_err
d0c3 : 60               [ 6] 	rts
d0c4 :                       df_tk_nterm_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse numeric operator
                             ;****************************************
d0c6 :                       df_tk_nop
d0c6 : 20aece           [ 6] 	jsr df_tk_skip_ws
d0c9 : c900             [ 2] 	cmp #0
d0cb : f0b8             [ 3] 	beq df_tk_nop_false
                             	; must be an operator token for numeric
d0cd : a90c             [ 2] 	lda #DFTK_OP | DFTK_STROP
d0cf : 20ced1           [ 6] 	jsr df_tk_matchtok
d0d2 : b0b1             [ 3] 	bcs df_tk_nop_false
                             	; got a token
d0d4 : 0980             [ 2] 	ora #DFTK_TOKEN
d0d6 : 205dce           [ 6] 	jsr df_tk_put_tok
d0d9 : 18               [ 2] 	clc
d0da : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   74
---------------------------------- bank1.s -----------------------------------

                             
                             	
                             ;****************************************
                             ;* Parse numeric expression
                             ;****************************************
d0db :                       df_tk_expression
                             	; Tokenise a numeric term
d0db : 207ad0           [ 6] 	jsr df_tk_nterm
d0de : b006             [ 3] 	bcs df_tk_expre_err
                             	; Try and tokenise a numeric operator
d0e0 : 20c6d0           [ 6] 	jsr df_tk_nop
                             	; If an operator was tokenised
                             	; then loop back for another term
d0e3 : 90f6             [ 3] 	bcc df_tk_expression
                             	; If no operator was found then
                             	; expression is done
d0e5 :                       df_tk_not_eos
d0e5 : 18               [ 2] 	clc
d0e6 :                       df_tk_expre_err
d0e6 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find expected token and parse expression
                             ;****************************************
d0e7 :                       df_tk_tok_expression
d0e7 : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
d0ea : 4cdbd0           [ 3] 	jmp df_tk_expression
                             
                             
                             ;****************************************
                             ;* Check end of statement
                             ;****************************************
d0ed :                       df_tk_isEOS
d0ed : a93a             [ 2] 	lda #':'
d0ef : 20dece           [ 6] 	jsr df_tk_expect_tok
d0f2 : b0f1             [ 3] 	bcs df_tk_not_eos
                             	; this is the position of the next statement
d0f4 : a5bf             [ 3] 	lda df_tokoff
                             	; put it in the last statement offset slot
d0f6 : a4c1             [ 3] 	ldy df_nxtstidx
d0f8 : 99800a           [ 5] 	sta df_tokbuff,y
d0fb : 38               [ 2] 	sec
d0fc : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* Parse user defined proc
                             ;****************************************
d0fd :                       df_tk_parse_user_proc
                             	; put proc token in as a call
d0fd : a981             [ 2] 	lda #0x81
d0ff : 205dce           [ 6] 	jsr df_tk_put_tok
d102 : a901             [ 2] 	lda #1
d104 : 4ce7cf           [ 3] 	jmp df_tk_proc
                             
                             
                             ;****************************************
                             ;* Parse a command
                             ;* Do not fatal error if this fails
                             ;****************************************
d107 :                       df_tk_parse_command
                             	; only looking for keywords
AS65 Assembler for R6502 [1.42].                                     Page   75
---------------------------------- bank1.s -----------------------------------

d107 : a901             [ 2] 	lda #DFTK_KW
d109 : 20ced1           [ 6] 	jsr df_tk_matchtok
                             	; if didn't find regular keywords then try non f
d10c : b010             [ 3] 	bcs df_tk_parse_command_err
                             	; if match then store token in the line buffer
                             	; Set MSB
d10e : 0980             [ 2] 	ora #0x80
d110 : 205dce           [ 6] 	jsr df_tk_put_tok
                             	; call the parser to do tokenise based on the st
d113 : a5c5             [ 3] 	lda df_symoff
d115 : 20a0d1           [ 6] 	jsr df_tk_exec_parser
d118 : b004             [ 3] 	bcs df_tk_parse_command_err
                             	; [1] ignore white space but keep it
d11a : 20aece           [ 6] 	jsr df_tk_skip_ws
                             	; No error in parsing this command
d11d :                       df_tk_parse_command_done
d11d : 18               [ 2] 	clc
d11e :                       df_tk_parse_command_err
d11e : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* lexer
                             ;****************************************
d11f :                       df_lexer_line
d11f : a900             [ 2] 	lda #0
                             	; start at the beginning of the line buffer
d121 : 85be             [ 3] 	sta df_linoff
                             	; start at the beginning of the tokenised buffer
d123 : 85bf             [ 3] 	sta df_tokoff
                             	; set current line to the token buffer
d125 : a980             [ 2] 	lda #lo(df_tokbuff)
d127 : 85c8             [ 3] 	sta df_currlin
d129 : a90a             [ 2] 	lda #hi(df_tokbuff)
d12b : 85c9             [ 3] 	sta df_currlin+1
                             	; Set the line length to 0
d12d : a900             [ 2] 	lda #0
d12f : 205dce           [ 6] 	jsr df_tk_put_tok
                             
                             	; any leading white space, ignore and discard
                             ;	jsr df_tk_strip_ws
                             
                             	; if peek next character is a number then assume
                             	; else assume a statement
d132 : 204cce           [ 6] 	jsr df_tk_peek_buf
d135 : 206bce           [ 6] 	jsr df_tk_isdigit
d138 : 9006             [ 3] 	bcc df_lexer_skip_lnum
                             	; if line number then capture the line number an
d13a : 20afd1           [ 6] 	jsr df_tk_linenum
d13d : 4c48d1           [ 3] 	jmp df_tk_body
d140 :                       df_lexer_skip_lnum
                             	; if no line number then zero out the line numbe
                             	; line zero will indicate an immediate mode comm
d140 : a900             [ 2] 	lda #0
d142 : 205dce           [ 6] 	jsr df_tk_put_tok				; Line num low byte
d145 : 205dce           [ 6] 	jsr df_tk_put_tok				; Line num high byte
d148 :                       df_tk_body
                             	; Offset for next statement
d148 : a5bf             [ 3] 	lda df_tokoff
d14a : 85c1             [ 3] 	sta df_nxtstidx
d14c : a900             [ 2] 	lda #0
d14e : 205dce           [ 6] 	jsr df_tk_put_tok				; Offset to next statement
AS65 Assembler for R6502 [1.42].                                     Page   76
---------------------------------- bank1.s -----------------------------------

d151 : 204cce           [ 6] 	jsr df_tk_peek_buf				; Check for a single space
d154 : 20c9ce           [ 6] 	jsr df_tk_isws					; and first character
d157 : 9002             [ 3] 	bcc df_tk_skip_1_spc
d159 : e6be             [ 5] 	inc df_linoff					; Don't tokenise this single s
d15b :                       df_tk_skip_1_spc
                             	; [1] capture white space from line buffer in to
d15b : 20aece           [ 6] 	jsr df_tk_skip_ws
                             	; If next non ws is zero then this is an empty l
                             	; so return with length zero but line number fil
                             	; token buffer
d15e : c900             [ 2] 	cmp #0
d160 : f03a             [ 3] 	beq df_tk_line_empty
                             	; if next char is _ then parse a user defined pr
d162 : 20a8ce           [ 6] 	jsr df_tk_isproc
d165 : 9006             [ 3] 	bcc df_tk_try_command
d167 : 20fdd0           [ 6] 	jsr df_tk_parse_user_proc
d16a : 4c7ed1           [ 3] 	jmp df_tk_done
d16d :                       df_tk_try_command
                             	; try  a keyword
d16d : 2007d1           [ 6] 	jsr df_tk_parse_command
d170 : b002             [ 3] 	bcs	df_tk_try_asm
d172 : 900a             [ 3] 	bcc df_tk_done
d174 :                       df_tk_try_asm
                             	; try an asm keyword
d174 : 20ebf4           [ 6] 	jsr df_tk_asm_parse_command
d177 : 9005             [ 3] 	bcc df_tk_done
d179 :                       df_tk_try_assign
                             	; nothing but to try an assignment operation
d179 : 200cd6           [ 6] 	jsr df_tk_assign
d17c : b020             [ 3] 	bcs	df_tk_parseerror
d17e :                       df_tk_done
                             	; put statement index stuff here in case of mult
                             	; check for : and if present tokenise plus updat
                             	; then go back to try and process another statem
d17e : 20edd0           [ 6] 	jsr df_tk_isEOS
d181 : b0c5             [ 3] 	bcs df_tk_body
                             	; if not at end of line, then must be error
d183 : 204cce           [ 6] 	jsr df_tk_peek_buf
d186 : c900             [ 2] 	cmp #0
d188 : d014             [ 3] 	bne df_tk_parseerror
                             	; this is the position of the next line
d18a : a5bf             [ 3] 	lda df_tokoff
                             	; put it in the last statement offset slot
d18c : a4c1             [ 3] 	ldy df_nxtstidx
d18e : 99800a           [ 5] 	sta df_tokbuff,y
                             	; Get line length
d191 : a4bf             [ 3] 	ldy df_tokoff
                             	; ensure there is always a zero after the last t
                             	; A is already zero
d193 : a900             [ 2] 	lda #0
d195 : 99800a           [ 5] 	sta df_tokbuff,y
                             	; save the line length
d198 : 98               [ 2] 	tya
d199 : 8d800a           [ 4] 	sta df_tokbuff
d19c :                       df_tk_line_empty
d19c : 18               [ 2] 	clc
d19d : 60               [ 6] 	rts
d19e :                       df_tk_parseerror
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   77
---------------------------------- bank1.s -----------------------------------

                             ;* df_tk_parsestatement
                             ;* Execute parse routine for this statement
                             ;* Input: df_tokoff is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
d1a0 :                       df_tk_exec_parser
d1a0 : 0a               [ 2] 	asl a
d1a1 : aa               [ 2] 	tax
d1a2 : bd71d4           [ 4] 	lda df_tk_tokenjmp,x
d1a5 : 85e3             [ 3] 	sta df_tmpptra
d1a7 : bd72d4           [ 4] 	lda df_tk_tokenjmp+1,x
d1aa : 85e4             [ 3] 	sta df_tmpptra+1
d1ac : 6ce300           [ 6] 	jmp (df_tmpptra)
                             
                             
                             ;****************************************
                             ;* df_tk_linenum
                             ;* Tokenise line number
                             ;****************************************
d1af :                       df_tk_linenum
                             	; Convert line number to 16 bit number
                             	; Save the line number
                             	; Increment the buffer pointer
d1af : 18               [ 2] 	clc
d1b0 : a900             [ 2] 	lda #lo(df_linbuff)
d1b2 : 65be             [ 3] 	adc df_linoff
d1b4 : aa               [ 2] 	tax
d1b5 : a90a             [ 2] 	lda #hi(df_linbuff)
d1b7 : 6900             [ 2] 	adc #0
d1b9 : a001             [ 2] 	ldy #1			; Decimal format only
d1bb : 201bc9           [ 6] 	jsr con_n_to_a
d1be : 18               [ 2] 	clc
d1bf : 8a               [ 2] 	txa
d1c0 : 65be             [ 3] 	adc df_linoff
d1c2 : 85be             [ 3] 	sta df_linoff
                             	; Now save line number
d1c4 : a585             [ 3] 	lda num_a
d1c6 : 205dce           [ 6] 	jsr df_tk_put_tok
d1c9 : a586             [ 3] 	lda num_a+1
d1cb : 4c5dce           [ 3] 	jmp df_tk_put_tok
                             
                             ;****************************************
                             ;* df_tk_matchtok
                             ;* Try and find a token match against the table d
                             ;* Input:
                             ;*			Current df_linbuff and df_linoff
                             ;* Return: 	CC = No Error, CS = Error
                             ;*			df_linoff points to next char if CC else unc
                             ;*			df_symoff is the symbol table index
                             ;****************************************
d1ce :                       df_tk_matchtok
                             	; save the mask to check types against
d1ce : 48               [ 3] 	pha
                             	; Start at token symbols beginning
d1cf : a950             [ 2] 	lda #lo(df_tokensyms)
d1d1 : 85c3             [ 3] 	sta df_symtab
d1d3 : a9d2             [ 2] 	lda #hi(df_tokensyms)
d1d5 : 85c4             [ 3] 	sta df_symtab+1
d1d7 : a900             [ 2] 	lda #0
d1d9 : 85c5             [ 3] 	sta df_symoff
d1db :                       df_tk_checknexttok
                             	; check this token type first
AS65 Assembler for R6502 [1.42].                                     Page   78
---------------------------------- bank1.s -----------------------------------

d1db : 68               [ 4] 	pla
d1dc : 48               [ 3] 	pha
d1dd : a6c5             [ 3] 	ldx df_symoff
d1df : 3d67d5           [ 4] 	and df_tk_tokentype,x
d1e2 : f032             [ 4] 	beq df_tk_symnomatch
                             	; Special check for operator token
                             	; because of order of precedence fudge
                             	; ******FIX THIS ONE DAY!!!!!!******
                             	; if parm and token type = DFTK_OP then ok
                             	; if parm and token type <> DFTK_OP then not ok
d1e4 : bd67d5           [ 4] 	lda df_tk_tokentype,x
d1e7 : 2908             [ 2] 	and #DFTK_OP
d1e9 : f009             [ 3] 	beq df_tk_matchtok_skip_op
d1eb : 68               [ 4] 	pla
d1ec : 48               [ 3] 	pha
d1ed : 2908             [ 2] 	and #DFTK_OP
d1ef : 3d67d5           [ 4] 	and df_tk_tokentype,x
d1f2 : f022             [ 4] 	beq df_tk_symnomatch
d1f4 :                       df_tk_matchtok_skip_op
                             	; From the line buffer current pointer
                             	; Check for a token match
d1f4 : a4be             [ 3] 	ldy df_linoff
d1f6 : a200             [ 2] 	ldx #0
d1f8 :                       df_tk_checktokch
                             	; Get symtable char
                             	; and mask off MSB
d1f8 : a1c3             [ 6] 	lda (df_symtab,x)
                             	; Save the value and mask off MSB
d1fa : 48               [ 3] 	pha
d1fb : 297f             [ 2] 	and #0x7f
                             	; Compare with current line buffer char
d1fd : d9000a           [ 4] 	cmp df_linbuff,y
                             	; If chars not match then this symbol fails
d200 : d013             [ 3] 	bne df_tk_symnomatchp
                             	; If match and symbol has MSB then
                             	; all of the symbol matched
d202 : 68               [ 4] 	pla
d203 : 3033             [ 3] 	bmi df_tk_symfound
                             	; else more chars to match
                             	; so increment line buffer pointers
                             	_incZPWord df_symtab
                             
d20b : c8               [ 2] 	iny
                             	; If buffer is '.' then let this be a match
d20c : b9000a           [ 4] 	lda df_linbuff,y
d20f : c92e             [ 2] 	cmp #'.'
d211 : f025             [ 3] 	beq df_tk_symfound
d213 : d0e3             [ 4] 	bne df_tk_checktokch	; branch always
d215 :                       df_tk_symnomatchp
d215 : 68               [ 4] 	pla
d216 :                       df_tk_symnomatch
                             	; Increment symbol counter to next symbol
d216 : e6c5             [ 5] 	inc df_symoff
d218 :                       df_tk_symnextentry
d218 : a200             [ 2] 	ldx #0
d21a : a1c3             [ 6] 	lda (df_symtab,x)
                             	; End of symbol is MSB
d21c : 3009             [ 3] 	bmi  df_tk_foundsymend
                             	_incZPWord df_symtab
                             
d224 : 4c18d2           [ 3] 	jmp df_tk_symnextentry
d227 :                       df_tk_foundsymend
AS65 Assembler for R6502 [1.42].                                     Page   79
---------------------------------- bank1.s -----------------------------------

                             	; Increment char to point to new symbol
                             	; for matching with line buffer
                             	_incZPWord df_symtab
                             
                             	; If next char is not zero then
                             	; try and match with line buffer
d22d : a1c3             [ 6] 	lda (df_symtab,x)
d22f : d0aa             [ 4] 	bne df_tk_checknexttok
                             	; else symbol table exhausted
                             	; so no match found
                             	; pop mask off stack
d231 : 68               [ 4] 	pla
                             	; Zero symbol counter
d232 : a900             [ 2] 	lda #0
d234 : 85c5             [ 3] 	sta df_symoff
                             	; Set C to indicate error (no match)
d236 : 38               [ 2] 	sec
d237 : 60               [ 6] 	rts
d238 :                       df_tk_symfound
                             	; Full match with keyword in symtable but
                             	; if matching with something that ended in alpha
                             	; then check the next buffer char is not alphanu
                             	; as this could be part of a variable name
                             	; Point to next buffer char in any case
d238 : c8               [ 2] 	iny
                             	; First mask off MSB
d239 : 297f             [ 2] 	and #0x7f
                             	; Then check if alpha
d23b : 2095ce           [ 6] 	jsr df_tk_isalpha
                             	; if not alpha then we're definitely done
d23e : 9008             [ 3] 	bcc df_tk_symfound_final
                             	; else check buffer
d240 : b9000a           [ 4] 	lda df_linbuff,y
                             	; if it is an alphanum then
d243 : 20a2ce           [ 6] 	jsr df_tk_isalphanum
                             	; do not count as a match
d246 : b0ce             [ 3] 	bcs df_tk_symnomatch
d248 :                       df_tk_symfound_final
                             	; pop mask off stack
d248 : 68               [ 4] 	pla
                             	; Save line buffer pointer (points to next char)
                             	; Clear C to indicate success (match)
d249 : 84be             [ 3] 	sty df_linoff
d24b : a5c5             [ 3] 	lda df_symoff
d24d : aa               [ 2] 	tax
d24e : 18               [ 2] 	clc
d24f : 60               [ 6] 	rts
                             
                             	include "dflat/tksymtab.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  TKSYMTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
AS65 Assembler for R6502 [1.42].                                     Page   80
---------------------------------- bank1.s -----------------------------------

                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Statement Token table
                             ; keywords
d250 :                       df_tokensyms
d250 : 80                    	db	0x80						; Implicit numeric assign
d251 : 80                    	db	0x80						; Implicit call procedure
d252 : bb                    	db	";"+0x80					; Comment
d253 : 7072696e746cee        	db	"printl",'n'+0x80			; println exprlist
d25a : 7072696e7461f4        	db	"printa",'t'+0x80			; printat x,y,exprlist
d261 : 7072696ef4            	db	"prin",'t'+0x80				; print exprlist
d266 : 6465e6                	db	"de",'f'+0x80				; def_subname
d269 : 656e646465e6          	db	"endde",'f'+0x80			; enddef
d26f : 7265747572ee          	db	"retur",'n'+0x80			; return
d275 : 61626f72f4            	db	"abor",'t'+0x80				; abort
d27a : 6c6f6361ec            	db	"loca",'l'+0x80				; local varlist
d27f : 6469ed                	db	"di",'m'+0x80				; dim varlist
d282 : 7265706561f4          	db	"repea",'t'+0x80			; repeat
d288 : 756e7469ec            	db	"unti", 'l'+0x80			; until condition
d28d : 666ff2                	db	"fo",'r'+0x80				; for var=start,end,incremen
d290 : 6e6578f4              	db	"nex",'t'+0x80				; next
d294 : 7768696ce5            	db	"whil",'e'+0x80				; while condition
d299 : 77656ee4              	db	"wen",'d'+0x80				; wend
d29d : 69e6                  	db	"i",'f'+0x80				; if condition
d29f : 656c73e5              	db	"els",'e'+0x80				; else
d2a3 : 656e6469e6            	db	"endi",'f'+0x80				; endif
d2a8 : 656c69e6              	db	"eli",'f'+0x80				; elif condition
d2ac : 646174e1              	db	"dat",'a'+0x80				; data
d2b0 : ff                    	db	0xff						; assembler command (non standard p
d2b1 : 7275ee                	db	"ru",'n'+0x80				; run
d2b4 : 6c6973f4              	db	"lis",'t'+0x80				; list _proc-|*|line,line
d2b8 : 696e7075f4            	db	"inpu",'t'+0x80				; input var
d2bd : 6d6f64e5              	db	"mod",'e'+0x80				; mode n
d2c1 : 706c6ff4              	db	"plo",'t'+0x80				; plot x,y,char|string
d2c5 : 637572736ff2          	db	"curso",'r'+0x80			; cursor n
d2cb : 636cf3                	db	"cl",'s'+0x80				; cls
d2ce : 76706f6be5            	db	"vpok",'e'+0x80				; vpoke addr,val
d2d3 : 7365747664f0          	db	"setvd",'p'+0x80			; setvdp reg,val
d2d9 : 636f6c6f75f2          	db	"colou",'r'+0x80			; colour reg,val
d2df : 73707269746570..      	db	"spritepa",'t'+0x80			; spritepat patnum,arra
d2e8 : 73707269746570..      	db	"spritepo",'s'+0x80			; spritepos sprnum,x,y
d2f1 : 73707269746563..      	db	"spriteco",'l'+0x80			; spritecol sprnum,col
d2fa : 7370726974656e..      	db	"spritenm",'e'+0x80			; spritenme sprnum,patn
d303 : 7370726974e5          	db	"sprit",'e'+0x80			; sprite n,x,y,p,c
d309 : 706f6be5              	db	"pok",'e'+0x80				; poke a,v
d30d : 646f6be5              	db	"dok",'e'+0x80				; doke a,v
d311 : 736f756ee4            	db	"soun",'d'+0x80				; sound
d316 : 6d757369e3            	db	"musi",'c'+0x80				; music
d31b : 706c61f9              	db	"pla",'y'+0x80				; play
d31f : 736176e5              	db	"sav",'e'+0x80				; save
d323 : 6c6f61e4              	db	"loa",'d'+0x80				; load
AS65 Assembler for R6502 [1.42].                                     Page   81
---------------------------------- bank1.s -----------------------------------

d327 : 6469f2                	db	"di",'r'+0x80				; dir (compact listing)
d32a : 646972ec              	db	"dir",'l'+0x80				; dirl (long listing)
d32e : 6465ec                	db 	"de",'l'+0x80				; del
d331 : 726561e4              	db	"rea",'d'+0x80				; read
d335 : 6e65f7                	db	"ne",'w'+0x80				; new
d338 : 72656e75ed            	db	"renu",'m'+0x80				; renum start,offset,incre
d33d : 776169f4              	db	"wai",'t'+0x80				; wait delay
d341 : 72657365f4            	db	"rese",'t'+0x80				; reset var
d346 : 68697265f3            	db	"hire",'s'+0x80				; hires col
d34b : 706f696ef4            	db	"poin",'t'+0x80				; point x,y,mode
d350 : 6c696ee5              	db	"lin",'e'+0x80				; line x0,y0,x1,y1
d354 : 68706c6ff4            	db	"hplo",'t'+0x80				; hplot x,y,char|string
d359 : 7069786d6f64e5        	db	"pixmod",'e'+0x80			; pixmode n
d360 : 7069786d6173eb        	db	"pixmas",'k'+0x80			; pixmask n
d367 : 706978636fec          	db	"pixco",'l'+0x80			; pixcol n
d36d : 626ff8                	db	"bo",'x'+0x80				; box x0,y0,x1,y1
d370 : 636972636ce5          	db	"circl",'e'+0x80			; circle x0,y0,r
d376 : 73686170e5            	db	"shap",'e'+0x80				; shape x,y,coords[]
d37b : 766c6f61e4            	db	"vloa",'d'+0x80				; vload addr,filename
d380 : 626c6f61e4            	db	"bloa",'d'+0x80				; bload mem,hdr,addr,filen
d385 : 62736176e5            	db	"bsav",'e'+0x80				; bsave mem,hdr,addr,len,f
d38a : 68696d65ed            	db	"hime",'m'+0x80				; himem addr
d38f : 6d6f6e69746ff2        	db	"monito",'r'+0x80			; monitor
d396 : 63686469f2            	db	"chdi",'r'+0x80				; chdir fname
d39b : 6d6b6469f2            	db	"mkdi",'r'+0x80				; mkdir fname
d3a0 : 6461746574696de5      	db	"datetim",'e'+0x80			; datetime string output
d3a8 : 6e76706f6be5          	db	"nvpok",'e'+0x80			; NV poke addr,val
d3ae : 666f6ef4              	db	"fon",'t'+0x80				; font <font file>
d3b2 : 6465766963e5          	db	"devic",'e'+0x80			; device <devnum>
d3b8 : 66636c6f73e5          	db	"fclos",'e'+0x80			; fclose
d3be : 72656469ed            	db	"redi",'m'+0x80				; redim varlist
d3c3 : 7075f4                	db  "pu",'t'+0x80				; put byte 
d3c6 : 70746c6f61e4          	db	"ptloa",'d'+0x80			; ptload addr,filename
d3cc : 7074696e69f4          	db	"ptini",'t'+0x80			; ptinit addr 
d3d2 : 70747275ee            	db	"ptru",'n'+0x80				; ptrun flag 
                             ; Functions
d3d7 : 767065656ba8          	db	"vpeek",'('+0x80			; vpeek(x)
d3dd : 7065656ba8            	db	"peek",'('+0x80				; peek(x)
d3e2 : 6465656ba8            	db	"deek",'('+0x80				; deek(x)
d3e7 : 737469636ba8          	db	"stick",'('+0x80			; stick(x)
d3ed : 6b6579a8              	db	"key",'('+0x80				; key(x)
d3f1 : 636872a8              	db	"chr",'('+0x80				; chr(x)
d3f5 : 6c656674a8            	db	"left",'('+0x80				; left(x$,y)
d3fa : 7269676874a8          	db	"right",'('+0x80			; right(x$,y)
d400 : 6d6964a8              	db	"mid",'('+0x80				; mid(x$,y)
d404 : 6c656ea8              	db	"len",'('+0x80				; len(x$)
d408 : 6d656da8              	db	"mem",'('+0x80				; mem(x)
d40c : 7363726ea8            	db	"scrn",'('+0x80				; scrn(x,y)
d411 : 726e64a8              	db	"rnd",'('+0x80				; rnd(x)
d415 : 656c6170736564a8      	db	"elapsed",'('+0x80			; elapsed(var)
d41d : 63616c6ca8            	db	"call",'('+0x80				; call(addr,A,X,Y)
d422 : 686578a8              	db	"hex",'('+0x80				; hex(x)
d426 : 646563a8              	db	"dec","("+0x80				; dec(x)
d42a : 617363a8              	db	"asc",'('+0x80				; asc(x$)
d42e : 76616ca8              	db	"val",'('+0x80				; val(x$)
d432 : 706978656ca8          	db	"pixel",'('+0x80			; pixel(x,y)
d438 : 73676ea8              	db	"sgn",'('+0x80				; sgn(x)
d43c : 61646472a8            	db	"addr",'('+0x80				; addr(var)
d441 : 6e767065656ba8        	db  "nvpeek",'('+0x80			; nvpeek(addr)
d448 : 66637265617465a8      	db	"fcreate",'('+0x80			; success=fcreate(filena
d450 : 666f70656ea8          	db	"fopen",'('+0x80			; success=fopen(filename)
d456 : 676574a8              	db	"get",'('+0x80				; alias for key()
AS65 Assembler for R6502 [1.42].                                     Page   82
---------------------------------- bank1.s -----------------------------------

                             ; Numeric operators, in priority
d45a : aa                    	db	'*'+0x80					; Multiply
d45b : af                    	db 	'/'+0x80					; Divide
d45c : dc                    	db 	'\\'+0x80					; Modulus
d45d : 3cbc                  	db	'<','<'+0x80				; Shift left
d45f : 3ebe                  	db	'>','>'+0x80				; Shift right
d461 : ab                    	db 	'+'+0x80					; Add
d462 : ad                    	db	'-'+0x80					; Subtract
                             ; Bool and conditional operators, in priority
d463 : a6                    	db '&'+0x80						; AND
d464 : fc                    	db '|'+0x80						; OR
d465 : de                    	db '^'+0x80						; EOR
d466 : 3cbd                  	db "<",'='+0x80					; Less than or equal
d468 : 3ebd                  	db ">",'='+0x80					; Greater than or equal
d46a : 3cbe                  	db "<",'>'+0x80					; Not equal
d46c : bc                    	db '<'+0x80						; Less than
d46d : be                    	db '>'+0x80						; Greater than
d46e : 3dbd                  	db "=",'='+0x80					; Equality (always last)
                             
d470 : 00                    	db  0
                             
                             
                             	
                             	
                             	include "dflat/tkjmptab.s"
                             ;************************************************
                             ;*
                             ;*	DOLO-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  full credit of my authorship please!
                             ;*
                             ;*  TKJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; In token order of df_tokensyms
d471 :                       df_tk_tokenjmp
d471 : 0cd6                  	dw	df_tk_assign
d473 : e1d6                  	dw	df_tk_callproc
d475 : 14d6                  	dw	df_tk_comment
d477 : 71d6                  	dw	df_tk_println
d479 : 65d6                  	dw	df_tk_printat
d47b : 71d6                  	dw	df_tk_print
d47d : b9d6                  	dw	df_tk_def
d47f : 21d7                  	dw	df_tk_enddef
AS65 Assembler for R6502 [1.42].                                     Page   83
---------------------------------- bank1.s -----------------------------------

d481 : 23d7                  	dw	df_tk_return
d483 : 21d7                  	dw	df_tk_abort
d485 : a7d6                  	dw	df_tk_local
d487 : 98d6                  	dw	df_tk_dim
d489 : 21d7                  	dw	df_tk_repeat
d48b : 26d7                  	dw	df_tk_until
d48d : bfd6                  	dw	df_tk_for
d48f : 21d7                  	dw	df_tk_next
d491 : 26d7                  	dw	df_tk_while
d493 : 21d7                  	dw	df_tk_wend
d495 : 26d7                  	dw	df_tk_if
d497 : 21d7                  	dw	df_tk_else
d499 : 21d7                  	dw	df_tk_endif
d49b : 26d7                  	dw	df_tk_elseif
d49d : 71d6                  	dw	df_tk_data
d49f : 97f4                  	dw	df_trap_monitor
d4a1 : 21d7                  	dw	df_tk_run
d4a3 : 43d6                  	dw	df_tk_list
d4a5 : 7fd6                  	dw	df_tk_input
d4a7 : 26d7                  	dw	df_tk_mode
d4a9 : 36d7                  	dw	df_tk_plot
d4ab : 26d7                  	dw	df_tk_cursor
d4ad : 21d7                  	dw	df_tk_cls
d4af : 2ad7                  	dw	df_tk_vpoke
d4b1 : 2ad7                  	dw	df_tk_setvdp
d4b3 : 36d7                  	dw	df_tk_colour
d4b5 : 2ad7                  	dw	df_tk_spritepat
d4b7 : 36d7                  	dw	df_tk_spritepos
d4b9 : 2ad7                  	dw	df_tk_spritecol
d4bb : 2ad7                  	dw	df_tk_spritenme
d4bd : 4ed7                  	dw	df_tk_sprite
d4bf : 2ad7                  	dw	df_tk_poke
d4c1 : 2ad7                  	dw	df_tk_doke
d4c3 : 36d7                  	dw	df_tk_sound
d4c5 : 42d7                  	dw	df_tk_music
d4c7 : 42d7                  	dw	df_tk_play
d4c9 : 26d7                  	dw	df_tk_save
d4cb : 26d7                  	dw	df_tk_load
d4cd : 21d7                  	dw	df_tk_dir
d4cf : 21d7                  	dw	df_tk_dirl
d4d1 : 26d7                  	dw	df_tk_del
d4d3 : 89d6                  	dw	df_tk_read
d4d5 : 21d7                  	dw	df_tk_new
d4d7 : 36d7                  	dw	df_tk_renum
d4d9 : 26d7                  	dw	df_tk_wait
d4db : e3d6                  	dw	df_tk_reset
d4dd : 26d7                  	dw	df_tk_hires
d4df : 2ad7                  	dw	df_tk_point
d4e1 : 42d7                  	dw	df_tk_line
d4e3 : 36d7                  	dw	df_tk_hplot
d4e5 : 26d7                  	dw	df_tk_pixmode
d4e7 : 26d7                  	dw	df_tk_pixmask
d4e9 : 26d7                  	dw	df_tk_pixcol
d4eb : 42d7                  	dw	df_tk_box
d4ed : 36d7                  	dw	df_tk_circle
d4ef : 36d7                  	dw	df_tk_shape
d4f1 : 2ad7                  	dw	df_tk_vload
d4f3 : 42d7                  	dw	df_tk_bload
d4f5 : 4ed7                  	dw	df_tk_bsave
d4f7 : 26d7                  	dw	df_tk_himem
d4f9 : 21d7                  	dw	df_tk_monitor
d4fb : 26d7                  	dw	df_tk_chdir
AS65 Assembler for R6502 [1.42].                                     Page   84
---------------------------------- bank1.s -----------------------------------

d4fd : 26d7                  	dw	df_tk_mkdir
d4ff : ecd6                  	dw	df_tk_datetime
d501 : 2ad7                  	dw	df_tk_nvpoke
d503 : 26d7                  	dw	df_tk_font
d505 : 26d7                  	dw	df_tk_device
d507 : 21d7                  	dw	df_tk_fclose
d509 : 98d6                  	dw	df_tk_redim
d50b : 26d7                  	dw  df_tk_put
d50d : 2ad7                  	dw	df_tk_ptload
d50f : 26d7                  	dw	df_tk_ptinit
d511 : 26d7                  	dw	df_tk_ptrun
                             
d513 : f5d6                  	dw	df_tk_vpeek
d515 : f5d6                  	dw	df_tk_peek
d517 : f5d6                  	dw	df_tk_deek
d519 : f5d6                  	dw	df_tk_stick
d51b : f5d6                  	dw	df_tk_key
d51d : f5d6                  	dw	df_tk_chr
d51f : 07d7                  	dw	df_tk_left
d521 : 07d7                  	dw	df_tk_right
d523 : 0dd7                  	dw	df_tk_mid
d525 : f5d6                  	dw	df_tk_len
d527 : f5d6                  	dw	df_tk_mem
d529 : 07d7                  	dw	df_tk_scrn
d52b : f5d6                  	dw	df_tk_rnd
d52d : fed6                  	dw	df_tk_elapsed
d52f : 13d7                  	dw	df_tk_call
d531 : f5d6                  	dw	df_tk_hex
d533 : f5d6                  	dw	df_tk_dec
d535 : f5d6                  	dw	df_tk_asc
d537 : f5d6                  	dw	df_tk_val
d539 : 07d7                  	dw	df_tk_pixel
d53b : f5d6                  	dw	df_tk_sgn
d53d : fed6                  	dw	df_tk_addr
d53f : f5d6                  	dw	df_tk_nvpeek
d541 : f5d6                  	dw	df_tk_fcreate
d543 : f5d6                  	dw	df_tk_fopen
d545 : f5d6                  	dw  df_tk_get
                             	
d547 : 21d7                  	dw	df_tk_mult
d549 : 21d7                  	dw	df_tk_div
d54b : 21d7                  	dw	df_tk_mod
d54d : 21d7                  	dw	df_tk_asl
d54f : 21d7                  	dw	df_tk_lsr
d551 : 21d7                  	dw	df_tk_add
d553 : 21d7                  	dw	df_tk_sub
                             	
d555 : 21d7                  	dw	df_tk_and
d557 : 21d7                  	dw	df_tk_or
d559 : 21d7                  	dw	df_tk_eor
d55b : 21d7                  	dw	df_tk_lte
d55d : 21d7                  	dw	df_tk_gte
d55f : 21d7                  	dw	df_tk_ne
d561 : 21d7                  	dw	df_tk_lt
d563 : 21d7                  	dw	df_tk_gt
d565 : 21d7                  	dw	df_tk_eq
                             
                             	
                             	
                             	
                             	
                             	
AS65 Assembler for R6502 [1.42].                                     Page   85
---------------------------------- bank1.s -----------------------------------

                             	include "dflat/tktyptab.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser type table (is it a keyword, function
                             ; In token order of df_tokensyms
d567 :                       df_tk_tokentype
d567 : 01                    	db	DFTK_KW
d568 : 01                    	db	DFTK_KW
d569 : 01                    	db	DFTK_KW
d56a : 01                    	db	DFTK_KW
d56b : 01                    	db	DFTK_KW
d56c : 01                    	db	DFTK_KW
d56d : 01                    	db	DFTK_KW
d56e : 01                    	db	DFTK_KW
d56f : 01                    	db	DFTK_KW
d570 : 01                    	db	DFTK_KW
d571 : 01                    	db	DFTK_KW
d572 : 01                    	db	DFTK_KW
d573 : 01                    	db	DFTK_KW
d574 : 01                    	db	DFTK_KW
d575 : 01                    	db	DFTK_KW
d576 : 01                    	db	DFTK_KW
d577 : 01                    	db	DFTK_KW
d578 : 01                    	db	DFTK_KW
d579 : 01                    	db	DFTK_KW
d57a : 01                    	db	DFTK_KW
d57b : 01                    	db	DFTK_KW
d57c : 01                    	db	DFTK_KW
d57d : 01                    	db	DFTK_KW
d57e : 01                    	db	DFTK_KW
d57f : 01                    	db	DFTK_KW
d580 : 01                    	db	DFTK_KW
d581 : 01                    	db	DFTK_KW
d582 : 01                    	db	DFTK_KW
d583 : 01                    	db	DFTK_KW
d584 : 01                    	db	DFTK_KW
d585 : 01                    	db	DFTK_KW
d586 : 01                    	db	DFTK_KW
AS65 Assembler for R6502 [1.42].                                     Page   86
---------------------------------- bank1.s -----------------------------------

d587 : 01                    	db	DFTK_KW
d588 : 01                    	db	DFTK_KW
d589 : 01                    	db	DFTK_KW
d58a : 01                    	db	DFTK_KW
d58b : 01                    	db	DFTK_KW
d58c : 01                    	db	DFTK_KW
d58d : 01                    	db	DFTK_KW
d58e : 01                    	db	DFTK_KW
d58f : 01                    	db	DFTK_KW
d590 : 01                    	db	DFTK_KW
d591 : 01                    	db	DFTK_KW
d592 : 01                    	db	DFTK_KW
d593 : 01                    	db	DFTK_KW
d594 : 01                    	db	DFTK_KW
d595 : 01                    	db	DFTK_KW
d596 : 01                    	db	DFTK_KW
d597 : 01                    	db	DFTK_KW
d598 : 01                    	db	DFTK_KW
d599 : 01                    	db	DFTK_KW
d59a : 01                    	db	DFTK_KW
d59b : 01                    	db	DFTK_KW
d59c : 01                    	db	DFTK_KW
d59d : 01                    	db	DFTK_KW
d59e : 01                    	db	DFTK_KW
d59f : 01                    	db	DFTK_KW
d5a0 : 01                    	db	DFTK_KW
d5a1 : 01                    	db	DFTK_KW
d5a2 : 01                    	db	DFTK_KW
d5a3 : 01                    	db	DFTK_KW
d5a4 : 01                    	db	DFTK_KW
d5a5 : 01                    	db	DFTK_KW
d5a6 : 01                    	db	DFTK_KW
d5a7 : 01                    	db	DFTK_KW
d5a8 : 01                    	db	DFTK_KW
d5a9 : 01                    	db	DFTK_KW
d5aa : 01                    	db	DFTK_KW
d5ab : 01                    	db	DFTK_KW
d5ac : 01                    	db	DFTK_KW
d5ad : 01                    	db	DFTK_KW
d5ae : 01                    	db	DFTK_KW
d5af : 01                    	db	DFTK_KW
d5b0 : 01                    	db	DFTK_KW
d5b1 : 01                    	db	DFTK_KW
d5b2 : 01                    	db	DFTK_KW
d5b3 : 01                    	db	DFTK_KW
d5b4 : 01                    	db	DFTK_KW
d5b5 : 01                    	db	DFTK_KW
d5b6 : 01                    	db	DFTK_KW
d5b7 : 01                    	db	DFTK_KW
                             
d5b8 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5b9 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5ba : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5bb : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5bc : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5bd : 42                    	db 	DFTK_FN | DFTK_STR
d5be : 42                    	db 	DFTK_FN | DFTK_STR
d5bf : 42                    	db 	DFTK_FN | DFTK_STR
d5c0 : 42                    	db 	DFTK_FN | DFTK_STR
d5c1 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5c2 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5c3 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
AS65 Assembler for R6502 [1.42].                                     Page   87
---------------------------------- bank1.s -----------------------------------

d5c4 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5c5 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5c6 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5c7 : 42                    	db 	DFTK_FN | DFTK_STR
d5c8 : 42                    	db 	DFTK_FN | DFTK_STR
d5c9 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5ca : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5cb : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5cc : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5cd : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5ce : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5cf : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5d0 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d5d1 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
                             	;* Operators add the order of precedence (0=high
d5d2 : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
d5d3 : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
d5d4 : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
d5d5 : 39                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
d5d6 : 39                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
d5d7 : 3e                    	db 	DFTK_OP | DFTK_STROP | DFTK_INT | DFTK_BYT +
d5d8 : 3a                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 2
                             
d5d9 : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
d5da : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
d5db : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
d5dc : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
d5dd : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
d5de : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
d5df : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
d5e0 : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
d5e1 : 3f                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 7
                             
                             
                             	
                             	
                             	
                             	
                             
                             	include "dflat/toksubs.s"
                             ;************************************************
                             ;*
                             ;*	DOLO-1 HOMEBREW COMPUTER
                             ;*	Hardware and software design by Dolo Miah
                             ;*	Copyright 2014-18
                             ;*  Free to use for any non-commercial purpose su
                             ;*  full credit of original my authorship please!
                             ;*
                             ;*  TOKSUBS.S
                             ;*  Module that implements the tokenisation of ke
                             ;*  When a line is being parsed, the index of the
                             ;*  found in the symbol table is used to call a r
                             ;*  here.  The job of a routine here is then to f
                             ;*  parse the raw input e.g. a command that takes
                             ;*  parameters, need to do what it needs to ident
                             ;*  Despite the number of keywords in dflat, this
                             ;*  anywhere near the size of rtsubs.s (the runti
                             ;*  equivalent of this) because there is so much 
                             ;*  synactically.
                             ;*  The tokenised output is put in to its own buf
                             ;*  if the whole input was tokenised successfully
                             ;*  dflat will either try and execute (if in imme
AS65 Assembler for R6502 [1.42].                                     Page   88
---------------------------------- bank1.s -----------------------------------

                             ;*  mode), or save it to program memory in line n
                             ;*  order.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             
                             ;* General routine to tokenise a mandatory variab
d5e2 :                       df_tk_variable
d5e2 : 20aece           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
d5e5 : 204cce           [ 6] 	jsr df_tk_peek_buf
d5e8 : 2095ce           [ 6] 	jsr df_tk_isalpha
d5eb : 901d             [ 4] 	bcc df_tk_error
d5ed : a900             [ 2] 	lda #0
d5ef : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Parse assignment preamble
                             ;****************************************
d5f0 :                       df_tk_preassign
                             	; Put assignment token
                             	; assume its a numeric int for now
d5f0 : a980             [ 2] 	lda #0x80
d5f2 : 205dce           [ 6] 	jsr df_tk_put_tok
                             	
                             	; first find or create a variable
d5f5 : 20e2d5           [ 6] 	jsr df_tk_variable
d5f8 : 2094cf           [ 6] 	jsr df_tk_var
                             	; next char sound be =
d5fb : a93d             [ 2] 	lda #'='
d5fd : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
                             	; skip more ws
d600 : 20aece           [ 6] 	jsr df_tk_skip_ws
                             	; should not be at end of line
d603 : 204cce           [ 6] 	jsr df_tk_peek_buf
d606 : f002             [ 3] 	beq df_tk_parse_ass_err
d608 : 18               [ 2] 	clc
d609 : 60               [ 6] 	rts
d60a :                       df_tk_parse_ass_err
d60a :                       df_tk_error
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse numeric assignment
                             ;****************************************
d60c :                       df_tk_assign
d60c : 20f0d5           [ 6] 	jsr df_tk_preassign
                             	; tokenise an expression (int or byte)
d60f : 20dbd0           [ 6] 	jsr df_tk_expression
d612 : 18               [ 2] 	clc
d613 : 60               [ 6] 	rts
                             
                             
d614 :                       df_tk_comment
                             	; copy all subsequent chars to token
d614 : 2052ce           [ 6] 	jsr df_tk_get_buf
d617 : f005             [ 3] 	beq df_tk_comment_done
d619 : 205dce           [ 6] 	jsr df_tk_put_tok
AS65 Assembler for R6502 [1.42].                                     Page   89
---------------------------------- bank1.s -----------------------------------

d61c : 80f6             [ 3] 	bra df_tk_comment
d61e :                       df_tk_comment_done
d61e : 18               [ 2] 	clc
d61f : 60               [ 6] 	rts
                             
                             ; Utility to get procedure name with _
d620 :                       df_tk_listp_procname
                             	; try and find the first proc
d620 : a95f             [ 2] 	lda #'_'
d622 : 20dece           [ 6] 	jsr df_tk_expect_tok
d625 : b01a             [ 3] 	bcs df_tk_listp_procname_err
                             	; now get first alpha then all alphanum
d627 : 204cce           [ 6] 	jsr df_tk_peek_buf
d62a : 2095ce           [ 6] 	jsr df_tk_isalpha
d62d : 9012             [ 3] 	bcc df_tk_listp_procname_err
d62f :                       df_tk_listp_procname_ch
d62f : 204cce           [ 6] 	jsr df_tk_peek_buf
d632 : 20a2ce           [ 6] 	jsr df_tk_isalphanum
d635 : 9008             [ 3] 	bcc df_tk_listp_procname_ok
d637 : 2052ce           [ 6] 	jsr df_tk_get_buf
d63a : 205dce           [ 6] 	jsr df_tk_put_tok
d63d : 80f0             [ 3] 	bra df_tk_listp_procname_ch
d63f :                       df_tk_listp_procname_ok
d63f : 18               [ 2] 	clc
d640 : 60               [ 6] 	rts
d641 :                       df_tk_listp_procname_err
d641 : 38               [ 2] 	sec
d642 : 60               [ 6] 	rts
                             
d643 :                       df_tk_list
d643 : 2020d6           [ 6] 	jsr df_tk_listp_procname
                             	; if not found try '*' or normal list
d646 : b007             [ 3] 	bcs df_tk_list_procs
                             	; the '-' allows to list to end
d648 : a92d             [ 2] 	lda #'-'
                             	; find and add if it exists
d64a : 20dece           [ 6] 	jsr df_tk_expect_tok
d64d : 8014             [ 3] 	bra df_tk_list_done
                             	; '*' means list procs
d64f :                       df_tk_list_procs
                             	; try and find the first proc
d64f : a92a             [ 2] 	lda #'*'
d651 : 20dece           [ 6] 	jsr df_tk_expect_tok
d654 : 900d             [ 3] 	bcc df_tk_list_done
                             	; else normal line number
d656 :                       df_tk_list_line
                             	; tokenise an expression
d656 : 20dbd0           [ 6] 	jsr df_tk_expression
                             	; if not at the end then keep going
d659 : a92c             [ 2] 	lda #','
d65b : 20dece           [ 6] 	jsr df_tk_expect_tok
d65e : b003             [ 3] 	bcs df_tk_list_done
                             	; else get the next expression
d660 : 20dbd0           [ 6] 	jsr df_tk_expression	
d663 :                       df_tk_list_done
d663 : 18               [ 2] 	clc
d664 : 60               [ 6] 	rts
                             
d665 :                       df_tk_printat
                             	; Must get 2 parms for x,y
d665 : 202ad7           [ 6] 	jsr df_tk_2parms
                             	; if not at the end then keep going
AS65 Assembler for R6502 [1.42].                                     Page   90
---------------------------------- bank1.s -----------------------------------

d668 : a92c             [ 2] 	lda #','
d66a : 20dece           [ 6] 	jsr df_tk_expect_tok
d66d : 9002             [ 3] 	bcc df_tk_print
                             	; else done
d66f : 18               [ 2] 	clc
d670 : 60               [ 6] 	rts
d671 :                       df_tk_data
d671 :                       df_tk_println
d671 :                       df_tk_print
d671 :                       df_tk_asm_db
d671 :                       df_tk_asm_dw
                             	; tokenise an expression
d671 : 20dbd0           [ 6] 	jsr df_tk_expression
                             	; is there more to come?
d674 : a92c             [ 2] 	lda #','
d676 : 20dece           [ 6] 	jsr df_tk_expect_tok
d679 : b002             [ 3] 	bcs df_tk_print_done
d67b : 80f4             [ 3] 	bra df_tk_print
d67d :                       df_tk_print_done
d67d : 18               [ 2] 	clc
d67e : 60               [ 6] 	rts
                             
d67f :                       df_tk_input
d67f : 20aece           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
d682 : 20e2d5           [ 6] 	jsr df_tk_variable
d685 : 2094cf           [ 6] 	jsr df_tk_var
                             	; either cc or cs depending on error condition
d688 : 60               [ 6] 	rts
                             	
d689 :                       df_tk_read
                             	; tokenise a variable
d689 : 20e2d5           [ 6] 	jsr df_tk_variable
d68c : 2094cf           [ 6] 	jsr df_tk_var
                             	; if not at the end then keep going
d68f : a92c             [ 2] 	lda #','
d691 : 20dece           [ 6] 	jsr df_tk_expect_tok
d694 : 90f3             [ 3] 	bcc df_tk_read
d696 : 18               [ 2] 	clc
d697 : 60               [ 6] 	rts
                             
d698 :                       df_tk_dim
d698 :                       df_tk_redim
                             	; tokenise a variable
d698 : 20e2d5           [ 6] 	jsr df_tk_variable
d69b : 20dccf           [ 6] 	jsr df_tk_arrvar
                             	; if not at the end then keep going
d69e : a92c             [ 2] 	lda #','
d6a0 : 20dece           [ 6] 	jsr df_tk_expect_tok
d6a3 : 90f3             [ 3] 	bcc df_tk_dim
d6a5 : 18               [ 2] 	clc
d6a6 : 60               [ 6] 	rts
                             
d6a7 :                       df_tk_local
d6a7 : 20aece           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
d6aa : 20e2d5           [ 6] 	jsr df_tk_variable
d6ad : 20c6cf           [ 6] 	jsr df_tk_localvar
                             	; if not at the end then keep going
d6b0 : a92c             [ 2] 	lda #','
d6b2 : 20dece           [ 6] 	jsr df_tk_expect_tok
d6b5 : 90f0             [ 3] 	bcc df_tk_local
AS65 Assembler for R6502 [1.42].                                     Page   91
---------------------------------- bank1.s -----------------------------------

d6b7 : 18               [ 2] 	clc
d6b8 : 60               [ 6] 	rts
                             
                             ; A = 0 : Def
                             ; A = 1 : Call
d6b9 :                       df_tk_def
d6b9 : a900             [ 2] 	lda #0
d6bb : 20e7cf           [ 6] 	jsr df_tk_proc
d6be : 60               [ 6] 	rts
                             
                             
                             ; syntax : for %a=1,10,1
d6bf :                       df_tk_for
d6bf : 20aece           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise the for variable
d6c2 : a901             [ 2] 	lda #DFVVT_INT
d6c4 : 2094cf           [ 6] 	jsr df_tk_var
                             
                             	; always expect '='
d6c7 : a93d             [ 2] 	lda #'='
d6c9 : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
                             
                             	; starting value
d6cc : 20dbd0           [ 6] 	jsr df_tk_expression
                             	
                             	; always expect ',' separator
d6cf : a92c             [ 2] 	lda #','
d6d1 : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
                             
                             	; ending value
d6d4 : 20dbd0           [ 6] 	jsr df_tk_expression
                             	
                             	; always expect ',' separator
d6d7 : a92c             [ 2] 	lda #','
d6d9 : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
                             	
                             	; step value
d6dc : 20dbd0           [ 6] 	jsr df_tk_expression
d6df :                       df_tk_for_done
d6df : 18               [ 2] 	clc
d6e0 : 60               [ 6] 	rts
                             	
                             ; call to proc should not occur by itself
d6e1 :                       df_tk_callproc
d6e1 : 38               [ 2] 	sec
d6e2 : 60               [ 6] 	rts
                             
                             ; timer reset expects an int variable only
d6e3 :                       df_tk_reset
d6e3 : 20aece           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise a variable
d6e6 : a901             [ 2] 	lda #DFVVT_INT
d6e8 : 2094cf           [ 6] 	jsr df_tk_var
d6eb : 60               [ 6] 	rts
                             
                             ; date time expects a string variable only
d6ec :                       df_tk_datetime
d6ec : 20aece           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise a variable
AS65 Assembler for R6502 [1.42].                                     Page   92
---------------------------------- bank1.s -----------------------------------

d6ef : a904             [ 2] 	lda #DFVVT_STR
d6f1 : 2094cf           [ 6] 	jsr df_tk_var
d6f4 : 60               [ 6] 	rts
                             
                             ; These functions expect 1 parmeter
d6f5 :                       df_tk_len
d6f5 :                       df_tk_chr
d6f5 :                       df_tk_key
d6f5 :                       df_tk_get
d6f5 :                       df_tk_stick
d6f5 :                       df_tk_deek
d6f5 :                       df_tk_vpeek
d6f5 :                       df_tk_peek
d6f5 :                       df_tk_nvpeek
d6f5 :                       df_tk_mem
d6f5 :                       df_tk_rnd
d6f5 :                       df_tk_hex
d6f5 :                       df_tk_dec
d6f5 :                       df_tk_asc
d6f5 :                       df_tk_val
d6f5 :                       df_tk_sgn
d6f5 :                       df_tk_fcreate
d6f5 :                       df_tk_fopen
d6f5 : 20dbd0           [ 6] 	jsr df_tk_expression
d6f8 :                       df_tk_closebrkt
d6f8 : a929             [ 2] 	lda #')'
d6fa : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
d6fd : 60               [ 6] 	rts
                             
                             ; This function expects a variable only
d6fe :                       df_tk_addr
d6fe :                       df_tk_elapsed
d6fe : 20e2d5           [ 6] 	jsr df_tk_variable
d701 : 2094cf           [ 6] 	jsr df_tk_var
                             	; must have close braket
d704 : 4cf8d6           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 2 parameters
d707 :                       df_tk_left
d707 :                       df_tk_right
d707 :                       df_tk_scrn
d707 :                       df_tk_pixel
d707 : 202ad7           [ 6] 	jsr df_tk_2parms
d70a : 4cf8d6           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 3 parameters
d70d :                       df_tk_mid
d70d : 2036d7           [ 6] 	jsr df_tk_3parms
d710 : 4cf8d6           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 4 parameters
d713 :                       df_tk_call
d713 : 202ad7           [ 6] 	jsr df_tk_2parms
d716 : a92c             [ 2] 	lda #','
d718 : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
d71b : 202ad7           [ 6] 	jsr df_tk_2parms
d71e : 4cf8d6           [ 3] 	jmp df_tk_closebrkt
                             
                             ;all these commands require no parameters
d721 :                       df_tk_else
d721 :                       df_tk_endif
d721 :                       df_tk_enddef
AS65 Assembler for R6502 [1.42].                                     Page   93
---------------------------------- bank1.s -----------------------------------

d721 :                       df_tk_abort
d721 :                       df_tk_repeat
d721 :                       df_tk_next
d721 :                       df_tk_wend
d721 :                       df_tk_run
d721 :                       df_tk_add
d721 :                       df_tk_sadd
d721 :                       df_tk_dir
d721 :                       df_tk_dirl
d721 :                       df_tk_cls
d721 :                       df_tk_new
d721 :                       df_tk_mult
d721 :                       df_tk_div
d721 :                       df_tk_mod
d721 :                       df_tk_asl
d721 :                       df_tk_lsr
d721 :                       df_tk_sub
d721 :                       df_tk_and
d721 :                       df_tk_or
d721 :                       df_tk_eor
d721 :                       df_tk_lte
d721 :                       df_tk_lt
d721 :                       df_tk_gte
d721 :                       df_tk_gt
d721 :                       df_tk_ne
d721 :                       df_tk_eq
d721 :                       df_tk_monitor
d721 :                       df_tk_fclose
                             ;df_tk_retsub
d721 : 18               [ 2] 	clc
d722 : 60               [ 6] 	rts
                             
                             ; 0 or 1 parameter special!
d723 :                       df_tk_return
d723 : 4cdbd0           [ 3] 	jmp df_tk_expression
                             
                             ; These commands expect 1 parameter	
d726 :                       df_tk_while
d726 :                       df_tk_until
d726 :                       df_tk_if
d726 :                       df_tk_elseif
d726 :                       df_tk_wait
d726 :                       df_tk_cursor
d726 :                       df_tk_mode
d726 :                       df_tk_del
d726 :                       df_tk_chdir
d726 :                       df_tk_mkdir
d726 :                       df_tk_hires
d726 :                       df_tk_load
d726 :                       df_tk_save
d726 :                       df_tk_pixmode
d726 :                       df_tk_pixmask
d726 :                       df_tk_pixcol
d726 :                       df_tk_put
d726 :                       df_tk_himem
d726 :                       df_tk_font
d726 :                       df_tk_device
d726 :                       df_tk_ptinit
d726 :                       df_tk_ptrun
                             ;df_tk_goto
                             ;df_tk_gosub
                             
AS65 Assembler for R6502 [1.42].                                     Page   94
---------------------------------- bank1.s -----------------------------------

d726 :                       df_tk_asm_org
d726 :                       df_tk_asm_opt
d726 :                       df_tk_asm_ds
                             
                             	; first parm
d726 : 20dbd0           [ 6] 	jsr df_tk_expression
d729 : 60               [ 6] 	rts
                             
                             ; These commands expect 2 numeric parameters
d72a :                       df_tk_setvdp
d72a :                       df_tk_spritepat
d72a :                       df_tk_spritecol
d72a :                       df_tk_spritenme
d72a :                       df_tk_vpoke
d72a :                       df_tk_poke
d72a :                       df_tk_doke
d72a :                       df_tk_nvpoke
d72a :                       df_tk_point
d72a :                       df_tk_vload
d72a :                       df_tk_ptload
d72a :                       df_tk_2parms
                             	; first parm
d72a : 20dbd0           [ 6] 	jsr df_tk_expression
d72d : a92c             [ 2] 	lda #','
d72f : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
                             	; tokenise second parm
d732 : 20dbd0           [ 6] 	jsr df_tk_expression
d735 : 60               [ 6] 	rts
                             
                             ; these commands expect 3 numeric parameters
d736 :                       df_tk_hplot
d736 :                       df_tk_plot
d736 :                       df_tk_circle
d736 :                       df_tk_sound
d736 :                       df_tk_colour
d736 :                       df_tk_spritepos
d736 :                       df_tk_shape
d736 :                       df_tk_renum
d736 :                       df_tk_3parms
d736 : 202ad7           [ 6] 	jsr df_tk_2parms
d739 : a92c             [ 2] 	lda #','
d73b : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
                             	; tokenise third parm
d73e : 20dbd0           [ 6] 	jsr df_tk_expression
d741 : 60               [ 6] 	rts
                             
                             ; these commands expect 4 numeric parameters
d742 :                       df_tk_play
d742 :                       df_tk_music
d742 :                       df_tk_line
d742 :                       df_tk_box
d742 :                       df_tk_bload
d742 :                       df_tk_4parms
d742 : 202ad7           [ 6] 	jsr df_tk_2parms
d745 : a92c             [ 2] 	lda #','
d747 : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
d74a : 202ad7           [ 6] 	jsr df_tk_2parms
d74d : 60               [ 6] 	rts
                             
                             ; these commands expect 5 numeric parameters
d74e :                       df_tk_sprite
d74e :                       df_tk_bsave
AS65 Assembler for R6502 [1.42].                                     Page   95
---------------------------------- bank1.s -----------------------------------

d74e :                       df_tk_5parms
d74e : 2042d7           [ 6] 	jsr df_tk_4parms
d751 : a92c             [ 2] 	lda #','
d753 : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
d756 : 20dbd0           [ 6] 	jsr df_tk_expression
d759 : 60               [ 6] 	rts
                             
                             
                             
d75a :                       mod_sz_tokenise_e
                             
                             
                             
                             	include "dflat/progedit.s"
                             ;************************************************
                             ;*
                             ;*	BBC128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  PROGEDIT.S
                             ;*  dflat module to enable editing of a dflat pro
                             ;*  dflat bascially starts here - waiting for use
                             ;*  when a line is entered, if it is not preceede
                             ;*  line number it is tokenised and attempted to 
                             ;*  immediatly.  If it is preceeded by a line num
                             ;*  number is used to save the tokenised line in 
                             ;*  position in memory.
                             ;*  So this is just like a good old editing sessi
                             ;*  nearly any common flavour of 80s basic. Howev
                             ;*  tokenises everything except whitespace and st
                             ;*  constants - even when saving.  Unlike my trus
                             ;*  where I could type in any garbage and it woul
                             ;*  saved with the line number, dflat needs to be
                             ;*  tokenise the line.  So it's actually a bit mo
                             ;*  Atari 8 bit BASIC.
                             ;*
                             ;************************************************
                             
d75a :                       mod_sz_progedit_s
                             
                             ;****************************************
                             ;* df_pg_find_line
                             ;* Find a line number in X(L), A(H)
                             ;* Return X(L), A(H) of line, Y = Length
                             ;* C=1 Exact match not found, C=0 Exact Found
                             ;* If not exact match then next highest line addr
                             ;* Will be in X and A
                             ;****************************************
d75a :                       df_pg_find_line
d75a : a4a7             [ 3] 	ldy df_prgstrt		; num_tmp contains starting poin
d75c : 8491             [ 3] 	sty num_tmp
d75e : a4a8             [ 3] 	ldy df_prgstrt+1
d760 : 8492             [ 3] 	sty num_tmp+1
d762 : 8685             [ 3] 	stx num_a			; num_a contains the line number to 
d764 : 8586             [ 3] 	sta num_a+1
d766 :                       df_pg_check_next_line	; Also used during runtime 
d766 : a591             [ 3] 	lda num_tmp
d768 : c5a9             [ 3] 	cmp df_prgend
d76a : d011             [ 3] 	bne df_pg_check_line
AS65 Assembler for R6502 [1.42].                                     Page   96
---------------------------------- bank1.s -----------------------------------

d76c : a592             [ 3] 	lda num_tmp+1
d76e : c5aa             [ 3] 	cmp df_prgend+1
d770 : d00b             [ 3] 	bne df_pg_check_line
d772 :                       df_pr_line_gt_target	
                             	; End of program or line > target
                             	; X,A = address of finish
                             	; Load Y with the length
d772 : a200             [ 2] 	ldx #0
d774 : a191             [ 6] 	lda (num_tmp,x)
d776 : a8               [ 2] 	tay
d777 : a691             [ 3] 	ldx num_tmp
d779 : a592             [ 3] 	lda num_tmp+1
d77b : 38               [ 2] 	sec
d77c : 60               [ 6] 	rts
d77d :                       df_pg_check_line
d77d : 38               [ 2] 	sec					; Do a trial subtract of
d77e : a001             [ 2] 	ldy #DFTK_LINNUM	; target - line
d780 : a585             [ 3] 	lda num_a
d782 : f191             [ 5] 	sbc (num_tmp),y
d784 : 8593             [ 3] 	sta num_tmp+2		; Partial result of sbc
d786 : c8               [ 2] 	iny
d787 : a586             [ 3] 	lda num_a+1
d789 : f191             [ 5] 	sbc (num_tmp),y
d78b : 0593             [ 3] 	ora num_tmp+2		; or with partial result for z ch
                             	; If C=0 then line > target (done)
d78d : 90e3             [ 3] 	bcc df_pr_line_gt_target
                             	; If partial result Z=0 then got an exact match
d78f : f00f             [ 3] 	beq df_pr_line_match
                             	; Else we go to next line
d791 : a200             [ 2] 	ldx #0
d793 : 18               [ 2] 	clc
d794 : a591             [ 3] 	lda num_tmp
d796 : 6191             [ 6] 	adc (num_tmp,x)
d798 : 8591             [ 3] 	sta num_tmp
d79a : 90ca             [ 3] 	bcc df_pg_check_next_line
d79c : e692             [ 5] 	inc num_tmp+1
d79e : d0c6             [ 3] 	bne df_pg_check_next_line	; Always
d7a0 :                       df_pr_line_match
d7a0 : a200             [ 2] 	ldx #0
d7a2 : a191             [ 6] 	lda (num_tmp,x)
d7a4 : a8               [ 2] 	tay
d7a5 : a691             [ 3] 	ldx num_tmp
d7a7 : a592             [ 3] 	lda num_tmp+1
d7a9 : 18               [ 2] 	clc
d7aa : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* df_pg_insert_block
                             ;* Insert a block at adr (X, A) of size Y
                             ;* df_prgend updated
                             ;* C=1 Error, C=0 Ok
                             ;****************************************
d7ab :                       df_pg_insert_block
                             	; Inserting requires a block copy from
                             	; end of program space to the insert address
                             	
                             	; Save address as this is the lowest address
d7ab : 8685             [ 3] 	stx num_a
d7ad : 8586             [ 3] 	sta num_a+1
                             	; End of program space is the first byte to move
d7af : a5a9             [ 3] 	lda df_prgend
d7b1 : 858d             [ 3] 	sta num_x
AS65 Assembler for R6502 [1.42].                                     Page   97
---------------------------------- bank1.s -----------------------------------

d7b3 : a5aa             [ 3] 	lda df_prgend+1
d7b5 : 858e             [ 3] 	sta num_x+1	
d7b7 :                       df_pg_insert_byte
                             	; Move a byte from the current top
d7b7 : a200             [ 2] 	ldx #0
d7b9 : a18d             [ 6] 	lda (num_x,x)
                             	; To the new top (+Y)
d7bb : 918d             [ 5] 	sta (num_x),y
                             	; Compare current address with lowest
d7bd : a58d             [ 3] 	lda num_x
d7bf : c585             [ 3] 	cmp num_a
d7c1 : d012             [ 3] 	bne df_pg_insert_next_byte
d7c3 : a58e             [ 3] 	lda num_x+1
d7c5 : c586             [ 3] 	cmp num_a+1
d7c7 : d00c             [ 3] 	bne df_pg_insert_next_byte
                             	; Finished, update program end pointer
d7c9 : 18               [ 2] 	clc
d7ca : 98               [ 2] 	tya
d7cb : 65a9             [ 3] 	adc df_prgend
d7cd : 85a9             [ 3] 	sta df_prgend
                             	_bcc 2
                             
d7d1 : e6aa             [ 5] 	inc df_prgend+1
d7d3 : 18               [ 2] 	clc
d7d4 : 60               [ 6] 	rts	; C=0
d7d5 :                       df_pg_insert_next_byte
                             	; Decrement current address (trashes A)
                             	_decZPWordA num_x
                             
d7e2 : 4cb7d7           [ 3] 	jmp df_pg_insert_byte
                             
                             ;****************************************
                             ;* df_pg_delete_block
                             ;* Delete a block at adr (X, A) of size Y
                             ;* df_prgend updated
                             ;* C=1 Error, C=0 Ok
                             ;****************************************
d7e5 :                       df_pg_delete_block
                             	; Deleting requires a block copy from
                             	; deletion address to end of program
                             	
                             	; Save address as this is the start address
d7e5 : 8685             [ 3] 	stx num_a
d7e7 : 8586             [ 3] 	sta num_a+1
d7e9 : a200             [ 2] 	ldx #0	; No indirect indexing
d7eb :                       df_pg_delete_byte
                             	; Move a byte from current+Y
d7eb : b185             [ 5] 	lda (num_a),y
                             	; Down to current (x=0)
d7ed : 8185             [ 6] 	sta (num_a,x)
                             	; Compare current address with lowest
d7ef : a585             [ 3] 	lda num_a
d7f1 : c5a9             [ 3] 	cmp df_prgend
d7f3 : d017             [ 4] 	bne df_pg_delete_next_byte
d7f5 : a586             [ 3] 	lda num_a+1
d7f7 : c5aa             [ 3] 	cmp df_prgend+1
d7f9 : d011             [ 4] 	bne df_pg_delete_next_byte
                             	; Finished, update program end pointer
d7fb : 8485             [ 3] 	sty num_a
d7fd : 38               [ 2] 	sec
d7fe : a5a9             [ 3] 	lda df_prgend
d800 : e585             [ 3] 	sbc num_a
AS65 Assembler for R6502 [1.42].                                     Page   98
---------------------------------- bank1.s -----------------------------------

d802 : 85a9             [ 3] 	sta df_prgend
d804 : a5aa             [ 3] 	lda df_prgend+1
d806 : e900             [ 2] 	sbc #0
d808 : 85aa             [ 3] 	sta df_prgend+1
d80a : 18               [ 2] 	clc
d80b : 60               [ 6] 	rts
d80c :                       df_pg_delete_next_byte
                             	; Increment current address
                             	_incZPWord num_a
                             
d812 : 4cebd7           [ 3] 	jmp df_pg_delete_byte
                             
                             
                             ;****************************************
                             ;* Get a line of input
                             ;* Input: C=1 for echo, 0 for no echo
                             ;* Output: C=0 means linbuff is valid
                             ;****************************************
d815 :                       df_pg_inputline
                             	; C is set on input for echo or not
                             	; Read a line of input into df_linbuff
d815 : a200             [ 2] 	ldx #lo(df_linbuff)
d817 : a90a             [ 2] 	lda #hi(df_linbuff)
d819 : a078             [ 2] 	ldy #120
d81b : 20cfc5           [ 6] 	jsr io_read_line
                             	
                             	; If nothing entered then sec
d81e : 98               [ 2] 	tya
d81f : d002             [ 3] 	bne df_pg_inputline_ok
d821 : 38               [ 2] 	sec
d822 : 60               [ 6] 	rts
d823 :                       df_pg_inputline_ok
d823 : 18               [ 2] 	clc
d824 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* df_pg_dflat
                             ;* Start a dflat editing session
                             ;****************************************
d825 :                       df_pg_dflat
                             	; reset stack pointer
d825 : a2ff             [ 2] 	ldx #255
d827 : 9a               [ 2] 	txs
                             
                             	; error handler address
d828 : a906             [ 2] 	lda #lo(df_trap_error)
d82a : 85a2             [ 3] 	sta df_pc
d82c : a9f4             [ 2] 	lda #hi(df_trap_error)
d82e : 85a3             [ 3] 	sta df_pc+1
                             	
                             	; make sure normal I/O is resumed
                             	;jsr io_init_default
d830 :                       df_pg_prompt
d830 : a2ce             [ 2] 	ldx #lo(df_pg_prompt_msg)
d832 : a9d8             [ 2] 	lda #hi(df_pg_prompt_msg)
d834 : 200bc6           [ 6] 	jsr io_print_line
d837 : a900             [ 2] 	lda #0
d839 : 85a0             [ 3] 	sta df_immed
d83b :                       df_pg_getcommand
                             	; current line is the token buffer when editing
d83b : a980             [ 2] 	lda #lo(df_tokbuff)
AS65 Assembler for R6502 [1.42].                                     Page   99
---------------------------------- bank1.s -----------------------------------

d83d : 85c8             [ 3] 	sta df_currlin
d83f : a90a             [ 2] 	lda #hi(df_tokbuff)
d841 : 85c9             [ 3] 	sta df_currlin+1
d843 : 38               [ 2] 	sec
d844 : 2015d8           [ 6] 	jsr df_pg_inputline
d847 : b0e7             [ 3] 	bcs df_pg_prompt	; If no input then back to prom
d849 : ad000a           [ 4] 	lda df_linbuff		; Check if first char is ! to es
d84c : c921             [ 2] 	cmp #'!'
d84e : d005             [ 3] 	bne df_pg_skip_mon
d850 : 200ec5           [ 6] 	jsr _cmd_immediate	; If so call monitor immediat
d853 : 80db             [ 3] 	bra df_pg_prompt
d855 :                       df_pg_skip_mon
d855 : 206ed8           [ 6] 	jsr df_pg_tokenise
d858 : a5a0             [ 3] 	lda df_immed
d85a : f0df             [ 3] 	beq df_pg_getcommand
                             	; clear variables ready to run the statement
d85c : 20d5d8           [ 6] 	jsr df_initrun
                             	; run from tokbuff
d85f : a280             [ 2] 	ldx #lo(df_tokbuff)
d861 : a90a             [ 2] 	lda #hi(df_tokbuff)
                             	; always skip length and line number
d863 : a003             [ 2] 	ldy #3
                             ;	sty df_exeoff
                             	; init currlin
d865 : 2062dc           [ 6] 	jsr df_rt_init_stat_ptr
                             	; start execution
d868 : 2073dc           [ 6] 	jsr df_rt_exec_stat
                             	; Go and get another line of input
d86b : 4c30d8           [ 3] 	jmp df_pg_prompt
                             
                             	; tokenise the line
d86e :                       df_pg_tokenise
d86e : a900             [ 2] 	lda #0
d870 : 859f             [ 3] 	sta errno
d872 : 201fd1           [ 6] 	jsr df_lexer_line
                             	; check if line number == 0
d875 : ad810a           [ 4] 	lda df_tokbuff+DFTK_LINNUM
d878 : 0d820a           [ 4] 	ora df_tokbuff+DFTK_LINNUM+1
d87b : d00f             [ 3] 	bne df_pg_line_number
                             	; check if line empty
d87d : ad800a           [ 4] 	lda df_tokbuff
d880 : f009             [ 3] 	beq df_pg_nothing
                             	
                             	; line number == 0 so in immediate mode from tok
                             	; don't zero out the line length as some routine
                             	; run the line in immediate mode
d882 : a901             [ 2] 	lda #1
d884 : 85a0             [ 3] 	sta df_immed
                             	; Zero out text line buffer
d886 : a900             [ 2] 	lda #0
d888 : 8d000a           [ 4] 	sta df_linbuff
d88b :                       df_pg_nothing
d88b : 60               [ 6] 	rts
                             
                             	; put the numbered line in to the right bit of m
d88c :                       df_pg_line_number
                             	; Check if this line exists
d88c : ad810a           [ 4] 	lda df_tokbuff+DFTK_LINNUM
d88f : aa               [ 2] 	tax
d890 : ad820a           [ 4] 	lda df_tokbuff+DFTK_LINNUM+1
d893 : 205ad7           [ 6] 	jsr df_pg_find_line
                             	; Save line address for later X then A
AS65 Assembler for R6502 [1.42].                                     Page  100
---------------------------------- bank1.s -----------------------------------

d896 : 8545             [ 3] 	sta tmp_d
d898 : 8a               [ 2] 	txa
d899 : 48               [ 3] 	pha
d89a : a545             [ 3] 	lda tmp_d
d89c : 48               [ 3] 	pha
                             	; If line exists then it needs deleting
d89d : b003             [ 3] 	bcs df_pg_skip_del_line
                             
                             	; delete line from program
d89f : 20e5d7           [ 6] 	jsr df_pg_delete_block
d8a2 :                       df_pg_skip_del_line
                             	; If line length is zero
                             	; then nothing else to do (i.e. line was deleted
d8a2 : ad800a           [ 4] 	lda df_tokbuff+DFTK_LINLEN
                             	; save the tokenised line length
d8a5 : 48               [ 3] 	pha
d8a6 : d004             [ 3] 	bne df_pg_insertline
                             	; Length was zero, so get temp stuff off stack
d8a8 : 68               [ 4] 	pla
d8a9 : 68               [ 4] 	pla
d8aa : 68               [ 4] 	pla
d8ab : 60               [ 6] 	rts
                             
                             	; insert a program line unless it is immediate
d8ac :                       df_pg_insertline
                             	; Restore previously saved length
d8ac : 68               [ 4] 	pla
d8ad : a8               [ 2] 	tay
                             	; Restore previously saved address to reinsert t
d8ae : 68               [ 4] 	pla
d8af : 8545             [ 3] 	sta tmp_d
d8b1 : 68               [ 4] 	pla
d8b2 : aa               [ 2] 	tax
d8b3 : a545             [ 3] 	lda tmp_d
                             	; And save it all back to stack again A,X,Y
                             	_pushAXY
                             
                             	; We now have insert address and length
d8b8 : 20abd7           [ 6] 	jsr df_pg_insert_block
                             	; Restore length and sub 1 to get index in to th
d8bb : 68               [ 4] 	pla
d8bc : a8               [ 2] 	tay
d8bd : 88               [ 2] 	dey
                             	; Restore address to a pointer, X is pulled firs
d8be : 68               [ 4] 	pla
d8bf : aa               [ 2] 	tax
d8c0 : 8685             [ 3] 	stx num_a
d8c2 : 68               [ 4] 	pla
d8c3 : 8586             [ 3] 	sta num_a+1
                             	; num_a is destination, tokbuff is source, Y is 
d8c5 :                       df_pg_insertlinbyte
d8c5 : b9800a           [ 4] 	lda df_tokbuff,y
d8c8 : 9185             [ 5] 	sta (num_a),y
d8ca : 88               [ 2] 	dey
d8cb : 10f8             [ 3] 	bpl df_pg_insertlinbyte
d8cd : 60               [ 6] 	rts
                             	
d8ce :                       df_pg_prompt_msg
d8ce : 52656164790d00        	db "Ready",UTF_CR,0
                             
d8d5 :                       mod_sz_progedit_e
                             
AS65 Assembler for R6502 [1.42].                                     Page  101
---------------------------------- bank1.s -----------------------------------

                             	include "dflat/runtime.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RUNTIME.S
                             ;*  This module is the runtime coordinator.  When
                             ;*  wants to run a program, execution of statemen
                             ;*  required procedure starts and proceeds from t
                             ;*  according to normal program flow.
                             ;*  This module also contains critical routines f
                             ;*  evaluation of expressions (numeric and string
                             ;*  Whilst the code to implement a specific comma
                             ;*  rtsubs.s, this is the key module that control
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
d8d5 :                       mod_sz_runtime_s
                             
                             ;****************************************
                             ;* df_initrun
                             ;* Initialise program space for runtime
                             ;****************************************
d8d5 :                       df_initrun
                             	; Set the key mask to check every 16 instruction
d8d5 : a910             [ 2] 	lda #0x10
d8d7 : 859e             [ 3] 	sta df_checkmsk
d8d9 : 859d             [ 3] 	sta df_checkkey
                             
                             	; String and array heap initialisation
                             	; Grows up from end of prog space PLUS 1
                             	; Initially empty (dim will allocate)
                             	_cpyZPWord df_prgend,df_starstrt
                             
                             	_incZPWord df_starstrt
                             
                             	_cpyZPWord df_starstrt,df_starend
                             
                             
d8f1 : a2ff             [ 2] 	ldx #0xff
                             	; Reset runtime stack (grows down)
d8f3 : 86b8             [ 3] 	stx df_rtstop
                             	; make X=0
d8f5 : e8               [ 2] 	inx
                             	; Reset parameter stack (grows up)
d8f6 : 86b9             [ 3] 	stx df_parmtop
                             	; Reset data pointer high byte
d8f8 : 86d7             [ 3] 	stx df_currdat+1
                             	; if nest counter zeroed
d8fa : 86d5             [ 3] 	stx df_ifnest
                             
                             	; clear proc addresses
d8fc : 2000d9           [ 6] 	jsr df_rt_init_vvt
                             
                             ;	clc
AS65 Assembler for R6502 [1.42].                                     Page  102
---------------------------------- bank1.s -----------------------------------

d8ff : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Initialise vvt
                             ;****************************************
d900 :                       df_rt_init_vvt
                             	; starting at beginning of vvt
                             	_cpyZPWord df_vvtend,df_tmpptra
                             
d908 : a200             [ 2] 	ldx #0
d90a :                       df_rt_init_vvt_slot
d90a : a5e3             [ 3] 	lda df_tmpptra
d90c : c5af             [ 3] 	cmp df_vvtstrt
d90e : d006             [ 3] 	bne df_rt_init_vvt_slot_undim
d910 : a5e4             [ 3] 	lda df_tmpptra+1
d912 : c5b0             [ 3] 	cmp df_vvtstrt+1
d914 : f02b             [ 3] 	beq df_rt_init_done
d916 :                       df_rt_init_vvt_slot_undim
                             	; Only zero out proc and array pointers
                             	; Scalar variables are not initialised
d916 : a000             [ 2] 	ldy #0
d918 : b1e3             [ 5] 	lda (df_tmpptra),y
d91a : 29c0             [ 2] 	and #DFVVT_PROC|DFVVT_PTR
d91c : f016             [ 3] 	beq df_rt_init_vvt_skip
                             	; skip over the first byte which is variable typ
d91e : c8               [ 2] 	iny
                             	; zero out first 3 bytes for proc and arrays
d91f : a900             [ 2] 	lda #0
d921 : 91e3             [ 5] 	sta (df_tmpptra),y
d923 : c8               [ 2] 	iny
d924 : 91e3             [ 5] 	sta (df_tmpptra),y
d926 : c8               [ 2] 	iny
d927 : 91e3             [ 5] 	sta (df_tmpptra),y
d929 : c8               [ 2] 	iny
                             	; before doing dim2 check if proc
                             	; as we don't want to erase the parm count
                             ;	lda (df_tmpptra,x)
d92a : b2e3             [ 5] 	lda (df_tmpptra)
d92c : 2940             [ 2] 	and #DFVVT_PROC
d92e : d004             [ 3] 	bne df_rt_init_vvt_skip
                             	; if not proc then zero dim2
d930 : a900             [ 2] 	lda #0
d932 : 91e3             [ 5] 	sta (df_tmpptra),y
d934 :                       df_rt_init_vvt_skip
                             	; increment pointer to next slot
                             	_adcZPByte df_tmpptra,#8
                             
                             ;	jmp df_rt_init_vvt_slot 	; Don't rely on bcc
d93f : 80c9             [ 3] 	bra df_rt_init_vvt_slot 	; Don't rely on bcc
d941 :                       df_rt_init_done
d941 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Evaluate a numeric expression
                             ;* pop  X,A result from operator stack
                             ;****************************************
d942 :                       df_rt_getnval
                             	; evaluate the expression
d942 : 2048d9           [ 6] 	jsr df_rt_neval
                             	; get X,A off operator stack
d945 : 4cdaf2           [ 3] 	jmp df_ost_popInt
                             
AS65 Assembler for R6502 [1.42].                                     Page  103
---------------------------------- bank1.s -----------------------------------

                             
                             ;****************************************
                             ;* Evaluate a numeric expression
                             ;* Push result to operator stack
                             ;****************************************
d948 :                       df_rt_neval
                             	; push terminator on cpu stack
                             	; so we know where we are
d948 : a900             [ 2] 	lda #0
d94a : 48               [ 3] 	pha
                             
                             	; find escape token or keyword token
                             	; if escape token push on to operand stack
                             	; if keyword token push on to operator stack
d94b :                       df_rt_neval_optk
d94b : a4ca             [ 3] 	ldy df_exeoff
                             	; check end of line
                             
                             ;	cpy df_eolidx
                             ;	beq df_rt_neval_process
d94d : c4c1             [ 3] 	cpy df_nxtstidx
d94f : f03a             [ 3] 	beq df_rt_neval_process
d951 : b1c8             [ 5] 	lda (df_currlin),y		; Get the byte which could b
d953 : 3024             [ 3] 	bmi df_rt_neval_tk		; N=1 means it's a keyword t
d955 : c920             [ 2] 	cmp #DFTK_ESCVAL		; >=32 means it's an normal ch
d957 : b007             [ 3] 	bcs df_rt_neval_chr
d959 :                       df_rt_neval_esc
d959 : 20cdd9           [ 6] 	jsr df_rt_eval_esc
                             	; move to next byte
d95c : e6ca             [ 5] 	inc df_exeoff
d95e : d0eb             [ 3] 	bne df_rt_neval_optk		; ALWAYS as exeoff != 0
d960 :                       df_rt_neval_chr
                             	; check for evaluation terminators
                             	; specifically ',' and ']'
d960 : c92c             [ 2] 	cmp #','
d962 : f027             [ 3] 	beq df_rt_neval_process
d964 : c95d             [ 2] 	cmp #']'
d966 : f023             [ 3] 	beq df_rt_neval_process
                             	; check for brackets
                             	; if close bracket then process
d968 : c929             [ 2] 	cmp #')'
d96a : f01f             [ 3] 	beq df_rt_neval_process
                             	; Nothing of interest matched or it's open brack
                             	; so move to next byte either way
d96c : e6ca             [ 5] 	inc df_exeoff				; Next byte 
                             	; if bracket then evaluate expression recursivel
d96e : c928             [ 2] 	cmp #'('
d970 : d0d9             [ 3] 	bne df_rt_neval_optk
                             	; call evaluation function recursively
d972 : 2048d9           [ 6] 	jsr df_rt_neval
                             	; move to next byte
d975 : e6ca             [ 5] 	inc df_exeoff
d977 : d0d2             [ 3] 	bne df_rt_neval_optk		; ALWAYS as exeoff != 0
                             	; if a token then push on operator stack
d979 :                       df_rt_neval_tk
d979 : 297f             [ 2] 	and #0x7f
                             	; check if op (look up type using X as index)
                             	; X contains the current operator index
                             
d97b : aa               [ 2] 	tax
d97c : bd67d5           [ 4] 	lda df_tk_tokentype,x
                             	; A contains token type
AS65 Assembler for R6502 [1.42].                                     Page  104
---------------------------------- bank1.s -----------------------------------

d97f : 48               [ 3] 	pha
d980 : 2908             [ 2] 	and #DFTK_OP
d982 : d01c             [ 3] 	bne df_rt_neval_tk_opp
                             	; check if fn
d984 : 68               [ 4] 	pla
d985 : 2902             [ 2] 	and #DFTK_FN
d987 : d00c             [ 3] 	bne df_rt_neval_tk_fn
                             
                             	; If got here then something wrong
                             	SWBRK DFERR_OK
                             
                             
d98b :                       df_rt_neval_process
                             	; pop operator off stack and execute
                             	; keep popping until reached the terminator
d98b : 68               [ 4] 	pla
d98c : f006             [ 3] 	beq df_rt_neval_done
                             	; run the token code
d98e : 20d9dc           [ 6] 	jsr df_rt_run_token
                             	; top two bytes on ost stack is the result
d991 : 4c8bd9           [ 3] 	jmp df_rt_neval_process
d994 :                       df_rt_neval_done
d994 : 60               [ 6] 	rts
                             
d995 :                       df_rt_neval_tk_fn
d995 : 18               [ 2] 	clc
d996 : 8a               [ 2] 	txa
                             	; run a fn token - returns a value on stack
d997 : e6ca             [ 5] 	inc df_exeoff
d999 : 20d9dc           [ 6] 	jsr df_rt_run_token
                             	; move to next byte
d99c :                       df_rt_neval_nextbyte
d99c : e6ca             [ 5] 	inc df_exeoff
d99e : d0ab             [ 3] 	bne df_rt_neval_optk		; ALWAYS as exeoff != 0
                             
d9a0 :                       df_rt_neval_tk_opp
d9a0 : 68               [ 4] 	pla				; Get A off stack which is the type
d9a1 :                       df_rt_neval_tk_op
                             	; X=Op, A=Type
                             	; if this op < current top of op stack
                             	; then do the op as it is higher priority so sho
                             	; not be pushed
                             	; what is top of the op stack?
                             	; save current op token value
                             	; C=0 means process the op now, else don't
                             	; save current operator index
d9a1 : 86e3             [ 3] 	stx df_tmpptra				; Index in to token table not 
                             	; mask off to keep priority
d9a3 : 2907             [ 2] 	and #DFTK_OPMSK
d9a5 : 85e5             [ 3] 	sta df_tmpptrb
                             	; peek top of op stack - pull and push X
d9a7 : 68               [ 4] 	pla
d9a8 : 48               [ 3] 	pha
d9a9 : aa               [ 2] 	tax
                             	; if 0 then nothing so push op
d9aa : f01c             [ 3] 	beq df_rt_neval_pushOp
                             	; use it to index in to type table
d9ac : bd67d5           [ 4] 	lda df_tk_tokentype,x
                             	; mask off to keep priority
d9af : 2907             [ 2] 	and #DFTK_OPMSK
                             	; compare with the saved token type which includ
d9b1 : c5e5             [ 3] 	cmp df_tmpptrb
AS65 Assembler for R6502 [1.42].                                     Page  105
---------------------------------- bank1.s -----------------------------------

                             	; if top of stack >= current then C=1
                             	; else C=0
                             	; what is the state of C?
                             	; if 1 then just pushOp
d9b3 : f002             [ 3] 	beq df_rt_neval_donow
d9b5 : b011             [ 3] 	bcs df_rt_neval_pushOp
d9b7 :                       df_rt_neval_donow
                             	; was C=0 so process now before pushing the new 
                             	; get operator off cpu stack
d9b7 : 68               [ 4] 	pla
d9b8 : a8               [ 2] 	tay		; Save whilst need to push other things
                             	; save the current op on cpu stack
d9b9 : a5e3             [ 3] 	lda df_tmpptra
d9bb : 48               [ 3] 	pha
d9bc : aa               [ 2] 	tax		; X = current op
d9bd : 98               [ 2] 	tya		; Get A back from Y (new op)
                             	; now run the token in A that came off the stack
d9be : 20d9dc           [ 6] 	jsr df_rt_run_token
                             	; get current op off cpu stack in to X
d9c1 : 68               [ 4] 	pla
d9c2 : aa               [ 2] 	tax
                             	; get the token type in to A
d9c3 : bd67d5           [ 4] 	lda df_tk_tokentype,x
                             	; now go back around again to check whether to p
d9c6 : d0d9             [ 3] 	bne df_rt_neval_tk_op		; ALWAYS as type never ze
d9c8 :                       df_rt_neval_pushOp
                             	; push the operator
d9c8 : a5e3             [ 3] 	lda df_tmpptra
d9ca : 48               [ 3] 	pha
                             	; move to next byte
d9cb : d0cf             [ 3] 	bne df_rt_neval_nextbyte	; ALWAYS as token index
                             
                             
                             
                             
                             ; jump to escape evaluation routine
d9cd :                       df_rt_eval_esc
d9cd : 0a               [ 2] 	asl a
d9ce : aa               [ 2] 	tax
d9cf : 7cd2d9           [ 6] 	jmp (df_rt_eval_esc_tab,x)
                             ;	lda df_rt_eval_esc_tab,x
                             ;	sta df_tmpptra
                             ;	lda df_rt_eval_esc_tab+1,x
                             ;	sta df_tmpptra+1
                             ;	jmp (df_tmpptra)
                             
d9d2 :                       df_rt_eval_esc_tab
d9d2 : 8fda                  	dw df_rt_eval_chr
d9d4 : 9bda                  	dw df_rt_eval_reserved
d9d6 : 9bda                  	dw df_rt_eval_reserved
d9d8 : 9bda                  	dw df_rt_eval_reserved
d9da : 9bda                  	dw df_rt_eval_reserved
d9dc : 9bda                  	dw df_rt_eval_reserved	; no such thing as bytdec
d9de : 8fda                  	dw df_rt_eval_bythex
d9e0 : 8fda                  	dw df_rt_eval_bytbin
d9e2 : 9bda                  	dw df_rt_eval_reserved
d9e4 : 8fda                  	dw df_rt_eval_intdec
d9e6 : 8fda                  	dw df_rt_eval_inthex
d9e8 : 8fda                  	dw df_rt_eval_intbin
d9ea : 9bda                  	dw df_rt_eval_reserved
d9ec : 9bda                  	dw df_rt_eval_reserved
d9ee : 9bda                  	dw df_rt_eval_reserved
AS65 Assembler for R6502 [1.42].                                     Page  106
---------------------------------- bank1.s -----------------------------------

d9f0 : 9bda                  	dw df_rt_eval_reserved
d9f2 : 9dda                  	dw df_rt_eval_strlit
d9f4 : e2da                  	dw df_rt_eval_var
d9f6 : d6db                  	dw df_rt_eval_proc
                             
                             
                             ;****************************************
                             ;* Evaluate a string expression
                             ;* X, A = Destination is string accumulator
                             ;****************************************
d9f8 :                       df_rt_seval
d9f8 : a6bc             [ 3] 	ldx df_sevalptr
d9fa : a5bd             [ 3] 	lda df_sevalptr+1
                             ;****************************************
                             ;* Evaluate a string expression
                             ;* X, A = Destination buffer / space
                             ;****************************************
d9fc :                       df_rt_sval
                             	; keep X,A on the stack - will be modified
d9fc : 8545             [ 3] 	sta tmp_d
d9fe : 48               [ 3] 	pha
d9ff : 8a               [ 2] 	txa
da00 : 48               [ 3] 	pha
da01 : a545             [ 3] 	lda tmp_d
                             	; push original destination
da03 : 20aff2           [ 6] 	jsr df_ost_pushStr
                             	; Push the destination to the 6502 stack
                             	; hi byte first then lo
                             	; push string idx so we know our starting positi
                             	; in the string buffer
                             	; this limits all evaluations to 255 bytes
                             ;	lda df_stridx
                             ;	jsr df_ost_pushOp
                             
                             	; find escape token or keyword token
                             	; if escape token push on to operand stack
                             	; if keyword operator token push on to operator 
                             	; if keyword function token run it
                             
da06 :                       df_rt_seval_optk
da06 : a4ca             [ 3] 	ldy df_exeoff
                             	; check end of line
                             ;	cpy df_eolidx
                             ;	beq df_rt_seval_done
da08 : c4c1             [ 3] 	cpy df_nxtstidx
da0a : f069             [ 3] 	beq df_rt_seval_done
                             
da0c : b1c8             [ 5] 	lda (df_currlin),y
da0e : 301c             [ 3] 	bmi df_rt_seval_tk
                             
da10 : c920             [ 2] 	cmp #DFTK_ESCVAL
da12 : 900a             [ 3] 	bcc df_rt_seval_esc
                             	; check for evaluation terminators
                             	; specifically ',' and ')'
da14 : c92c             [ 2] 	cmp #','
da16 : f05d             [ 3] 	beq df_rt_seval_done
da18 : c929             [ 2] 	cmp #')'
da1a : f059             [ 3] 	beq df_rt_seval_done
da1c : d04a             [ 3] 	bne df_rt_seval_nextbyte
da1e :                       df_rt_seval_esc
                             	; the only escape char is STRLIT, VAR or PROC
da1e : c910             [ 2] 	cmp #DFTK_STRLIT
AS65 Assembler for R6502 [1.42].                                     Page  107
---------------------------------- bank1.s -----------------------------------

da20 : f04b             [ 3] 	beq	df_rt_seval_esc_strlit
da22 : c911             [ 2] 	cmp #DFTK_VAR
da24 : f028             [ 3] 	beq	df_rt_seval_esc_var
da26 : c912             [ 2] 	cmp #DFTK_PROC
da28 : f049             [ 3] 	beq	df_rt_seval_esc_proc
                             
                             	; error if got here
                             	SWBRK DFERR_SYNTAX
                             
                             
                             	; if a token then push on operator stack
da2c :                       df_rt_seval_tk
da2c : 84ca             [ 3] 	sty df_exeoff
da2e : 297f             [ 2] 	and #0x7f
                             	; check if op
da30 : aa               [ 2] 	tax
da31 : bd67d5           [ 4] 	lda df_tk_tokentype,x
da34 : 2904             [ 2] 	and #DFTK_STROP
da36 : d009             [ 3] 	bne df_rt_seval_tk_op
                             	; check if fn
da38 : bd67d5           [ 4] 	lda df_tk_tokentype,x
da3b : 2902             [ 2] 	and #DFTK_FN
da3d : d006             [ 3] 	bne df_rt_seval_tk_fn
                             
                             	; token type mismatch if got here
                             	SWBRK DFERR_TYPEMISM
                             
                             
da41 :                       df_rt_seval_tk_op
                             	; the only op is $+
                             	; so just ignore!
da41 : 8a               [ 2] 	txa
da42 : 4c68da           [ 3] 	jmp df_rt_seval_nextbyte
                             
da45 :                       df_rt_seval_tk_fn
da45 : 8a               [ 2] 	txa
da46 : e6ca             [ 5] 	inc df_exeoff
da48 : 20d9dc           [ 6] 	jsr df_rt_run_token
da4b : 4c52da           [ 3] 	jmp df_rt_seval_copy
                             
da4e :                       df_rt_seval_esc_var
                             	; go process the variable as a normal RVAL
da4e : 18               [ 2] 	clc
da4f : 20e2da           [ 6] 	jsr df_rt_eval_var
                             	; copy source off rt stack to destination
da52 :                       df_rt_seval_copy
                             	; pull destination pointer
da52 : 68               [ 4] 	pla
da53 : 85e3             [ 3] 	sta df_tmpptra
da55 : 68               [ 4] 	pla
da56 : 85e4             [ 3] 	sta df_tmpptra+1
                             	; pop source string pointer off stack
da58 : 20d2f2           [ 6] 	jsr df_ost_popStr
da5b : 86e5             [ 3] 	stx df_tmpptrb
da5d : 85e6             [ 3] 	sta df_tmpptrb+1
                             	; go and copy the string
da5f : 2079da           [ 6] 	jsr df_rt_copyStr
                             	; now save the destination
da62 : a5e4             [ 3] 	lda df_tmpptra+1
da64 : 48               [ 3] 	pha
da65 : a5e3             [ 3] 	lda df_tmpptra
da67 : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page  108
---------------------------------- bank1.s -----------------------------------

                             
                             ;	jmp df_rt_seval_nextbyte
da68 :                       df_rt_seval_nextbyte
da68 : e6ca             [ 5] 	inc df_exeoff
da6a : 4c06da           [ 3] 	jmp df_rt_seval_optk
                             
da6d :                       df_rt_seval_esc_strlit
                             	; evaluate string literal
da6d : 209dda           [ 6] 	jsr df_rt_eval_strlit
da70 : 4c52da           [ 3] 	jmp df_rt_seval_copy
                             
da73 :                       df_rt_seval_esc_proc
                             	; not yet suported *******
                             	SWBRK DFERR_OK
                             
                             
                             	; keep going until non-ws char found or end of l
da75 :                       df_rt_seval_done
                             	;
da75 : 68               [ 4] 	pla
da76 : 68               [ 4] 	pla
                             
da77 : 18               [ 2] 	clc
da78 : 60               [ 6] 	rts
                             
                             
                             ; Copy string from ptrb to ptra
da79 :                       df_rt_copyStr
da79 : a000             [ 2] 	ldy #0
da7b :                       df_rt_copyStr_ch
da7b : b1e5             [ 5] 	lda (df_tmpptrb),y
da7d : 91e3             [ 5] 	sta (df_tmpptra),y
da7f : f003             [ 3] 	beq df_rt_copyStr_done
da81 : c8               [ 2] 	iny
da82 : d0f7             [ 3] 	bne df_rt_copyStr_ch	; Always relying in Y never
da84 :                       df_rt_copyStr_done
da84 : 98               [ 2] 	tya
da85 : 18               [ 2] 	clc
da86 : 65e3             [ 3] 	adc df_tmpptra
da88 : 85e3             [ 3] 	sta df_tmpptra
                             	_bcc 2
                             
da8c : e6e4             [ 5] 	inc df_tmpptra+1
da8e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Evaluate and push numeric value
                             ;****************************************
da8f :                       df_rt_eval_intdec
da8f :                       df_rt_eval_bytdec
da8f :                       df_rt_eval_inthex
da8f :                       df_rt_eval_bythex
da8f :                       df_rt_eval_intbin
da8f :                       df_rt_eval_bytbin
da8f :                       df_rt_eval_chr
                             	; numeric constant
da8f : c8               [ 2] 	iny
da90 : b1c8             [ 5] 	lda (df_currlin),y
da92 : aa               [ 2] 	tax
da93 : c8               [ 2] 	iny
da94 : b1c8             [ 5] 	lda (df_currlin),y
                             	; save offset before calling any routine
AS65 Assembler for R6502 [1.42].                                     Page  109
---------------------------------- bank1.s -----------------------------------

da96 : 84ca             [ 3] 	sty df_exeoff
                             	; push number on to stack
da98 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
da9b :                       df_rt_eval_reserved
                             	; should not get here
                             	SWBRK DFERR_OK
                             
                             
                             ;****************************************
                             ;* Evaluate and push string constant
                             ;****************************************
da9d :                       df_rt_eval_strlit
da9d : 84ca             [ 3] 	sty df_exeoff
                             	; calculate the effective address in to AX
                             	; y + currlin
da9f : 98               [ 2] 	tya
                             	; set carry to add one extra
daa0 : 38               [ 2] 	sec
daa1 : 65c8             [ 3] 	adc df_currlin
daa3 : aa               [ 2] 	tax
daa4 : a5c9             [ 3] 	lda df_currlin+1
daa6 : 6900             [ 2] 	adc #0
                             
                             	; push string on to stack
daa8 : 20aff2           [ 6] 	jsr df_ost_pushStr
                             	; now proceed until end of string found
daab : a4ca             [ 3] 	ldy df_exeoff
daad :                       df_rt_eval_strlit_ch
daad : b1c8             [ 5] 	lda (df_currlin),y
daaf : f003             [ 3] 	beq df_rt_eval_strlit_done
dab1 : c8               [ 2] 	iny
dab2 : d0f9             [ 3] 	bne df_rt_eval_strlit_ch
dab4 :                       df_rt_eval_strlit_done	; Always relying on Y neve
dab4 : 84ca             [ 3] 	sty df_exeoff
dab6 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Return array parameter
                             ;* A has parm
                             ;****************************************
dab7 :                       df_rt_arry_parm
                             	; move past open bracket or comma
dab7 : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate expression inside bracket
dab9 : 2042d9           [ 6] 	jsr df_rt_getnval
dabc : 8a               [ 2] 	txa
                             ;	clc
dabd : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Return double array parameter
                             ;* X = dim1, Y = dim2
                             ;****************************************
dabe :                       df_rt_arry_parm2
                             	; go get array parm 1
dabe : 20b7da           [ 6] 	jsr df_rt_arry_parm
dac1 : 48               [ 3] 	pha
dac2 : a200             [ 2] 	ldx #0
dac4 : a4ca             [ 3] 	ldy df_exeoff
dac6 :                       df_rt_arry_parm2_term
dac6 : b1c8             [ 5] 	lda (df_currlin),y
AS65 Assembler for R6502 [1.42].                                     Page  110
---------------------------------- bank1.s -----------------------------------

dac8 : c95d             [ 2] 	cmp #']'
daca : f011             [ 3] 	beq df_rt_arry_parm2_skiparry2
dacc : c92c             [ 2] 	cmp #','
dace : f006             [ 3] 	beq df_rt_arry_parm2_arry2
dad0 : 84ca             [ 3] 	sty df_exeoff
dad2 : c8               [ 2] 	iny
dad3 : 4cc6da           [ 3] 	jmp df_rt_arry_parm2_term
dad6 :                       df_rt_arry_parm2_arry2
                             	; get second dimension and put in Y
dad6 : 20b7da           [ 6] 	jsr df_rt_arry_parm
dad9 : a8               [ 2] 	tay
dada : 68               [ 4] 	pla
dadb : aa               [ 2] 	tax
                             ;	clc
dadc : 60               [ 6] 	rts
dadd :                       df_rt_arry_parm2_skiparry2
dadd : a000             [ 2] 	ldy #0
dadf : 68               [ 4] 	pla
dae0 : aa               [ 2] 	tax
                             ;	clc
dae1 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* Evaluate and push variable
                             ;* The actual value is pushed if numeric
                             ;* The pointer is pushed if string
                             ;* Carry Set = LVAR else normal RVAR
                             ;* LVAR : Y = line index, A=vvt type, tmpptra = v
                             ;****************************************
dae2 :                       df_rt_eval_var
                             	; save carry bit
dae2 : 08               [ 3] 	php
                             	; if lvar mode then already passed escape token
dae3 : b00e             [ 3] 	bcs df_rt_eval_lvskip
                             	; move past var escape token
dae5 : c8               [ 2] 	iny
                             	; get var vvt address
dae6 : b1c8             [ 5] 	lda (df_currlin),y
dae8 : 85e3             [ 3] 	sta df_tmpptra
daea : c8               [ 2] 	iny
daeb : 84ca             [ 3] 	sty df_exeoff
daed : b1c8             [ 5] 	lda (df_currlin),y
daef : 85e4             [ 3] 	sta df_tmpptra+1
                             	; push vvt type first as this is the last thing 
daf1 : b2e3             [ 5] 	lda (df_tmpptra)
daf3 :                       df_rt_eval_lvskip
daf3 : 48               [ 3] 	pha
                             	; Test A for array or string
daf4 : 2984             [ 2] 	and #DFVVT_PTR|DFVVT_STR
                             	; simple variable
daf6 : f00e             [ 4] 	beq df_rt_eval_var_notarry
                             	; even if an array if no dimensions then return 
                             	; if at end of statement or line then simple cop
daf8 : c4c1             [ 3] 	cpy df_nxtstidx
dafa : f027             [ 4] 	beq df_rt_eval_var_simple
                             	; if next ch is not [ then simple copy
dafc : c8               [ 2] 	iny
dafd : b1c8             [ 5] 	lda (df_currlin),y
daff : 88               [ 2] 	dey
db00 : c95b             [ 2] 	cmp #'['
db02 : d01f             [ 3] 	bne df_rt_eval_var_simple
AS65 Assembler for R6502 [1.42].                                     Page  111
---------------------------------- bank1.s -----------------------------------

                             	; go do array handling
db04 : f02d             [ 3] 	beq df_rt_eval_var_do_arry
db06 :                       df_rt_eval_var_notarry
                             	; pull the type, not needed here
db06 : 68               [ 4] 	pla
                             	; pull C and check if lvar wanted rather than rv
db07 : 28               [ 4] 	plp
db08 : b00c             [ 3] 	bcs df_rt_eval_lvar
                             	; just push the vvt lo,hi value
db0a : a001             [ 2] 	ldy #DFVVT_LO
db0c : b1e3             [ 5] 	lda (df_tmpptra),y
db0e : aa               [ 2] 	tax
db0f : a002             [ 2] 	ldy #DFVVT_HI
db11 : b1e3             [ 5] 	lda (df_tmpptra),y
                             
db13 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
db16 :                       df_rt_eval_lvar
                             	; it's not an array, push the address of DFVVT_L
                             	; add DFVVT_LO offset to slot address in X,A
db16 : 18               [ 2] 	clc
db17 : a901             [ 2] 	lda #DFVVT_LO
db19 : 65e3             [ 3] 	adc df_tmpptra
db1b : aa               [ 2] 	tax
db1c : a5e4             [ 3] 	lda df_tmpptra+1
db1e : 6900             [ 2] 	adc #0
                             
                             	; push pointer to lo,hi
db20 : 4cb3f2           [ 3] 	jmp df_ost_pushPtr
                             
                             	; Simple push of pointer, needs to be valid
db23 :                       df_rt_eval_var_simple
                             	; clean up stack
db23 : 68               [ 4] 	pla
db24 : 68               [ 4] 	pla
                             	; simply get lo,hi and push ptr on stack
db25 : a001             [ 2] 	ldy #DFVVT_LO
db27 : b1e3             [ 5] 	lda (df_tmpptra),y
db29 : aa               [ 2] 	tax
db2a : a002             [ 2] 	ldy #DFVVT_HI
db2c : b1e3             [ 5] 	lda (df_tmpptra),y
db2e : f078             [ 3] 	beq df_rt_not_dimed
db30 : 4cb3f2           [ 3] 	jmp df_ost_pushPtr
                             
db33 :                       df_rt_eval_var_do_arry
                             	; move past var index
db33 : e6ca             [ 5] 	inc df_exeoff
                             	; zero out x,y as they have dimension info
db35 : a200             [ 2] 	ldx #0
db37 : a000             [ 2] 	ldy #0
                             
                             	; ** Array handling routine **
                             	; A on stack = type
                             	; save vvt address
db39 : a5e4             [ 3] 	lda df_tmpptra+1
db3b : 48               [ 3] 	pha
db3c : a5e3             [ 3] 	lda df_tmpptra
db3e : 48               [ 3] 	pha
                             
                             	; get array parms in X,Y
db3f : 20beda           [ 6] 	jsr df_rt_arry_parm2
                             	; restore vvt address
AS65 Assembler for R6502 [1.42].                                     Page  112
---------------------------------- bank1.s -----------------------------------

db42 : 68               [ 4] 	pla
db43 : 85e3             [ 3] 	sta df_tmpptra
db45 : 68               [ 4] 	pla
db46 : 85e4             [ 3] 	sta df_tmpptra+1
                             	; save dimension indices for later
db48 : 86e5             [ 3] 	stx df_tmpptrb
db4a : 84e6             [ 3] 	sty df_tmpptrb+1
                             	; if y is zero then need to decide some stuff
db4c : c000             [ 2] 	cpy #0
db4e : d00e             [ 3] 	bne df_rt_eval_var_dim2adj
                             	; if dim2 > 0 then swap x,y
db50 : a004             [ 2] 	ldy #DFVVT_DIM2
db52 : b1e3             [ 5] 	lda (df_tmpptra),y
db54 : f008             [ 3] 	beq df_rt_eval_var_dim2adj
                             	; swap x,y
db56 : a6e5             [ 3] 	ldx df_tmpptrb
db58 : a4e6             [ 3] 	ldy df_tmpptrb+1
db5a : 86e6             [ 3] 	stx df_tmpptrb+1
db5c : 84e5             [ 3] 	sty df_tmpptrb
                             
db5e :                       df_rt_eval_var_dim2adj
db5e : a6e5             [ 3] 	ldx df_tmpptrb
db60 : a4e6             [ 3] 	ldy df_tmpptrb+1
                             	; don't let y=0
db62 : d001             [ 3] 	bne df_rt_eval_var_dim2adjy
db64 : c8               [ 2] 	iny
db65 :                       df_rt_eval_var_dim2adjy
                             	; don't let x=0
db65 : e000             [ 2] 	cpx #0
db67 : d001             [ 3] 	bne df_rt_eval_var_dim2adjx
db69 : e8               [ 2] 	inx
db6a :                       df_rt_eval_var_dim2adjx
                             	;calculate offset
                             	;(y-1)*dim1 + (x-1)
db6a : ca               [ 2] 	dex
db6b : a900             [ 2] 	lda #0
db6d : 8586             [ 3] 	sta num_a+1
db6f : 88               [ 2] 	dey
                             	; (y-1)
db70 : 8485             [ 3] 	sty num_a
                             	; if y is 0 then no need to multiply
db72 : f00d             [ 3] 	beq df_rt_eval_var_nomult
                             	; (dim1)
db74 : a003             [ 2] 	ldy #DFVVT_DIM1
db76 : a900             [ 2] 	lda #0
db78 : 858a             [ 3] 	sta num_b+1
db7a : b1e3             [ 5] 	lda (df_tmpptra),y
db7c : 8589             [ 3] 	sta num_b
                             	; (y-1)*dim1 num_a has result
db7e : 2015cc           [ 6] 	jsr int_fast_mult
db81 :                       df_rt_eval_var_nomult
                             	; move x to a
db81 : 8a               [ 2] 	txa
                             	; add x to num_a
db82 : 18               [ 2] 	clc
db83 : 6585             [ 3] 	adc num_a
db85 : 8585             [ 3] 	sta num_a
                             	_bcc 2
                             
db89 : e686             [ 5] 	inc num_a+1
                             	; now have element offset in num_a
                             	; dimensions in x and y
AS65 Assembler for R6502 [1.42].                                     Page  113
---------------------------------- bank1.s -----------------------------------

db8b : a6e5             [ 3] 	ldx df_tmpptrb
db8d : a4e6             [ 3] 	ldy df_tmpptrb+1
                             	; get type of variable originally found
db8f : 68               [ 4] 	pla
db90 : 48               [ 3] 	pha
db91 : 2901             [ 2] 	and #DFVVT_INT
db93 : f004             [ 3] 	beq df_rt_eval_var_push
                             	; if it is int then multiply offset by 2
db95 : 0685             [ 5] 	asl num_a
db97 : 2686             [ 5] 	rol num_a+1
db99 :                       df_rt_eval_var_push
                             	; add pointer in lo,hi to num_a
db99 : 18               [ 2] 	clc
db9a : a001             [ 2] 	ldy #DFVVT_LO
db9c : b1e3             [ 5] 	lda (df_tmpptra),y
db9e : 6585             [ 3] 	adc num_a
dba0 : 8585             [ 3] 	sta num_a
dba2 : a002             [ 2] 	ldy #DFVVT_HI
dba4 : b1e3             [ 5] 	lda (df_tmpptra),y
dba6 : d002             [ 3] 	bne df_rt_array_exists
                             	; if vvt address hi is zero then array not dimen
dba8 :                       df_rt_not_dimed
                             	SWBRK DFERR_DIM
                             
dbaa :                       df_rt_array_exists
dbaa : 6586             [ 3] 	adc num_a+1
dbac : 8586             [ 3] 	sta num_a+1
                             	; get the type
dbae : 68               [ 4] 	pla
                             	; if not int or byte then push string
dbaf : 2903             [ 2] 	and #DFVVT_INT|DFVVT_BYT
dbb1 : f01b             [ 3] 	beq df_rt_eval_var_str
                             	; get LVAR preference
dbb3 : 28               [ 4] 	plp
dbb4 : b019             [ 3] 	bcs df_rt_eval_ptr
                             	; need to load lo and hi for int
                             	; but only lo for byt
dbb6 : 2901             [ 2] 	and #DFVVT_INT
dbb8 : f00b             [ 3] 	beq df_rt_eval_byt
                             	; push the contents pointed to by num_a
dbba : a000             [ 2] 	ldy #0
dbbc : b185             [ 5] 	lda (num_a),y
dbbe : aa               [ 2] 	tax
dbbf : c8               [ 2] 	iny
dbc0 : b185             [ 5] 	lda (num_a),y
dbc2 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
dbc5 :                       df_rt_eval_byt
dbc5 : a000             [ 2] 	ldy #0
dbc7 : b185             [ 5] 	lda (num_a),y
dbc9 : aa               [ 2] 	tax
dbca : 98               [ 2] 	tya			; Make A=0
dbcb : 4cbaf2           [ 3] 	jmp df_ost_pushInt
dbce :                       df_rt_eval_var_str
dbce : 28               [ 4] 	plp
dbcf :                       df_rt_eval_ptr
                             ;	clc
                             	; put num_a not contents
dbcf : a685             [ 3] 	ldx num_a
dbd1 : a586             [ 3] 	lda num_a+1
dbd3 : 4cb3f2           [ 3] 	jmp df_ost_pushPtr
                             
dbd6 :                       df_rt_eval_proc
AS65 Assembler for R6502 [1.42].                                     Page  114
---------------------------------- bank1.s -----------------------------------

dbd6 : a5b9             [ 3] 	lda df_parmtop				; Save current position of par
dbd8 : 48               [ 3] 	pha
dbd9 : 2024f1           [ 6] 	jsr df_rt_proc				; Go and call the user functio
dbdc : 68               [ 4] 	pla							; Get back the original parameter stac
dbdd : c5b9             [ 3] 	cmp df_parmtop				; if it is the same, then no r
dbdf : f002             [ 3] 	beq df_rt_eval_proc_err
dbe1 : 18               [ 2] 	clc
dbe2 : 60               [ 6] 	rts
dbe3 :                       df_rt_eval_proc_err
                             	; if no return value then report an errror
                             	SWBRK DFERR_RETURN
                             
                             
                             
                             
                             ;****************************************
                             ;* get two ints off the runtime stack
                             ;* first parm in ptrb, second in ptra
                             ;****************************************
dbe5 :                       df_rt_get2Ints
                             	; the first int popped is actually the second pa
dbe5 : 20daf2           [ 6] 	jsr df_ost_popInt
dbe8 : 86e5             [ 3] 	stx df_tmpptrb
dbea : 85e6             [ 3] 	sta df_tmpptrb+1
                             
dbec : 20daf2           [ 6] 	jsr df_ost_popInt
dbef : 86e3             [ 3] 	stx df_tmpptra
dbf1 : 85e4             [ 3] 	sta df_tmpptra+1
dbf3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* get two strings off the runtime stack
                             ;* first parm in ptrb, second in ptra
                             ;****************************************
dbf4 :                       df_rt_get2Strs
                             	; the first int popped is actually the second pa
dbf4 : 20d2f2           [ 6] 	jsr df_ost_popStr
dbf7 : 86e5             [ 3] 	stx df_tmpptrb
dbf9 : 85e6             [ 3] 	sta df_tmpptrb+1
                             
dbfb : 20d2f2           [ 6] 	jsr df_ost_popStr
dbfe : 86e3             [ 3] 	stx df_tmpptra
dc00 : 85e4             [ 3] 	sta df_tmpptra+1
dc02 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; common code for 2 ints runtime parsing
                             ;****************************************
dc03 :                       df_rt_parm_2ints
                             	; evaluate 1st parm
dc03 : 2048d9           [ 6] 	jsr df_rt_neval
                             	; jump over comma
dc06 : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
dc08 : 2048d9           [ 6] 	jsr df_rt_neval
                             	
dc0b : 4ce5db           [ 3] 	jmp df_rt_get2Ints
                             	; pop 2nd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             	; pop 1st parm
AS65 Assembler for R6502 [1.42].                                     Page  115
---------------------------------- bank1.s -----------------------------------

                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;	rts
                             
                             ;****************************************
                             ; common code for 3 ints runtime parsing
                             ;****************************************
dc0e :                       df_rt_parm_3ints
                             	; evaluate 1st parm
dc0e : 2048d9           [ 6] 	jsr df_rt_neval
dc11 : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
dc13 : 2048d9           [ 6] 	jsr df_rt_neval
dc16 : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
dc18 : 2048d9           [ 6] 	jsr df_rt_neval
                             
                             	; pop 3rd parm
dc1b :                       df_rt_parm_pop3
dc1b : 20daf2           [ 6] 	jsr df_ost_popInt
dc1e : 86e7             [ 3] 	stx df_tmpptrc
dc20 : 85e8             [ 3] 	sta df_tmpptrc+1
                             	; pop 2nd and 1st
dc22 : 4ce5db           [ 3] 	jmp df_rt_get2Ints
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             	; pop 1st parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;	rts
                             
                             ;****************************************
                             ; common code for 4 ints runtime parsing
                             ;****************************************
dc25 :                       df_rt_parm_4ints
                             	; evaluate 1st parm
dc25 : 2048d9           [ 6] 	jsr df_rt_neval
dc28 : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
dc2a : 2048d9           [ 6] 	jsr df_rt_neval
dc2d : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
dc2f : 2048d9           [ 6] 	jsr df_rt_neval
dc32 : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the 4th parm
dc34 : 2048d9           [ 6] 	jsr df_rt_neval
                             
                             	; pop 4th parm
dc37 :                       df_rt_parm_pop4
dc37 : 20daf2           [ 6] 	jsr df_ost_popInt
dc3a : 86e9             [ 3] 	stx df_tmpptrd
dc3c : 85ea             [ 3] 	sta df_tmpptrd+1
                             
                             	; pop 3,2,1 parms
dc3e : 4c1bdc           [ 3] 	jmp df_rt_parm_pop3
                             
                             	; pop 3rd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrc
AS65 Assembler for R6502 [1.42].                                     Page  116
---------------------------------- bank1.s -----------------------------------

                             ;	sta df_tmpptrc+1
                             	; pop 2nd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             	; pop 1st parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;	rts
                             
                             ;****************************************
                             ; common code for 5 ints runtime parsing
                             ;****************************************
dc41 :                       df_rt_parm_5ints
                             	; evaluate 1st parm
dc41 : 2048d9           [ 6] 	jsr df_rt_neval
dc44 : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
dc46 : 2048d9           [ 6] 	jsr df_rt_neval
dc49 : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
dc4b : 2048d9           [ 6] 	jsr df_rt_neval
dc4e : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the 4th parm
dc50 : 2048d9           [ 6] 	jsr df_rt_neval
dc53 : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the 5th parm
dc55 : 2048d9           [ 6] 	jsr df_rt_neval
                             
                             	; pop 5th parm
dc58 : 20daf2           [ 6] 	jsr df_ost_popInt
dc5b : 86eb             [ 3] 	stx df_tmpptre
dc5d : 85ec             [ 3] 	sta df_tmpptre+1
                             
                             	; pop 4,3,2,1 parms
dc5f : 4c37dc           [ 3] 	jmp df_rt_parm_pop4
                             
                             ;	; pop 4th parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrd
                             ;	sta df_tmpptrd+1
                             ;	; pop 3rd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrc
                             ;	sta df_tmpptrc+1
                             ;	; pop 2nd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             ;	; pop 1st parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;
                             ;	rts
                             
                             ;****************************************
                             ;* initialise statement to be executed
                             ;* X,A = line pointer, Y=statement offset
                             ;****************************************
dc62 :                       df_rt_init_stat_ptr
AS65 Assembler for R6502 [1.42].                                     Page  117
---------------------------------- bank1.s -----------------------------------

                             	; save current line
dc62 : 86c8             [ 3] 	stx df_currlin
dc64 : 85c9             [ 3] 	sta df_currlin+1
dc66 : 84ca             [ 3] 	sty df_exeoff
dc68 : 84c2             [ 3] 	sty df_curstidx
dc6a : b1c8             [ 5] 	lda (df_currlin),y
dc6c : 85c1             [ 3] 	sta df_nxtstidx
                             ;	ldx #0
                             ;	lda (df_currlin,x)
dc6e : b2c8             [ 5] 	lda (df_currlin)
dc70 : 85c0             [ 3] 	sta df_eolidx
dc72 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Execute from a statement pointed to
                             ;* by currlin and exeoff
                             ;****************************************
dc73 :                       df_rt_exec_stat
dc73 : a6c8             [ 3] 	ldx df_currlin
dc75 : a5c9             [ 3] 	lda df_currlin+1
dc77 : a4ca             [ 3] 	ldy df_exeoff
dc79 :                       df_rt_exec_init_ptr
dc79 : 2062dc           [ 6] 	jsr df_rt_init_stat_ptr
                             	; assume normal flow of control if next line hi 
                             	; this means no line can execute below page 1, n
                             ;	lda #0
                             ;	sta df_nextlin+1
dc7c : 64cc             [ 3] 	stz df_nextlin+1
                             
                             	; find first token in statement
dc7e :                       df_rt_exec_find_tok
dc7e : c8               [ 2] 	iny
dc7f : b1c8             [ 5] 	lda (df_currlin),y
dc81 : 10fb             [ 3] 	bpl df_rt_exec_find_tok
dc83 :                       df_rt_exec_found_tok
                             	; skip past token to next byte in readiness
dc83 : c8               [ 2] 	iny
dc84 : 84ca             [ 3] 	sty df_exeoff
                             	; Run that statement - if end of return will pul
                             	; and effectively do an rts from this routine.
dc86 : 20d9dc           [ 6] 	jsr df_rt_run_token
                             
                             	; check for break, asynch get
dc89 : a59e             [ 3] 	lda df_checkmsk
dc8b : 300e             [ 3] 	bmi df_rt_exec_no_key
dc8d : c69d             [ 5] 	dec df_checkkey
dc8f : d00a             [ 3] 	bne df_rt_exec_no_key
dc91 : a59e             [ 3] 	lda df_checkmsk
dc93 : 859d             [ 3] 	sta df_checkkey
dc95 : 18               [ 2] 	clc
dc96 : 20bdc5           [ 6] 	jsr io_get_ch
dc99 : 9027             [ 3] 	bcc df_rt_exec_check_key
dc9b :                       df_rt_exec_no_key
                             	; check if normal flow of control
dc9b : a5cc             [ 3] 	lda df_nextlin+1
dc9d : d031             [ 3] 	bne df_rt_exec_jump
                             	; try and execute another statement until end of
dc9f : a4c1             [ 3] 	ldy df_nxtstidx
dca1 : c4c0             [ 3] 	cpy df_eolidx
dca3 : 84ca             [ 3] 	sty df_exeoff
dca5 : d0cc             [ 3] 	bne df_rt_exec_stat
                             	
AS65 Assembler for R6502 [1.42].                                     Page  118
---------------------------------- bank1.s -----------------------------------

                             
                             	; reached end of line, move to next
dca7 : 18               [ 2] 	clc
                             ;	ldx #0
                             ;	lda (df_currlin,x)
dca8 : b2c8             [ 5] 	lda (df_currlin)
dcaa : 65c8             [ 3] 	adc df_currlin
dcac : 85c8             [ 3] 	sta df_currlin
                             	_bcc 2
                             
dcb0 : e6c9             [ 5] 	inc df_currlin+1
                             
                             	; start from first statement in new line
dcb2 : a003             [ 2] 	ldy #3
dcb4 : 84ca             [ 3] 	sty df_exeoff
                             
                             	; check if this line has any content (length >0)
                             ;	lda (df_currlin,x)
dcb6 : b2c8             [ 5] 	lda (df_currlin)
dcb8 : 85c0             [ 3] 	sta df_eolidx
                             	; no more lines (len = 0), program done
dcba : d0b7             [ 3] 	bne df_rt_exec_stat
                             	; else done
                             	; normally wouldn't get here except immediate mo
                             	; if line number <> 0 then error
dcbc : a5a0             [ 3] 	lda df_immed
dcbe : f00e             [ 3] 	beq df_rt_unexpected_end
dcc0 :                       df_rt_exec_end
dcc0 : 18               [ 2] 	clc
dcc1 : 60               [ 6] 	rts
dcc2 :                       df_rt_exec_check_key
dcc2 : c91a             [ 2] 	cmp #UTF_BRK					; CTRK-Z?
dcc4 : f006             [ 3] 	beq df_rt_exec_ctrl_z
dcc6 : c903             [ 2] 	cmp #UTF_ETX					; CTRL-C?
dcc8 : d0d1             [ 3] 	bne df_rt_exec_no_key			; None relevant keys, go
dcca :                       df_rt_exec_ctrl_c
                             	SWBRK DFERR_BREAK
                             
dccc :                       df_rt_exec_ctrl_z
                             	; Force a break with zero error number
                             	; this will drop in to the monitor
                             	SWBRK 0
                             
                             
dcce :                       df_rt_unexpected_end
                             	SWBRK DFERR_IMMEDIATE
                             
                             
                             	; if hi byte of nextline is not zero then
                             	; current line = next line
dcd0 :                       df_rt_exec_jump
                             	; initialise statement pointer from nextlin,toks
dcd0 : a6cb             [ 3] 	ldx df_nextlin
dcd2 : a5cc             [ 3] 	lda df_nextlin+1
dcd4 : a4c1             [ 3] 	ldy df_nxtstidx
dcd6 : 4c79dc           [ 3] 	jmp df_rt_exec_init_ptr
                             
                             
                             ;****************************************
                             ;* Run statement in A
                             ;****************************************
dcd9 :                       df_rt_run_token
AS65 Assembler for R6502 [1.42].                                     Page  119
---------------------------------- bank1.s -----------------------------------

                             	; mask off MSB
                             ;	and #0x7f
                             	; multiply by 2
dcd9 : 0a               [ 2] 	asl a
dcda : aa               [ 2] 	tax
dcdb : 7cb6dd           [ 6] 	jmp (df_rt_tokenjmp,x)
                             ;	lda df_rt_tokenjmp,x
                             ;	sta df_tmpptra
                             ;	lda df_rt_tokenjmp+1,x
                             ;	sta df_tmpptra+1
                             ;	; execution code finishes with rts
                             ;	jmp (df_tmpptra)
                             
                             
                             ;****************************************
                             ;* X,A : Line Address, Y = Index
                             ;* C=0 Found next statement
                             ;* C=1 No statement found
                             ;****************************************
dcde :                       df_rt_nextstat
                             	; save pointer
dcde : 86d2             [ 3] 	stx df_lineptr
dce0 : 85d3             [ 3] 	sta df_lineptr+1
                             	; if end of program then err
                             ;	ldx #0
                             ;	lda (df_lineptr,x)
dce2 : b2d2             [ 5] 	lda (df_lineptr)
dce4 : f022             [ 4] 	beq df_rt_nextstat_err
                             	; if next statement idx == line length
                             ;	lda (df_lineptr),y
                             ;	beq df_rt_nextstat_ln
dce6 : b1d2             [ 5] 	lda (df_lineptr),y
                             ;	cmp (df_lineptr,x)
dce8 : d2d2             [ 5] 	cmp (df_lineptr)
dcea : f007             [ 3] 	beq df_rt_nextstat_ln
                             	; then go to next line
                             	; else make this Y
dcec : a8               [ 2] 	tay
                             	; X = line low
dced : a6d2             [ 3] 	ldx df_lineptr
                             	; A = line high
dcef : a5d3             [ 3] 	lda df_lineptr+1
dcf1 : 18               [ 2] 	clc
dcf2 : 60               [ 6] 	rts
dcf3 :                       df_rt_nextstat_ln
                             	; for next line, add line length to ptr
dcf3 : 18               [ 2] 	clc
dcf4 : 65d2             [ 3] 	adc df_lineptr
dcf6 : 85d2             [ 3] 	sta df_lineptr
                             	_bcc 2
                             
dcfa : e6d3             [ 5] 	inc df_lineptr+1
                             	; if end of program set C as error
                             ;	lda (df_lineptr,x)
dcfc : b2d2             [ 5] 	lda (df_lineptr)
dcfe : f008             [ 4] 	beq df_rt_nextstat_err
dd00 : a6d2             [ 3] 	ldx df_lineptr
dd02 : a5d3             [ 3] 	lda df_lineptr+1
                             	; always skip line number and length for start o
dd04 : a003             [ 2] 	ldy #3
dd06 : 18               [ 2] 	clc
dd07 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  120
---------------------------------- bank1.s -----------------------------------

dd08 :                       df_rt_nextstat_err
dd08 : a000             [ 2] 	ldy #0
dd0a : 38               [ 2] 	sec
dd0b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push current line and statement to runtime sta
                             ;****************************************
dd0c :                       df_rt_push_stat
dd0c : a5c2             [ 3] 	lda df_curstidx
dd0e : 207cf2           [ 6] 	jsr df_rst_pushByte
dd11 : a5c9             [ 3] 	lda df_currlin+1
dd13 : a6c8             [ 3] 	ldx df_currlin
dd15 : 4c94f2           [ 3] 	jmp df_rst_pushWord
                             ;	clc
                             ;	rts
                             
                             ;****************************************
                             ;* Pop line and statement from runtime stack
                             ;* And transfer control to next statement
                             ;****************************************
dd18 :                       df_rt_pop_stat
dd18 : 20a2f2           [ 6] 	jsr df_rst_popWord
dd1b : 86cb             [ 3] 	stx	df_nextlin
dd1d : 85cc             [ 3] 	sta df_nextlin+1
dd1f : 2085f2           [ 6] 	jsr df_rst_popByte
dd22 : a8               [ 2] 	tay
dd23 : a6cb             [ 3] 	ldx df_nextlin
dd25 : a5cc             [ 3] 	lda df_nextlin+1
dd27 : 20dedc           [ 6] 	jsr df_rt_nextstat
dd2a : 86cb             [ 3] 	stx df_nextlin
dd2c : 85cc             [ 3] 	sta df_nextlin+1
dd2e : 84c1             [ 3] 	sty df_nxtstidx
                             ;	clc
dd30 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find proc definition in procptr
                             ;* Only call if proc not found before
                             ;****************************************
dd31 :                       df_rt_findproc
                             	; start at program beginning
                             	_cpyZPWord df_prgstrt,df_lineptr
                             
dd39 : a003             [ 2] 	ldy #3
dd3b : 84d4             [ 3] 	sty df_lineidx
                             ;	ldx #0
                             ;	lda (df_lineptr,x)
dd3d : b2d2             [ 5] 	lda (df_lineptr)
dd3f : f034             [ 3] 	beq df_rt_findproc_err
dd41 :                       df_rt_findproc_cmd
dd41 : c8               [ 2] 	iny
dd42 : b1d2             [ 5] 	lda (df_lineptr),y
dd44 : 10fb             [ 3] 	bpl df_rt_findproc_cmd
dd46 : c986             [ 2] 	cmp #DFRT_DEF
dd48 : d017             [ 3] 	bne df_rt_findproc_nextstat
                             	; skip def token
dd4a : c8               [ 2] 	iny
                             	; skip proc escape token
dd4b : c8               [ 2] 	iny
                             	; now check the proc address against procptr
dd4c : b1d2             [ 5] 	lda (df_lineptr),y
AS65 Assembler for R6502 [1.42].                                     Page  121
---------------------------------- bank1.s -----------------------------------

dd4e : c5d0             [ 3] 	cmp df_procptr
dd50 : d00f             [ 3] 	bne df_rt_findproc_nextstat
dd52 : c8               [ 2] 	iny
dd53 : b1d2             [ 5] 	lda (df_lineptr),y
dd55 : c5d1             [ 3] 	cmp df_procptr+1
dd57 : d008             [ 3] 	bne df_rt_findproc_nextstat
                             
                             	; found it, return AXY with line details
dd59 : a6d2             [ 3] 	ldx df_lineptr
dd5b : a5d3             [ 3] 	lda df_lineptr+1
dd5d : a4d4             [ 3] 	ldy df_lineidx
dd5f : 18               [ 2] 	clc
dd60 : 60               [ 6] 	rts
dd61 :                       df_rt_findproc_nextstat
                             	; restore AXY line details and find next stateme
dd61 : a6d2             [ 3] 	ldx df_lineptr
dd63 : a5d3             [ 3] 	lda df_lineptr+1
dd65 : a4d4             [ 3] 	ldy df_lineidx
dd67 : 20dedc           [ 6] 	jsr df_rt_nextstat
dd6a : b009             [ 3] 	bcs df_rt_findproc_err
dd6c : 86d2             [ 3] 	stx df_lineptr
dd6e : 85d3             [ 3] 	sta df_lineptr+1
dd70 : 84d4             [ 3] 	sty df_lineidx
dd72 : 4c41dd           [ 3] 	jmp df_rt_findproc_cmd
                             	; error
dd75 :                       df_rt_findproc_err
                             	SWBRK DFERR_NOPROC
                             
                             
                             ;****************************************
                             ;* Find an escape value
                             ;* Does not check for end of line or statement
                             ;****************************************
dd77 :                       df_rt_findescval
dd77 : a4ca             [ 3] 	ldy df_exeoff
dd79 : 88               [ 2] 	dey
dd7a :                       df_rt_findescval_loop
dd7a : c8               [ 2] 	iny
dd7b : b1c8             [ 5] 	lda (df_currlin),y
dd7d : c920             [ 2] 	cmp #DFTK_ESCVAL
dd7f : b0f9             [ 3] 	bcs df_rt_findescval_loop
dd81 : 84ca             [ 3] 	sty df_exeoff
dd83 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Skip white space
                             ;* Does not check for end of line or statement
                             ;* A contains non-ws char, df_exeoff updated
                             ;****************************************
dd84 :                       df_rt_skip_ws
dd84 : a4ca             [ 3] 	ldy df_exeoff
dd86 : 88               [ 2] 	dey
dd87 :                       df_rt_skip_ws_loop
dd87 : c8               [ 2] 	iny
dd88 : b1c8             [ 5] 	lda (df_currlin),y
dd8a : c920             [ 2] 	cmp #' '
dd8c : f0f9             [ 3] 	beq df_rt_skip_ws_loop
dd8e : 84ca             [ 3] 	sty df_exeoff
dd90 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Get an lvar
AS65 Assembler for R6502 [1.42].                                     Page  122
---------------------------------- bank1.s -----------------------------------

                             ;* Assumes next token will be escape DFTK_VAR
                             ;* tmpptra contains vvt slot address
                             ;* X,A is the lvar pointer
                             ;****************************************
dd91 :                       df_rt_getlvar
dd91 : 2077dd           [ 6] 	jsr df_rt_findescval
                             	; move past the escape value
dd94 : c8               [ 2] 	iny
                             
                             	; get variable address
dd95 : b1c8             [ 5] 	lda (df_currlin),y
dd97 : 85e3             [ 3] 	sta df_tmpptra
dd99 : c8               [ 2] 	iny
dd9a : b1c8             [ 5] 	lda (df_currlin),y
dd9c : 85e4             [ 3] 	sta df_tmpptra+1
                             
dd9e : 84ca             [ 3] 	sty df_exeoff
                             	; get the type
dda0 : a000             [ 2] 	ldy #0
dda2 : b1e3             [ 5] 	lda (df_tmpptra),y
                             	; set carry flag to return pointer (lvar)
dda4 : 38               [ 2] 	sec
dda5 : a4ca             [ 3] 	ldy df_exeoff
dda7 : 20e2da           [ 6] 	jsr df_rt_eval_var
ddaa : 4cd6f2           [ 3] 	jmp df_ost_popPtr
                             ;	rts
                             
                             ;****************************************
                             ;* Pop stat from rt stack and continue
                             ;* Y MUST BE ON THE CPU STACK AS IT GETS PLYed HE
                             ;****************************************
ddad :                       df_rt_pop_stat_go
ddad : 2018dd           [ 6] 	jsr df_rt_pop_stat
                             	; restore stack pointer so we don't lose this en
ddb0 : 68               [ 4] 	pla
ddb1 : a8               [ 2] 	tay
ddb2 : 84b8             [ 3] 	sty df_rtstop
ddb4 : 18               [ 2] 	clc
ddb5 : 60               [ 6] 	rts
                             
                             	include "dflat/rtjmptab.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime token an
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page  123
---------------------------------- bank1.s -----------------------------------

                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; In token order of df_tokensyms
ddb6 :                       df_rt_tokenjmp
ddb6 : 36e6                  	dw	df_rt_assign
ddb8 : 24f1                  	dw	df_rt_proc
ddba : 3ce6                  	dw	df_rt_comment
ddbc : eae5                  	dw	df_rt_println
ddbe : afe5                  	dw	df_rt_printat
ddc0 : b9e5                  	dw	df_rt_print
ddc2 : c4f1                  	dw	df_rt_def			; 0x86
ddc4 : 3ef2                  	dw	df_rt_enddef		; 0x87
ddc6 : 3bf2                  	dw	df_rt_return		; 0x88
ddc8 : e1f0                  	dw	df_rt_abort			; 0x89
ddca : 90e3                  	dw	df_rt_local
ddcc : bce3                  	dw	df_rt_dim
ddce : 65e2                  	dw	df_rt_repeat		; 0x8c
ddd0 : 6de2                  	dw	df_rt_until
ddd2 : d0e1                  	dw	df_rt_for			; 0x8e
ddd4 : 0ae2                  	dw	df_rt_next			; 0x8f
ddd6 : b2e0                  	dw	df_rt_while			; 0x90
ddd8 : 17e1                  	dw	df_rt_wend			; 0x81
ddda : 91e1                  	dw	df_rt_if			; 0x92
dddc : 7fe1                  	dw	df_rt_else			; 0x93
ddde : 7ae1                  	dw	df_rt_endif			; 0x94
dde0 : 7fe1                  	dw	df_rt_elseif		; 0x95
dde2 : 3ce6                  	dw	df_rt_data			; 0x96
dde4 : e3f5                  	dw	df_rt_asm_assemble	; 0x97
dde6 : 3de6                  	dw	df_rt_run
dde8 : 32e7                  	dw	df_rt_list
ddea : 5be3                  	dw	df_rt_input
ddec : c6e4                  	dw	df_rt_mode
ddee : 4ae4                  	dw	df_rt_plot
ddf0 : b3e4                  	dw	df_rt_cursor
ddf2 : 40e4                  	dw	df_rt_cls
ddf4 : 96e9                  	dw	df_rt_vpoke
ddf6 : ade9                  	dw	df_rt_setvdp
ddf8 : b7e9                  	dw	df_rt_colour
ddfa : 06ea                  	dw	df_rt_spritepat
ddfc : 34ea                  	dw	df_rt_spritepos
ddfe : 72ea                  	dw	df_rt_spritecol
de00 : 77ea                  	dw	df_rt_spritenme
de02 : dde9                  	dw	df_rt_sprite
de04 : 8ee9                  	dw	df_rt_poke
de06 : 80e9                  	dw	df_rt_doke
de08 : a5ea                  	dw	df_rt_sound
de0a : b9ea                  	dw	df_rt_music
de0c : d7ea                  	dw	df_rt_play
de0e : b0eb                  	dw	df_rt_save
de10 : cbeb                  	dw	df_rt_load
de12 : 5aed                  	dw	df_rt_dir
de14 : daed                  	dw	df_rt_dirl
de16 : 1dec                  	dw	df_rt_del
de18 : 43e3                  	dw	df_rt_read
de1a : afe0                  	dw	df_rt_new
de1c : 4ee6                  	dw	df_rt_renum
de1e : 96e5                  	dw	df_rt_wait
de20 : 10ee                  	dw	df_rt_reset
AS65 Assembler for R6502 [1.42].                                     Page  124
---------------------------------- bank1.s -----------------------------------

de22 : c6e4                  	dw	df_rt_hires
de24 : e7e4                  	dw	df_rt_point
de26 : 0fe5                  	dw	df_rt_line
de28 : f1e4                  	dw	df_rt_hplot
de2a : cde4                  	dw	df_rt_pixmode
de2c : d3e4                  	dw	df_rt_pixmask
de2e : d9e4                  	dw	df_rt_pixcol
de30 : 25e5                  	dw	df_rt_box
de32 : fde4                  	dw	df_rt_circle
de34 : 3be5                  	dw	df_rt_shape
de36 : 65ec                  	dw	df_rt_vload
de38 : 36ec                  	dw	df_rt_bload
de3a : 08eb                  	dw	df_rt_bsave
de3c : b9e4                  	dw	df_rt_himem
de3e : abe0                  	dw	df_rt_monitor
de40 : 24ec                  	dw	df_rt_chdir
de42 : 2dec                  	dw	df_rt_mkdir
de44 : 28ee                  	dw	df_rt_datetime
de46 : a2e9                  	dw	df_rt_nvpoke
de48 : 58ec                  	dw	df_rt_font
de4a : 09f1                  	dw	df_rt_device
de4c : fef0                  	dw	df_rt_fclose
de4e : b9e3                  	dw	df_rt_redim
de50 : dfe4                  	dw  df_rt_put
de52 : ccec                  	dw	df_rt_ptload
de54 : 35ed                  	dw	df_rt_ptinit
de56 : 42ed                  	dw	df_rt_ptrun
                             
de58 : a0ee                  	dw	df_rt_vpeek
de5a : 87ee                  	dw	df_rt_peek
de5c : 84ee                  	dw	df_rt_deek
de5e : ddee                  	dw	df_rt_stick
de60 : 4def                  	dw	df_rt_key
de62 : 11f0                  	dw	df_rt_chr
de64 : 64f0                  	dw	df_rt_left
de66 : 75f0                  	dw	df_rt_right
de68 : 90f0                  	dw	df_rt_mid
de6a : aef0                  	dw	df_rt_len
de6c : 01ef                  	dw	df_rt_mem
de6e : 60ef                  	dw	df_rt_scrn
de70 : b8ee                  	dw	df_rt_rnd
de72 : 7cef                  	dw	df_rt_elapsed
de74 : 9aef                  	dw	df_rt_call
de76 : 25f0                  	dw	df_rt_hex
de78 : 56f0                  	dw	df_rt_dec
de7a : baf0                  	dw	df_rt_asc
de7c : cbf0                  	dw	df_rt_val
de7e : 70ef                  	dw	df_rt_pixel
de80 : acef                  	dw	df_rt_sgn
de82 : c9ef                  	dw	df_rt_addr
de84 : acee                  	dw	df_rt_nvpeek
de86 : e3f0                  	dw	df_rt_fcreate
de88 : f6f0                  	dw	df_rt_fopen
de8a : 4def                  	dw  df_rt_get
                             	
de8c : ffde                  	dw	df_rt_mult
de8e : 20df                  	dw	df_rt_div
de90 : 41df                  	dw	df_rt_mod
de92 : 62df                  	dw	df_rt_asl
de94 : 75df                  	dw	df_rt_lsr
de96 : d9de                  	dw	df_rt_add
de98 : ecde                  	dw	df_rt_sub
AS65 Assembler for R6502 [1.42].                                     Page  125
---------------------------------- bank1.s -----------------------------------

                             	
de9a : 88df                  	dw	df_rt_and
de9c : 97df                  	dw	df_rt_or
de9e : a6df                  	dw	df_rt_eor
dea0 : 45e0                  	dw	df_rt_comlte
dea2 : 50e0                  	dw	df_rt_comgte
dea4 : 5be0                  	dw	df_rt_comne
dea6 : 24e0                  	dw	df_rt_comlt
dea8 : 2fe0                  	dw	df_rt_comgt
deaa : 3ae0                  	dw	df_rt_comeq
                             
                             
                             ; escape sequence handlers
                             ; to do the reverse of tokenising during the list
                             ; command which is also used to save to disk.
deac :                       df_rt_escjmp
deac : 06e8                  	dw df_rt_lst_chr
deae : 05e8                  	dw df_rt_lst_reserved
deb0 : 05e8                  	dw df_rt_lst_reserved
deb2 : 05e8                  	dw df_rt_lst_reserved
deb4 : 05e8                  	dw df_rt_lst_reserved	
deb6 : 05e8                  	dw df_rt_lst_reserved	; no such thing as bytdec
deb8 : 23e8                  	dw df_rt_lst_bythex
deba : 48e8                  	dw df_rt_lst_bytbin
debc : 05e8                  	dw df_rt_lst_reserved	
debe : 6ce8                  	dw df_rt_lst_intdec
dec0 : 36e8                  	dw df_rt_lst_inthex
dec2 : 50e8                  	dw df_rt_lst_intbin
dec4 : 05e8                  	dw df_rt_lst_reserved
dec6 : 05e8                  	dw df_rt_lst_reserved
dec8 : 05e8                  	dw df_rt_lst_reserved
deca : 05e8                  	dw df_rt_lst_reserved	
decc : c9e8                  	dw df_rt_lst_strlit
dece : 77e8                  	dw df_rt_lst_var
ded0 : 77e8                  	dw df_rt_lst_proc
                             
                             	include "dflat/rtsubs.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTSUBS.S
                             ;*  Module that implements the runtime execution 
                             ;*  keywords and functions.
                             ;*  So this is where most of the action is for ru
                             ;*  a line is being executed, the dflat runtime c
                             ;*  jumps through the runtime table to routines h
                             ;*  Every dflat statement begins with a token (ig
                             ;*  whitespace), even the implicit assignment and
                             ;*  invocation.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
ded2 :                       mod_sz_rtsubs_s
                             
AS65 Assembler for R6502 [1.42].                                     Page  126
---------------------------------- bank1.s -----------------------------------

                             	include "dflat\numop.s"
                             ;************************************************
                             ;*
                             ;*	BBC128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  NUMOP.S
                             ;*	Dflat number AND string operators.
                             ;*  Uses the operator stack to get parameters, le
                             ;*  result on the operator stack.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; common pushint code
ded2 :                       df_rt_putintres
ded2 : a6e3             [ 3] 	ldx df_tmpptra
ded4 : a5e4             [ 3] 	lda df_tmpptra+1
ded6 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
                             ; add two numbers
ded9 :                       df_rt_add
ded9 : 20e5db           [ 6] 	jsr df_rt_get2Ints
                             	_addZPWord df_tmpptra,df_tmpptrb
                             
dee9 : 4cd2de           [ 3] 	jmp df_rt_putintres
                             	
                             ; subtract
deec :                       df_rt_sub
deec : 20e5db           [ 6] 	jsr df_rt_get2Ints
                             	_subZPWord df_tmpptra,df_tmpptrb
                             
defc : 4cd2de           [ 3] 	jmp df_rt_putintres
                             
                             ; multiply
deff :                       df_rt_mult
deff : 20e5db           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
df12 : 203ccc           [ 6] 	jsr int_mult
                             	_cpyZPWord num_a,df_tmpptra
                             
df1d : 4cd2de           [ 3] 	jmp df_rt_putintres
                             
                             ; divide
df20 :                       df_rt_div
df20 : 20e5db           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
df33 : 2065cc           [ 6] 	jsr int_div
                             	_cpyZPWord num_a,df_tmpptra
                             
df3e : 4cd2de           [ 3] 	jmp df_rt_putintres
AS65 Assembler for R6502 [1.42].                                     Page  127
---------------------------------- bank1.s -----------------------------------

                             
                             ; mod
df41 :                       df_rt_mod
df41 : 20e5db           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
df54 : 2065cc           [ 6] 	jsr int_div
                             	_cpyZPWord num_x,df_tmpptra
                             
df5f : 4cd2de           [ 3] 	jmp df_rt_putintres
                             
                             ; shift left
df62 :                       df_rt_asl
df62 : 20e5db           [ 6] 	jsr df_rt_get2Ints
                             	; use low byte only for # of shifts
df65 : a6e5             [ 3] 	ldx df_tmpptrb
df67 : e8               [ 2] 	inx
df68 :                       df_rt_aslbit
df68 : ca               [ 2] 	dex
df69 : f007             [ 3] 	beq df_rt_asldone
df6b : 06e3             [ 5] 	asl df_tmpptra
df6d : 26e4             [ 5] 	rol df_tmpptra+1
df6f : 4c68df           [ 3] 	jmp df_rt_aslbit
df72 :                       df_rt_asldone
df72 : 4cd2de           [ 3] 	jmp df_rt_putintres
                             
                             ; shift right
df75 :                       df_rt_lsr
df75 : 20e5db           [ 6] 	jsr df_rt_get2Ints
                             	; use low byte only for # of shifts
df78 : a6e5             [ 3] 	ldx df_tmpptrb
df7a : e8               [ 2] 	inx
df7b :                       df_rt_lsrbit
df7b : ca               [ 2] 	dex
df7c : f007             [ 3] 	beq df_rt_lsrdone
df7e : 46e4             [ 5] 	lsr df_tmpptra+1
df80 : 66e3             [ 5] 	ror df_tmpptra
df82 : 4c7bdf           [ 3] 	jmp df_rt_lsrbit
df85 :                       df_rt_lsrdone
df85 : 4cd2de           [ 3] 	jmp df_rt_putintres
                             
                             ; logical and
df88 :                       df_rt_and
df88 : 20e5db           [ 6] 	jsr df_rt_get2Ints
df8b : a5e3             [ 3] 	lda df_tmpptra
df8d : 25e5             [ 3] 	and df_tmpptrb
df8f : aa               [ 2] 	tax
df90 : a5e4             [ 3] 	lda df_tmpptra+1
df92 : 25e6             [ 3] 	and df_tmpptrb+1
df94 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             	
                             ; logical or
df97 :                       df_rt_or
df97 : 20e5db           [ 6] 	jsr df_rt_get2Ints
df9a : a5e3             [ 3] 	lda df_tmpptra
df9c : 05e5             [ 3] 	ora df_tmpptrb
df9e : aa               [ 2] 	tax
df9f : a5e4             [ 3] 	lda df_tmpptra+1
dfa1 : 05e6             [ 3] 	ora df_tmpptrb+1
dfa3 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
AS65 Assembler for R6502 [1.42].                                     Page  128
---------------------------------- bank1.s -----------------------------------

                             
                             ; logical eor
dfa6 :                       df_rt_eor
dfa6 : 20e5db           [ 6] 	jsr df_rt_get2Ints
dfa9 : a5e3             [ 3] 	lda df_tmpptra
dfab : 45e5             [ 3] 	eor df_tmpptrb
dfad : aa               [ 2] 	tax
dfae : a5e4             [ 3] 	lda df_tmpptra+1
dfb0 : 45e6             [ 3] 	eor df_tmpptrb+1
dfb2 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
                             ; a==b common function
dfb5 :                       df_rt_aequb
dfb5 : a5e3             [ 3] 	lda df_tmpptra
dfb7 : c5e5             [ 3] 	cmp df_tmpptrb
dfb9 : d004             [ 3] 	bne df_rt_aequbFin
dfbb : a5e4             [ 3] 	lda df_tmpptra+1
dfbd : c5e6             [ 3] 	cmp df_tmpptrb+1
dfbf :                       df_rt_aequbFin
dfbf : 60               [ 6] 	rts
                             
                             ; a-b common function
dfc0 :                       df_rt_asubb
dfc0 : 38               [ 2] 	sec
dfc1 : a5e3             [ 3] 	lda df_tmpptra
dfc3 : e5e5             [ 3] 	sbc df_tmpptrb
dfc5 : a5e4             [ 3] 	lda df_tmpptra+1
dfc7 : e5e6             [ 3] 	sbc df_tmpptrb+1
dfc9 : 5002             [ 3] 	bvc df_rt_asubbFin
dfcb : 4980             [ 2] 	eor #0x80
dfcd :                       df_rt_asubbFin
dfcd : 60               [ 6] 	rts
                             
                             ; b-a common function
dfce :                       df_rt_bsuba
dfce : 38               [ 2] 	sec
dfcf : a5e5             [ 3] 	lda df_tmpptrb
dfd1 : e5e3             [ 3] 	sbc df_tmpptra
dfd3 : a5e6             [ 3] 	lda df_tmpptrb+1
dfd5 : e5e4             [ 3] 	sbc df_tmpptra+1
dfd7 : 5002             [ 3] 	bvc df_rt_bsubaFin
dfd9 : 4980             [ 2] 	eor #0x80
dfdb :                       df_rt_bsubaFin
dfdb : 60               [ 6] 	rts
                             
                             ; common routine push true
dfdc :                       df_rt_true
dfdc : a2ff             [ 2] 	ldx #0xff
dfde : 8a               [ 2] 	txa
dfdf : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
                             ; common routine push false
dfe2 :                       df_rt_false
dfe2 : a200             [ 2] 	ldx #0x00
dfe4 : 8a               [ 2] 	txa
dfe5 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
                             ; a < b == (a-b) < 0
dfe8 :                       df_rt_lt
dfe8 : 20e5db           [ 6] 	jsr df_rt_get2Ints
dfeb : 20c0df           [ 6] 	jsr df_rt_asubb
dfee : 30ec             [ 3] 	bmi df_rt_true
AS65 Assembler for R6502 [1.42].                                     Page  129
---------------------------------- bank1.s -----------------------------------

dff0 : 10f0             [ 3] 	bpl df_rt_false
                             
                             ; a <=b == !(b-a > 0)
dff2 :                       df_rt_lte
dff2 : 20e5db           [ 6] 	jsr df_rt_get2Ints
dff5 :                       df_rt_lte_calc
dff5 : 20cedf           [ 6] 	jsr df_rt_bsuba
dff8 : 30e8             [ 3] 	bmi df_rt_false
dffa : 10e0             [ 3] 	bpl df_rt_true
                             
                             ; a > b == (b-a) < 0
dffc :                       df_rt_gt
dffc : 20e5db           [ 6] 	jsr df_rt_get2Ints
dfff : 20cedf           [ 6] 	jsr df_rt_bsuba
e002 : 30d8             [ 4] 	bmi df_rt_true
e004 : 10dc             [ 4] 	bpl df_rt_false
                             
                             ; a >= b == (a-b >=0)
e006 :                       df_rt_gte
e006 : 20e5db           [ 6] 	jsr df_rt_get2Ints
e009 :                       df_rt_gte_calc
e009 : 20c0df           [ 6] 	jsr df_rt_asubb
e00c : 10ce             [ 4] 	bpl df_rt_true
e00e : 30d2             [ 4] 	bmi df_rt_false
                             
                             ; a == b
e010 :                       df_rt_eq
e010 : 20e5db           [ 6] 	jsr df_rt_get2Ints
e013 : 20b5df           [ 6] 	jsr df_rt_aequb
e016 : d0ca             [ 4] 	bne df_rt_false
e018 : f0c2             [ 4] 	beq df_rt_true
                             
                             ; a <> b
e01a :                       df_rt_ne
e01a : 20e5db           [ 6] 	jsr df_rt_get2Ints
e01d : 20b5df           [ 6] 	jsr df_rt_aequb
e020 : f0c0             [ 4] 	beq df_rt_false
e022 : d0b8             [ 4] 	bne df_rt_true
                             
                             ; Common usage of boolean operators for num and s
                             
e024 :                       df_rt_comlt
                             	; First find the data type on the stack
                             	_df_ost_peekType
                             
e029 : 2904             [ 2] 	and #DFST_STR
e02b : d054             [ 3] 	bne df_rt_slt
                             	; If not string then assume number
e02d : f0b9             [ 4] 	beq df_rt_lt
                             
e02f :                       df_rt_comgt
                             	; First find the data type on the stack
                             	_df_ost_peekType
                             
e034 : 2904             [ 2] 	and #DFST_STR
e036 : d050             [ 3] 	bne df_rt_sgt
                             	; If not string then assume number
e038 : f0c2             [ 4] 	beq df_rt_gt
                             
e03a :                       df_rt_comeq
                             	; First find the data type on the stack
                             	_df_ost_peekType
AS65 Assembler for R6502 [1.42].                                     Page  130
---------------------------------- bank1.s -----------------------------------

                             
e03f : 2904             [ 2] 	and #DFST_STR
e041 : d04e             [ 3] 	bne df_rt_seq
                             	; If not string then assume number
e043 : f0cb             [ 3] 	beq df_rt_eq
                             
e045 :                       df_rt_comlte
                             	; First find the data type on the stack
                             	_df_ost_peekType
                             
e04a : 2904             [ 2] 	and #DFST_STR
e04c : d018             [ 3] 	bne df_rt_slte
                             	; If not string then assume number
e04e : f0a2             [ 4] 	beq df_rt_lte
                             	
e050 :                       df_rt_comgte
                             	; First find the data type on the stack
                             	_df_ost_peekType
                             
e055 : 2904             [ 2] 	and #DFST_STR
e057 : d01a             [ 3] 	bne df_rt_sgte
                             	; If not string then assume number
e059 : f0ab             [ 3] 	beq df_rt_gte
                             
e05b :                       df_rt_comne
                             	; First find the data type on the stack
                             	_df_ost_peekType
                             
e060 : 2904             [ 2] 	and #DFST_STR
e062 : d016             [ 3] 	bne df_rt_sne
                             	; If not string then assume number
e064 : f0b4             [ 3] 	beq df_rt_ne
                             
                             
                             ;********** STRING OPS **********
                             
                             ; string less than or equal
e066 :                       df_rt_slte
e066 : 2098e0           [ 6] 	jsr df_rt_str_comp
e069 : 9005             [ 3] 	bcc df_rt_str_comp_true
e06b : f003             [ 3] 	beq df_rt_str_comp_true
e06d :                       df_rt_str_comp_false
e06d : 4ce2df           [ 3] 	jmp df_rt_false
e070 :                       df_rt_str_comp_true
e070 : 4cdcdf           [ 3] 	jmp df_rt_true	
                             
                             ; string greater then or equal	
e073 :                       df_rt_sgte
e073 : 2098e0           [ 6] 	jsr df_rt_str_comp
e076 : b0f8             [ 3] 	bcs df_rt_str_comp_true
e078 : 90f3             [ 3] 	bcc df_rt_str_comp_false
                             
                             ; string not equal
e07a :                       df_rt_sne
e07a : 2098e0           [ 6] 	jsr df_rt_str_comp
e07d : d0f1             [ 3] 	bne df_rt_str_comp_true
e07f : f0ec             [ 3] 	beq df_rt_str_comp_false
                             
                             ; string less than
e081 :                       df_rt_slt
e081 : 2098e0           [ 6] 	jsr df_rt_str_comp
e084 : 90ea             [ 3] 	bcc df_rt_str_comp_true
AS65 Assembler for R6502 [1.42].                                     Page  131
---------------------------------- bank1.s -----------------------------------

e086 : b0e5             [ 3] 	bcs df_rt_str_comp_false
                             
                             ; string greater than
e088 :                       df_rt_sgt
e088 : 2098e0           [ 6] 	jsr df_rt_str_comp
e08b : f0e0             [ 3] 	beq df_rt_str_comp_false
e08d : 90de             [ 3] 	bcc df_rt_str_comp_false
e08f : d0df             [ 3] 	bne df_rt_str_comp_true
                             
                             ; string equal
e091 :                       df_rt_seq
e091 : 2098e0           [ 6] 	jsr df_rt_str_comp
e094 : f0da             [ 3] 	beq df_rt_str_comp_true
e096 : d0d5             [ 3] 	bne df_rt_str_comp_false
                             
                             ; common string comparator
                             ; C=0 means <
                             ; C=1,Z=0 means >
                             ; C=1,Z=1 means ==
e098 :                       df_rt_str_comp
e098 : 20f4db           [ 6] 	jsr df_rt_get2Strs
e09b : a000             [ 2] 	ldy #0
e09d :                       df_rt_str_comp_byte
e09d : b1e3             [ 5] 	lda (df_tmpptra),y
e09f : d1e5             [ 5] 	cmp (df_tmpptrb),y
e0a1 : d007             [ 3] 	bne df_rt_str_comp_done
                             	; if here then both strings still the same
e0a3 : c900             [ 2] 	cmp #0				; What was op1 char
                             	; if char is zero then end
e0a5 : f003             [ 3] 	beq df_rt_str_comp_done
                             	; else do next char
e0a7 : c8               [ 2] 	iny
e0a8 : d0f3             [ 3] 	bne df_rt_str_comp_byte ; Always - relying on Y 
e0aa :                       df_rt_str_comp_done
e0aa : 60               [ 6] 	rts
                             
                             
                             
                             
e0ab :                       df_rt_monitor
e0ab : 20b6c2           [ 6] 	jsr _command_line
e0ae : 60               [ 6] 	rts
                             	
e0af :                       df_rt_new
e0af : 4c1cf3           [ 3] 	jmp df_clear
                             
                             ; df_rt_gotosub_common
                             ; 	; get line number in A,X and put in num_a
                             ; 	jsr df_rt_getnval
                             ; 	stx num_a
                             ; 	sta num_a+1
                             ; 	; For the moment start from the beginning
                             ; 	ldy df_prgstrt		; num_tmp contains starting po
                             ; 	sty num_tmp
                             ; 	ldy df_prgstrt+1
                             ; 	sty num_tmp+1
                             ; 	; if current line number > target then start f
                             ; 	; else start from this line number
                             ; 	; do a trial substract of current - target
                             ; 	sec
                             ; 	ldy #DFTK_LINNUM
                             ; 	lda (df_currlin),y
AS65 Assembler for R6502 [1.42].                                     Page  132
---------------------------------- bank1.s -----------------------------------

                             ; 	sbc num_a
                             ; 	iny
                             ; 	lda (df_currlin),y
                             ; 	sbc num_a+1
                             ; 	; if C=1 then current >= target so start from 
                             ; 	bcs df_rt_goto_find_line
                             ; 	; else use current line address
                             ; 	lda df_currlin
                             ; 	sta num_tmp
                             ; 	lda df_currlin+1
                             ; 	sta num_tmp+1
                             ; df_rt_goto_find_line
                             ; 	jsr df_pg_check_next_line	; Reuses the line fi
                             ; 	bcs df_rt_goto_not_found	; If no exact match t
                             ; 	rts							; X,A contains address of target lin
                             ; df_rt_goto_not_found
                             ; 	SWBRK DFERR_NOLINE
                             
                             ; df_rt_gosub
                             ; 	; push statement address for return
                             ; 	jsr df_rt_push_stat
                             ; 	; DFRT_WHILE token
                             ; 	lda #DFRT_GOSUB
                             ; 	jsr df_rst_pushByte
                             ; 	; *IMPORTANT* : falls through to the goto code
                             ; df_rt_goto
                             ; 	; Find the line number to goto
                             ; 	jsr df_rt_gotosub_common
                             ; 	; Save it in the next line property
                             ; 	stx df_nextlin
                             ; 	sta df_nextlin+1
                             ; 	; GOTO is from the beginning of a line only
                             ; 	ldy #3
                             ; 	sty df_nxtstidx
                             ; 	; Runtime will change flow to use next line pr
                             ; 	rts
                             
                             ; df_rt_retsub
                             ; 	; The top of stack needs to be a gosub return 
                             ; 	jsr df_rst_popByte
                             ; 	cmp #DFRT_GOSUB
                             ; 	bne df_rt_retsub_err
                             ; 	; pop the stat and continue
                             ; 	jmp df_rt_pop_stat
                             ; df_rt_retsub_err
                             ; 	SWBRK DFERR_RETURN
                             
                             
e0b2 :                       df_rt_while
                             	; push statement address
e0b2 : 200cdd           [ 6] 	jsr df_rt_push_stat
                             	; DFRT_WHILE token
e0b5 : a990             [ 2] 	lda #DFRT_WHILE
e0b7 : 207cf2           [ 6] 	jsr df_rst_pushByte
                             
                             	; get value in A,X
e0ba : 2042d9           [ 6] 	jsr df_rt_getnval
                             
                             	; if value<>0 then continue
e0bd : e000             [ 2] 	cpx #0
e0bf : f001             [ 3] 	beq df_rt_while_done
e0c1 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  133
---------------------------------- bank1.s -----------------------------------

e0c2 :                       df_rt_while_done
                             	; pop while data off stack as not needed
e0c2 : 2085f2           [ 6] 	jsr df_rst_popByte
e0c5 : 2085f2           [ 6] 	jsr df_rst_popByte
e0c8 : 20a2f2           [ 6] 	jsr df_rst_popWord
                             	; while evaluated false so find wend
                             	; but check for any nested while/wends
                             	; nest = 1 to start
e0cb : a5d5             [ 3] 	lda df_ifnest
e0cd : 48               [ 3] 	pha
e0ce : a901             [ 2] 	lda #1
e0d0 : 85d5             [ 3] 	sta df_ifnest
                             	; find the matching else/elseif/endif
                             	; start from current statement
                             	_cpyZPWord df_currlin,df_nextlin
                             
e0da :                       df_rt_findwend
e0da : a6cb             [ 3] 	ldx df_nextlin
e0dc : a5cc             [ 3] 	lda df_nextlin+1
e0de : a4c2             [ 3] 	ldy df_curstidx
e0e0 : 20dedc           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e0e3 : b030             [ 4] 	bcs df_rt_wend_end
e0e5 : 86cb             [ 3] 	stx df_nextlin
e0e7 : 85cc             [ 3] 	sta df_nextlin+1
e0e9 : 84c2             [ 3] 	sty df_curstidx
                             	; find the command token
e0eb :                       df_rt_while_cmd
e0eb : c8               [ 2] 	iny
e0ec : b1cb             [ 5] 	lda (df_nextlin),y
e0ee : 10fb             [ 3] 	bpl df_rt_while_cmd
                             	; check for wend
e0f0 : c991             [ 2] 	cmp #DFRT_WEND
e0f2 : d019             [ 4] 	bne df_rt_check_while
                             	; decrement nest
e0f4 : c6d5             [ 5] 	dec df_ifnest
                             	; if not zero then go find more commands
e0f6 : d0e2             [ 3] 	bne df_rt_findwend
                             	; else found it, restore if nest
                             	; and skip the wend statement
e0f8 : 68               [ 4] 	pla
e0f9 : 85d5             [ 3] 	sta df_ifnest
e0fb : a6cb             [ 3] 	ldx df_nextlin
e0fd : a5cc             [ 3] 	lda df_nextlin+1
e0ff : a4c2             [ 3] 	ldy df_curstidx
e101 : 20dedc           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e104 : b00f             [ 3] 	bcs df_rt_wend_end
                             	; need to update nxtstidx to transfer control
e106 : 86cb             [ 3] 	stx df_nextlin
e108 : 85cc             [ 3] 	sta df_nextlin+1
e10a : 84c1             [ 3] 	sty df_nxtstidx	
e10c : 60               [ 6] 	rts
e10d :                       df_rt_check_while
                             	; check for while
e10d : c990             [ 2] 	cmp #DFRT_WHILE
e10f : d0c9             [ 4] 	bne df_rt_findwend
                             	; if while found then increment nest
e111 : e6d5             [ 5] 	inc df_ifnest
e113 : 80c5             [ 4] 	bra df_rt_findwend
e115 :                       df_rt_wend_end
                             	SWBRK DFERR_IMMEDIATE
AS65 Assembler for R6502 [1.42].                                     Page  134
---------------------------------- bank1.s -----------------------------------

                             
                             
e117 :                       df_rt_wend
e117 : 2085f2           [ 6] 	jsr df_rst_popByte
e11a : c990             [ 2] 	cmp #DFRT_WHILE
e11c : d00d             [ 3] 	bne df_rt_wend_err
                             	; pop the stat and continue
e11e : 20a2f2           [ 6] 	jsr df_rst_popWord
e121 : 86cb             [ 3] 	stx	df_nextlin
e123 : 85cc             [ 3] 	sta df_nextlin+1
e125 : 2085f2           [ 6] 	jsr df_rst_popByte
e128 : 85c1             [ 3] 	sta df_nxtstidx
e12a : 60               [ 6] 	rts
e12b :                       df_rt_wend_err
                             	SWBRK DFERR_WEND
                             
                             
                             ;move to next statement during if/else matching
                             ;end of program is an error
e12d :                       df_rt_if_stat
e12d : a6cb             [ 3] 	ldx df_nextlin
e12f : a5cc             [ 3] 	lda df_nextlin+1
e131 : a4c2             [ 3] 	ldy df_curstidx
e133 : 20dedc           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e136 : b009             [ 3] 	bcs df_rt_if_stat_err
e138 : 86cb             [ 3] 	stx df_nextlin
e13a : 85cc             [ 3] 	sta df_nextlin+1
e13c : 84c2             [ 3] 	sty df_curstidx
e13e : 84c1             [ 3] 	sty df_nxtstidx
e140 : 60               [ 6] 	rts
                             ; program ended with no match
e141 :                       df_rt_if_stat_err
                             	SWBRK DFERR_UNCLOSEDIF
                             
                             	
                             ; find matching else/elseif/endif
                             ; C = 0 match else/elseif/endif
                             ; C = 1 match endif only
                             ; endif is always matched
                             ; ** MAKE SURE NEXTLIN IS POPULATED! **
e143 :                       df_rt_if_match
                             	; save the current if nest level
e143 : a5d5             [ 3] 	lda df_ifnest
e145 : 48               [ 3] 	pha
                             	; local if nest level is zero to start with
e146 : 64d5             [ 3] 	stz df_ifnest	
                             	; save match pref
e148 : 08               [ 3] 	php
                             	; find the matching else/elseif/endif
                             	; start from df_nextlin, df_curstidx
e149 :                       df_rt_findelseendif
e149 : 202de1           [ 6] 	jsr df_rt_if_stat
                             	; find command
e14c :                       df_rt_ifcmd
e14c : c8               [ 2] 	iny
e14d : b1cb             [ 5] 	lda (df_nextlin),y
e14f : 10fb             [ 3] 	bpl df_rt_ifcmd
                             	; check for endif
e151 : c994             [ 2] 	cmp #DFRT_ENDIF
e153 : f014             [ 3] 	beq df_rt_ifelse
                             
AS65 Assembler for R6502 [1.42].                                     Page  135
---------------------------------- bank1.s -----------------------------------

e155 : 28               [ 4] 	plp
e156 : 08               [ 3] 	php
                             	
e157 : b008             [ 3] 	bcs df_rt_ifskipelseif
e159 : c993             [ 2] 	cmp #DFRT_ELSE
e15b : f00c             [ 3] 	beq df_rt_ifelse
e15d : c995             [ 2] 	cmp #DFRT_ELSEIF
e15f : f008             [ 3] 	beq df_rt_ifelse
e161 :                       df_rt_ifskipelseif
                             	; another if token found - increment lcoal if ne
e161 : c992             [ 2] 	cmp #DFRT_IF
e163 : d002             [ 3] 	bne df_rt_skipnestif
e165 : e6d5             [ 5] 	inc df_ifnest
e167 :                       df_rt_skipnestif
                             	; no tokens of interest found, so next statement
e167 : 80e0             [ 3] 	bra df_rt_findelseendif
                             	
                             	; found else/elseif/endif
                             	; but check if this is nested
e169 :                       df_rt_ifelse
                             	; nest counter zero then found matching else/els
e169 : a6d5             [ 3] 	ldx df_ifnest
e16b : f008             [ 3] 	beq df_rt_if_found
                             	; endif token found so decrement local nest
e16d : c994             [ 2] 	cmp #DFRT_ENDIF
e16f : d002             [ 3] 	bne df_rt_skipnestendif
e171 : c6d5             [ 5] 	dec df_ifnest
e173 :                       df_rt_skipnestendif	
                             	; continue to search for else/endif
e173 : 80d4             [ 3] 	bra df_rt_findelseendif
                             	; ok got a match
e175 :                       df_rt_if_found
                             	; remove pref
e175 : 28               [ 4] 	plp
                             	; restore global if nest
e176 : fa               [ 4] 	plx
e177 : 86d5             [ 3] 	stx df_ifnest
                             
                             	;A contains the token found, Y is index in to df
                             ;	clc
e179 : 60               [ 6] 	rts
                             
e17a :                       df_rt_endif
                             	; decrement if next level
e17a : c6d5             [ 5] 	dec df_ifnest
e17c : 3011             [ 3] 	bmi df_rt_noif_err
                             ;	clc
e17e : 60               [ 6] 	rts
                             	
                             	; else and ifelse encountered in a normal sequen
                             	; only happens when the clause has been executed
                             	; so we only now need to find the endif
e17f :                       df_rt_elseif
e17f :                       df_rt_else
                             	; not in if mode then error
e17f : a5d5             [ 3] 	lda df_ifnest
e181 : f00c             [ 3] 	beq df_rt_noif_err
                             	; find endif only
                             	; starting from current line and curstidx
                             	_cpyZPWord df_currlin,df_nextlin
                             
e18b : 38               [ 2] 	sec
AS65 Assembler for R6502 [1.42].                                     Page  136
---------------------------------- bank1.s -----------------------------------

e18c : 4c43e1           [ 3] 	jmp df_rt_if_match
                             
                             ; endif/else/elseif encountered outside of an if	
e18f :                       df_rt_noif_err
                             	SWBRK DFERR_NOIF
                             
                             	
                             	; when if is encountered, the job of this routin
                             	; to determine which clause to execute, then tra
                             	; program control to that point.  in normal prog
                             	; sequence else/elseif statements will signify t
                             	; of an if construct.
e191 :                       df_rt_if
                             	; increment global if nest counter
e191 : e6d5             [ 5] 	inc df_ifnest
e193 :                       df_rt_ifeval
                             	; get value
e193 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; if value<>0 if is successful then continue nor
e196 : c900             [ 2] 	cmp #0
e198 : d035             [ 3] 	bne df_rt_if_done
e19a : e000             [ 2] 	cpx #0
e19c : d031             [ 3] 	bne df_rt_if_done
                             	; got here then if clause evaluated to false
                             	; match with else/elseif/endif
                             	; df_nextlin is used to find the clause to execu
                             	_cpyZPWord df_currlin,df_nextlin
                             
e1a6 : 18               [ 2] 	clc						
e1a7 : 2043e1           [ 6] 	jsr df_rt_if_match
                             	; A contains the token found, Y is index of this
                             
e1aa : c993             [ 2] 	cmp #DFRT_ELSE
                             	; else: df_nextlin and df_nxtstidx points to the
e1ac : f01e             [ 3] 	beq df_rt_do_else
                             
e1ae : c994             [ 2] 	cmp #DFRT_ENDIF
                             	; else: df_nextlin and df_nxtstidx points to the
e1b0 : f01d             [ 3] 	beq df_rt_if_done
                             
                             	; elif detected - increment past the token and e
                             	; make this the current line and token index
                             	_cpyZPWord df_nextlin,df_currlin
                             
                             	; move past the token and save position
e1ba : c8               [ 2] 	iny
e1bb : 5a               [ 3] 	phy
                             	; initialise statement pointer
e1bc : a4c2             [ 3] 	ldy df_curstidx
e1be : a6c8             [ 3] 	ldx df_currlin
e1c0 : a5c9             [ 3] 	lda df_currlin+1
e1c2 : 2062dc           [ 6] 	jsr df_rt_init_stat_ptr
                             	; restore Y (one byte past the token) and save i
e1c5 : 7a               [ 4] 	ply
e1c6 : 84ca             [ 3] 	sty df_exeoff
                             	; don't force a jump as we've initalised all var
e1c8 : 64cc             [ 3] 	stz df_nextlin+1
                             	; now everyting is set up to evaluate the elif c
e1ca : 80c7             [ 3] 	bra df_rt_ifeval
                             	
e1cc :                       df_rt_do_else
                             	; we need to point to the next statement not thi
AS65 Assembler for R6502 [1.42].                                     Page  137
---------------------------------- bank1.s -----------------------------------

e1cc : 202de1           [ 6] 	jsr df_rt_if_stat
e1cf :                       df_rt_if_done
                             ;	clc
e1cf : 60               [ 6] 	rts
                             	
e1d0 :                       df_rt_for
                             	; push statement address to rt stack
e1d0 : 200cdd           [ 6] 	jsr df_rt_push_stat
                             	; get lvar
e1d3 : 2091dd           [ 6] 	jsr df_rt_getlvar
                             	; Save lvar pointer
e1d6 : 48               [ 3] 	pha
e1d7 : da               [ 3] 	phx
                             
                             	; find starting value
                             	; evaluate the starting value
                             	; can't use df_rt_getnval as need to use A,X fir
e1d8 : e6ca             [ 5] 	inc df_exeoff
e1da : 2048d9           [ 6] 	jsr df_rt_neval
                             	; get ready to update the counter
e1dd : fa               [ 4] 	plx
e1de : 86e3             [ 3] 	stx df_tmpptra
e1e0 : 68               [ 4] 	pla
e1e1 : 85e4             [ 3] 	sta df_tmpptra+1
e1e3 : 48               [ 3] 	pha
e1e4 : da               [ 3] 	phx
                             	; get the starting value from op stack
e1e5 : 20daf2           [ 6] 	jsr df_ost_popInt
                             	; save it to counter slot
e1e8 : a001             [ 2] 	ldy #1
e1ea : 91e3             [ 5] 	sta (df_tmpptra),y
e1ec : 8a               [ 2] 	txa
e1ed : 88               [ 2] 	dey
e1ee : 92e3             [ 5] 	sta (df_tmpptra)
                             
                             	; find end value
                             	; evaluate the end value
e1f0 : e6ca             [ 5] 	inc df_exeoff
e1f2 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; and put on rt stack
e1f5 : 2094f2           [ 6] 	jsr df_rst_pushWord
                             
                             	; find step value
                             	; evaluate the end value
e1f8 : e6ca             [ 5] 	inc df_exeoff
e1fa : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; and push on rt stack
e1fd : 2094f2           [ 6] 	jsr df_rst_pushWord
                             	; save the counter slot address
e200 : fa               [ 4] 	plx
e201 : 68               [ 4] 	pla
e202 : 2094f2           [ 6] 	jsr df_rst_pushWord
                             	; all done - counter set to start
                             	; stack contains counter slot, step val, end val
                             	; now push for token
e205 : a98e             [ 2] 	lda #DFRT_FOR
e207 : 4c7cf2           [ 3] 	jmp df_rst_pushByte
                             ;	rts
                             
e20a :                       df_rt_next
                             	; remember stack position
e20a : a4b8             [ 3] 	ldy df_rtstop
AS65 Assembler for R6502 [1.42].                                     Page  138
---------------------------------- bank1.s -----------------------------------

e20c : 5a               [ 3] 	phy
e20d : 2085f2           [ 6] 	jsr df_rst_popByte
e210 : c98e             [ 2] 	cmp #DFRT_FOR
e212 : d04f             [ 3] 	bne df_rt_next_err
                             	; get the slot address
e214 : 20a2f2           [ 6] 	jsr df_rst_popWord
                             	; save address to ptrd, contents to ptra
e217 : 86e9             [ 3] 	stx df_tmpptrd
e219 : 85ea             [ 3] 	sta df_tmpptrd+1
e21b : b2e9             [ 5] 	lda (df_tmpptrd)
e21d : 85e3             [ 3] 	sta df_tmpptra
e21f : a001             [ 2] 	ldy #1
e221 : b1e9             [ 5] 	lda (df_tmpptrd),y
e223 : 85e4             [ 3] 	sta df_tmpptra+1
                             	
                             	; get step value, save in ptrb
e225 : 20a2f2           [ 6] 	jsr df_rst_popWord
e228 : 86e5             [ 3] 	stx df_tmpptrb
e22a : 85e6             [ 3] 	sta df_tmpptrb+1
e22c : 48               [ 3] 	pha					; Push A to check for -ve step
                             
                             	; add step to counter and save back to counter
                             	_addZPWord df_tmpptra,df_tmpptrb
                             
e23a : a5e3             [ 3] 	lda df_tmpptra
e23c : 92e9             [ 5] 	sta (df_tmpptrd)
e23e : a001             [ 2] 	ldy #1
e240 : a5e4             [ 3] 	lda df_tmpptra+1
e242 : 91e9             [ 5] 	sta (df_tmpptrd),y
                             	
                             	; get end value, save in ptrb
e244 : 20a2f2           [ 6] 	jsr df_rst_popWord
e247 : 86e5             [ 3] 	stx df_tmpptrb
e249 : 85e6             [ 3] 	sta df_tmpptrb+1
e24b : 68               [ 4] 	pla					; check if if +ve or -ve step
e24c : 1005             [ 3] 	bpl df_rt_check_pos
                             	; call gte operation but no need to get ints
                             	; as already in ptra and ptrb
e24e : 2009e0           [ 6] 	jsr df_rt_gte_calc
e251 : 8003             [ 3] 	bra df_rt_next_check
e253 :                       df_rt_check_pos	
                             	; call lte operation but no need to get ints
                             	; as already in ptra and ptrb
e253 : 20f5df           [ 6] 	jsr df_rt_lte_calc
e256 :                       df_rt_next_check
                             	; check if true or false
e256 : 20daf2           [ 6] 	jsr df_ost_popInt
e259 : e000             [ 2] 	cpx #0
                             	; if false then next is done
e25b : f003             [ 3] 	beq df_next_done
                             	; else we continue
e25d : 4caddd           [ 3] 	jmp df_rt_pop_stat_go
                             	; if done, then continue with next statement
e260 :                       df_next_done
e260 : 4c81e2           [ 3] 	jmp df_rt_untilnext_done
                             	
e263 :                       df_rt_next_err
                             	SWBRK DFERR_NEXTFOR
                             
                             
                             	
e265 :                       df_rt_repeat
AS65 Assembler for R6502 [1.42].                                     Page  139
---------------------------------- bank1.s -----------------------------------

                             	; push statement address
e265 : 200cdd           [ 6] 	jsr df_rt_push_stat
                             	; DFRT_REPEAT token
e268 : a98c             [ 2] 	lda #DFRT_REPEAT
e26a : 4c7cf2           [ 3] 	jmp df_rst_pushByte
                             ;	rts
                             	
e26d :                       df_rt_until
                             	; remember stack position
e26d : a4b8             [ 3] 	ldy df_rtstop
e26f : 5a               [ 3] 	phy
e270 : 2085f2           [ 6] 	jsr df_rst_popByte
e273 : c98c             [ 2] 	cmp #DFRT_REPEAT
e275 : d011             [ 3] 	bne df_rt_until_err
                             	; evaluate expression in to A,X
e277 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; if value<>0 then continue
e27a : e000             [ 2] 	cpx #0
e27c : d003             [ 3] 	bne df_rt_untilnext_done
                             
                             	; pop the stat and continue
e27e : 4caddd           [ 3] 	jmp df_rt_pop_stat_go
                             
e281 :                       df_rt_untilnext_done
e281 : 7a               [ 4] 	ply
                             	; pop 2 items off stack (line address, index)
e282 : 20a2f2           [ 6] 	jsr df_rst_popWord
e285 : 4c85f2           [ 3] 	jmp df_rst_popByte
                             	; and continue
                             ;	clc
                             ;	rts
                             
e288 :                       df_rt_until_err
                             	SWBRK DFERR_UNTIL
                             
                             	
e28a :                       df_rt_sadd
                             ;	clc
e28a : 60               [ 6] 	rts
                             	
e28b :                       df_rt_print_num
e28b : 20daf2           [ 6] 	jsr df_ost_popInt
e28e : 18               [ 2] 	clc
e28f : 4c5acb           [ 3] 	jmp print_a_to_d
                             ;	rts
                             	
e292 :                       df_rt_print_str
e292 : 20d2f2           [ 6] 	jsr df_ost_popStr
e295 : 86e3             [ 3] 	stx df_tmpptra
e297 : 85e4             [ 3] 	sta df_tmpptra+1
e299 : a000             [ 2] 	ldy #0
e29b :                       df_rt_print_str_ch
e29b : b1e3             [ 5] 	lda (df_tmpptra),y
e29d : f006             [ 3] 	beq df_rt_print_str_done
e29f : 20c0c5           [ 6] 	jsr io_put_ch
e2a2 : c8               [ 2] 	iny
e2a3 : 80f6             [ 3] 	bra df_rt_print_str_ch
e2a5 :                       df_rt_print_str_done
                             ;	clc
e2a5 : 60               [ 6] 	rts
                             
                             ; * Find the position of the next data item to re
AS65 Assembler for R6502 [1.42].                                     Page  140
---------------------------------- bank1.s -----------------------------------

e2a6 :                       df_rt_nextdatum
e2a6 : a200             [ 2] 	ldx #0
                             	; load data line offset
e2a8 : a4d8             [ 3] 	ldy df_datoff
                             	; if data pointer unitialised (because high byte
e2aa : a5d7             [ 3] 	lda df_currdat+1
e2ac : d02e             [ 3] 	bne df_rt_skipinitdataptr
                             	; then start at program beginning
                             	_cpyZPWord df_prgstrt,df_currdat
                             
e2b6 :                       df_rt_datlinstart
                             	; if end of program then error
e2b6 : a1d6             [ 6] 	lda (df_currdat,x)
e2b8 : f032             [ 3] 	beq df_rt_datumerr
                             	; index in to first line byte
e2ba : a003             [ 2] 	ldy #3
e2bc : 84d8             [ 3] 	sty df_datoff
                             	; find first 'data' statement
e2be :                       df_rt_datastatement
e2be : c8               [ 2] 	iny
e2bf : 98               [ 2] 	tya
                             	; end of line reached?
e2c0 : c1d6             [ 6] 	cmp (df_currdat,x)
                             	; if not find data token
e2c2 : d00e             [ 3] 	bne df_rt_getdatatk
e2c4 :                       df_rt_datnextlin
                             	; if so then go to next line
e2c4 : 18               [ 2] 	clc
e2c5 : a5d6             [ 3] 	lda df_currdat
e2c7 : 61d6             [ 6] 	adc (df_currdat,x)
e2c9 : 85d6             [ 3] 	sta df_currdat
                             	_bcc 2
                             
e2cd : e6d7             [ 5] 	inc df_currdat+1
e2cf : 4cb6e2           [ 3] 	jmp df_rt_datlinstart
e2d2 :                       df_rt_getdatatk
e2d2 : b1d6             [ 5] 	lda (df_currdat),y
e2d4 : 10e8             [ 3] 	bpl df_rt_datastatement
                             	; found data statement?
e2d6 : c996             [ 2] 	cmp #DFRT_DATA
                             	; if not then go to next line
e2d8 : d0ea             [ 3] 	bne df_rt_datnextlin
e2da : 84d8             [ 3] 	sty df_datoff
e2dc :                       df_rt_skipinitdataptr
e2dc : 98               [ 2] 	tya
                             	; end of line reached?
e2dd : c1d6             [ 6] 	cmp (df_currdat,x)
                             	; if so go to next line
e2df : f0e3             [ 3] 	beq df_rt_datnextlin
                             	; else see if escape value
e2e1 : b1d6             [ 5] 	lda (df_currdat),y
e2e3 : c920             [ 2] 	cmp #DFTK_ESCVAL
e2e5 : c8               [ 2] 	iny
e2e6 : b0f4             [ 3] 	bcs df_rt_skipinitdataptr
                             	; ok found an escape value
                             	; save position and return
e2e8 : 88               [ 2] 	dey
e2e9 : 84d8             [ 3] 	sty df_datoff
e2eb : 60               [ 6] 	rts
e2ec :                       df_rt_datumerr
                             	SWBRK DFERR_NODATA
                             
AS65 Assembler for R6502 [1.42].                                     Page  141
---------------------------------- bank1.s -----------------------------------

                             
                             ; read a datum
e2ee :                       df_rt_readdatum
                             	; update data pointer to next data item
e2ee : 20a6e2           [ 6] 	jsr df_rt_nextdatum
                             	; now get lvar X,A from current statement
e2f1 : 2091dd           [ 6] 	jsr df_rt_getlvar
                             	; save lvar in tmpb, vvt ptr in tmpa
e2f4 : 86e5             [ 3] 	stx df_tmpptrb
e2f6 : 85e6             [ 3] 	sta df_tmpptrb+1
                             
                             	; first save save current prgoram line and offse
e2f8 : a5c8             [ 3] 	lda df_currlin
e2fa : 48               [ 3] 	pha
e2fb : a5c9             [ 3] 	lda df_currlin+1
e2fd : 48               [ 3] 	pha
e2fe : a5ca             [ 3] 	lda df_exeoff
e300 : 48               [ 3] 	pha
e301 : a5c0             [ 3] 	lda df_eolidx
e303 : 48               [ 3] 	pha
e304 : a5c1             [ 3] 	lda df_nxtstidx
e306 : 48               [ 3] 	pha
e307 : a5c2             [ 3] 	lda df_curstidx
e309 : 48               [ 3] 	pha
                             
                             	; use data pointer as current position for evalu
                             	_cpyZPWord df_currdat,df_currlin
                             
e312 : a5d8             [ 3] 	lda df_datoff
e314 : 85ca             [ 3] 	sta df_exeoff
e316 : a200             [ 2] 	ldx #0
e318 : a1d6             [ 6] 	lda (df_currdat,x)
e31a : 85c0             [ 3] 	sta df_eolidx
e31c : 85c1             [ 3] 	sta df_nxtstidx
e31e : a903             [ 2] 	lda #3
e320 : 85c2             [ 3] 	sta df_curstidx
                             
                             	; get type from vvt ptr in tmpa
e322 : a1e3             [ 6] 	lda (df_tmpptra,x)
e324 : a8               [ 2] 	tay
                             	; get lvar point from tmpb
e325 : a6e5             [ 3] 	ldx df_tmpptrb
e327 : a5e6             [ 3] 	lda df_tmpptrb+1
                             
                             	; X,A and Y set up, now evaluate and perform ass
e329 : 2028e6           [ 6] 	jsr df_rt_doassign
                             
                             	; update data offset as data has been consumed
e32c : a5ca             [ 3] 	lda df_exeoff
e32e : 85d8             [ 3] 	sta df_datoff
                             	; restore line settings
e330 : 68               [ 4] 	pla
e331 : 85c2             [ 3] 	sta df_curstidx
e333 : 68               [ 4] 	pla
e334 : 85c1             [ 3] 	sta df_nxtstidx
e336 : 68               [ 4] 	pla
e337 : 85c0             [ 3] 	sta df_eolidx
e339 : 68               [ 4] 	pla
e33a : 85ca             [ 3] 	sta df_exeoff
e33c : 68               [ 4] 	pla
e33d : 85c9             [ 3] 	sta df_currlin+1
e33f : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page  142
---------------------------------- bank1.s -----------------------------------

e340 : 85c8             [ 3] 	sta df_currlin
e342 : 60               [ 6] 	rts
                             
                             
e343 :                       df_rt_read
                             	; find variable to read in to from current posit
e343 : a4ca             [ 3] 	ldy df_exeoff
e345 :                       df_rt_read_find_var
e345 : c8               [ 2] 	iny
                             	; if end of line or statement then done
                             ;	cpy df_eolidx
                             ;	beq df_rt_read_done
e346 : c4c1             [ 3] 	cpy df_nxtstidx
e348 : f00e             [ 3] 	beq df_rt_read_done
                             	; if not found escape then next byte
e34a : b1c8             [ 5] 	lda (df_currlin),y
e34c : c920             [ 2] 	cmp #DFTK_ESCVAL
e34e : b0f5             [ 3] 	bcs df_rt_read_find_var
                             	; ok found escape, save position
e350 : 84ca             [ 3] 	sty df_exeoff
                             	; go and read in the value
e352 : 20eee2           [ 6] 	jsr df_rt_readdatum
                             	; try find another variable
e355 : 4c43e3           [ 3] 	jmp df_rt_read
                             
e358 :                       df_rt_read_done
                             	; save position
e358 : 84ca             [ 3] 	sty df_exeoff
e35a : 60               [ 6] 	rts
                             
                             
e35b :                       df_rt_input
                             	; df_tmpptra has the vvt address, X,A is the lva
e35b : 2091dd           [ 6] 	jsr df_rt_getlvar
                             	; Save lvar pointer
e35e : 86e5             [ 3] 	stx df_tmpptrb
e360 : 85e6             [ 3] 	sta df_tmpptrb+1
e362 : a078             [ 2] 	ldy #120
                             	; go read a line of input
                             	; X,A is ptr has the input, Y is size
e364 : 38               [ 2] 	sec
e365 : 20cfc5           [ 6] 	jsr io_read_line
                             	; check the type
e368 : b2e3             [ 5] 	lda (df_tmpptra)
e36a : 2904             [ 2] 	and #DFVVT_STR
e36c : d008             [ 3] 	bne df_rt_input_str
e36e : b2e3             [ 5] 	lda (df_tmpptra)
e370 : 2903             [ 2] 	and #DFVVT_INT|DFVVT_BYT
e372 : d003             [ 3] 	bne df_rt_input_num
                             	; if not int or byte then error
e374 : 8018             [ 3] 	bra df_rt_input_err
e376 :                       df_rt_input_str
                             	; If string then done!
                             ;	clc
e376 : 60               [ 6] 	rts
                             
e377 :                       df_rt_input_num
                             	; X,A = address from tmpb, linbuff must be on pa
e377 : a6e5             [ 3] 	ldx df_tmpptrb
e379 : a5e6             [ 3] 	lda df_tmpptrb+1
e37b : a000             [ 2] 	ldy #0				; any numeric format
e37d : 201bc9           [ 6] 	jsr con_n_to_a
AS65 Assembler for R6502 [1.42].                                     Page  143
---------------------------------- bank1.s -----------------------------------

e380 : b00c             [ 3] 	bcs df_rt_input_err
e382 : a000             [ 2] 	ldy #0
e384 : a585             [ 3] 	lda num_a
e386 : 91e5             [ 5] 	sta (df_tmpptrb),y
e388 : c8               [ 2] 	iny
e389 : a586             [ 3] 	lda num_a+1
e38b : 91e5             [ 5] 	sta (df_tmpptrb),y
                             ;	clc
e38d : 60               [ 6] 	rts
e38e :                       df_rt_input_err
                             	SWBRK DFERR_TYPEMISM
                             
                             	
e390 :                       df_rt_local
                             	; get current local count off rt stack
e390 : 2085f2           [ 6] 	jsr df_rst_popByte
                             	; save on pc stack for incrmenting
e393 : 48               [ 3] 	pha
e394 : a4ca             [ 3] 	ldy df_exeoff
e396 : 88               [ 2] 	dey
e397 :                       df_rt_local_findesc
e397 : c8               [ 2] 	iny
                             	; check end of line
                             ;	cpy df_eolidx
                             ;	beq df_rt_local_done
e398 : c4c1             [ 3] 	cpy df_nxtstidx
e39a : f019             [ 3] 	beq df_rt_local_done
                             	; find a var
e39c : b1c8             [ 5] 	lda (df_currlin),y
e39e : c911             [ 2] 	cmp #DFTK_VAR
e3a0 : d0f5             [ 3] 	bne df_rt_local_findesc
                             	; jump over escape value
e3a2 : c8               [ 2] 	iny
                             	; get var slot in A,X
e3a3 : b1c8             [ 5] 	lda (df_currlin),y
e3a5 : aa               [ 2] 	tax
e3a6 : c8               [ 2] 	iny
e3a7 : b1c8             [ 5] 	lda (df_currlin),y
e3a9 : 84ca             [ 3] 	sty df_exeoff
                             	; localise this variable
e3ab : 2068f2           [ 6] 	jsr df_rt_proc_local
                             	; increment local counter
e3ae : 68               [ 4] 	pla
e3af : 1a               [ 2] 	inc a
e3b0 : 48               [ 3] 	pha
e3b1 : a4ca             [ 3] 	ldy df_exeoff
e3b3 : 80e2             [ 3] 	bra df_rt_local_findesc
e3b5 :                       df_rt_local_done
                             	; get the local counter
                             	; put on to rt stack
e3b5 : 68               [ 4] 	pla
e3b6 : 4c7cf2           [ 3] 	jmp df_rst_pushByte
                             ;	clc
                             ;	rts
                             	
e3b9 :                       df_rt_redim
e3b9 : 38               [ 2] 	sec
e3ba : b001             [ 3] 	bcs df_rt_dim_main
e3bc :                       df_rt_dim
e3bc : 18               [ 2] 	clc
e3bd :                       df_rt_dim_main
e3bd : 08               [ 3] 	php
AS65 Assembler for R6502 [1.42].                                     Page  144
---------------------------------- bank1.s -----------------------------------

e3be :                       df_rt_dim_loop
e3be : a4ca             [ 3] 	ldy df_exeoff
e3c0 : 88               [ 2] 	dey
e3c1 :                       df_rt_dim_findesc
                             	; check end of line
e3c1 : c8               [ 2] 	iny
                             ;	cpy df_eolidx
                             ;	beq df_rt_dim_done
e3c2 : c4c1             [ 3] 	cpy df_nxtstidx
e3c4 : f076             [ 4] 	beq df_rt_dim_done
                             	; find a var
e3c6 : b1c8             [ 5] 	lda (df_currlin),y
e3c8 : c911             [ 2] 	cmp #DFTK_VAR
e3ca : d0f5             [ 3] 	bne df_rt_dim_findesc
                             	; jump over escape value
e3cc : c8               [ 2] 	iny
                             	; get var address
e3cd : b1c8             [ 5] 	lda (df_currlin),y
e3cf : 85e3             [ 3] 	sta df_tmpptra
e3d1 : c8               [ 2] 	iny
e3d2 : b1c8             [ 5] 	lda (df_currlin),y
e3d4 : 85e4             [ 3] 	sta df_tmpptra+1
                             	; move to open bracket
e3d6 : c8               [ 2] 	iny
e3d7 : 84ca             [ 3] 	sty df_exeoff
                             	; If re-dim, don't check for existing dimensions
e3d9 : 28               [ 4] 	plp
e3da : 08               [ 3] 	php
e3db : b006             [ 3] 	bcs df_rt_skip_dim_chk
                             	; check if already dim'd
e3dd : a003             [ 2] 	ldy #DFVVT_DIM1
e3df : b1e3             [ 5] 	lda (df_tmpptra),y
e3e1 : d05b             [ 4] 	bne df_rt_dim_err
e3e3 :                       df_rt_skip_dim_chk
                             	; Save slot address found earlier
e3e3 : a5e3             [ 3] 	lda df_tmpptra
e3e5 : 48               [ 3] 	pha
e3e6 : a5e4             [ 3] 	lda df_tmpptra+1
e3e8 : 48               [ 3] 	pha
e3e9 : 20beda           [ 6] 	jsr df_rt_arry_parm2
                             	; Restore slot address
e3ec : 68               [ 4] 	pla
e3ed : 85e4             [ 3] 	sta df_tmpptra+1
e3ef : 68               [ 4] 	pla
e3f0 : 85e3             [ 3] 	sta df_tmpptra
                             ;	bcs df_rt_dim_err
                             	; save x,y to dim1,2
e3f2 : 5a               [ 3] 	phy
e3f3 : da               [ 3] 	phx
e3f4 : a003             [ 2] 	ldy #DFVVT_DIM1
e3f6 : 68               [ 4] 	pla
e3f7 : 91e3             [ 5] 	sta (df_tmpptra),y
e3f9 : c8               [ 2] 	iny
e3fa : 68               [ 4] 	pla
e3fb : 91e3             [ 5] 	sta (df_tmpptra),y	
e3fd : 28               [ 4] 	plp
e3fe : 08               [ 3] 	php
e3ff : b02f             [ 4] 	bcs df_rt_dim_set_type
e401 :                       df_rt_dim_alloc
                             	; ok we have up to 2 dimensions
                             	; mult dim 1 and 2 if dim 2 <> 0
e401 : a003             [ 2] 	ldy #DFVVT_DIM1
AS65 Assembler for R6502 [1.42].                                     Page  145
---------------------------------- bank1.s -----------------------------------

e403 : b1e3             [ 5] 	lda (df_tmpptra),y
e405 : 8585             [ 3] 	sta num_a
e407 : 6486             [ 3] 	stz num_a+1
e409 : c8               [ 2] 	iny
e40a : b1e3             [ 5] 	lda (df_tmpptra),y
e40c : d002             [ 3] 	bne df_rt_dim2_nz
e40e : a901             [ 2] 	lda #1
e410 :                       df_rt_dim2_nz
e410 : 8589             [ 3] 	sta num_b
e412 : 648a             [ 3] 	stz num_b+1
e414 : 2015cc           [ 6] 	jsr int_fast_mult
                             	; check the type if int then mult2
e417 : b2e3             [ 5] 	lda (df_tmpptra)
e419 : 2901             [ 2] 	and #DFVVT_INT
e41b : f004             [ 3] 	beq df_rt_dim2_mul2
e41d : 0685             [ 5] 	asl num_a
e41f : 2686             [ 5] 	rol num_a+1
e421 :                       df_rt_dim2_mul2	
                             	; finally, we have a size of array
e421 : a685             [ 3] 	ldx num_a
e423 : a586             [ 3] 	lda num_a+1
                             
                             	; get a block of that size from heap
e425 : 20f7f2           [ 6] 	jsr df_st_malloc
                             	; save pointer to block in var
e428 : a002             [ 2] 	ldy #DFVVT_HI
e42a : 91e3             [ 5] 	sta (df_tmpptra),y
e42c : 8a               [ 2] 	txa
e42d : 88               [ 2] 	dey
e42e : 91e3             [ 5] 	sta (df_tmpptra),y
                             	; finally, update the type to indicate array
e430 :                       df_rt_dim_set_type
e430 : b2e3             [ 5] 	lda (df_tmpptra)
e432 : 0980             [ 2] 	ora #DFVVT_PTR
e434 : 92e3             [ 5] 	sta (df_tmpptra)
                             	; don't increment byte again - go check for more
e436 : 8086             [ 4] 	bra df_rt_dim_loop	
e438 :                       df_rt_dim_next_byte
e438 : e6ca             [ 5] 	inc df_exeoff
e43a : 8080             [ 4] 	bra df_rt_dim
e43c :                       df_rt_dim_done
                             ;	clc
e43c : 28               [ 4] 	plp
e43d : 60               [ 6] 	rts
e43e :                       df_rt_dim_err
                             	SWBRK DFERR_DIM
                             
                             
e440 :                       df_rt_cls
                             	; set cursror position to top left first
e440 : a200             [ 2] 	ldx #0
e442 : a000             [ 2] 	ldy #0
e444 : 20a6c3           [ 6] 	jsr _gr_set_cur
e447 : 4ccec2           [ 3] 	jmp _gr_cls
                             ;	clc
                             ;	rts
                             	
e44a :                       df_rt_plot
                             	; evaluate the expression
e44a : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; save lo byte
e44d : da               [ 3] 	phx
AS65 Assembler for R6502 [1.42].                                     Page  146
---------------------------------- bank1.s -----------------------------------

                             	; jump over comma
e44e : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the expression
e450 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; save lo byte
e453 : da               [ 3] 	phx
                             	; jump over comma
e454 : e6ca             [ 5] 	inc df_exeoff
                             	; evaluate the expression
e456 : 2048d9           [ 6] 	jsr df_rt_neval
                             	; check the type on the stack
                             	_df_ost_peekType
                             
                             	; if >=0x80 then a pointer / string
e45e : 2904             [ 2] 	and #DFST_STR
e460 : d014             [ 3] 	bne df_rt_plotstr
                             	; else it is int
e462 : 20daf2           [ 6] 	jsr df_ost_popInt
                             	; put low byte of pop result in a
e465 : 8a               [ 2] 	txa
e466 : a622             [ 3] 	ldx vdp_base+vdp_gmode	; Check if in hires mode
e468 : e010             [ 2] 	cpx #0x10
e46a : b005             [ 3] 	bcs df_rt_hchar
                             	; get y and x in that order
e46c : 7a               [ 4] 	ply
e46d : fa               [ 4] 	plx
e46e : 4c46c3           [ 3] 	jmp _gr_plot
e471 :                       df_rt_hchar
                             	; get y and x in that order
e471 : 7a               [ 4] 	ply
e472 : fa               [ 4] 	plx
e473 : 4c5ec3           [ 3] 	jmp _gr_hchar
                             
e476 :                       df_rt_plotstr
                             	; pop string pointer
e476 : 20d6f2           [ 6] 	jsr df_ost_popPtr
                             	; save pointer to tmpa
e479 : 86e3             [ 3] 	stx df_tmpptra
e47b : 85e4             [ 3] 	sta df_tmpptra+1
e47d : a422             [ 3] 	ldy vdp_base+vdp_gmode	; Check if in hires mode
e47f : c010             [ 2] 	cpy #0x10
e481 : b017             [ 3] 	bcs df_rt_hplotstr
                             	; get y and x in that order
e483 : 7a               [ 4] 	ply
e484 : fa               [ 4] 	plx
                             	; set cursror position
e485 :                       df_rt_plotstrch
e485 : b2e3             [ 5] 	lda (df_tmpptra)
e487 : f010             [ 3] 	beq df_rt_plotstrdone
                             	_incZPWord df_tmpptra
                             
e48f : da               [ 3] 	phx
e490 : 5a               [ 3] 	phy
e491 : 2046c3           [ 6] 	jsr _gr_plot
e494 : 7a               [ 4] 	ply
e495 : fa               [ 4] 	plx
e496 : e8               [ 2] 	inx
e497 : 80ec             [ 3] 	bra df_rt_plotstrch
e499 :                       df_rt_plotstrdone
e499 : 60               [ 6] 	rts
e49a :                       df_rt_hplotstr
                             	; get y and x in that order
AS65 Assembler for R6502 [1.42].                                     Page  147
---------------------------------- bank1.s -----------------------------------

e49a : 7a               [ 4] 	ply
e49b : fa               [ 4] 	plx
                             	; set cursror position
e49c :                       df_rt_hplotstrch
e49c : b2e3             [ 5] 	lda (df_tmpptra)
e49e : f0f9             [ 3] 	beq df_rt_plotstrdone
                             	_incZPWord df_tmpptra
                             
e4a6 : da               [ 3] 	phx
e4a7 : 5a               [ 3] 	phy
e4a8 : 205ec3           [ 6] 	jsr _gr_hchar
e4ab : 7a               [ 4] 	ply
e4ac : 68               [ 4] 	pla
e4ad : 18               [ 2] 	clc			; Assume pitch 8 for now
e4ae : 6908             [ 2] 	adc #8
e4b0 : aa               [ 2] 	tax
e4b1 : 80e9             [ 3] 	bra df_rt_hplotstrch
                             
e4b3 :                       df_rt_cursor
                             	; evaluate the expression
e4b3 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; write low byte of vdp_curoff
                             	; by writing a zero then cursor on else not
e4b6 : 8612             [ 3] 	stx vdp_curoff
                             ;	clc
e4b8 : 60               [ 6] 	rts
                             		
e4b9 :                       df_rt_himem
                             	; evaluate the expression
e4b9 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; write X,A to df_memtop
e4bc : 8ea70c           [ 4] 	stx df_memtop
e4bf : 8da80c           [ 4] 	sta df_memtop+1
                             	; now clear everything down
e4c2 : 4c1cf3           [ 3] 	jmp df_clear
e4c5 : 60               [ 6] 	rts
                             
e4c6 :                       df_rt_mode
e4c6 :                       df_rt_hires
                             	; evaluate the expression
e4c6 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; only interested in low byte
e4c9 : 8a               [ 2] 	txa
e4ca : 4cc6c1           [ 3] 	jmp _gr_init_screen
                             	
e4cd :                       df_rt_pixmode
                             	; evaluate the expression X = mode
e4cd : 2042d9           [ 6] 	jsr df_rt_getnval
e4d0 : 862e             [ 3] 	stx gr_scrngeom+gr_pixmode
                             ;	clc
e4d2 : 60               [ 6] 	rts
                             
e4d3 :                       df_rt_pixmask
                             	; evaluate the expression X = mask
e4d3 : 2042d9           [ 6] 	jsr df_rt_getnval
e4d6 : 862f             [ 3] 	stx gr_scrngeom+gr_pixmask
                             ;	clc
e4d8 : 60               [ 6] 	rts
                             
e4d9 :                       df_rt_pixcol
                             	; evaluate the expression X = col
e4d9 : 2042d9           [ 6] 	jsr df_rt_getnval
AS65 Assembler for R6502 [1.42].                                     Page  148
---------------------------------- bank1.s -----------------------------------

e4dc : 8630             [ 3] 	stx gr_scrngeom+gr_pixcol
                             ;	clc
e4de : 60               [ 6] 	rts
                             
e4df :                       df_rt_put
                             	; evaluate the byte to put
e4df : 2042d9           [ 6] 	jsr df_rt_getnval
e4e2 : 8a               [ 2] 	txa
e4e3 : 20c0c5           [ 6] 	jsr io_put_ch
e4e6 : 60               [ 6] 	rts
                             
e4e7 :                       df_rt_point
e4e7 : 2003dc           [ 6] 	jsr df_rt_parm_2ints
e4ea : a6e3             [ 3] 	ldx df_tmpptra
e4ec : a4e5             [ 3] 	ldy df_tmpptrb
e4ee : 4c76c3           [ 3] 	jmp _gr_point
                             ;	clc
                             ;	rts
                             
e4f1 :                       df_rt_hplot
e4f1 : 200edc           [ 6] 	jsr df_rt_parm_3ints
e4f4 : a6e3             [ 3] 	ldx df_tmpptra				; load x
e4f6 : a4e5             [ 3] 	ldy	df_tmpptrb				; load y
e4f8 : a5e7             [ 3] 	lda df_tmpptrc				; load char
e4fa : 4c5ec3           [ 3] 	jmp _gr_hchar
                             
e4fd :                       df_rt_circle
e4fd : 200edc           [ 6] 	jsr df_rt_parm_3ints
e500 : a5e3             [ 3] 	lda df_tmpptra				; load x0
e502 : 8585             [ 3] 	sta num_a
e504 : a5e5             [ 3] 	lda	df_tmpptrb				; load y0
e506 : 8586             [ 3] 	sta num_a+1
e508 : a5e7             [ 3] 	lda df_tmpptrc				; load r
e50a : 8587             [ 3] 	sta num_a+2
e50c : 4c2ec3           [ 3] 	jmp _gr_circle
                             
e50f :                       df_rt_line
e50f : 2025dc           [ 6] 	jsr df_rt_parm_4ints
e512 : a5e3             [ 3] 	lda df_tmpptra				; load x0
e514 : 8585             [ 3] 	sta num_a
e516 : a5e5             [ 3] 	lda	df_tmpptrb				; load y0
e518 : 8586             [ 3] 	sta num_a+1
e51a : a5e7             [ 3] 	lda df_tmpptrc				; load x1
e51c : 8587             [ 3] 	sta num_a+2
e51e : a5e9             [ 3] 	lda df_tmpptrd				; load y1
e520 : 8588             [ 3] 	sta num_a+3
e522 : 4cfec2           [ 3] 	jmp _gr_line
                             
e525 :                       df_rt_box
e525 : 2025dc           [ 6] 	jsr df_rt_parm_4ints
e528 : a5e3             [ 3] 	lda df_tmpptra				; load x0
e52a : 8585             [ 3] 	sta num_a
e52c : a5e5             [ 3] 	lda	df_tmpptrb				; load y0
e52e : 8586             [ 3] 	sta num_a+1
e530 : a5e7             [ 3] 	lda df_tmpptrc				; load x1
e532 : 8587             [ 3] 	sta num_a+2
e534 : a5e9             [ 3] 	lda df_tmpptrd				; load y1
e536 : 8588             [ 3] 	sta num_a+3
e538 : 4c16c3           [ 3] 	jmp _gr_box
                             
e53b :                       df_rt_shape
e53b : 200edc           [ 6] 	jsr df_rt_parm_3ints
AS65 Assembler for R6502 [1.42].                                     Page  149
---------------------------------- bank1.s -----------------------------------

e53e : a6e3             [ 3] 	ldx df_tmpptra				; load x
e540 : da               [ 3] 	phx
e541 : a4e5             [ 3] 	ldy	df_tmpptrb				; load y
e543 : 5a               [ 3] 	phy
e544 : a6e7             [ 3] 	ldx df_tmpptrc				; load coords[]
e546 : a5e8             [ 3] 	lda df_tmpptrc+1			; load coords[]
e548 : 2094f2           [ 6] 	jsr df_rst_pushWord
e54b :                       df_rt_shapeLoop
e54b : 20a2f2           [ 6] 	jsr df_rst_popWord			; Get pointer
e54e : 86e3             [ 3] 	stx df_tmpptra
e550 : 85e4             [ 3] 	sta df_tmpptra+1
e552 : b2e3             [ 5] 	lda (df_tmpptra)			; Get X coord as int
e554 : 853f             [ 3] 	sta tmp_v1
e556 : a001             [ 2] 	ldy #1
e558 : b1e3             [ 5] 	lda (df_tmpptra),y			; Get X hi byte
e55a : 8540             [ 3] 	sta tmp_v1+1
e55c : c8               [ 2] 	iny
e55d : b1e3             [ 5] 	lda (df_tmpptra),y			; Get Y coord as int
e55f : 8543             [ 3] 	sta tmp_b
e561 : c8               [ 2] 	iny
e562 : b1e3             [ 5] 	lda (df_tmpptra),y			; Get Y hi byte
e564 : 8544             [ 3] 	sta tmp_b+1
e566 : a53f             [ 3] 	lda tmp_v1					; If X and Y low are zero then en
e568 : d007             [ 3] 	bne df_rt_shapeCalc
e56a : a543             [ 3] 	lda tmp_b
e56c : d003             [ 3] 	bne df_rt_shapeCalc
                             	; Got here then must be finished
e56e : 68               [ 4] 	pla							; Pop bytes off 6502 stack
e56f : 68               [ 4] 	pla
e570 : 60               [ 6] 	rts
e571 :                       df_rt_shapeCalc
e571 : 18               [ 2] 	clc
e572 : a5e3             [ 3] 	lda df_tmpptra				; Increment coord pointer 
e574 : 6904             [ 2] 	adc #4						; 2 ints is 4 bytes per coord
e576 : aa               [ 2] 	tax
e577 : a5e4             [ 3] 	lda df_tmpptra+1
e579 : 6900             [ 2] 	adc #0
e57b : 2094f2           [ 6] 	jsr df_rst_pushWord			; Put pointer on runtime s
                             	; previous cursor is starting position
                             	; plus delta is new position
e57e : 68               [ 4] 	pla							; get y0 off stack
e57f : 18               [ 2] 	clc
e580 : 8586             [ 3] 	sta num_a+1
e582 : 6543             [ 3] 	adc tmp_b
e584 : 8588             [ 3] 	sta num_a+3					; y1 = y0+dy
e586 : aa               [ 2] 	tax							; save y1 in X reg
e587 : 68               [ 4] 	pla							; get x0 off stack
e588 : 18               [ 2] 	clc
e589 : 8585             [ 3] 	sta num_a					; x0
e58b : 653f             [ 3] 	adc tmp_v1
e58d : 8587             [ 3] 	sta num_a+2					; x1
e58f : 48               [ 3] 	pha							; save x1
e590 : da               [ 3] 	phx							; save y1
e591 : 20fec2           [ 6] 	jsr _gr_line				; line x0,y0,x1,y1
e594 : 80b5             [ 3] 	bra df_rt_shapeLoop			; go back to next coord
                             	
e596 :                       df_rt_wait
                             	; evaluate the expression
e596 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; put high byte in to Y (X,Y)=16 bits
e599 : a8               [ 2] 	tay
e59a :                       df_rt_wait_loop
AS65 Assembler for R6502 [1.42].                                     Page  150
---------------------------------- bank1.s -----------------------------------

                             	; check X,Y==0
e59a : 8a               [ 2] 	txa
e59b : d004             [ 3] 	bne df_rt_wait_countdown
e59d : 98               [ 2] 	tya
e59e : d001             [ 3] 	bne df_rt_wait_countdown
                             	; Done (wait 0 returns immediately)
e5a0 : 60               [ 6] 	rts
e5a1 :                       df_rt_wait_countdown
                             	; get vdp low byte timer val in A for tick wait
e5a1 : a510             [ 3] 	lda vdp_int_cnt
e5a3 : ca               [ 2] 	dex
e5a4 : e0ff             [ 2] 	cpx #0xff
e5a6 : d001             [ 3] 	bne df_rt_wait_tick
e5a8 : 88               [ 2] 	dey
e5a9 :                       df_rt_wait_tick
                             	; check if a tick has occurred (i.e. val <> A)
e5a9 : c510             [ 3] 	cmp vdp_int_cnt
e5ab : f0fc             [ 3] 	beq df_rt_wait_tick
e5ad : d0eb             [ 3] 	bne df_rt_wait_loop		; Always
                             	
e5af :                       df_rt_printat
                             	; Get x,y
e5af : 2003dc           [ 6] 	jsr df_rt_parm_2ints
e5b2 : a6e3             [ 3] 	ldx df_tmpptra
e5b4 : a4e5             [ 3] 	ldy df_tmpptrb
                             	; Set the cursror here
e5b6 : 20a6c3           [ 6] 	jsr _gr_set_cur
                             	; and continue to normal print command
e5b9 :                       df_rt_print
e5b9 : a4ca             [ 3] 	ldy df_exeoff
e5bb : 88               [ 2] 	dey
e5bc :                       df_rt_print_ws
e5bc : c8               [ 2] 	iny
                             	; evaluate an expression
                             ;	cpy df_eolidx
                             ;	beq df_rt_print_done
e5bd : c4c1             [ 3] 	cpy df_nxtstidx
e5bf : f026             [ 3] 	beq df_rt_print_done
e5c1 : b1c8             [ 5] 	lda (df_currlin),y
e5c3 : c93a             [ 2] 	cmp #':'
e5c5 : f020             [ 3] 	beq df_rt_print_done
e5c7 : c920             [ 2] 	cmp #' '
e5c9 : f0f1             [ 3] 	beq df_rt_print_ws
e5cb : c92c             [ 2] 	cmp #','
e5cd : f0ed             [ 3] 	beq df_rt_print_ws
                             	; save index
e5cf : 84ca             [ 3] 	sty df_exeoff
                             	
                             	; if starts with string literal then process sev
                             ;	cmp #DFTK_STRLIT
                             ;	beq df_rt_print_string
                             	; else evaluate a numeric
e5d1 : 2048d9           [ 6] 	jsr df_rt_neval
                             	; check what is on the argument stack
                             	_df_ost_peekType
                             
e5d9 : 2904             [ 2] 	and #DFST_STR
e5db : d005             [ 3] 	bne df_rt_print_gotstr
e5dd : 208be2           [ 6] 	jsr df_rt_print_num
e5e0 : 80d7             [ 3] 	bra df_rt_print
e5e2 :                       df_rt_print_gotstr
e5e2 : 2092e2           [ 6] 	jsr df_rt_print_str
AS65 Assembler for R6502 [1.42].                                     Page  151
---------------------------------- bank1.s -----------------------------------

e5e5 : 80d2             [ 3] 	bra df_rt_print
                             ;df_rt_print_string
                             ;	; point to string accumulator
                             ;	ldx df_sevalptr
                             ;	lda df_sevalptr+1
                             ;	jsr df_rt_seval
                             ;	bra df_rt_print_gotstr
e5e7 :                       df_rt_print_done
e5e7 : 84ca             [ 3] 	sty df_exeoff
e5e9 : 60               [ 6] 	rts
                             	
e5ea :                       df_rt_println
e5ea : 20b9e5           [ 6] 	jsr df_rt_print
e5ed : a90d             [ 2] 	lda #UTF_CR
e5ef : 4cc0c5           [ 3] 	jmp io_put_ch
                             
                             
                             ; assign to a number variable
                             ; X,A must have lvar
e5f2 :                       df_rt_nassign
e5f2 : 48               [ 3] 	pha
e5f3 : da               [ 3] 	phx
                             	; now go evaluate expression in to A,X
e5f4 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; restore variable address to write to
e5f7 : 7a               [ 4] 	ply
e5f8 : 84e3             [ 3] 	sty df_tmpptra
e5fa : 7a               [ 4] 	ply
e5fb : 84e4             [ 3] 	sty df_tmpptra+1
                             	; save X,A int in contents section
e5fd : a001             [ 2] 	ldy #1
e5ff : 91e3             [ 5] 	sta (df_tmpptra),y
e601 : 8a               [ 2] 	txa
e602 : 88               [ 2] 	dey
e603 : 91e3             [ 5] 	sta (df_tmpptra),y
                             
e605 : 60               [ 6] 	rts
                             
                             ; assign to a string variable
                             ; X,A must have lvar
e606 :                       df_rt_sassign
                             	; now go evaluate expression
                             	; with the destination being X,A
e606 : 20fcd9           [ 6] 	jsr df_rt_sval
                             
                             	; get string pointer from top of runtime stack
e609 : 4cd2f2           [ 3] 	jmp df_ost_popStr
                             	
                             ;	clc
                             ;	rts
                             
                             ; generate lvar from a var token ready for assign
e60c :                       df_rt_generate_lvar
                             	; move past escape val
e60c : a4ca             [ 3] 	ldy df_exeoff
e60e : c8               [ 2] 	iny
                             	; pointing to variable index
e60f : b1c8             [ 5] 	lda (df_currlin),y
e611 : 85e3             [ 3] 	sta df_tmpptra
e613 : c8               [ 2] 	iny
e614 : b1c8             [ 5] 	lda (df_currlin),y
e616 : 84ca             [ 3] 	sty df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  152
---------------------------------- bank1.s -----------------------------------

e618 : 85e4             [ 3] 	sta df_tmpptra+1
                             
                             	; get the type and save
e61a : b2e3             [ 5] 	lda (df_tmpptra)
e61c : 48               [ 3] 	pha
                             
                             	; set carry flag to return pointer (lvar)
e61d : 38               [ 2] 	sec
e61e : 20e2da           [ 6] 	jsr df_rt_eval_var
e621 : 20d6f2           [ 6] 	jsr df_ost_popPtr
                             	; pull the type previously saved into Y
e624 : 7a               [ 4] 	ply
                             	; move past the lvar variable index
e625 : e6ca             [ 5] 	inc df_exeoff
                             ;	clc
e627 : 60               [ 6] 	rts
                             
                             ; assign
                             ; X,A,Y contain lvar pointer and type
e628 :                       df_rt_doassign
                             	; save A and put type Y in to A
e628 : 48               [ 3] 	pha
e629 : 98               [ 2] 	tya
e62a : 2904             [ 2] 	and #DFVVT_STR
                             	; if a string then string expression
e62c : f004             [ 3] 	beq df_rt_assign_num
                             	; remember to restore A
                             	; jump to string expression evaluator
e62e : 68               [ 4] 	pla
e62f : 4c06e6           [ 3] 	jmp df_rt_sassign
e632 :                       df_rt_assign_num
                             	; else jump to numeric expression evaluator
                             	; remember to restore A
e632 : 68               [ 4] 	pla
e633 : 4cf2e5           [ 3] 	jmp df_rt_nassign
                             
                             ; general assignment execution
e636 :                       df_rt_assign
e636 : 200ce6           [ 6] 	jsr df_rt_generate_lvar
                             	; go and do the assignment
e639 : 4c28e6           [ 3] 	jmp df_rt_doassign
                             	
                             ; comment or data token is ignored by runtime
e63c :                       df_rt_comment
e63c :                       df_rt_data
                             ;	clc
e63c : 60               [ 6] 	rts
                             
                             	
                             ; run token	
e63d :                       df_rt_run
                             ;	sec
e63d : 60               [ 6] 	rts
                             
                             ; end of line / statement indicator
                             ; CS = End, CC = not end
e63e :                       df_rt_eos
e63e : a4ca             [ 3] 	ldy df_exeoff
                             ;	cpy df_eolidx
                             ;	beq df_rt_eos_true
e640 : c4c1             [ 3] 	cpy df_nxtstidx
e642 : f008             [ 3] 	beq df_rt_eos_true
AS65 Assembler for R6502 [1.42].                                     Page  153
---------------------------------- bank1.s -----------------------------------

e644 : b1c8             [ 5] 	lda (df_currlin),y
e646 : c93a             [ 2] 	cmp #':'
e648 : f002             [ 3] 	beq df_rt_eos_true
e64a : 18               [ 2] 	clc
e64b : 60               [ 6] 	rts
e64c :                       df_rt_eos_true
e64c : 38               [ 2] 	sec
e64d : 60               [ 6] 	rts
                             
                             ; renum startLine,newStart,increment
                             ; renumbers from the first matching line to end o
e64e :                       df_rt_renum
e64e : e6ca             [ 5] 	inc df_exeoff
e650 : 200edc           [ 6] 	jsr df_rt_parm_3ints
                             	; starting line number
e653 : a6e3             [ 3] 	ldx df_tmpptra
e655 : a5e4             [ 3] 	lda df_tmpptra+1
e657 : 205ad7           [ 6] 	jsr df_pg_find_line
e65a : 9002             [ 3] 	bcc df_rt_renum_ok
                             	SWBRK DFERR_NOLINE
                             
e65e :                       df_rt_renum_ok
                             	; save starting position pointer in ptrd
e65e : 86e9             [ 3] 	stx df_tmpptrd
e660 : 85ea             [ 3] 	sta df_tmpptrd+1
e662 :                       df_rt_renum_do
                             	; if not end of program
e662 : a000             [ 2] 	ldy #0
e664 : b1e9             [ 5] 	lda (df_tmpptrd),y
                             	; then renumber this line
e666 : d001             [ 3] 	bne df_rt_renum_update
                             	; else done
e668 : 60               [ 6] 	rts
e669 :                       df_rt_renum_update
                             	; so set this line number to new line number
e669 : a001             [ 2] 	ldy #DFTK_LINNUM
e66b : a5e5             [ 3] 	lda df_tmpptrb
e66d : 91e9             [ 5] 	sta (df_tmpptrd),y
e66f : c8               [ 2] 	iny
e670 : a5e6             [ 3] 	lda df_tmpptrb+1
e672 : 91e9             [ 5] 	sta (df_tmpptrd),y
                             	; add increment to new line
                             	_addZPWord df_tmpptrb,df_tmpptrc
                             
e681 :                       df_rt_renum_next
                             	; point ptrd to the next line
e681 : 18               [ 2] 	clc
e682 : a5e9             [ 3] 	lda df_tmpptrd
e684 : a200             [ 2] 	ldx #0
e686 : 61e9             [ 6] 	adc (df_tmpptrd,x)
e688 : 85e9             [ 3] 	sta df_tmpptrd
                             	_bcc 2
                             
e68c : e6ea             [ 5] 	inc df_tmpptrd+1
e68e : 4c62e6           [ 3] 	jmp df_rt_renum_do
                             
                             
                             ; * List all procs in VNT
e691 :                       df_rt_listprocnames
                             	; start at the beginning of the vnt table
                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
AS65 Assembler for R6502 [1.42].                                     Page  154
---------------------------------- bank1.s -----------------------------------

                             	; start at varcnt
e699 : a5b3             [ 3] 	lda df_varcnt
e69b : 85e5             [ 3] 	sta df_tmpptrb
e69d :                       df_rt_listcheckvnt
                             	; If reached 0 then not found
e69d : a5e5             [ 3] 	lda df_tmpptrb
e69f : f03a             [ 3] 	beq df_rt_listpn_done
e6a1 : a000             [ 2] 	ldy #0
e6a3 : b1e3             [ 5] 	lda (df_tmpptra),y
e6a5 : c95f             [ 2] 	cmp #'_'
e6a7 : d01b             [ 3] 	bne df_rt_listnextvnt
e6a9 :                       df_rt_listprocch
e6a9 : b1e3             [ 5] 	lda (df_tmpptra),y
e6ab : 20c0c5           [ 6] 	jsr io_put_ch
e6ae : aa               [ 2] 	tax
e6af : f003             [ 3] 	beq df_rt_listproccr
e6b1 : c8               [ 2] 	iny
e6b2 : d0f5             [ 3] 	bne df_rt_listprocch		; Always
e6b4 :                       df_rt_listproccr
e6b4 : a90d             [ 2] 	lda #UTF_CR
e6b6 : 20c0c5           [ 6] 	jsr io_put_ch
e6b9 : 18               [ 2] 	clc
e6ba :                       df_rt_listprocpause
e6ba : 20bdc5           [ 6] 	jsr io_get_ch
e6bd : c920             [ 2] 	cmp #' '
e6bf : d003             [ 3] 	bne df_rt_listnextvnt
e6c1 :                       df_rt_listwait
e6c1 : 38               [ 2] 	sec
e6c2 : b0f6             [ 3] 	bcs df_rt_listprocpause
e6c4 :                       df_rt_listnextvnt
e6c4 : b1e3             [ 5] 	lda (df_tmpptra),y
e6c6 : f003             [ 3] 	beq df_rt_listgotnext
e6c8 : c8               [ 2] 	iny
e6c9 : d0f9             [ 3] 	bne df_rt_listnextvnt		; Always
e6cb :                       df_rt_listgotnext
                             	; dec vnt #
e6cb : c6e5             [ 5] 	dec df_tmpptrb
                             	; skip past zero terminator
e6cd : c8               [ 2] 	iny
                             	; add this to vnt pointer
e6ce : 18               [ 2] 	clc
e6cf : 98               [ 2] 	tya
e6d0 : 65e3             [ 3] 	adc df_tmpptra
e6d2 : 85e3             [ 3] 	sta df_tmpptra
                             	_bcc 2
                             
e6d6 : e6e4             [ 5] 	inc df_tmpptra+1
e6d8 : 4c9de6           [ 3] 	jmp df_rt_listcheckvnt
e6db :                       df_rt_listpn_done
e6db : 60               [ 6] 	rts
                             
e6dc :                       df_rt_listproc
                             	; A already contains '_'
e6dc : 8d000a           [ 4] 	sta df_linbuff
e6df : a200             [ 2] 	ldx #0
e6e1 : a4ca             [ 3] 	ldy df_exeoff
e6e3 :                       df_rt_listp_copy
e6e3 : c8               [ 2] 	iny
e6e4 : e8               [ 2] 	inx
e6e5 : b1c8             [ 5] 	lda (df_currlin),y
e6e7 : 9d000a           [ 5] 	sta df_linbuff,x
e6ea : 20a2ce           [ 6] 	jsr df_tk_isalphanum
AS65 Assembler for R6502 [1.42].                                     Page  155
---------------------------------- bank1.s -----------------------------------

e6ed : b0f4             [ 3] 	bcs df_rt_listp_copy
                             	; zero the line index
e6ef : a200             [ 2] 	ldx #0
e6f1 : 86be             [ 3] 	stx df_linoff
                             	; save runtime pos
e6f3 : 84ca             [ 3] 	sty df_exeoff
                             	; Now try and find in VNT
e6f5 : 20c4cc           [ 6] 	jsr df_var_find
e6f8 : b036             [ 4] 	bcs df_rt_listp_notfound
                             	; Ok we have got a match in X,A find the proc
e6fa : 86d0             [ 3] 	stx df_procptr
e6fc : 85d1             [ 3] 	sta df_procptr+1
e6fe : 2031dd           [ 6] 	jsr df_rt_findproc
                             	; Save the line pointer
e701 : 86e3             [ 3] 	stx df_tmpptra
e703 : 85e4             [ 3] 	sta df_tmpptra+1
                             	; save statement index in to line
                             ;	sty df_lineidx
                             ;	; Check if '-' option used
                             ;	ldy df_exeoff
                             ;	lda (df_currlin),y
                             ;	cmp #'-'
                             ;	; if so, list to end of program
                             ;	beq df_rt_listprgend
                             	; Now try and find the end of this procedure
                             	; enddef or another def
                             	; A,X=Line ptr, Y=line idx
                             ;	ldx df_tmpptra
                             ;	lda df_tmpptra+1
                             ;	ldy df_lineidx
e705 :                       df_rt_listp_findend
                             	; Go to next stat
e705 : 20dedc           [ 6] 	jsr df_rt_nextstat
e708 : b057             [ 3] 	bcs df_rt_listprgend
                             	; save y (a,x in lineptr), A is ok to trample
e70a : 98               [ 2] 	tya
e70b : 48               [ 3] 	pha
                             	; find the command
e70c :                       df_rt_listp_findcmd
e70c : c8               [ 2] 	iny
e70d : b1d2             [ 5] 	lda (df_lineptr),y
e70f : 10fb             [ 3] 	bpl df_rt_listp_findcmd
                             	; restore y to stat beginning
e711 : 8545             [ 3] 	sta tmp_d
e713 : 68               [ 4] 	pla
e714 : a8               [ 2] 	tay
e715 : a545             [ 3] 	lda tmp_d
                             	; check A - looking for enddef or def
e717 : c987             [ 2] 	cmp #DFRT_ENDDEF
e719 : f00b             [ 3] 	beq df_rt_listp_done
e71b : c986             [ 2] 	cmp #DFRT_DEF
e71d : f007             [ 3] 	beq df_rt_listp_done
                             	; if neither then next stat from current
e71f : a6d2             [ 3] 	ldx df_lineptr
e721 : a5d3             [ 3] 	lda df_lineptr+1
e723 : 4c05e7           [ 3] 	jmp df_rt_listp_findend
e726 :                       df_rt_listp_done
                             	; Push end line on to stack
e726 : a5d3             [ 3] 	lda df_lineptr+1
e728 : 48               [ 3] 	pha
e729 : 8a               [ 2] 	txa
e72a : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page  156
---------------------------------- bank1.s -----------------------------------

e72b : a5d3             [ 3] 	lda df_lineptr+1
e72d : 4c67e7           [ 3] 	jmp df_rt_list_line
e730 :                       df_rt_listp_notfound
                             	; Fatal error if proc not found
                             	SWBRK DFERR_NOPROC
                             
                             
                             ; list token
e732 :                       df_rt_list
e732 : a900             [ 2] 	lda #0
e734 : 85eb             [ 3] 	sta df_tmpptre		; Zero means in normal list mode
                             	; find non-ws
e736 : 2084dd           [ 6] 	jsr df_rt_skip_ws
                             	; if end of statement then no line specifiers
e739 : 203ee6           [ 6] 	jsr df_rt_eos
                             	; so list whole program
e73c : b01b             [ 3] 	bcs df_rt_listprg
                             
                             	;if '_' then use procnames
e73e : c95f             [ 2] 	cmp #'_'
e740 : d003             [ 3] 	bne df_rt_list_all
e742 : 4cdce6           [ 3] 	jmp df_rt_listproc
e745 :                       df_rt_list_all
                             	;if '*' then display all procnames
e745 : c92a             [ 2] 	cmp #'*'
e747 : d003             [ 3] 	bne df_rt_list_linno
e749 : 4c91e6           [ 3] 	jmp df_rt_listprocnames
e74c :                       df_rt_list_linno
                             	; else get 1st parameter
e74c : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; find the starting line number in X,A
e74f : 205ad7           [ 6] 	jsr df_pg_find_line
                             	; save start in ptra
e752 : 86e3             [ 3] 	stx df_tmpptra
e754 : 85e4             [ 3] 	sta df_tmpptra+1
e756 : 4c61e7           [ 3] 	jmp df_rt_listprgend
                             	; NO ability to choose and ending line number!
                             
                             ; Common listing routine used by LIST and SAVE
                             ; tmpe = 0 means in LIST mode else SAVE mode
                             ; can stop the listing in LIST mode with CTRL-C
e759 :                       df_rt_listprg
                             	; program start and end as for pointer value
                             	_cpyZPWord df_prgstrt, df_tmpptra
                             
e761 :                       df_rt_listprgend
e761 : a5aa             [ 3] 	lda df_prgend+1
e763 : 48               [ 3] 	pha						; df_prgend hi at 102,x
e764 : a5a9             [ 3] 	lda df_prgend
e766 : 48               [ 3] 	pha						; df_prgend lo at 101,x
e767 :                       df_rt_list_line
                             	; if line length = 0 then end of program
e767 : a000             [ 2] 	ldy #0
e769 : b1e3             [ 5] 	lda (df_tmpptra),y
e76b : f039             [ 3] 	beq df_rt_list_line_fin
                             	; if in list mode and CTRL-C then also stop
e76d : a5eb             [ 3] 	lda df_tmpptre
e76f : d010             [ 3] 	bne df_rt_list_line_cont
                             	; check for break, asynch get
e771 : 18               [ 2] 	clc
e772 :                       df_rt_list_synckey
e772 : a5eb             [ 3] 	lda df_tmpptre					; Ignore keys on save mode
AS65 Assembler for R6502 [1.42].                                     Page  157
---------------------------------- bank1.s -----------------------------------

e774 : d00b             [ 3] 	bne df_rt_list_line_cont
e776 :                       df_rt_list_pause
e776 : 20bdc5           [ 6] 	jsr io_get_ch
e779 : c920             [ 2] 	cmp #' '						; Space = PAUSE
e77b : f0f9             [ 3] 	beq df_rt_list_pause			; C=1 for synchronouse ke
e77d : c903             [ 2] 	cmp #UTF_ETX					; CTRL-C?
e77f : f025             [ 3] 	beq df_rt_list_line_fin
e781 :                       df_rt_list_line_cont
e781 : a000             [ 2] 	ldy #0
e783 : 84be             [ 3] 	sty df_linoff
e785 : 20a9e7           [ 6] 	jsr df_rt_list_all_line
e788 :                       df_rt_list_next_line
                             	; new line
e788 : 20a3c8           [ 6] 	jsr utilPrintCRLF
                             	; increment pointer to next line
e78b : 18               [ 2] 	clc
e78c : a5e3             [ 3] 	lda df_tmpptra
e78e : a000             [ 2] 	ldy #0
e790 : 71e3             [ 5] 	adc (df_tmpptra),y
e792 : 85e3             [ 3] 	sta df_tmpptra
                             	_bcc 2
                             
e796 : e6e4             [ 5] 	inc df_tmpptra+1
                             	; if pointer > end then listing is done
e798 : ba               [ 2] 	tsx
e799 : 38               [ 2] 	sec
e79a : bd0101           [ 4] 	lda 0x101,x						; get prend lo from stack frame
e79d : e5e3             [ 3] 	sbc df_tmpptra
e79f : bd0201           [ 4] 	lda 0x102,x						; get prend hi from stack frame
e7a2 : e5e4             [ 3] 	sbc df_tmpptra+1
e7a4 : b0c1             [ 3] 	bcs df_rt_list_line
e7a6 :                       df_rt_list_line_fin
                             	; if got here then reached tmpb
e7a6 : 68               [ 4] 	pla
e7a7 : 68               [ 4] 	pla
e7a8 :                       df_rt_list_line_only_fin
e7a8 : 60               [ 6] 	rts
                             
                             ;Using df_tmpptra as line pointer
                             ;Print decode an entire line
e7a9 :                       df_rt_list_all_line				; Start here to include nu
e7a9 : 20e3e8           [ 6] 	jsr df_rt_list_linnum
e7ac :                       df_rt_list_line_only			; Start here for just the 
e7ac : a003             [ 2] 	ldy #3
e7ae : b1e3             [ 5] 	lda (df_tmpptra),y
e7b0 : 85d4             [ 3] 	sta df_lineidx
e7b2 : c8               [ 2] 	iny
e7b3 : 84be             [ 3] 	sty df_linoff
e7b5 :                       df_rt_list_decode
e7b5 : a4be             [ 3] 	ldy df_linoff
e7b7 : b1e3             [ 5] 	lda (df_tmpptra),y
e7b9 : 3010             [ 3] 	bmi df_rt_list_token
e7bb : c920             [ 2] 	cmp #DFTK_ESCVAL
e7bd : 9006             [ 3] 	bcc df_rt_list_escval
                             	; normal char just print it
e7bf : 20c0c5           [ 6] 	jsr io_put_ch
e7c2 : 4ccee7           [ 3] 	jmp df_rt_list_nexttok
e7c5 :                       df_rt_list_escval
                             	; A and Y need to be valid on entry
e7c5 : 20e7e7           [ 6] 	jsr df_rt_list_decode_esc
e7c8 : 4ccee7           [ 3] 	jmp df_rt_list_nexttok
e7cb :                       df_rt_list_token
AS65 Assembler for R6502 [1.42].                                     Page  158
---------------------------------- bank1.s -----------------------------------

e7cb : 20f4e8           [ 6] 	jsr df_rt_list_decode_token
e7ce :                       df_rt_list_nexttok
                             	; advance the line offset
e7ce : e6be             [ 5] 	inc df_linoff
e7d0 : a5be             [ 3] 	lda df_linoff
                             	; check if at end of line
e7d2 : a200             [ 2] 	ldx #0
e7d4 : c1e3             [ 6] 	cmp (df_tmpptra,x)
e7d6 : f0d0             [ 3] 	beq df_rt_list_line_only_fin
                             	; check if at end of statement
e7d8 : c5d4             [ 3] 	cmp df_lineidx
e7da : d0d9             [ 3] 	bne df_rt_list_decode
e7dc : a8               [ 2] 	tay
                             	; save the next statement offset
e7dd : b1e3             [ 5] 	lda (df_tmpptra),y
e7df : 85d4             [ 3] 	sta df_lineidx
e7e1 : c8               [ 2] 	iny
e7e2 : 84be             [ 3] 	sty df_linoff
e7e4 : 4cb5e7           [ 3] 	jmp df_rt_list_decode
                             
                             
                             ; decode escape sequences
                             ; Input: A contains the esc val and Y is char lin
e7e7 :                       df_rt_list_decode_esc
                             	; jump over esc byte
e7e7 : c8               [ 2] 	iny
e7e8 : 84be             [ 3] 	sty df_linoff
e7ea : 48               [ 3] 	pha
                             	; get the next two bytes in case needed
e7eb : b1e3             [ 5] 	lda (df_tmpptra),y
e7ed : 85e5             [ 3] 	sta df_tmpptrb
e7ef : c8               [ 2] 	iny
e7f0 : b1e3             [ 5] 	lda (df_tmpptra),y
e7f2 : 85e6             [ 3] 	sta df_tmpptrb+1
e7f4 : 88               [ 2] 	dey				; Y is on byte after esc byte
e7f5 : 68               [ 4] 	pla
                             	; x2 to get jmp offset
e7f6 : 0a               [ 2] 	asl a
e7f7 : aa               [ 2] 	tax
e7f8 : bdacde           [ 4] 	lda df_rt_escjmp,x
e7fb : 85e7             [ 3] 	sta df_tmpptrc
e7fd : bdadde           [ 4] 	lda df_rt_escjmp+1,x
e800 : 85e8             [ 3] 	sta df_tmpptrc+1
                             	; now jump to decoder
e802 : 6ce700           [ 6] 	jmp (df_tmpptrc)
                             
                             ; reserved
e805 :                       df_rt_lst_reserved
e805 : 60               [ 6] 	rts
                             
                             ; decode a byte char
e806 :                       df_rt_lst_chr
e806 : a927             [ 2] 	lda #0x27			; Single quote
e808 : 20c0c5           [ 6] 	jsr io_put_ch
e80b : a5e5             [ 3] 	lda df_tmpptrb
e80d : 20c0c5           [ 6] 	jsr io_put_ch
e810 : a927             [ 2] 	lda #0x27			; Single quote
e812 : 20c0c5           [ 6] 	jsr io_put_ch
e815 : c8               [ 2] 	iny
e816 : 84be             [ 3] 	sty df_linoff
e818 : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  159
---------------------------------- bank1.s -----------------------------------

                             ; Output 0x for hex chars
e819 :                       df_rt_lst_hex_pre
e819 : a930             [ 2] 	lda #'0'
e81b : 20c0c5           [ 6] 	jsr io_put_ch
e81e : a978             [ 2] 	lda #'x'
e820 : 4cc0c5           [ 3] 	jmp io_put_ch
                             
                             
                             ; Decode a byte hex
e823 :                       df_rt_lst_bythex
e823 : 2019e8           [ 6] 	jsr df_rt_lst_hex_pre
e826 :                       df_rt_lst_lo_hex
e826 : a5e5             [ 3] 	lda df_tmpptrb
e828 : 20d0c8           [ 6] 	jsr str_a_to_x
e82b : 20c0c5           [ 6] 	jsr io_put_ch
e82e : 8a               [ 2] 	txa
e82f : 20c0c5           [ 6] 	jsr io_put_ch
e832 :                       df_rt_lst_const_done
e832 : c8               [ 2] 	iny
e833 : 84be             [ 3] 	sty df_linoff
e835 : 60               [ 6] 	rts
                             
                             ; Decode an int hex
e836 :                       df_rt_lst_inthex
e836 : 2019e8           [ 6] 	jsr df_rt_lst_hex_pre
e839 : a5e6             [ 3] 	lda df_tmpptrb+1
e83b : 20d0c8           [ 6] 	jsr str_a_to_x
e83e : 20c0c5           [ 6] 	jsr io_put_ch
e841 : 8a               [ 2] 	txa
e842 : 20c0c5           [ 6] 	jsr io_put_ch
e845 : 4c26e8           [ 3] 	jmp df_rt_lst_lo_hex
                             
                             ; Decode a byte binary
e848 :                       df_rt_lst_bytbin
e848 : a5e5             [ 3] 	lda df_tmpptrb
e84a : 85e6             [ 3] 	sta df_tmpptrb+1
e84c : a208             [ 2] 	ldx #8
e84e : d002             [ 3] 	bne df_rt_lst_bin
                             
                             ; Decode a int binary
e850 :                       df_rt_lst_intbin
e850 : a210             [ 2] 	ldx #16
                             	; FALL THROUGH
                             ; Main 01 decoding of binary
e852 :                       df_rt_lst_bin
e852 : a930             [ 2] 	lda #'0'
e854 : 20c0c5           [ 6] 	jsr io_put_ch
e857 : a962             [ 2] 	lda #'b'
e859 : 20c0c5           [ 6] 	jsr io_put_ch
e85c :                       df_rt_lst_bit
e85c : a930             [ 2] 	lda #'0'
e85e : 06e5             [ 5] 	asl df_tmpptrb
e860 : 26e6             [ 5] 	rol df_tmpptrb+1
e862 : 6900             [ 2] 	adc #0				; If C=1 then '0' becomes '1'
e864 :                       df_rt_lst_bit_skip0
e864 : 20c0c5           [ 6] 	jsr io_put_ch
e867 : ca               [ 2] 	dex
e868 : d0f2             [ 3] 	bne df_rt_lst_bit
e86a : f0c6             [ 3] 	beq df_rt_lst_const_done
                             
                             ; Decode a decimal integer
e86c :                       df_rt_lst_intdec
AS65 Assembler for R6502 [1.42].                                     Page  160
---------------------------------- bank1.s -----------------------------------

e86c : a6e5             [ 3] 	ldx df_tmpptrb
e86e : a5e6             [ 3] 	lda df_tmpptrb+1
e870 : c8               [ 2] 	iny
e871 : 84be             [ 3] 	sty df_linoff
e873 : 18               [ 2] 	clc
e874 : 4c5acb           [ 3] 	jmp print_a_to_d
                             
                             
                             ; decode a variable or procedure
                             ; Slot address to decode in ptrb
e877 :                       df_rt_lst_var
e877 :                       df_rt_lst_proc
                             	; jump over the address bytes
e877 : c8               [ 2] 	iny
e878 : 84be             [ 3] 	sty df_linoff
                             
                             	; ptrc starts at VNT start
                             	_cpyZPWord df_vntstrt,df_tmpptrc
                             
                             
                             	; ptrd starts at end of VVT
                             	_cpyZPWord df_vvtend,df_tmpptrd
                             
e88a : a000             [ 2] 	ldy #0
e88c :                       df_rt_list_findvvt
                             	; Check have we reached target addr in vvt?
e88c : a5e9             [ 3] 	lda df_tmpptrd
e88e : c5e5             [ 3] 	cmp df_tmpptrb
e890 : d006             [ 3] 	bne df_rt_list_vvtend
e892 : a5ea             [ 3] 	lda df_tmpptrd+1
e894 : c5e6             [ 3] 	cmp df_tmpptrb+1
e896 : f021             [ 3] 	beq df_rt_list_gotvvt
e898 :                       df_rt_list_vvtend
e898 : b1e7             [ 5] 	lda (df_tmpptrc),y
e89a : f009             [ 3] 	beq df_rt_list_gotvvtend
                             	_incZPWord df_tmpptrc
                             
e8a2 : 4c98e8           [ 3] 	jmp df_rt_list_vvtend
e8a5 :                       df_rt_list_gotvvtend
                             	_incZPWord df_tmpptrc
                             
                             	; move target slot address towards top of mem
e8ab : 18               [ 2] 	clc
e8ac : a5e9             [ 3] 	lda df_tmpptrd
e8ae : 6908             [ 2] 	adc #DFVVT_SZ
e8b0 : 85e9             [ 3] 	sta df_tmpptrd
                             	_bcc 2
                             
e8b4 : e6ea             [ 5] 	inc df_tmpptrd+1
                             	; go back and check again
e8b6 : 4c8ce8           [ 3] 	jmp df_rt_list_findvvt
e8b9 :                       df_rt_list_gotvvt
e8b9 : b1e7             [ 5] 	lda (df_tmpptrc),y
e8bb : f025             [ 3] 	beq df_rt_list_donvvt
e8bd : 20c0c5           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrc
                             
e8c6 : 4cb9e8           [ 3] 	jmp df_rt_list_gotvvt
                             
e8c9 :                       df_rt_lst_strlit
e8c9 : a922             [ 2] 	lda #0x22
e8cb : 20c0c5           [ 6] 	jsr io_put_ch
AS65 Assembler for R6502 [1.42].                                     Page  161
---------------------------------- bank1.s -----------------------------------

e8ce : a4be             [ 3] 	ldy df_linoff
e8d0 :                       df_rt_lst_strlitch
e8d0 : b1e3             [ 5] 	lda (df_tmpptra),y
e8d2 : f007             [ 3] 	beq df_rt_lst_strlitdon
e8d4 : 20c0c5           [ 6] 	jsr io_put_ch
e8d7 : c8               [ 2] 	iny
e8d8 : 4cd0e8           [ 3] 	jmp df_rt_lst_strlitch
e8db :                       df_rt_lst_strlitdon
e8db : a922             [ 2] 	lda #0x22
e8dd : 20c0c5           [ 6] 	jsr io_put_ch
e8e0 : 84be             [ 3] 	sty df_linoff
e8e2 :                       df_rt_list_donvvt
e8e2 : 60               [ 6] 	rts
                             
e8e3 :                       df_rt_list_linnum
e8e3 : a001             [ 2] 	ldy #1
e8e5 : b1e3             [ 5] 	lda (df_tmpptra),y
e8e7 : aa               [ 2] 	tax
e8e8 : c8               [ 2] 	iny
e8e9 : b1e3             [ 5] 	lda (df_tmpptra),y
e8eb : 18               [ 2] 	clc
e8ec : 205acb           [ 6] 	jsr print_a_to_d
e8ef : a920             [ 2] 	lda #0x20			; Always add a space after line num
e8f1 : 4cc0c5           [ 3] 	jmp io_put_ch
                             
                             ; decode a token value with MSB set
e8f4 :                       df_rt_list_decode_token
                             	; if not assembler then normal listing
e8f4 : c997             [ 2] 	cmp #DFRT_ASM
e8f6 : d003             [ 3] 	bne df_rt_list_decode_token_normal
e8f8 : 4c32e9           [ 3] 	jmp df_rt_asm_decode_token
e8fb :                       df_rt_list_decode_token_normal
e8fb : 297f             [ 2] 	and #0x7f
                             	; token 0 and 1 don't get decoded they are impli
e8fd : c902             [ 2] 	cmp #2
e8ff : b001             [ 4] 	bcs df_rt_list_do_decode_tkn
e901 : 60               [ 6] 	rts
e902 :                       df_rt_list_do_decode_tkn
e902 : aa               [ 2] 	tax
e903 : a950             [ 2] 	lda #lo(df_tokensyms)
e905 : 85e5             [ 3] 	sta df_tmpptrb
e907 : a9d2             [ 2] 	lda #hi(df_tokensyms)
e909 : 85e6             [ 3] 	sta df_tmpptrb+1
e90b :                       df_rt_list_find_sym
e90b : 8a               [ 2] 	txa
e90c : f012             [ 3] 	beq df_rt_list_got_sym
e90e : a000             [ 2] 	ldy #0
e910 :                       df_rt_list_next_ch
e910 : b1e5             [ 5] 	lda (df_tmpptrb),y
e912 : 48               [ 3] 	pha
                             	_incZPWord df_tmpptrb
                             
e919 : 68               [ 4] 	pla
e91a : 10f4             [ 3] 	bpl df_rt_list_next_ch
e91c :                       df_rt_list_got_last_sym
                             	; ok got to the last ch
                             	; advance to next sym
e91c : ca               [ 2] 	dex
e91d : 4c0be9           [ 3] 	jmp df_rt_list_find_sym
e920 :                       df_rt_list_got_sym
e920 : a1e5             [ 6] 	lda (df_tmpptrb,x)		; Relies on X=0 from branch
e922 : 08               [ 3] 	php
AS65 Assembler for R6502 [1.42].                                     Page  162
---------------------------------- bank1.s -----------------------------------

e923 : 297f             [ 2] 	and #0x7f
e925 : 20c0c5           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrb
                             
e92e : 28               [ 4] 	plp
e92f : 10ef             [ 3] 	bpl df_rt_list_got_sym
e931 : 60               [ 6] 	rts
                             
                             ;** Decode assembler token in A **
e932 :                       df_rt_asm_decode_token
e932 : e6be             [ 5] 	inc df_linoff		; Point to token after asm token
e934 : a4be             [ 3] 	ldy df_linoff
e936 : b1e3             [ 5] 	lda (df_tmpptra),y	;If token N=1 then keyword
e938 : 300a             [ 3] 	bmi df_rt_asm_decode_token_keyword
e93a : a92e             [ 2] 	lda #'.'			;Put the '.' before escape processing
e93c : 20c0c5           [ 6] 	jsr io_put_ch
e93f : b1e3             [ 5] 	lda (df_tmpptra),y	;Get asm token back
e941 : 4ce7e7           [ 3] 	jmp df_rt_list_decode_esc
e944 :                       df_rt_asm_decode_token_keyword
e944 : 297f             [ 2] 	and #0x7f			; Mask off MSB
e946 : aa               [ 2] 	tax					;Put it in to X as the counter
                             	; Point to asm symbol table
e947 : a90a             [ 2] 	lda #lo(df_asm_tokensyms)
e949 : 85e5             [ 3] 	sta df_tmpptrb
e94b : a9f9             [ 2] 	lda #hi(df_asm_tokensyms)
e94d : 85e6             [ 3] 	sta df_tmpptrb+1
e94f :                       df_rt_list_find_asm_sym
e94f : 8a               [ 2] 	txa
e950 : f01b             [ 3] 	beq df_rt_list_got_asm_sym
e952 : a000             [ 2] 	ldy #0
e954 :                       df_rt_list_next_asm_ch
                             	_incZPWord df_tmpptrb
                             
e95a : b1e5             [ 5] 	lda (df_tmpptrb),y
e95c : c920             [ 2] 	cmp #' '			; Skip all chars >=' '
e95e : b0f4             [ 3] 	bcs df_rt_list_next_asm_ch
e960 : 38               [ 2] 	sec					; Skip offset and mode bytes
e961 : 65e5             [ 3] 	adc df_tmpptrb
e963 : 85e5             [ 3] 	sta df_tmpptrb
                             	_bcc 2
                             
e967 : e6e6             [ 5] 	inc df_tmpptrb+1
e969 : ca               [ 2] 	dex					; One less symbol to skip over
e96a : 4c4fe9           [ 3] 	jmp df_rt_list_find_asm_sym
e96d :                       df_rt_list_got_asm_sym
e96d : a1e5             [ 6] 	lda (df_tmpptrb,x)	; Relies on X=0 from branch
e96f : c920             [ 2] 	cmp #' '
e971 : 900c             [ 3] 	bcc df_rt_asm_decode_token_done
e973 : 20c0c5           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrb
                             
e97c : 4c6de9           [ 3] 	jmp df_rt_list_got_asm_sym
e97f :                       df_rt_asm_decode_token_done
e97f : 60               [ 6] 	rts
                             
                             
e980 :                       df_rt_doke
e980 : 2003dc           [ 6] 	jsr df_rt_parm_2ints
e983 : a5e5             [ 3] 	lda df_tmpptrb
e985 : 92e3             [ 5] 	sta (df_tmpptra)
                             	; get high byte to doke
e987 : a5e6             [ 3] 	lda df_tmpptrb+1
AS65 Assembler for R6502 [1.42].                                     Page  163
---------------------------------- bank1.s -----------------------------------

e989 : a001             [ 2] 	ldy #1
                             	; poke hi byte
e98b : 91e3             [ 5] 	sta (df_tmpptra),y
e98d : 60               [ 6] 	rts
                             	
e98e :                       df_rt_poke
e98e : 2003dc           [ 6] 	jsr df_rt_parm_2ints
e991 : a5e5             [ 3] 	lda df_tmpptrb
e993 : 92e3             [ 5] 	sta (df_tmpptra)
                             ;	clc
e995 : 60               [ 6] 	rts
                             
e996 :                       df_rt_vpoke
e996 : 2003dc           [ 6] 	jsr df_rt_parm_2ints
e999 : a6e3             [ 3] 	ldx df_tmpptra
e99b : a4e4             [ 3] 	ldy df_tmpptra+1
e99d : a5e5             [ 3] 	lda df_tmpptrb
e99f : 4c1ec4           [ 3] 	jmp _vdp_poke
                             ;	clc
                             ;	rts
                             
e9a2 :                       df_rt_nvpoke
e9a2 : 2003dc           [ 6] 	jsr df_rt_parm_2ints
e9a5 : a6e3             [ 3] 	ldx df_tmpptra
e9a7 : a5e5             [ 3] 	lda df_tmpptrb
e9a9 : 4caec4           [ 3] 	jmp _rtc_nvwrite
                             ;	clc
e9ac : 60               [ 6] 	rts
                             
e9ad :                       df_rt_setvdp
e9ad : 2003dc           [ 6] 	jsr df_rt_parm_2ints
e9b0 : a5e3             [ 3] 	lda df_tmpptra
e9b2 : a6e5             [ 3] 	ldx df_tmpptrb
e9b4 : 4c50c6           [ 3] 	jmp vdp_wr_reg
                             ;	clc
                             ;	rts
                             
e9b7 :                       df_rt_colour
e9b7 : 200edc           [ 6] 	jsr df_rt_parm_3ints
                             	; colour is a combination of b and c parms
e9ba : a5e5             [ 3] 	lda df_tmpptrb
e9bc : 0a               [ 2] 	asl a
e9bd : 0a               [ 2] 	asl a
e9be : 0a               [ 2] 	asl a
e9bf : 0a               [ 2] 	asl a
e9c0 : 05e7             [ 3] 	ora df_tmpptrc
e9c2 : 48               [ 3] 	pha
e9c3 : a5e3             [ 3] 	lda df_tmpptra
e9c5 : c920             [ 2] 	cmp #32					; 32 = border colour
e9c7 : f00e             [ 3] 	beq df_rt_colour_border
                             	; else write to the colour table
                             	; first calculate the colour table address
e9c9 : 18               [ 2] 	clc
e9ca : 6519             [ 3] 	adc vdp_base+vdp_addr_col
e9cc : aa               [ 2] 	tax
e9cd : a51a             [ 3] 	lda vdp_base+vdp_addr_col+1
e9cf : 6900             [ 2] 	adc #0
e9d1 : a8               [ 2] 	tay
e9d2 : 68               [ 4] 	pla
                             	; A = colour, YX = address
e9d3 : 208ac6           [ 6] 	jsr vdp_poke
e9d6 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  164
---------------------------------- bank1.s -----------------------------------

e9d7 :                       df_rt_colour_border
e9d7 : a907             [ 2] 	lda #7
e9d9 : fa               [ 4] 	plx
e9da : 4c50c6           [ 3] 	jmp vdp_wr_reg
                             
e9dd :                       df_rt_sprite
e9dd : 2041dc           [ 6] 	jsr df_rt_parm_5ints
                             	; calculate the sprite number in vram
e9e0 : a5e3             [ 3] 	lda df_tmpptra
e9e2 : 0a               [ 2] 	asl a
e9e3 : 0a               [ 2] 	asl a
e9e4 : 18               [ 2] 	clc
e9e5 : 651d             [ 3] 	adc vdp_base+vdp_addr_spa
e9e7 : aa               [ 2] 	tax
e9e8 : a51e             [ 3] 	lda vdp_base+vdp_addr_spa+1
e9ea : 6900             [ 2] 	adc #0
e9ec : 78               [ 2] 	sei				; Disable interrupts
e9ed : 205dc6           [ 6] 	jsr vdp_wr_addr
                             	; now write the vertical position (tmpc, not b)
e9f0 : a5e7             [ 3] 	lda df_tmpptrc
e9f2 : 2085c6           [ 6] 	jsr vdp_wr_vram
                             	; now write the horizontal position (tmpb)
e9f5 : a5e5             [ 3] 	lda df_tmpptrb
e9f7 : 2085c6           [ 6] 	jsr vdp_wr_vram
                             	; now write the pattern name (tmpd)
e9fa : a5e9             [ 3] 	lda df_tmpptrd
e9fc : 2085c6           [ 6] 	jsr vdp_wr_vram
                             	; now write the colour / ec byte (tmpe)
e9ff : a5eb             [ 3] 	lda df_tmpptre
ea01 : 2085c6           [ 6] 	jsr vdp_wr_vram
ea04 : 58               [ 2] 	cli				; Enable interrupts
ea05 : 60               [ 6] 	rts
                             
                             
                             ; copy pattern array to sprite pattern vram
                             ; pattern array is a mim 4 element int
ea06 :                       df_rt_spritepat
ea06 : 2003dc           [ 6] 	jsr df_rt_parm_2ints
                             	; save sprite number
ea09 : 86e3             [ 3] 	stx df_tmpptra
ea0b : 64e4             [ 3] 	stz df_tmpptra+1
                             	; multiply by 8 to get pattern offset
ea0d : 06e3             [ 5] 	asl df_tmpptra
ea0f : 26e4             [ 5] 	rol df_tmpptra+1
ea11 : 06e3             [ 5] 	asl df_tmpptra
ea13 : 26e4             [ 5] 	rol df_tmpptra+1
ea15 : 06e3             [ 5] 	asl df_tmpptra
ea17 : 26e4             [ 5] 	rol df_tmpptra+1
                             	; add offset to sprite pattern base
                             	; and put in X,A
ea19 : a5e3             [ 3] 	lda df_tmpptra
ea1b : 651f             [ 3] 	adc vdp_base+vdp_addr_spp
ea1d : aa               [ 2] 	tax
ea1e : a5e4             [ 3] 	lda df_tmpptra+1
ea20 : 6520             [ 3] 	adc vdp_base+vdp_addr_spp+1
ea22 : 78               [ 2] 	sei			; Disable interrupts
                             	; set vdp address
ea23 : 205dc6           [ 6] 	jsr vdp_wr_addr
                             	; start from beginning of array
ea26 : a000             [ 2] 	ldy #0
ea28 :                       df_rt_spritepat_line
                             	; get the sprite patten from array
AS65 Assembler for R6502 [1.42].                                     Page  165
---------------------------------- bank1.s -----------------------------------

ea28 : b1e5             [ 5] 	lda (df_tmpptrb),y
                             	; and write to vdp
ea2a : 2085c6           [ 6] 	jsr vdp_wr_vram
ea2d : c8               [ 2] 	iny
                             	; do this for 8 bytes (4 elements)
ea2e : c008             [ 2] 	cpy #8
ea30 : d0f6             [ 3] 	bne df_rt_spritepat_line
ea32 : 58               [ 2] 	cli			; Enable interrupts
ea33 : 60               [ 6] 	rts
                             
ea34 :                       df_rt_spritepos
ea34 : 200edc           [ 6] 	jsr df_rt_parm_3ints
                             	; calculate the sprite number in vram
ea37 : a5e3             [ 3] 	lda df_tmpptra
ea39 : 0a               [ 2] 	asl a
ea3a : 0a               [ 2] 	asl a
ea3b : 651d             [ 3] 	adc vdp_base+vdp_addr_spa
ea3d : aa               [ 2] 	tax
ea3e : a51e             [ 3] 	lda vdp_base+vdp_addr_spa+1
ea40 : 6900             [ 2] 	adc #0
ea42 : 78               [ 2] 	sei
ea43 : 205dc6           [ 6] 	jsr vdp_wr_addr
                             	; now write the vertical position (tmpc, not b)
ea46 : a5e7             [ 3] 	lda df_tmpptrc
ea48 : 2085c6           [ 6] 	jsr vdp_wr_vram
                             	; now write the horizontal position (tmpb)
ea4b : a5e5             [ 3] 	lda df_tmpptrb
ea4d : 2085c6           [ 6] 	jsr vdp_wr_vram
ea50 : 58               [ 2] 	cli
ea51 : 60               [ 6] 	rts
                             
                             ; common routine for col and nme variations
                             ; A contains offset in to sprite table to update
ea52 :                       df_rt_spriteattr
                             	; save A which contains the offset
ea52 : 48               [ 3] 	pha
ea53 : 2003dc           [ 6] 	jsr df_rt_parm_2ints
                             	; calculate the sprite number in vram
ea56 : a5e3             [ 3] 	lda df_tmpptra
ea58 : 0a               [ 2] 	asl a
ea59 : 0a               [ 2] 	asl a
ea5a : 651d             [ 3] 	adc vdp_base+vdp_addr_spa
ea5c : 85e3             [ 3] 	sta df_tmpptra
ea5e : a51e             [ 3] 	lda vdp_base+vdp_addr_spa+1
ea60 : 6900             [ 2] 	adc #0
ea62 : 85e4             [ 3] 	sta df_tmpptra+1
                             	; add offset and put in X,A to set VRAM address
ea64 : 68               [ 4] 	pla							; get offset from stack
ea65 : 65e3             [ 3] 	adc df_tmpptra
ea67 : aa               [ 2] 	tax
ea68 : a5e4             [ 3] 	lda df_tmpptra+1
ea6a : 6900             [ 2] 	adc #0
ea6c : a8               [ 2] 	tay
ea6d : a5e5             [ 3] 	lda df_tmpptrb
ea6f : 4c8ac6           [ 3] 	jmp vdp_poke
                             
ea72 :                       df_rt_spritecol
                             	; offset is 3 for colour byte
ea72 : a903             [ 2] 	lda #3
ea74 : 4c52ea           [ 3] 	jmp df_rt_spriteattr
                             
ea77 :                       df_rt_spritenme
AS65 Assembler for R6502 [1.42].                                     Page  166
---------------------------------- bank1.s -----------------------------------

                             	; offset is 2 for name byte
ea77 : a902             [ 2] 	lda #2
ea79 : 4c52ea           [ 3] 	jmp df_rt_spriteattr
                             
ea7c :                       df_rt_snd_common
                             	; 3 inputs
                             	; tmpa = channel (1,2,3), tmpb = period, tmpc = 
ea7c : a5e3             [ 3] 	lda df_tmpptra
                             	; tone channel addressing is 0 to 2
ea7e : 3a               [ 2] 	dec a
ea7f : 2903             [ 2] 	and #3
                             	; ok doing a tone channel, get reg index for per
ea81 : 0a               [ 2] 	asl a
ea82 : aa               [ 2] 	tax
                             	; get low byte of period
ea83 : a4e5             [ 3] 	ldy df_tmpptrb
ea85 : 20eec3           [ 6] 	jsr _snd_set
                             	; increment reg number to high byte
ea88 : e8               [ 2] 	inx
                             	; get high byte of period
ea89 : a5e6             [ 3] 	lda df_tmpptrb+1
ea8b : 290f             [ 2] 	and #0x0f
ea8d : a8               [ 2] 	tay
                             	; set period
ea8e : 20eec3           [ 6] 	jsr _snd_set
                             	; get volume register index (8 = channel 1)
ea91 : 18               [ 2] 	clc
ea92 : a5e3             [ 3] 	lda df_tmpptra
ea94 : 2903             [ 2] 	and #3
ea96 : 6907             [ 2] 	adc #7
ea98 : aa               [ 2] 	tax
                             	; get volume
ea99 : a5e7             [ 3] 	lda df_tmpptrc
ea9b : 290f             [ 2] 	and #0x0f
ea9d : d002             [ 3] 	bne df_rt_sound_env_skip
                             	; envelope mode
ea9f : 0910             [ 2] 	ora #0x10
eaa1 :                       df_rt_sound_env_skip
eaa1 : a8               [ 2] 	tay
eaa2 : 4ceec3           [ 3] 	jmp _snd_set
                             ;	rts
                             
                             ; sound chan,period,volume	
eaa5 :                       df_rt_sound
eaa5 : 200edc           [ 6] 	jsr df_rt_parm_3ints
eaa8 :                       df_rt_dosound
                             	; check which channel (0 = noise)
eaa8 : a5e3             [ 3] 	lda df_tmpptra
eaaa : f003             [ 3] 	beq df_rt_sound_noise
eaac : 4c7cea           [ 3] 	jmp df_rt_snd_common
eaaf :                       df_rt_sound_noise
                             	; ok update the noise channel, volume is irrelev
eaaf : a206             [ 2] 	ldx #6
eab1 : a5e5             [ 3] 	lda df_tmpptrb
eab3 : 291f             [ 2] 	and #0x1f
eab5 : a8               [ 2] 	tay
eab6 : 4ceec3           [ 3] 	jmp _snd_set
                             ;	clc
                             ;	rts
                             
                             ; music chan,octave,note,volume
eab9 :                       df_rt_music
AS65 Assembler for R6502 [1.42].                                     Page  167
---------------------------------- bank1.s -----------------------------------

eab9 : 2025dc           [ 6] 	jsr df_rt_parm_4ints
                             	; parm 2 = octave, need to x 12word = 24
eabc : 18               [ 2] 	clc
eabd : a5e5             [ 3] 	lda df_tmpptrb
eabf : 65e5             [ 3] 	adc df_tmpptrb
eac1 : 65e5             [ 3] 	adc df_tmpptrb
eac3 : 0a               [ 2] 	asl a
eac4 : 0a               [ 2] 	asl a
                             	; we have x12, now add note to get index
eac5 : 65e7             [ 3] 	adc df_tmpptrc
eac7 : 0a               [ 2] 	asl a
eac8 : a8               [ 2] 	tay
                             	; get period A,X (hi/lo)
eac9 : 20bec3           [ 6] 	jsr _snd_get_note
eacc : 86e5             [ 3] 	stx df_tmpptrb
eace : 85e6             [ 3] 	sta df_tmpptrb+1
                             	; put vol in tmpc
ead0 : a5e9             [ 3] 	lda df_tmpptrd
ead2 : 85e7             [ 3] 	sta df_tmpptrc
                             	; tmpa,b,c contain chan,per,vol
ead4 : 4ca8ea           [ 3] 	jmp df_rt_dosound
                             	
                             	
                             ; play tonemask,noisemask,envelope,period
ead7 :                       df_rt_play
ead7 : 2025dc           [ 6] 	jsr df_rt_parm_4ints
                             	; parm 1 = tone enable
eada : a5e3             [ 3] 	lda df_tmpptra
eadc : 2907             [ 2] 	and #7
eade : 85e3             [ 3] 	sta df_tmpptra
                             	; parm 2 = noise enable
eae0 : a5e5             [ 3] 	lda df_tmpptrb
eae2 : 2907             [ 2] 	and #7
eae4 : 0a               [ 2] 	asl a
eae5 : 0a               [ 2] 	asl a
eae6 : 0a               [ 2] 	asl a
eae7 : 05e3             [ 3] 	ora df_tmpptra
                             	; we now have bits set for channels to enable
                             	; but need to invert for the 8910
                             	; keep top 2 bits 0 as these are port a and b in
eae9 : 493f             [ 2] 	eor #0x3f
eaeb : a8               [ 2] 	tay
                             	; reg 7 is control register
eaec : a207             [ 2] 	ldx #7
eaee : 20eec3           [ 6] 	jsr _snd_set
                             	; parm 3 = envelope mode
eaf1 : a5e7             [ 3] 	lda df_tmpptrc
eaf3 : 290f             [ 2] 	and #0xf
eaf5 : a8               [ 2] 	tay
                             	; 13 is envelope shape register
eaf6 : a20d             [ 2] 	ldx #13
eaf8 : 20eec3           [ 6] 	jsr _snd_set
                             	; parm 4 = envelope period
                             	; 11 is envelope period register
eafb : a20b             [ 2] 	ldx #11
                             	; get low
eafd : a4e9             [ 3] 	ldy df_tmpptrd
eaff : 20eec3           [ 6] 	jsr _snd_set
                             	; get high
eb02 : e8               [ 2] 	inx
eb03 : a4ea             [ 3] 	ldy df_tmpptrd+1
eb05 : 4ceec3           [ 3] 	jmp _snd_set
AS65 Assembler for R6502 [1.42].                                     Page  168
---------------------------------- bank1.s -----------------------------------

                             ;	clc
                             ;	rts
                             
                             
                             ;* Binary save mem,hdr,addr,len,filename
eb08 :                       df_rt_bsave
                             	; Get mem type, 0=RAM, else VRAM
eb08 : 2048d9           [ 6] 	jsr df_rt_neval				; Get mem type
eb0b : 20daf2           [ 6] 	jsr df_ost_popInt			; X,A = mem type (only X)
                             	; if check X for v or r
eb0e : e076             [ 2] 	cpx #'v'
eb10 : d003             [ 3] 	bne df_rt_bsave_tryr
eb12 : 18               [ 2] 	clc							; Clear C for vram
eb13 : 8007             [ 3] 	bra df_rt_bsave_savep
eb15 :                       df_rt_bsave_tryr
eb15 : e072             [ 2] 	cpx #'r'
eb17 : f002             [ 3] 	beq	 df_rt_bsave_setR
                             	SWBRK DFERR_TYPEMISM		; was not v or r!
                             
eb1b :                       df_rt_bsave_setR
eb1b : 38               [ 2] 	sec							; Set C for ram
eb1c :                       df_rt_bsave_savep
                             	; save C, clear=VRAM, set=RAM
eb1c : 08               [ 3] 	php
                             
                             	; jump over comma
eb1d : e6ca             [ 5] 	inc df_exeoff
                             	; Get header length
eb1f : 2048d9           [ 6] 	jsr df_rt_neval				; Get header length
eb22 : 20daf2           [ 6] 	jsr df_ost_popInt			; X,A = Header length (only 
                             	; save X as header length
eb25 : da               [ 3] 	phx
                             
                             	; jump over comma
eb26 : e6ca             [ 5] 	inc df_exeoff
eb28 : 2048d9           [ 6] 	jsr df_rt_neval				; Get address
eb2b : 20daf2           [ 6] 	jsr df_ost_popInt			; X,A = Address
eb2e : 48               [ 3] 	pha
eb2f : da               [ 3] 	phx
                             
                             	; jump over comma
eb30 : e6ca             [ 5] 	inc df_exeoff
eb32 : 2048d9           [ 6] 	jsr df_rt_neval				; Get length
eb35 : 20daf2           [ 6] 	jsr df_ost_popInt			; X,A = Length
eb38 : 48               [ 3] 	pha
eb39 : da               [ 3] 	phx
                             
                             	; jump over comma
eb3a : e6ca             [ 5] 	inc df_exeoff
                             	; Process filename
eb3c : 20a7eb           [ 6] 	jsr df_rt_parse_file
eb3f : 20c6c5           [ 6] 	jsr io_open_write
eb42 : b05a             [ 3] 	bcs df_rt_file_errc3		; Error condition resets t
                             
                             	; On the stack, we have lenlo,lenhi,adlo,adhi,he
eb44 : ba               [ 2] 	tsx
eb45 : bc0501           [ 4] 	ldy 0x105,x					; Get header len
eb48 : f008             [ 3] 	beq df_rt_bsave_byte
eb4a : a900             [ 2] 	lda #0						; Zero filler
eb4c :                       df_rt_bsave_header
eb4c : 20c0c5           [ 6] 	jsr io_put_ch				; Write a byte to disk
eb4f : 88               [ 2] 	dey
AS65 Assembler for R6502 [1.42].                                     Page  169
---------------------------------- bank1.s -----------------------------------

eb50 : d0fa             [ 3] 	bne df_rt_bsave_header
eb52 :                       df_rt_bsave_byte
eb52 : ba               [ 2] 	tsx							; Restore SP to X
eb53 : bd0101           [ 4] 	lda 0x101,x					; low<>0 carry on
eb56 : d005             [ 3] 	bne df_rt_bsave_byte_do
eb58 : bd0201           [ 4] 	lda 0x102,x					; hi<>0 carry on
eb5b : f038             [ 3] 	beq df_rt_bsave_done		; else done
eb5d :                       df_rt_bsave_byte_do
eb5d : bd0601           [ 4] 	lda 0x106,x					; Get the C status
eb60 : 48               [ 3] 	pha
eb61 : 28               [ 4] 	plp							; C unaffected by next ops
                             	
eb62 : bd0301           [ 4] 	lda 0x103,x					; Get low address
eb65 : bc0401           [ 4] 	ldy 0x104,x					; Get high address
eb68 : aa               [ 2] 	tax							; X,Y contain address
                             
eb69 : b006             [ 3] 	bcs df_rt_bsave_ram			; RAM or VRAM?
                             	; Read from VRAM
eb6b : 98               [ 2] 	tya							; A needs to contain high byte
eb6c : 2006c4           [ 6] 	jsr _vdp_peek				; Peek VRAM
eb6f : 8006             [ 3] 	bra df_rt_bsave_write
eb71 :                       df_rt_bsave_ram
                             	; Read from RAM
eb71 : 86e3             [ 3] 	stx df_tmpptra				; Save address
eb73 : 84e4             [ 3] 	sty df_tmpptra+1
eb75 : b2e3             [ 5] 	lda (df_tmpptra)			; Peek RAM
eb77 :                       df_rt_bsave_write
eb77 : 20c0c5           [ 6] 	jsr io_put_ch				; Write to disk
eb7a : ba               [ 2] 	tsx							; Get SP to X
eb7b : fe0301           [ 6] 	inc 0x103,x					; Increment low address
eb7e : d003             [ 3] 	bne df_rt_bsave_skiph
eb80 : fe0401           [ 6] 	inc 0x104,x					; Increment high address
eb83 :                       df_rt_bsave_skiph
eb83 : bc0101           [ 4] 	ldy 0x101,x					; Get low len byte
eb86 : f005             [ 3] 	beq df_rt_bsave_dech
eb88 : de0101           [ 6] 	dec 0x101,x					; A simple decrement
eb8b : 80c5             [ 3] 	bra df_rt_bsave_byte		; Process next byte
eb8d :                       df_rt_bsave_dech
eb8d : de0101           [ 6] 	dec 0x101,x					; Decrement low in readiness
eb90 : de0201           [ 6] 	dec 0x102,x					; Decrement high
eb93 : 80bd             [ 3] 	bra df_rt_bsave_byte		; Process next byte
eb95 :                       df_rt_bsave_done
                             	; Tidy the stack
eb95 : 68               [ 4] 	pla
eb96 : 68               [ 4] 	pla
eb97 : 68               [ 4] 	pla
eb98 : 68               [ 4] 	pla
eb99 : 68               [ 4] 	pla
eb9a : 68               [ 4] 	pla
eb9b : 4cc4eb           [ 3] 	jmp df_rt_file_cleanup		; Clean up FS
                             
eb9e :                       df_rt_file_errc3				; Stepping stone!!!
eb9e : b0fe             [ 3] 	bcs df_rt_file_errc3
                             
                             ;* common filename procesing routine
                             ;* 
eba0 :                       df_rt_init_filename
                             	; evaluate string X,A has the string pointer
eba0 : 2048d9           [ 6] 	jsr df_rt_neval
eba3 : 20d2f2           [ 6] 	jsr df_ost_popStr
                             
eba6 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  170
---------------------------------- bank1.s -----------------------------------

                             	
                             ;* common file parsing routine
eba7 :                       df_rt_parse_file
eba7 : a902             [ 2] 	lda #2					; Only works for SD card now
eba9 : 20a5c5           [ 6] 	jsr io_active_device
                             
                             	; now process filename, XA has pointer
ebac : 20a0eb           [ 6] 	jsr df_rt_init_filename
ebaf : 60               [ 6] 	rts
                             ; save "file"
ebb0 :                       df_rt_save
ebb0 : 20a7eb           [ 6] 	jsr df_rt_parse_file
ebb3 : 20c6c5           [ 6] 	jsr io_open_write
ebb6 : b063             [ 4] 	bcs df_rt_file_errc
                             	; ok now have redirected output to device
                             	; go and list the program in save mode
ebb8 : a901             [ 2] 	lda #1
ebba : 85eb             [ 3] 	sta df_tmpptre
ebbc : 2059e7           [ 6] 	jsr df_rt_listprg
                             	; final CR to end the save
ebbf : a90d             [ 2] 	lda #UTF_CR
ebc1 : 20c0c5           [ 6] 	jsr io_put_ch
ebc4 :                       df_rt_file_cleanup
                             	; close the file
ebc4 : 20c9c5           [ 6] 	jsr io_close
ebc7 : 18               [ 2] 	clc
                             	; restore to default device io
ebc8 : 4ca2c5           [ 3] 	jmp io_set_default
                             ;	clc
                             ;	rts
                             
                             ; load 'x',"file" where 0=serial, 1=SDCard
ebcb :                       df_rt_load
ebcb : 20a7eb           [ 6] 	jsr df_rt_parse_file
ebce : 20c3c5           [ 6] 	jsr io_open_read
ebd1 : b048             [ 4] 	bcs df_rt_file_errc
                             	; no echo - very important
                             	; else might try and write to a device
                             	; only open for reading (i.e. SD CARD)
                             
                             	; Initialise to line 10 in scratch, scratch+1
ebd3 : a90a             [ 2] 	lda #10
ebd5 : 8d0009           [ 4] 	sta scratch
ebd8 : 9c0109           [ 4] 	stz scratch+1
ebdb :                       df_rt_loadline
ebdb : 18               [ 2] 	clc
ebdc : 2015d8           [ 6] 	jsr df_pg_inputline
                             	; if C clear then tokenise line
ebdf : 9013             [ 3] 	bcc df_rt_ldtokenise
                             	; else done
                             	; clear dflat runtime else will try to execute
                             	; the last tokenised line!
ebe1 : 9c800a           [ 4] 	stz df_tokbuff			; Offset to next line
ebe4 : 9c810a           [ 4] 	stz df_tokbuff+1		; Clear line low
ebe7 : 9c820a           [ 4] 	stz df_tokbuff+2		; Clear line high
ebea : 64c1             [ 3] 	stz df_nxtstidx			; Clear next statement
ebec : 64c0             [ 3] 	stz df_eolidx			; Clear end of line too
ebee : a901             [ 2] 	lda #1					; Set immediate mode to get a 'Ready'
ebf0 : 85a0             [ 3] 	sta df_immed			; But nothing to run
ebf2 : 80d0             [ 3] 	bra df_rt_file_cleanup	; Ok now can close and do
ebf4 :                       df_rt_ldtokenise
ebf4 : 201fd1           [ 6] 	jsr df_lexer_line		; Tokenise loaded string - ju
AS65 Assembler for R6502 [1.42].                                     Page  171
---------------------------------- bank1.s -----------------------------------

                             	; check if line number == 0
ebf7 : ad810a           [ 4] 	lda df_tokbuff+DFTK_LINNUM
ebfa : 0d820a           [ 4] 	ora df_tokbuff+DFTK_LINNUM+1
ebfd : d017             [ 4] 	bne df_rt_storeline		; No, then store the line
                             	; Else insert current line number to buffer posi
                             	; also add 10 to the current line number
ebff : 18               [ 2] 	clc
ec00 : ad0009           [ 4] 	lda scratch				; Get line number lo
ec03 : 8d810a           [ 4] 	sta df_tokbuff+1		; Use current line number
ec06 : 690a             [ 2] 	adc #10					; But increment for next by 10
ec08 : 8d0009           [ 4] 	sta scratch
ec0b : ad0109           [ 4] 	lda scratch+1			; Get line number hi
ec0e : 8d820a           [ 4] 	sta df_tokbuff+2
ec11 : 6900             [ 2] 	adc #0
ec13 : 8d0109           [ 4] 	sta scratch+1
ec16 :                       df_rt_storeline
ec16 : 208cd8           [ 6] 	jsr df_pg_line_number	; Save the line in the rig
ec19 : 80c0             [ 4] 	bra df_rt_loadline		; Continue with next until b
                             
                             ; Somwehere to go to raise a file error!
ec1b :                       df_rt_file_errc
                             	SWBRK DFERR_FNAME
                             
                             
ec1d :                       df_rt_del
ec1d : 20a0eb           [ 6] 	jsr df_rt_init_filename		; Parse filename
ec20 : 208ec0           [ 6] 	jsr _fs_delete_w			; Delete file
ec23 : 60               [ 6] 	rts
                             
ec24 :                       df_rt_chdir
ec24 : 20a0eb           [ 6] 	jsr df_rt_init_filename		; Parse filename
ec27 : 205ec0           [ 6] 	jsr _fs_chdir_w				; Try and change directory
ec2a : b0ef             [ 3] 	bcs df_rt_file_errc
ec2c : 60               [ 6] 	rts
                             
ec2d :                       df_rt_mkdir
ec2d : 20a0eb           [ 6] 	jsr df_rt_init_filename		; Parse filename
ec30 : 2076c0           [ 6] 	jsr _fs_mkdir_w				; Try and make directory
ec33 : b0e6             [ 3] 	bcs df_rt_file_errc
ec35 : 60               [ 6] 	rts
                             
                             ; bload MEM,HEAD,ADDR,FNAME
ec36 :                       df_rt_bload
                             	; Get mem type, 0=RAM, else VRAM
ec36 : 2048d9           [ 6] 	jsr df_rt_neval				; Get mem type
ec39 : 20daf2           [ 6] 	jsr df_ost_popInt			; X,A = mem type (only X)
                             	; if check X for v or r
ec3c : e076             [ 2] 	cpx #'v'
ec3e : d003             [ 3] 	bne df_rt_bload_tryr
ec40 : 18               [ 2] 	clc							; Clear C for vram
ec41 : 8007             [ 3] 	bra df_rt_bload_savep
ec43 :                       df_rt_bload_tryr
ec43 : e072             [ 2] 	cpx #'r'
ec45 : f002             [ 3] 	beq	 df_rt_bload_setR
                             	SWBRK DFERR_TYPEMISM		; was not v or r!
                             
ec49 :                       df_rt_bload_setR
ec49 : 38               [ 2] 	sec							; Set C for ram
ec4a :                       df_rt_bload_savep
                             	; save C, clear=VRAM, set=RAM
ec4a : 08               [ 3] 	php
                             	; jump over comma
AS65 Assembler for R6502 [1.42].                                     Page  172
---------------------------------- bank1.s -----------------------------------

ec4b : e6ca             [ 5] 	inc df_exeoff
                             	; Get header length
ec4d : 2048d9           [ 6] 	jsr df_rt_neval				; Get header length
ec50 : 20daf2           [ 6] 	jsr df_ost_popInt			; X,A = Header length (only 
                             	; save X as header length
ec53 : da               [ 3] 	phx
                             	; jump over comma
ec54 : e6ca             [ 5] 	inc df_exeoff
ec56 : 8012             [ 3] 	bra df_rt_bvload
ec58 :                       df_rt_font
ec58 : 18               [ 2] 	clc							; Set to video
ec59 : 08               [ 3] 	php
ec5a : a900             [ 2] 	lda #0						; No header
ec5c : 48               [ 3] 	pha
ec5d : a901             [ 2] 	lda #1						; 0x100 address - hi
ec5f : 48               [ 3] 	pha
ec60 : a900             [ 2] 	lda #0						; 0x100 address - lo
ec62 : 48               [ 3] 	pha
ec63 : 800d             [ 3] 	bra df_rt_bload_file
ec65 :                       df_rt_vload
ec65 : 18               [ 2] 	clc							; Hardcode for VRAM
ec66 : 08               [ 3] 	php
ec67 : a207             [ 2] 	ldx #7						; Hardcode header length
ec69 : da               [ 3] 	phx
ec6a :                       df_rt_bvload
ec6a : 2048d9           [ 6] 	jsr df_rt_neval				; Get address
ec6d : 20daf2           [ 6] 	jsr df_ost_popInt			; X,A = Address
ec70 : 48               [ 3] 	pha
ec71 : da               [ 3] 	phx
ec72 :                       df_rt_bload_file
                             	; jump over comma
ec72 : e6ca             [ 5] 	inc df_exeoff
ec74 : 20a7eb           [ 6] 	jsr df_rt_parse_file
ec77 : 20c3c5           [ 6] 	jsr io_open_read
ec7a : b09f             [ 3] 	bcs df_rt_file_errc		; Error condition resets th
                             	; On the stack:
                             	; 101+x = adlo
                             	; 102+x = adhi
                             	; 103+x = header length
                             	; 104+x = mem type (c=0 means video)
ec7c : ba               [ 2] 	tsx
ec7d : bc0301           [ 4] 	ldy 0x103,x					; Get header
ec80 : f008             [ 3] 	beq df_rt_vload_byte
ec82 :                       df_rt_vload_header
ec82 : 20bdc5           [ 6] 	jsr io_get_ch				; Get a character
ec85 : b03c             [ 3] 	bcs df_rt_vload_done		; If EOF then done
ec87 : 88               [ 2] 	dey
ec88 : d0f8             [ 3] 	bne df_rt_vload_header
ec8a :                       df_rt_vload_byte
ec8a : ba               [ 2] 	tsx							; Restore SP to X
ec8b : bd0401           [ 4] 	lda 0x104,x					; Get the C status
ec8e : 48               [ 3] 	pha
ec8f : 28               [ 4] 	plp							; C unaffected by next ops
                             	
ec90 : bd0101           [ 4] 	lda 0x101,x					; Get low address
ec93 : bc0201           [ 4] 	ldy 0x102,x					; Get high address
ec96 : aa               [ 2] 	tax							; X,Y contain address
                             
ec97 : b014             [ 3] 	bcs df_rt_vload_ram			; RAM or VRAM?
                             	; Poke to VRAM but skip 0x1800-0x1fff
ec99 : 20bdc5           [ 6] 	jsr io_get_ch				; Get a character
ec9c : b025             [ 3] 	bcs df_rt_vload_done		; If EOF then done
AS65 Assembler for R6502 [1.42].                                     Page  173
---------------------------------- bank1.s -----------------------------------

ec9e : c018             [ 2] 	cpy #0x18					; If page # <= 0x17
eca0 : 9006             [ 3] 	bcc df_rt_vload_do_vpoke	; then vpoke
eca2 : c020             [ 2] 	cpy #0x20					; Or page >= 0x20
eca4 : b002             [ 3] 	bcs df_rt_vload_do_vpoke	; then vpoke
eca6 : 8010             [ 3] 	bra df_rt_vload_next
eca8 :                       df_rt_vload_do_vpoke
eca8 : 201ec4           [ 6] 	jsr _vdp_poke				; Write to VRAM
ecab : 800b             [ 3] 	bra df_rt_vload_next
ecad :                       df_rt_vload_ram
                             	; Poke to RAM
ecad : 20bdc5           [ 6] 	jsr io_get_ch				; Get a character
ecb0 : b011             [ 3] 	bcs df_rt_vload_done		; If EOF then done
ecb2 : 86e3             [ 3] 	stx df_tmpptra				; Save address
ecb4 : 84e4             [ 3] 	sty df_tmpptra+1
ecb6 : 92e3             [ 5] 	sta (df_tmpptra)			; Poke byte to RAM
ecb8 :                       df_rt_vload_next
ecb8 : ba               [ 2] 	tsx							; Get SP to X
ecb9 : fe0101           [ 6] 	inc 0x101,x					; Increment low address
ecbc : d003             [ 3] 	bne df_rt_vload_byte_skip
ecbe : fe0201           [ 6] 	inc 0x102,x					; Increment high address
ecc1 :                       df_rt_vload_byte_skip
ecc1 : 80c7             [ 3] 	bra df_rt_vload_byte		; Back for next video byte
ecc3 :                       df_rt_vload_done
ecc3 :                       df_rt_ptload_done
                             	; Tidy the stack
ecc3 : 68               [ 4] 	pla
ecc4 : 68               [ 4] 	pla
ecc5 : 68               [ 4] 	pla
ecc6 : 68               [ 4] 	pla
ecc7 : 4cc4eb           [ 3] 	jmp df_rt_file_cleanup
                             
                             ; Loads a song into any part of RAM including sha
                             ; Always assumes the top half of memory is in ban
                             	SWBRK DFERR_FNAME
                             
eccc :                       df_rt_ptload
eccc : 2048d9           [ 6] 	jsr df_rt_neval				; Get address
eccf : 20daf2           [ 6] 	jsr df_ost_popInt			; X,A = Address
ecd2 : 48               [ 3] 	pha
ecd3 : da               [ 3] 	phx
                             	; jump over comma
ecd4 : e6ca             [ 5] 	inc df_exeoff
ecd6 : 20a7eb           [ 6] 	jsr df_rt_parse_file
ecd9 : 20c3c5           [ 6] 	jsr io_open_read
ecdc : b0ec             [ 3] 	bcs (df_rt_ptload-2)		; Error condition resets t
                             
                             	; Copy code from ROM that does write to RAM
ecde : a000             [ 2] 	ldy #0
ece0 :                       df_rt_ptload_copycode
ece0 : b910ed           [ 4] 	lda df_rt_ptload_code_s,y
ece3 : 99670c           [ 5] 	sta ram_code,y
ece6 : c8               [ 2] 	iny
ece7 : c025             [ 2] 	cpy #(df_rt_ptload_code_e-df_rt_ptload_code_s)
ece9 : d0f5             [ 3] 	bne df_rt_ptload_copycode
                             
eceb : 7a               [ 4] 	ply							; Pull the index of address as Y
ecec : 68               [ 4] 	pla							; Pull the high address
eced : 85e4             [ 3] 	sta df_tmpptra+1			; Just the page address, so l
ecef : 64e3             [ 3] 	stz df_tmpptra
                             
                             	; Save current port B status of both VIAs
ecf1 : ad0004           [ 4] 	lda IO_0+PRB				; VIA0 port B is the ROM and RAM
AS65 Assembler for R6502 [1.42].                                     Page  174
---------------------------------- bank1.s -----------------------------------

ecf4 : 48               [ 3] 	pha
ecf5 : 29cf             [ 2] 	and #0b11001111				; Mask off RAM bank bits
ecf7 : 0920             [ 2] 	ora #0b00100000				; Select bank 2
ecf9 : 48               [ 3] 	pha							; Save new bank select
ecfa : ad8004           [ 4] 	lda IO_1+PRB				; VIA1 port B controls ROM enabl
ecfd : 48               [ 3] 	pha
ecfe : 29df             [ 2] 	and #0b11011111				; Disable ROM bit
ed00 : 48               [ 3] 	pha							; Save ROM disable state
                             	; Stack contains:
                             	;	101,x = disable ROM value
                             	;	102,x = original ROM value
                             	;	103,x = new RAM bank select value
                             	;	104,x = original RAM bank select value
ed01 :                       df_rt_ptload_byte
ed01 : 20bdc5           [ 6] 	jsr io_get_ch				; Get a byte
ed04 : b0bd             [ 4] 	bcs df_rt_ptload_done		; If EOF then done
ed06 : 20670c           [ 6] 	jsr ram_code				; Poke byte to RAM bank 2 and ma
ed09 : c8               [ 2] 	iny							; Update page index
ed0a : d0f5             [ 3] 	bne df_rt_ptload_byte		; Back for next byte
ed0c : e6e4             [ 5] 	inc df_tmpptra+1			; Increment high address
ed0e : 80f1             [ 3] 	bra df_rt_ptload_byte		; Back for next byte
                             
                             ; This code gets copied to RAM to do the actual p
ed10 :                       df_rt_ptload_code_s
ed10 : 08               [ 3] 	php							; Save processor status
ed11 : 78               [ 2] 	sei							; Disable VDP interrupts
ed12 : 48               [ 3] 	pha
ed13 : ba               [ 2] 	tsx
ed14 : e8               [ 2] 	inx
ed15 : e8               [ 2] 	inx
ed16 : e8               [ 2] 	inx
ed17 : e8               [ 2] 	inx
ed18 : bd0101           [ 4] 	lda 0x101,x					; Get disable ROM value
ed1b : 8d8004           [ 4] 	sta IO_1+PRB				; Disable ROM
ed1e : bd0301           [ 4] 	lda 0x103,x					; Get new RAM bank select value
ed21 : 8d0004           [ 4] 	sta IO_0+PRB				; Select bank 2
ed24 : 68               [ 4] 	pla
ed25 : 91e3             [ 5] 	sta (df_tmpptra),y			; Actually poke the byte to
ed27 : bd0201           [ 4] 	lda 0x102,x					; Get original ROM value
ed2a : 8d8004           [ 4] 	sta IO_1+PRB				; Enable ROM
ed2d : bd0401           [ 4] 	lda 0x104,x					; Get original RAM bank select v
ed30 : 8d0004           [ 4] 	sta IO_0+PRB				; Restore RAM bank select	
ed33 : 28               [ 4] 	plp							; Restore processor status
ed34 : 60               [ 6] 	rts
ed35 :                       df_rt_ptload_code_e
                             
ed35 :                       df_rt_ptinit
ed35 : 2048d9           [ 6] 	jsr df_rt_neval				; Get address
ed38 : 20daf2           [ 6] 	jsr df_ost_popInt			; X,A = Address
ed3b : da               [ 3] 	phx							; But swap them
ed3c : 48               [ 3] 	pha
ed3d : fa               [ 4] 	plx
ed3e : 68               [ 4] 	pla
ed3f : 4c3ec5           [ 3] 	jmp _PT3START				; Off to the PT3 player module
                             
ed42 :                       df_rt_ptrun
ed42 : 2048d9           [ 6] 	jsr df_rt_neval				; Get run status in X
ed45 : 20daf2           [ 6] 	jsr df_ost_popInt			; X,A = Address
ed48 : e000             [ 2] 	cpx #0						; If 0 then stop
ed4a : f003             [ 3] 	beq df_rt_ptrun_stop
                             	; else start
ed4c : 4c6ec5           [ 3] 	jmp _PT3RESUME
AS65 Assembler for R6502 [1.42].                                     Page  175
---------------------------------- bank1.s -----------------------------------

ed4f :                       df_rt_ptrun_stop
ed4f : 4c56c5           [ 3] 	jmp _PT3PAUSE
                             
ed52 :                       df_rt_dir_string				; Name of a directory
ed52 : 3c4449523e202000      	db "<DIR>  ",0				; 7 chars + terminator
ed5a :                       df_rt_dir
ed5a : 204ec1           [ 6] 	jsr _fs_dir_root_start_w	; Start at root
ed5d : a214             [ 2] 	ldx #20						; Count of how many files before pa
ed5f : da               [ 3] 	phx
ed60 :                       df_rt_dir_show_entry
ed60 : 18               [ 2] 	clc							; Only looking for valid files
ed61 : 201ec1           [ 6] 	jsr _fs_dir_find_entry_w	; Find a valid entry
ed64 : b052             [ 3] 	bcs df_rt_dir_done			; If C then no more entries
ed66 : a200             [ 2] 	ldx #lo(scratch)			; Set up pointer to string sp
ed68 : a909             [ 2] 	lda #hi(scratch)
ed6a : 20c6c4           [ 6] 	jsr _fs_dir_fhandle_str		; Convert fhandle entry
ed6d : a20c             [ 2] 	ldx #12						; Put a zero terminator after filen
ed6f : 9e0009           [ 5] 	stz scratch,x
ed72 : a200             [ 2] 	ldx #lo(scratch)			; Print filename
ed74 : a909             [ 2] 	lda #hi(scratch)
ed76 : 200bc6           [ 6] 	jsr io_print_line			; Print name
ed79 : 209bc8           [ 6] 	jsr utilPrintSPC			; Gap
ed7c : a563             [ 3] 	lda fh_handle+FH_Attr		; Is it a directory?
ed7e : c910             [ 2] 	cmp #0x10
ed80 : d009             [ 3] 	bne df_rt_dir_size
ed82 : a252             [ 2] 	ldx #lo(df_rt_dir_string)	; Set up pointer to na
ed84 : a9ed             [ 2] 	lda #hi(df_rt_dir_string)
ed86 : 200bc6           [ 6] 	jsr io_print_line			; Print directory indicator
ed89 : 800d             [ 3] 	bra df_rt_dir_line
ed8b :                       df_rt_dir_size
ed8b : a223             [ 2] 	ldx #lo(scratch+35)			; Print size (already term
ed8d : a909             [ 2] 	lda #hi(scratch+35)
ed8f : 200bc6           [ 6] 	jsr io_print_line			; Print size - 5 chars left 
ed92 : 209bc8           [ 6] 	jsr utilPrintSPC			; Gap
ed95 : 209bc8           [ 6] 	jsr utilPrintSPC			; Gap
                             	; Printed exactly 20 chars per size
ed98 :                       df_rt_dir_line
ed98 : a527             [ 3] 	lda gr_scrngeom+gr_screen_w	; If 32 col screen t
ed9a : c920             [ 2] 	cmp #32
ed9c : d003             [ 3] 	bne df_rt_dir_skip_crlf
ed9e : 20a3c8           [ 6] 	jsr utilPrintCRLF
eda1 :                       df_rt_dir_skip_crlf
eda1 : fa               [ 4] 	plx							; Decrement file line counter
eda2 : ca               [ 2] 	dex
eda3 : d00d             [ 3] 	bne df_rt_dir_skip_pause
eda5 : a2bf             [ 2] 	ldx #lo(df_rt_pausemsg)		; Show pause message
eda7 : a9ed             [ 2] 	lda #hi(df_rt_pausemsg)
eda9 : 200bc6           [ 6] 	jsr io_print_line
edac : 38               [ 2] 	sec
edad : 20bdc5           [ 6] 	jsr io_get_ch				; Wait for any key
edb0 : a214             [ 2] 	ldx #20						; Reset line counter
edb2 :                       df_rt_dir_skip_pause	
edb2 : da               [ 3] 	phx							; Save line counter
edb3 : 2036c1           [ 6] 	jsr _fs_dir_entry_next_w	; Advance to next slot
edb6 : 80a8             [ 3] 	bra df_rt_dir_show_entry	; Find another entry
edb8 :                       df_rt_dir_done
edb8 : fa               [ 4] 	plx							; Pop line counter
edb9 : a90d             [ 2] 	lda #UTF_CR					; Final CR
edbb : 20c0c5           [ 6] 	jsr io_put_ch
edbe : 60               [ 6] 	rts
edbf :                       df_rt_pausemsg
edbf : 0d507265737320..      	db UTF_CR,"Press any key for more..",UTF_CR,0
AS65 Assembler for R6502 [1.42].                                     Page  176
---------------------------------- bank1.s -----------------------------------

                             
edda :                       df_rt_dirl						; Long listing format
edda : 204ec1           [ 6] 	jsr _fs_dir_root_start_w	; Start at root
eddd : a214             [ 2] 	ldx #20						; Count of how many files before pa
eddf : da               [ 3] 	phx
ede0 :                       df_rt_dirl_show_entry
ede0 : 18               [ 2] 	clc							; Only looking for valid files
ede1 : 201ec1           [ 6] 	jsr _fs_dir_find_entry_w	; Find a valid entry
ede4 : b025             [ 4] 	bcs df_rt_dirl_done			; If C then no more entrie
ede6 : a200             [ 2] 	ldx #lo(scratch)			; Set up pointer to string sp
ede8 : a909             [ 2] 	lda #hi(scratch)
edea : 20c6c4           [ 6] 	jsr _fs_dir_fhandle_str		; Convert fhandle entry
eded : a200             [ 2] 	ldx #lo(scratch)			; Print the whole entry
edef : a909             [ 2] 	lda #hi(scratch)
edf1 : 200bc6           [ 6] 	jsr io_print_line
edf4 :                       df_rt_dirl_line
edf4 : fa               [ 4] 	plx							; Decrement file line counter
edf5 : ca               [ 2] 	dex
edf6 : d00d             [ 4] 	bne df_rt_dirl_skip_pause
edf8 : a2bf             [ 2] 	ldx #lo(df_rt_pausemsg)		; Show pause message
edfa : a9ed             [ 2] 	lda #hi(df_rt_pausemsg)
edfc : 200bc6           [ 6] 	jsr io_print_line
edff : 38               [ 2] 	sec
ee00 : 20bdc5           [ 6] 	jsr io_get_ch				; Wait for any key
ee03 : a214             [ 2] 	ldx #20						; Reset line counter
ee05 :                       df_rt_dirl_skip_pause	
ee05 : da               [ 3] 	phx							; Save line counter
ee06 : 2036c1           [ 6] 	jsr _fs_dir_entry_next_w	; Advance to next slot
ee09 : 80d5             [ 4] 	bra df_rt_dirl_show_entry	; Find another entry
ee0b :                       df_rt_dirl_done
ee0b : fa               [ 4] 	plx							; Pop line counter
ee0c : 20a3c8           [ 6] 	jsr utilPrintCRLF			; Final CR
ee0f : 60               [ 6] 	rts
                             	
                             ; reset %var
ee10 :                       df_rt_reset
                             	; now get lvar X,A from current statement
ee10 : 2091dd           [ 6] 	jsr df_rt_getlvar
                             	; save lvar in tmpb, vvt ptr in tmpa
ee13 : 86e5             [ 3] 	stx df_tmpptrb
ee15 : 85e6             [ 3] 	sta df_tmpptrb+1
                             	; load the vdp count as the reset value of timer
                             	; turn off interrupts while reading vdp lo,hi
ee17 : a001             [ 2] 	ldy #1	; This is in readiness to read high byte 
                             	; Safe read of counter (2 bytes only) without di
ee19 : a510             [ 3] 	lda vdp_int_cnt
ee1b :                       df_rt_safe_read
ee1b : 92e5             [ 5] 	sta (df_tmpptrb)
ee1d : a511             [ 3] 	lda vdp_int_cnt+1
ee1f : 91e5             [ 5] 	sta (df_tmpptrb),y
                             	; If first byte has changed since reading it
                             	; then re-read (might happen due to VBI)
ee21 : a510             [ 3] 	lda vdp_int_cnt
ee23 : d2e5             [ 5] 	cmp (df_tmpptrb)
ee25 : d0f4             [ 3] 	bne df_rt_safe_read
ee27 : 60               [ 6] 	rts
                             
                             ; timedate var$
                             ; output to string as dd/mm/yy hh:mm:ss
ee28 :                       df_rt_datetime
                             	; now get lvar X,A from current statement
ee28 : 2091dd           [ 6] 	jsr df_rt_getlvar
AS65 Assembler for R6502 [1.42].                                     Page  177
---------------------------------- bank1.s -----------------------------------

                             	; and save it
ee2b : da               [ 3] 	phx
ee2c : 48               [ 3] 	pha
                             	; Point to 6 bytes of scratch
ee2d : a200             [ 2] 	ldx #lo(scratch)
ee2f : a909             [ 2] 	lda #hi(scratch)
                             	; Populate timedate as hmsdmy
ee31 : 2066c4           [ 6] 	jsr _rtc_gettimedate
                             	; Get destination pointer back
ee34 : 68               [ 4] 	pla
ee35 : 85e4             [ 3] 	sta df_tmpptra+1
ee37 : 68               [ 4] 	pla
ee38 : 85e3             [ 3] 	sta df_tmpptra
                             	; Start at first char of destination
ee3a : a000             [ 2] 	ldy #0
                             	; Get days binary and convert to BCD
ee3c : ae0309           [ 4] 	ldx scratch+3
                             	; Separator character
ee3f : a92f             [ 2] 	lda #'/'
ee41 : 206dee           [ 6] 	jsr df_rt_datetime_conv
                             	; Get months binary and convert to BCD
ee44 : ae0409           [ 4] 	ldx scratch+4
                             	; Separator character
ee47 : a92f             [ 2] 	lda #'/'
ee49 : 206dee           [ 6] 	jsr df_rt_datetime_conv
                             	; Get years binary and convert to BCD
ee4c : ae0509           [ 4] 	ldx scratch+5
                             	; Separator character is space between date and 
ee4f : a920             [ 2] 	lda #' '
ee51 : 206dee           [ 6] 	jsr df_rt_datetime_conv
                             	; Get hours binary and convert to BCD
ee54 : ae0009           [ 4] 	ldx scratch+0
                             	; Separator character
ee57 : a93a             [ 2] 	lda #':'
ee59 : 206dee           [ 6] 	jsr df_rt_datetime_conv
                             	; Get minutes binary and convert to BCD
ee5c : ae0109           [ 4] 	ldx scratch+1
                             	; Separator character
ee5f : a93a             [ 2] 	lda #':'
ee61 : 206dee           [ 6] 	jsr df_rt_datetime_conv
                             	; Get seconds binary and convert to BCD
ee64 : ae0209           [ 4] 	ldx scratch+2
                             	; Separator character is null to terminate strin
ee67 : a900             [ 2] 	lda #0
ee69 : 206dee           [ 6] 	jsr df_rt_datetime_conv
ee6c : 60               [ 6] 	rts
ee6d :                       df_rt_datetime_conv
ee6d : 48               [ 3] 	pha
ee6e : a900             [ 2] 	lda #0
ee70 : 20d3ca           [ 6] 	jsr word_to_bcd
                             	; We only need least 2 BCD digits
ee73 : a585             [ 3] 	lda num_a+0
                             	; put nibbles in A,X
ee75 : 20d0c8           [ 6] 	jsr str_a_to_x
                             	; And save to destination
ee78 : 91e3             [ 5] 	sta (df_tmpptra),y
ee7a : c8               [ 2] 	iny
ee7b : 8a               [ 2] 	txa
ee7c : 91e3             [ 5] 	sta (df_tmpptra),y
ee7e : c8               [ 2] 	iny
ee7f : 68               [ 4] 	pla
ee80 : 91e3             [ 5] 	sta (df_tmpptra),y
AS65 Assembler for R6502 [1.42].                                     Page  178
---------------------------------- bank1.s -----------------------------------

ee82 : c8               [ 2] 	iny
ee83 : 60               [ 6] 	rts
                             
                             ;***** FUNCTIONS *****
                             
ee84 :                       df_rt_deek
ee84 : 38               [ 2] 	sec
ee85 : 8001             [ 3] 	bra df_rt_readbyte
ee87 :                       df_rt_peek
ee87 : 18               [ 2] 	clc
ee88 :                       df_rt_readbyte
ee88 : 08               [ 3] 	php
                             ;	inc df_exeoff
ee89 : 2042d9           [ 6] 	jsr df_rt_getnval
ee8c : 86e3             [ 3] 	stx df_tmpptra
ee8e : 85e4             [ 3] 	sta df_tmpptra+1
ee90 : b2e3             [ 5] 	lda (df_tmpptra)
ee92 : aa               [ 2] 	tax
ee93 : a900             [ 2] 	lda #0
ee95 : 28               [ 4] 	plp
ee96 : 9005             [ 3] 	bcc df_rt_readbyte_skip
ee98 : 18               [ 2] 	clc
ee99 : a001             [ 2] 	ldy #1
ee9b : b1e3             [ 5] 	lda (df_tmpptra),y
ee9d :                       df_rt_readbyte_skip
ee9d : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
eea0 :                       df_rt_vpeek
                             ;	inc df_exeoff
eea0 : 2042d9           [ 6] 	jsr df_rt_getnval
eea3 : 2006c4           [ 6] 	jsr _vdp_peek
eea6 : aa               [ 2] 	tax
eea7 : a900             [ 2] 	lda #0
eea9 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
eeac :                       df_rt_nvpeek
                             ;	inc df_exeoff
eeac : 2042d9           [ 6] 	jsr df_rt_getnval
eeaf : 2096c4           [ 6] 	jsr _rtc_nvread
eeb2 : aa               [ 2] 	tax
eeb3 : a900             [ 2] 	lda #0
eeb5 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
                             ; Random number generator
                             ; rnd(0) = get next number
                             ; rnd(>0) = set seed
eeb8 :                       df_rt_rnd
                             ;	inc df_exeoff
eeb8 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; if input is 0 then generate next random number
eebb : e000             [ 2] 	cpx #0
eebd : d017             [ 3] 	bne df_rt_rnd_set
eebf : c900             [ 2] 	cmp #0
eec1 : d013             [ 3] 	bne df_rt_rnd_set
                             	; generate next number
eec3 : a5da             [ 3] 	lda df_rnd+1
eec5 : 4a               [ 2] 	lsr a
eec6 : 26d9             [ 5] 	rol df_rnd
eec8 : 9002             [ 3] 	bcc df_rt_rnd_noeor
eeca : 49b4             [ 2] 	eor #0xb4
eecc :                       df_rt_rnd_noeor
eecc : 85da             [ 3] 	sta df_rnd+1
AS65 Assembler for R6502 [1.42].                                     Page  179
---------------------------------- bank1.s -----------------------------------

eece : 45d9             [ 3] 	eor df_rnd
eed0 : aa               [ 2] 	tax
eed1 : a900             [ 2] 	lda #0
eed3 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             	; else set the seed to that number and done
eed6 :                       df_rt_rnd_set
eed6 : 86d9             [ 3] 	stx df_rnd
eed8 : 85da             [ 3] 	sta df_rnd+1
eeda : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
                             
                             ; Get joystick status	
eedd :                       df_rt_stick
                             ;	inc df_exeoff
eedd : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used
eee0 : 86e3             [ 3] 	stx df_tmpptra
eee2 : 20d6c3           [ 6] 	jsr _snd_get_joy0
eee5 : 98               [ 2] 	tya
                             	; invert the bits so that 1=switch on
eee6 : 49ff             [ 2] 	eor #0xff
eee8 : 25e3             [ 3] 	and df_tmpptra
eeea : aa               [ 2] 	tax
eeeb : a900             [ 2] 	lda #0
eeed : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
                             ; l = msbyte(x)
eef0 :                       df_rt_msbyte
                             ;	inc df_exeoff
eef0 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; only high byte is used
eef3 : aa               [ 2] 	tax
eef4 : a900             [ 2] 	lda #0
eef6 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             	
                             ; l = lsbyte(x)
eef9 :                       df_rt_lsbyte
                             ;	inc df_exeoff
eef9 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used
eefc : a900             [ 2] 	lda #0
eefe : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
                             
                             
                             ;* Return memory footprint as follows:
                             ;* 0	Return free memory (start of vvt - end of he
                             ;* 1	Return program size (end of prg - start of p
                             ;* 2	Return size of vars (end of vnt - start of v
ef01 :                       df_rt_mem
                             ;	inc df_exeoff
ef01 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used
ef04 : e001             [ 2] 	cpx #1
ef06 : f016             [ 3] 	beq df_rt_mem_prg
ef08 : e002             [ 2] 	cpx #2
ef0a : f024             [ 3] 	beq df_rt_mem_var
                             	; default is free memory
ef0c :                       df_rt_mem_free
                             	_cpyZPWord df_vvtstrt,df_tmpptra
                             
                             	_cpyZPWord df_starend,df_tmpptrb
AS65 Assembler for R6502 [1.42].                                     Page  180
---------------------------------- bank1.s -----------------------------------

                             
ef1c : 8022             [ 3] 	bra df_rt_mem_calc
ef1e :                       df_rt_mem_prg
                             	_cpyZPWord df_prgend,df_tmpptra
                             
                             	_cpyZPWord df_prgstrt,df_tmpptrb
                             
ef2e : 8010             [ 3] 	bra df_rt_mem_calc
ef30 :                       df_rt_mem_var
                             	_cpyZPWord df_vntend,df_tmpptra
                             
                             	_cpyZPWord df_vvtstrt,df_tmpptrb
                             
ef40 :                       df_rt_mem_calc
                             	; tmpa-tmpb result in X,A
ef40 : 38               [ 2] 	sec
ef41 : a5e3             [ 3] 	lda df_tmpptra
ef43 : e5e5             [ 3] 	sbc df_tmpptrb
ef45 : aa               [ 2] 	tax
ef46 : a5e4             [ 3] 	lda df_tmpptra+1
ef48 : e5e6             [ 3] 	sbc df_tmpptrb+1
ef4a : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
                             ; %k=key(%sync) %sync>=1 means sync
ef4d :                       df_rt_get					; get is alias for key
ef4d :                       df_rt_key
                             ;	inc df_exeoff
ef4d : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used, check for sync or async
                             	; c=1 if x==0 else x>0 makes c=0
ef50 : e001             [ 2] 	cpx #1
ef52 : 20bdc5           [ 6] 	jsr io_get_ch
ef55 : 9003             [ 3] 	bcc df_rt_key_valid
                             	; zero out A
ef57 : a900             [ 2] 	lda #0
ef59 : 18               [ 2] 	clc
ef5a :                       df_rt_key_valid
ef5a : aa               [ 2] 	tax
ef5b : a900             [ 2] 	lda #0
ef5d : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
                             	
                             ; s = scrn(x,y)
ef60 :                       df_rt_scrn
                             ;	inc df_exeoff
ef60 : 2003dc           [ 6] 	jsr df_rt_parm_2ints
ef63 : a6e3             [ 3] 	ldx df_tmpptra
ef65 : a4e5             [ 3] 	ldy df_tmpptrb
ef67 : 208ec3           [ 6] 	jsr _gr_get
ef6a : aa               [ 2] 	tax
ef6b : a900             [ 2] 	lda #0
ef6d : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
                             ; p = pixel(x,y)
ef70 :                       df_rt_pixel
                             ;	inc df_exeoff
ef70 : 2003dc           [ 6] 	jsr df_rt_parm_2ints
ef73 : a6e3             [ 3] 	ldx df_tmpptra
ef75 : a4e5             [ 3] 	ldy df_tmpptrb
ef77 : a900             [ 2] 	lda #0
ef79 : 4cb7f2           [ 3] 	jmp df_ost_pushIntA
                             
AS65 Assembler for R6502 [1.42].                                     Page  181
---------------------------------- bank1.s -----------------------------------

                             ; %e=elapsed(%var)
ef7c :                       df_rt_elapsed
                             	; now get lvar X,A from current statement
ef7c : 2091dd           [ 6] 	jsr df_rt_getlvar
ef7f : e6ca             [ 5] 	inc df_exeoff
                             	; save lvar in tmpb, vvt ptr in tmpa
ef81 : 86e5             [ 3] 	stx df_tmpptrb
ef83 : 85e6             [ 3] 	sta df_tmpptrb+1
                             	; subtract vdp counter from value
ef85 : a001             [ 2] 	ldy #1	; This is in readiness to read high byte 
                             	; Safe read of vdp counter without disabling int
ef87 :                       df_rt_elapsed_rd
ef87 : a510             [ 3] 	lda vdp_int_cnt
ef89 : a611             [ 3] 	ldx vdp_int_cnt+1
ef8b : c510             [ 3] 	cmp vdp_int_cnt			; If low counter changed due t
ef8d : d0f8             [ 3] 	bne df_rt_elapsed_rd
ef8f : 38               [ 2] 	sec
ef90 : f2e5             [ 5] 	sbc (df_tmpptrb)
ef92 : aa               [ 2] 	tax
ef93 : a511             [ 3] 	lda vdp_int_cnt+1
ef95 : f1e5             [ 5] 	sbc (df_tmpptrb),y
ef97 : 4cbaf2           [ 3] 	jmp df_ost_pushInt
                             
ef9a :                       df_rt_call
                             ;	inc df_exeoff
ef9a : 2025dc           [ 6] 	jsr df_rt_parm_4ints
ef9d : a5e5             [ 3] 	lda df_tmpptrb				; load A
ef9f : a6e7             [ 3] 	ldx	df_tmpptrc				; load X
efa1 : a4e9             [ 3] 	ldy df_tmpptrd				; load Y
efa3 : 20a9ef           [ 6] 	jsr df_rt_calljsr
efa6 :                       df_rt_push_int1
efa6 : 4cbaf2           [ 3] 	jmp df_ost_pushInt			; A,X pair is return value	
efa9 :                       df_rt_calljsr
efa9 : 6ce300           [ 6] 	jmp (df_tmpptra)			; tmpptra is address, return 
                             
                             
efac :                       df_rt_sgn
                             ;	inc df_exeoff
efac : 2042d9           [ 6] 	jsr df_rt_getnval
efaf : 86e3             [ 3] 	stx df_tmpptra
efb1 : 05e3             [ 3] 	ora df_tmpptra
efb3 : f00f             [ 3] 	beq df_rt_sgn_z
efb5 : 2980             [ 2] 	and #0x80
efb7 : d006             [ 3] 	bne df_rt_sgn_n
efb9 : a201             [ 2] 	ldx #1
efbb : a900             [ 2] 	lda #0
efbd : f0e7             [ 3] 	beq df_rt_push_int1			; Always
efbf :                       df_rt_sgn_n
efbf : a2ff             [ 2] 	ldx #0xff
efc1 : 8a               [ 2] 	txa
efc2 : d0e2             [ 3] 	bne df_rt_push_int1			; Always
efc4 :                       df_rt_sgn_z
efc4 : a200             [ 2] 	ldx #0
efc6 : 8a               [ 2] 	txa
efc7 : f0dd             [ 3] 	beq df_rt_push_int1			; Always
                             
                             ; addr(X)
efc9 :                       df_rt_addr
                             	; get lvar X,A from current statement
efc9 : 2091dd           [ 6] 	jsr df_rt_getlvar
efcc : e6ca             [ 5] 	inc df_exeoff
efce : 4cbaf2           [ 3] 	jmp df_ost_pushInt
AS65 Assembler for R6502 [1.42].                                     Page  182
---------------------------------- bank1.s -----------------------------------

                             
                             
                             ; string length calculator
                             ; X,A = source
                             ; A = length not including zero
efd1 :                       df_rt_strlen_common
efd1 : 86e3             [ 3] 	stx df_tmpptra
efd3 : 85e4             [ 3] 	sta df_tmpptra+1
efd5 : a0ff             [ 2] 	ldy #0xff
efd7 :                       df_rt_strlen_count
efd7 : c8               [ 2] 	iny
efd8 : b1e3             [ 5] 	lda (df_tmpptra),y
efda : d0fb             [ 3] 	bne df_rt_strlen_count
efdc : 98               [ 2] 	tya
efdd : 60               [ 6] 	rts
                             
                             
                             ; common routine to extract a string
                             ; tmpa = source string
                             ; tmpb = dest string
                             ; tmpc = start pos
                             ; tmpd = endpos
efde :                       df_rt_str_extract
                             	; source string
efde : 20d2f2           [ 6] 	jsr df_ost_popStr
efe1 : 86e3             [ 3] 	stx df_tmpptra
efe3 : 85e4             [ 3] 	sta df_tmpptra+1
                             	; destination is string accumulator
efe5 : a5bc             [ 3] 	lda df_sevalptr
efe7 : 85e5             [ 3] 	sta df_tmpptrb
efe9 : a5bd             [ 3] 	lda df_sevalptr+1
efeb : 85e6             [ 3] 	sta df_tmpptrb+1
                             	; start pos
efed : a4e7             [ 3] 	ldy df_tmpptrc
efef : a200             [ 2] 	ldx #0
eff1 :                       df_rt_str_cpy_ch
eff1 : c4e9             [ 3] 	cpy df_tmpptrd
eff3 : f011             [ 4] 	beq df_str_src_end
eff5 : b1e3             [ 5] 	lda (df_tmpptra),y
eff7 : f00d             [ 4] 	beq df_str_src_end
eff9 : 81e5             [ 6] 	sta (df_tmpptrb,x)
                             	_incZPWord df_tmpptrb
                             
f001 : c8               [ 2] 	iny
f002 : d0ed             [ 4] 	bne df_rt_str_cpy_ch
                             	SWBRK DFERR_STRLONG
                             
f006 :                       df_str_src_end
f006 : a900             [ 2] 	lda #0
f008 : 81e5             [ 6] 	sta (df_tmpptrb,x)
f00a : a6bc             [ 3] 	ldx df_sevalptr
f00c : a5bd             [ 3] 	lda df_sevalptr+1
f00e : 4caff2           [ 3] 	jmp df_ost_pushStr
                             
                             ; $c = chr(x)
f011 :                       df_rt_chr
                             ;	inc df_exeoff
                             	; get char in X
f011 : 2042d9           [ 6] 	jsr df_rt_getnval
f014 : a000             [ 2] 	ldy #0
                             	; transfer lo byte to A
f016 : 8a               [ 2] 	txa
AS65 Assembler for R6502 [1.42].                                     Page  183
---------------------------------- bank1.s -----------------------------------

f017 : 91bc             [ 5] 	sta (df_sevalptr),y
f019 : c8               [ 2] 	iny
                             	; zero terminator
f01a : a900             [ 2] 	lda #0
f01c : 91bc             [ 5] 	sta (df_sevalptr),y
                             	; point to seval scratch area
f01e : a6bc             [ 3] 	ldx df_sevalptr
f020 : a5bd             [ 3] 	lda df_sevalptr+1
f022 : 4caff2           [ 3] 	jmp df_ost_pushStr
                             
                             ; $c = hex(x)
f025 :                       df_rt_hex
                             ;	inc df_exeoff
                             	; create hex digits
f025 : 2042d9           [ 6] 	jsr df_rt_getnval
f028 : 85e3             [ 3] 	sta df_tmpptra	; Save the high byte
f02a : 8a               [ 2] 	txa				; Convert low byte first
f02b : 20d0c8           [ 6] 	jsr str_a_to_x	; Hex digits in A,X
f02e : 85e5             [ 3] 	sta df_tmpptrb
f030 : 8a               [ 2] 	txa				; Push low digit of low byte from X
f031 : 48               [ 3] 	pha
f032 : a5e5             [ 3] 	lda df_tmpptrb	; Get A back from temp
f034 : 48               [ 3] 	pha				; Push high digit of low byte
f035 : a5e3             [ 3] 	lda df_tmpptra	; Get the high byte
f037 : 20d0c8           [ 6] 	jsr str_a_to_x	; Hex digits in A,X
                             	; create string
f03a : a000             [ 2] 	ldy #0			; Index in to string temp area
                             	; hi/hi
f03c : 91bc             [ 5] 	sta (df_sevalptr),y
f03e : c8               [ 2] 	iny
                             	; hi/lo
f03f : 8a               [ 2] 	txa
f040 : 91bc             [ 5] 	sta (df_sevalptr),y
f042 : c8               [ 2] 	iny
                             	; lo/hi
f043 : 68               [ 4] 	pla
f044 : 91bc             [ 5] 	sta (df_sevalptr),y
f046 : c8               [ 2] 	iny
                             	; lo/lo
f047 : 68               [ 4] 	pla
f048 : 91bc             [ 5] 	sta (df_sevalptr),y
f04a : c8               [ 2] 	iny
                             	; zero terminator
f04b : a900             [ 2] 	lda #0
f04d : 91bc             [ 5] 	sta (df_sevalptr),y
                             	; point to seval scratch area
f04f : a6bc             [ 3] 	ldx df_sevalptr
f051 : a5bd             [ 3] 	lda df_sevalptr+1
f053 : 4caff2           [ 3] 	jmp df_ost_pushStr
                             
                             ; $c = dec(x)
f056 :                       df_rt_dec
f056 : 2042d9           [ 6] 	jsr df_rt_getnval
f059 : 18               [ 2] 	clc						; No leading zeros
f05a : 2017cb           [ 6] 	jsr int_to_str
                             	; point to num_buf scratch area
f05d : a295             [ 2] 	ldx #lo(num_buf)
f05f : a900             [ 2] 	lda #hi(num_buf)
f061 : 4caff2           [ 3] 	jmp df_ost_pushStr
                             
                             ; $l = left($s, x)
f064 :                       df_rt_left
AS65 Assembler for R6502 [1.42].                                     Page  184
---------------------------------- bank1.s -----------------------------------

                             ;	inc df_exeoff
                             
                             	; first get the string to act on
                             	; point to string accumulator
f064 : 20f8d9           [ 6] 	jsr df_rt_seval
                             	; now get the num of chars
f067 : e6ca             [ 5] 	inc df_exeoff
f069 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; number of chars to extract
f06c : 86e9             [ 3] 	stx df_tmpptrd
                             	; start position
f06e : a000             [ 2] 	ldy #0
f070 : 84e7             [ 3] 	sty df_tmpptrc
f072 : 4cdeef           [ 3] 	jmp df_rt_str_extract
                             
                             ; $r = right($s, x)
f075 :                       df_rt_right
                             ;	inc df_exeoff
                             	; first get the string to act on
                             	; point to string accumulator
f075 : 20f8d9           [ 6] 	jsr df_rt_seval
                             	; now get the num of chars from the right
f078 : e6ca             [ 5] 	inc df_exeoff
f07a : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; number of chars to extract from the right
f07d : 86e7             [ 3] 	stx df_tmpptrc
                             	; end pos = len
f07f : a6bc             [ 3] 	ldx df_sevalptr
f081 : a5bd             [ 3] 	lda df_sevalptr+1
f083 : 20d1ef           [ 6] 	jsr df_rt_strlen_common
f086 : 85e9             [ 3] 	sta df_tmpptrd
                             	; subtract num chars to extract to get start pos
f088 : 38               [ 2] 	sec
f089 : e5e7             [ 3] 	sbc df_tmpptrc
f08b : 85e7             [ 3] 	sta df_tmpptrc
f08d : 4cdeef           [ 3] 	jmp df_rt_str_extract
                             
                             ; $m = mid($s, x, y)
f090 :                       df_rt_mid
                             ;	inc df_exeoff
                             	; first get the string to act on
                             	; point to string accumulator
f090 : 20f8d9           [ 6] 	jsr df_rt_seval
                             	; now get start of string segment
f093 : e6ca             [ 5] 	inc df_exeoff
f095 : 2048d9           [ 6] 	jsr df_rt_neval
                             	; number of chars to extract
f098 : e6ca             [ 5] 	inc df_exeoff
f09a : 2042d9           [ 6] 	jsr df_rt_getnval
f09d : 86e9             [ 3] 	stx df_tmpptrd
                             	; start position
f09f : 20daf2           [ 6] 	jsr df_ost_popInt
f0a2 : ca               [ 2] 	dex					; zero offset rather than 1
f0a3 : 86e7             [ 3] 	stx df_tmpptrc
                             	; update end pos by adding start pos
f0a5 : 8a               [ 2] 	txa
f0a6 : 18               [ 2] 	clc
f0a7 : 65e9             [ 3] 	adc df_tmpptrd
f0a9 : 85e9             [ 3] 	sta df_tmpptrd
f0ab : 4cdeef           [ 3] 	jmp df_rt_str_extract
                             
                             ; %l = len($s)
AS65 Assembler for R6502 [1.42].                                     Page  185
---------------------------------- bank1.s -----------------------------------

f0ae :                       df_rt_len
                             ;	inc df_exeoff
                             	; evaluate the string in the string accumulator
f0ae : 20f8d9           [ 6] 	jsr df_rt_seval
f0b1 : 20d2f2           [ 6] 	jsr df_ost_popStr
                             	; now calculate the length of this string
f0b4 : 20d1ef           [ 6] 	jsr df_rt_strlen_common
f0b7 : 4cb7f2           [ 3] 	jmp df_ost_pushIntA
                             
                             ; %l = asc($s)
f0ba :                       df_rt_asc
                             ;	inc df_exeoff
                             	; Evaluate string in the string accumulator
f0ba : 20f8d9           [ 6] 	jsr df_rt_seval
f0bd : 20d2f2           [ 6] 	jsr df_ost_popStr
                             	; Store point in ZP
f0c0 : 86e3             [ 3] 	stx df_tmpptra
f0c2 : 85e4             [ 3] 	sta df_tmpptra+1
                             	; Find the character at beginning
f0c4 : a200             [ 2] 	ldx #0
f0c6 : a1e3             [ 6] 	lda (df_tmpptra,x)
f0c8 : 4cb7f2           [ 3] 	jmp df_ost_pushIntA
                             
                             ; %l = val($s)
f0cb :                       df_rt_val
                             ;	inc df_exeoff
                             	; evaluate the string
f0cb : 20f8d9           [ 6] 	jsr df_rt_seval
f0ce : 20d2f2           [ 6] 	jsr df_ost_popStr
f0d1 : a000             [ 2] 	ldy #0				; any numeric format
f0d3 : 201bc9           [ 6] 	jsr con_n_to_a		; result in num_a
f0d6 : b007             [ 3] 	bcs df_rt_val_err
f0d8 : a685             [ 3] 	ldx num_a
f0da : a586             [ 3] 	lda num_a+1
                             	; Save as an int
f0dc : 4cbaf2           [ 3] 	jmp df_ost_pushInt
f0df :                       df_rt_val_err
                             	SWBRK DFERR_TYPEMISM
                             
                             
                             ; stop execution
f0e1 :                       df_rt_abort
                             	SWBRK DFERR_ABORT
                             
                             
                             ;* ok=fcreate(filename)
f0e3 :                       df_rt_fcreate
f0e3 : 20a7eb           [ 6] 	jsr df_rt_parse_file
f0e6 : 20c6c5           [ 6] 	jsr io_open_write
f0e9 :                       df_rt_fcreate_check
                             	; Assume -1 which is OK
f0e9 : a2ff             [ 2] 	ldx #-1
f0eb : 9002             [ 3] 	bcc df_rt_fcreate_ok
                             	; Else 0 which is error
f0ed : a200             [ 2] 	ldx #0
f0ef :                       df_rt_fcreate_ok
f0ef : 8a               [ 2] 	txa				; make A=X
                             	; Save as an int
f0f0 : 20baf2           [ 6] 	jsr df_ost_pushInt
                             	; Ensure we're back to the normal IO device
f0f3 : 4ca2c5           [ 3] 	jmp io_set_default
                             	
AS65 Assembler for R6502 [1.42].                                     Page  186
---------------------------------- bank1.s -----------------------------------

                             ;* ok=fopen(filename)
f0f6 :                       df_rt_fopen
f0f6 : 20a7eb           [ 6] 	jsr df_rt_parse_file
f0f9 : 20c3c5           [ 6] 	jsr io_open_read
f0fc : 80eb             [ 3] 	bra df_rt_fcreate_check
                             
                             ;* ok=fclose()
f0fe :                       df_rt_fclose
f0fe : a902             [ 2] 	lda #2					; Only works for SD card now
f100 : 20a5c5           [ 6] 	jsr io_active_device
f103 : 20c9c5           [ 6] 	jsr io_close
                             	; Ensure we're back to the normal IO device
f106 : 4ca2c5           [ 3] 	jmp io_set_default
                             
                             ;* device <num>
f109 :                       df_rt_device
f109 : 2042d9           [ 6] 	jsr df_rt_getnval
                             	; Force update of status register
f10c : 8a               [ 2] 	txa
f10d : 300a             [ 3] 	bmi df_rt_device_default
                             	; Stop dflat from trying to read inputs for Ctrl
f10f : a59e             [ 3] 	lda df_checkmsk
f111 : 0980             [ 2] 	ora #0x80
f113 : 859e             [ 3] 	sta df_checkmsk
f115 : 8a               [ 2] 	txa
                             	; A contains the device to activate
f116 : 4ca5c5           [ 3] 	jmp io_active_device
f119 :                       df_rt_device_default
                             	; Allow dflat to read inputs for Ctrl-C
f119 : a59e             [ 3] 	lda df_checkmsk
f11b : 297f             [ 2] 	and #0x7f
f11d : 859e             [ 3] 	sta df_checkmsk
f11f : 4ca2c5           [ 3] 	jmp io_set_default
                             
f122 :                       mod_sz_rtsubs_e
                             
                             
                             	include "dflat/proc.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  PROC.S
                             ;*  dflat module to handle procedures:
                             ;*  - executing a procedure
                             ;*  - find a proc, pass local and non-local param
                             ;*  - return from a proc, unload locals
                             ;*  - save the definition of a proc in the VNT an
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f122 :                       mod_sz_proc_s
                             
f122 :                       df_rt_proc_parmerr
f122 :                       df_rt_deferr
AS65 Assembler for R6502 [1.42].                                     Page  187
---------------------------------- bank1.s -----------------------------------

                             	SWBRK DFERR_PROCPARM
                             
                             
                             
                             ; call procedure
f124 :                       df_rt_proc
                             	; move past escape token
f124 : a4ca             [ 3] 	ldy df_exeoff
f126 : c8               [ 2] 	iny
                             	; Get VVT address X,A and procptr
f127 : b1c8             [ 5] 	lda (df_currlin),y
f129 : aa               [ 2] 	tax
f12a : c8               [ 2] 	iny
f12b : b1c8             [ 5] 	lda (df_currlin),y
f12d : c8               [ 2] 	iny
f12e : 84ca             [ 3] 	sty df_exeoff
f130 : 86d0             [ 3] 	stx df_procptr
f132 : 85d1             [ 3] 	sta df_procptr+1
                             	
                             	; is index 0 (held in dim1)
                             	; then need to find the procedure
f134 : a003             [ 2] 	ldy #DFVVT_DIM1
f136 : b1d0             [ 5] 	lda (df_procptr),y
f138 : d014             [ 3] 	bne df_rt_proc_addr
                             	; find proc
f13a : 2031dd           [ 6] 	jsr df_rt_findproc
                             	; save y (line index)
f13d : 8445             [ 3] 	sty tmp_d
                             	; now go and update the proc vvt address
f13f : a002             [ 2] 	ldy #DFVVT_HI
f141 : 91d0             [ 5] 	sta (df_procptr),y
f143 : a001             [ 2] 	ldy #DFVVT_LO
f145 : 8a               [ 2] 	txa
f146 : 91d0             [ 5] 	sta (df_procptr),y
f148 : a003             [ 2] 	ldy #DFVVT_DIM1
                             	; get back line index in to A
f14a : a545             [ 3] 	lda tmp_d
f14c : 91d0             [ 5] 	sta (df_procptr),y
f14e :                       df_rt_proc_addr
                             	; move past first open bracket
f14e : e6ca             [ 5] 	inc df_exeoff
                             	
                             	; get parm count
f150 : a004             [ 2] 	ldy #DFVVT_DIM2
f152 : b1d0             [ 5] 	lda (df_procptr),y	
f154 : f018             [ 3] 	beq df_rt_proc_parm_none
                             	; push the right number of parms on
f156 : 48               [ 3] 	pha
                             
f157 : c6ca             [ 5] 	dec df_exeoff		; Pre-adjust
f159 :                       df_rt_proc_push_parm
                             	; move past comma or opening bracket
f159 : e6ca             [ 5] 	inc df_exeoff
                             	; if at end then error!
f15b : a4ca             [ 3] 	ldy df_exeoff
f15d : b1c8             [ 5] 	lda (df_currlin),y
f15f : c929             [ 2] 	cmp #')'
f161 : f0bf             [ 3] 	beq df_rt_proc_parmerr
                             	; else try and evaluate
f163 : 2048d9           [ 6] 	jsr df_rt_neval
                             	; get parm count off stack
f166 : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page  188
---------------------------------- bank1.s -----------------------------------

                             	; decrement
f167 : 38               [ 2] 	sec
f168 : e901             [ 2] 	sbc #1
                             	; and put back on stack
f16a : 48               [ 3] 	pha
                             	; go back and do all required parms
f16b : d0ec             [ 3] 	bne df_rt_proc_push_parm
                             	; remove parm counter from stack
f16d :                       df_rt_proc_parm_done
f16d : 68               [ 4] 	pla
f16e :                       df_rt_proc_parm_none
                             	; should be at close bracket
f16e : a4ca             [ 3] 	ldy df_exeoff
f170 : b1c8             [ 5] 	lda (df_currlin),y
f172 : c929             [ 2] 	cmp #')'
f174 : d0ac             [ 3] 	bne df_rt_proc_parmerr
                             	; should be no more parms
                             	; ok, finally we have all parms on rt stack
                             	; now execute the procedure
                             	; get back the proc address
f176 : a6d0             [ 3] 	ldx df_procptr
f178 : a5d1             [ 3] 	lda df_procptr+1
                             ;	bne df_rt_exec_proc		; ALWAYS as procptr+1 !=0
                             	
                             ; executing a procedure in VVT slot A,X
f17a :                       df_rt_exec_proc
                             	; save slot address
f17a : 86e3             [ 3] 	stx df_tmpptra
f17c : 85e4             [ 3] 	sta df_tmpptra+1
                             	
                             	; need to save all important vars
f17e : a5c8             [ 3] 	lda df_currlin
f180 : 48               [ 3] 	pha
f181 : a5c9             [ 3] 	lda df_currlin+1
f183 : 48               [ 3] 	pha
f184 : a5ca             [ 3] 	lda df_exeoff
f186 : 48               [ 3] 	pha
f187 : a5c1             [ 3] 	lda df_nxtstidx
f189 : 48               [ 3] 	pha
f18a : a5c2             [ 3] 	lda df_curstidx
f18c : 48               [ 3] 	pha
f18d : a5c0             [ 3] 	lda df_eolidx
f18f : 48               [ 3] 	pha
f190 : a5d5             [ 3] 	lda df_ifnest
f192 : 48               [ 3] 	pha
                             
                             	; now initialise the data
f193 : a001             [ 2] 	ldy #DFVVT_LO
f195 : b1e3             [ 5] 	lda (df_tmpptra),y
f197 : 85c8             [ 3] 	sta df_currlin
f199 : c8               [ 2] 	iny
f19a : b1e3             [ 5] 	lda (df_tmpptra),y
f19c : 85c9             [ 3] 	sta df_currlin+1
f19e : c8               [ 2] 	iny
f19f : b1e3             [ 5] 	lda (df_tmpptra),y
f1a1 : 85ca             [ 3] 	sta df_exeoff
f1a3 : 85c2             [ 3] 	sta df_curstidx
f1a5 : a000             [ 2] 	ldy #0		; hmm XXXXX might need to be tay to get 
f1a7 : b1c8             [ 5] 	lda (df_currlin),y
f1a9 : 85c1             [ 3] 	sta df_nxtstidx
                             	; now execute statements
f1ab : 2073dc           [ 6] 	jsr df_rt_exec_stat
AS65 Assembler for R6502 [1.42].                                     Page  189
---------------------------------- bank1.s -----------------------------------

                             ;	bcs df_rt_exec_proc_err
                             	; now restore the position
f1ae : 68               [ 4] 	pla
f1af : 85d5             [ 3] 	sta df_ifnest
f1b1 : 68               [ 4] 	pla
f1b2 : 85c0             [ 3] 	sta df_eolidx
f1b4 : 68               [ 4] 	pla
f1b5 : 85c2             [ 3] 	sta df_curstidx
f1b7 : 68               [ 4] 	pla
f1b8 : 85c1             [ 3] 	sta df_nxtstidx
f1ba : 68               [ 4] 	pla
f1bb : 85ca             [ 3] 	sta df_exeoff
f1bd : 68               [ 4] 	pla
f1be : 85c9             [ 3] 	sta df_currlin+1
f1c0 : 68               [ 4] 	pla
f1c1 : 85c8             [ 3] 	sta df_currlin
                             	; should be all restored, so return
f1c3 : 60               [ 6] 	rts
                             
                             
f1c4 :                       df_rt_def
                             	; line offset pointing at DFTK_PROC
                             	; skip over PROC address and open bracket
f1c4 : a6ca             [ 3] 	ldx df_exeoff
f1c6 : e8               [ 2] 	inx
f1c7 : e8               [ 2] 	inx
f1c8 : e8               [ 2] 	inx
f1c9 : 86ca             [ 3] 	stx df_exeoff
                             	; parms on stack in reverse order to parm list
                             	; so get each parm and type and save to scratch
f1cb : a201             [ 2] 	ldx #1									; index in to scratch
f1cd : 86ce             [ 3] 	stx df_procargs							; Proc args is the #args-1
f1cf : a4ca             [ 3] 	ldy df_exeoff
f1d1 :                       df_rt_def_find_var
f1d1 : c8               [ 2] 	iny
f1d2 : b1c8             [ 5] 	lda (df_currlin),y
                             	; check if end of parm list
f1d4 : c929             [ 2] 	cmp #')'
f1d6 : f021             [ 3] 	beq df_rt_def_parm_done
                             	; else check if found a variable escape token (<
f1d8 : c911             [ 2] 	cmp #DFTK_VAR
f1da : f007             [ 3] 	beq df_rt_def_got_var
                             	; else check if non-local specifier
f1dc : c926             [ 2] 	cmp #DFTK_VARPARM						; This is a regular ASCII
f1de : d0f1             [ 3] 	bne df_rt_def_find_var
f1e0 :                       df_rt_def_got_varparm
                             	; set high bit
f1e0 : 0980             [ 2] 	ora #0x80
                             	; advance over non-local specifier
f1e2 : c8               [ 2] 	iny
f1e3 :                       df_rt_def_got_var
f1e3 : 4980             [ 2] 	eor #0x80			; If was set by '&' qualifier then w
f1e5 : 9d0009           [ 5] 	sta scratch,x		; Save parm type (by value or ref
                             	; get address and save in scratch
f1e8 : c8               [ 2] 	iny
f1e9 : b1c8             [ 5] 	lda (df_currlin),y
f1eb : 9d2009           [ 5] 	sta scratch+32,x	; Hope 32 params is enough! :-)
f1ee : c8               [ 2] 	iny
f1ef : b1c8             [ 5] 	lda (df_currlin),y
f1f1 : 9d4009           [ 5] 	sta scratch+64,x
f1f4 : e8               [ 2] 	inx
f1f5 : e6ce             [ 5] 	inc df_procargs
AS65 Assembler for R6502 [1.42].                                     Page  190
---------------------------------- bank1.s -----------------------------------

f1f7 : d0d8             [ 3] 	bne df_rt_def_find_var  ; always - relies not ze
f1f9 :                       df_rt_def_parm_done
                             	; save index that we got to
f1f9 : 84ca             [ 3] 	sty df_exeoff
                             	; save def param list position in temp
f1fb : 86cd             [ 3] 	stx df_procmode
                             	; all var indices on the operator stack
                             	; now load up variables with parameters
                             	; initially assume no locals
f1fd : a900             [ 2] 	lda #0
f1ff : 85cf             [ 3] 	sta df_procloc
f201 :                       df_rt_def_load_var
f201 : c6ce             [ 5] 	dec df_procargs
f203 : f02f             [ 3] 	beq df_rt_def_load_var_done
                             	; get var address
f205 : c6cd             [ 5] 	dec df_procmode
f207 : a6cd             [ 3] 	ldx df_procmode
f209 : bd2009           [ 4] 	lda scratch+32,x
f20c : 85e3             [ 3] 	sta df_tmpptra
f20e : bd4009           [ 4] 	lda scratch+64,x
f211 : 85e4             [ 3] 	sta df_tmpptra+1
                             	
f213 : bd0009           [ 4] 	lda scratch,x
                             	; if MSB is clear then this is not a local varia
                             	; so just go an initialise with stacking
f216 : 1009             [ 3] 	bpl df_rt_def_initialise_parm
                             	; else call the local handling code to 
                             	; push the var address on to the runtime stack
f218 : a6e3             [ 3] 	ldx df_tmpptra
f21a : a5e4             [ 3] 	lda df_tmpptra+1
f21c : 2068f2           [ 6] 	jsr df_rt_proc_local
                             	; increment number of locals
f21f : e6cf             [ 5] 	inc df_procloc
f221 :                       df_rt_def_initialise_parm
                             	; load type
f221 : a000             [ 2] 	ldy #DFVVT_TYPE
f223 : b1e3             [ 5] 	lda (df_tmpptra),y
f225 : a8               [ 2] 	tay					; Put the type into Y
f226 : 20dcf2           [ 6] 	jsr df_ost_popParmX	; Try to get this off the st
                             	; update the variable
f229 : a002             [ 2] 	ldy #DFVVT_HI
f22b : 91e3             [ 5] 	sta (df_tmpptra),y
f22d : 88               [ 2] 	dey
f22e : 8a               [ 2] 	txa
f22f : 91e3             [ 5] 	sta (df_tmpptra),y
                             
f231 : 4c01f2           [ 3] 	jmp df_rt_def_load_var
f234 :                       df_rt_def_load_var_done
                             	; save the number of local parameters found so t
                             	; be unloaded when the proc ends
f234 : a5cf             [ 3] 	lda df_procloc
f236 : 207cf2           [ 6] 	jsr df_rst_pushByte
                             	; continue with next statement
f239 : 18               [ 2] 	clc
f23a : 60               [ 6] 	rts
                             
                             	
                             ; return a value
f23b :                       df_rt_return
                             	; evaluate the return and put on the parameter s
                             	; then process this like an end of procedure
f23b : 2048d9           [ 6] 	jsr df_rt_neval
AS65 Assembler for R6502 [1.42].                                     Page  191
---------------------------------- bank1.s -----------------------------------

                             ; end def for a proc
f23e :                       df_rt_enddef
                             	; unload any locals
                             ;	jsr df_rt_proc_unlocal
                             	; nothing to do - main loop will terminate
                             ;	clc
                             ;	rts
                             ; enddef falls through to the unlocal code	
                             	
                             ; unload any local variables from runtime stack
                             ;df_rt_proc_unlocal
f23e : 2085f2           [ 6] 	jsr df_rst_popByte
f241 : aa               [ 2] 	tax
f242 : f020             [ 3] 	beq df_rt_proc_unload_done
f244 :                       df_rt_proc_unloadvar
f244 : 8a               [ 2] 	txa
f245 : 48               [ 3] 	pha
                             	; var value is popped first then index
                             	; get a word and put in tmpb
f246 : 20a2f2           [ 6] 	jsr df_rst_popWord
f249 : 86e5             [ 3] 	stx df_tmpptrb
f24b : 85e6             [ 3] 	sta df_tmpptrb+1
                             	; get the var address
f24d : 20a2f2           [ 6] 	jsr df_rst_popWord
f250 : 86e3             [ 3] 	stx df_tmpptra
f252 : 85e4             [ 3] 	sta df_tmpptra+1
                             	; store lo byte first
f254 : a001             [ 2] 	ldy #DFVVT_LO
f256 : a5e5             [ 3] 	lda df_tmpptrb
f258 : 91e3             [ 5] 	sta (df_tmpptra),y
                             	; then hi
f25a : c8               [ 2] 	iny
f25b : a5e6             [ 3] 	lda df_tmpptrb+1
f25d : 91e3             [ 5] 	sta (df_tmpptra),y
                             	; restore counter
f25f : 68               [ 4] 	pla
f260 : aa               [ 2] 	tax
f261 : ca               [ 2] 	dex
f262 : d0e0             [ 3] 	bne df_rt_proc_unloadvar
f264 :                       df_rt_proc_unload_done
f264 : 68               [ 4] 	pla					; Pull the return address off stack
f265 : 68               [ 4] 	pla					; to get to the previous level
f266 : 18               [ 2] 	clc
f267 : 60               [ 6] 	rts
                             	
                             ; push a local variable to the runtime stack
                             ; X,A = var slot
f268 :                       df_rt_proc_local
                             	; save address
f268 : 86e3             [ 3] 	stx df_tmpptra
f26a : 85e4             [ 3] 	sta df_tmpptra+1
                             	; push var slot on rt stack
f26c : 2094f2           [ 6] 	jsr df_rst_pushWord
f26f :                       df_rt_proc_local_load	
                             	; load x,a with var value lo,hi
f26f : a001             [ 2] 	ldy #DFVVT_LO
f271 : b1e3             [ 5] 	lda (df_tmpptra),y
f273 : aa               [ 2] 	tax
f274 : c8               [ 2] 	iny
f275 : b1e3             [ 5] 	lda (df_tmpptra),y
                             	; push word on to rt stack
f277 : 2094f2           [ 6] 	jsr df_rst_pushWord
AS65 Assembler for R6502 [1.42].                                     Page  192
---------------------------------- bank1.s -----------------------------------

f27a : 18               [ 2] 	clc
f27b : 60               [ 6] 	rts
                             		
f27c :                       mod_sz_proc_e
                             
                             
f27c :                       mod_sz_runtime_e
                             
                             
                             
                             	include "dflat/stack.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  STACK.S
                             ;*  This module implements the dflat software sta
                             ;*  needs a few stacks:
                             ;*  - 6502 stack for expression parsing and reent
                             ;*  - dflat runtime stack for things like for/nex
                             ;*  - dflat parameter stack for passing parameter
                             ;*  The two software stacks are implemented in th
                             ;*  with the operator stack growing up from 0 and
                             ;*  runtime stack growing down from 255.  Hopeful
                             ;*  don't meet as there are no checks for this at
                             ;*  purely because I want speed over friendliness
                             ;*  I may come to regret this!
                             ;*  I have also added the only runtime memory all
                             ;*  needed by dflat here.  Humourously I have cal
                             ;*  which is taken from the C language, but it's 
                             ;*  grab some memory after end the of dflat progr
                             ;*  arrays - which of course cannot have storage 
                             ;*  tokenisation time (e.g. because I dimension a
                             ;*  a size from a variable).
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             
                             ;****************************************
                             ;* Push a byte on to runtime stack
                             ;* A = byte
                             ;****************************************
f27c :                       df_rst_pushByte
f27c : a4b8             [ 3] 	ldy df_rtstop
f27e : 99000b           [ 5] 	sta df_rtstck,y
f281 : 88               [ 2] 	dey
f282 : 84b8             [ 3] 	sty df_rtstop
f284 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop a byte off runtime stack
                             ;* A = byte
                             ;****************************************
f285 :                       df_rst_popByte
f285 : a4b8             [ 3] 	ldy df_rtstop
AS65 Assembler for R6502 [1.42].                                     Page  193
---------------------------------- bank1.s -----------------------------------

f287 : c8               [ 2] 	iny
f288 : b9000b           [ 4] 	lda df_rtstck,y
f28b : 84b8             [ 3] 	sty df_rtstop
f28d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Peek a byte off runtime stack
                             ;* A = byte
                             ;****************************************
f28e :                       df_rst_peekByte
f28e : a4b8             [ 3] 	ldy df_rtstop
                             	; Look at what is below top of stack
                             	; below means the next address up as
                             	; this stack grows downwards like 6502
f290 : b9010b           [ 4] 	lda df_rtstck+1,y
f293 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Push a word on to runtime stack
                             ;* X,A = word lo,hi
                             ;****************************************
f294 :                       df_rst_pushWord
f294 : a4b8             [ 3] 	ldy df_rtstop
f296 : 99000b           [ 5] 	sta df_rtstck,y
f299 : 88               [ 2] 	dey
f29a : 8a               [ 2] 	txa
f29b : 99000b           [ 5] 	sta df_rtstck,y
f29e : 88               [ 2] 	dey
f29f : 84b8             [ 3] 	sty df_rtstop
f2a1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop a word off runtime stack
                             ;* X,A = word lo,hi
                             ;****************************************
f2a2 :                       df_rst_popWord
f2a2 : a4b8             [ 3] 	ldy df_rtstop
f2a4 : c8               [ 2] 	iny
f2a5 : be000b           [ 4] 	ldx df_rtstck,y
f2a8 : c8               [ 2] 	iny
f2a9 : b9000b           [ 4] 	lda df_rtstck,y
f2ac : 84b8             [ 3] 	sty df_rtstop
f2ae : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push a string pointer on to parm stack
                             ;* X,A - int
                             ;****************************************
f2af :                       df_ost_pushStr
f2af : a004             [ 2] 	ldy #DFST_STR
f2b1 : d009             [ 3] 	bne df_ost_pushParmX		; ALWAYS!
                             
                             ;****************************************
                             ;* Push a general pointer on to parm stack
                             ;* X,A - int
                             ;****************************************
f2b3 :                       df_ost_pushPtr
f2b3 : a0ff             [ 2] 	ldy #DFST_PTR
f2b5 : d005             [ 3] 	bne df_ost_pushParmX		; ALWAYS!
                             	
                             ;****************************************
                             ;* Push A on to parm stack
AS65 Assembler for R6502 [1.42].                                     Page  194
---------------------------------- bank1.s -----------------------------------

                             ;* X,A - int
                             ;****************************************
f2b7 :                       df_ost_pushIntA
f2b7 : aa               [ 2] 	tax
f2b8 : a900             [ 2] 	lda #0
                             	; ***FALLS THROUGH TO NEXT ROUTINE***
                             
                             ;****************************************
                             ;* Push an int on to parm stack
                             ;* X,A - int
                             ;****************************************
f2ba :                       df_ost_pushInt
f2ba : a003             [ 2] 	ldy #DFST_INT
                             	; ***FALLS THROUGH TO NEXT ROUTINE***
                             
                             ;****************************************
                             ;* Push a parameter on to parm stack
                             ;* X,A - int
                             ;* Y - type
                             ;****************************************
f2bc :                       df_ost_pushParmX
f2bc : 8445             [ 3] 	sty tmp_d		; Save Type
f2be : a4b9             [ 3] 	ldy df_parmtop	; Get stack index
                             	; push high byte first (A)
f2c0 : 99000b           [ 5] 	sta df_rtstck,y
f2c3 : c8               [ 2] 	iny
                             	; push low byte next (X)
f2c4 : 8a               [ 2] 	txa
f2c5 : 99000b           [ 5] 	sta df_rtstck,y
f2c8 : c8               [ 2] 	iny
f2c9 : a545             [ 3] 	lda tmp_d		; get Type
f2cb : 99000b           [ 5] 	sta df_rtstck,y
f2ce : c8               [ 2] 	iny
                             	; save new top of stack
f2cf : 84b9             [ 3] 	sty df_parmtop
f2d1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop a string pointer off parm stack
                             ;* X,A - int
                             ;****************************************
f2d2 :                       df_ost_popStr
f2d2 : a904             [ 2] 	lda #DFST_STR
f2d4 : d006             [ 3] 	bne df_ost_popParmX			; ALWAYS!
                             	
                             ;****************************************
                             ;* Pop a general pointer off parm stack
                             ;* X,A - int
                             ;****************************************
f2d6 :                       df_ost_popPtr
f2d6 : a9ff             [ 2] 	lda #0xff
f2d8 : d002             [ 3] 	bne df_ost_popParmX			; ALWAYS!
                             		
                             ;****************************************
                             ;* Pop an int off parm stack
                             ;* X,A - int
                             ;****************************************
f2da :                       df_ost_popInt
f2da : a903             [ 2] 	lda #DFST_INT
                             	; ***FALL THROUGH TO NEXT ROUTINE***
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  195
---------------------------------- bank1.s -----------------------------------

                             ;* Pop parameter from the stack
                             ;* X,A - int
                             ;* A - type expected
                             ;****************************************
f2dc :                       df_ost_popParmX
f2dc : a4b9             [ 3] 	ldy df_parmtop
                             	; pull type first
f2de : 88               [ 2] 	dey
f2df : 39000b           [ 4] 	and df_rtstck,y
f2e2 : f00b             [ 3] 	beq df_st_typemismatcherr
                             	; pull low byte first
f2e4 : 88               [ 2] 	dey
f2e5 : be000b           [ 4] 	ldx df_rtstck,y
                             	; pull high byte next
f2e8 : 88               [ 2] 	dey
f2e9 : b9000b           [ 4] 	lda df_rtstck,y
                             	; save new top of stack
f2ec : 84b9             [ 3] 	sty df_parmtop
f2ee : 60               [ 6] 	rts
f2ef :                       df_st_typemismatcherr
                             	SWBRK DFERR_TYPEMISM
                             
                             
                             ;****************************************
                             ;* Return type on top of stack
                             ;* A - type
                             ;****************************************
f2f1 :                       df_ost_peekType
f2f1 : a4b9             [ 3] 	ldy df_parmtop
f2f3 : b9ff0a           [ 4] 	lda df_rtstck-1,y
f2f6 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Allocate space on the heap
                             ;* X, A = Number of bytes to allocate
                             ;* X, A return address of allocated space
                             ;****************************************
f2f7 :                       df_st_malloc
                             	; save A in Y
f2f7 : a8               [ 2] 	tay
                             	; save old starend
f2f8 : a5b7             [ 3] 	lda df_starend+1
f2fa : 48               [ 3] 	pha
f2fb : a5b6             [ 3] 	lda df_starend
f2fd : 48               [ 3] 	pha
                             	; restore A from Y
f2fe : 98               [ 2] 	tya
                             	; add X,A to starend
f2ff : 48               [ 3] 	pha
f300 : 8a               [ 2] 	txa
f301 : 18               [ 2] 	clc
f302 : 65b6             [ 3] 	adc df_starend
f304 : 85b6             [ 3] 	sta df_starend
f306 : 68               [ 4] 	pla
f307 : 65b7             [ 3] 	adc df_starend+1
f309 : 85b7             [ 3] 	sta df_starend+1
                             	; return old starend as start of space
f30b : 68               [ 4] 	pla
f30c : aa               [ 2] 	tax
f30d : 68               [ 4] 	pla
f30e : 60               [ 6] 	rts
                             	
AS65 Assembler for R6502 [1.42].                                     Page  196
---------------------------------- bank1.s -----------------------------------

                             
                             ;****************************************
                             ;* df_init
                             ;* Initialise dflat language settings
                             ;****************************************
f30f :                       df_init
                             	; Initialise top of memory to default
                             	; This can be overridden by himem command
f30f : a900             [ 2] 	lda #lo(DF_MEMTOP)
f311 : 8da70c           [ 4] 	sta df_memtop
f314 : a9c0             [ 2] 	lda #hi(DF_MEMTOP)
f316 : 8da80c           [ 4] 	sta df_memtop+1
                             
                             	; Init program space
f319 : 201cf3           [ 6] 	jsr df_clear
                             
                             	; Initialise assembler
                             ;	jsr asm_init
                             
                             ;	rts
                             
                             
                             ;****************************************
                             ;* df_clear
                             ;* Initialise program space
                             ;****************************************
f31c :                       df_clear
                             	; Start of program space
f31c : a9a9             [ 2] 	lda #lo(DF_PROGSTART)
f31e : 85a7             [ 3] 	sta df_prgstrt
f320 : 85a9             [ 3] 	sta df_prgend
f322 : a90c             [ 2] 	lda #hi(DF_PROGSTART)
f324 : 85a8             [ 3] 	sta df_prgstrt+1
f326 : 85aa             [ 3] 	sta df_prgend+1
                             	; Terminal value in prog space
f328 : a900             [ 2] 	lda #0
f32a : a8               [ 2] 	tay
f32b : 91a7             [ 5] 	sta (df_prgstrt),y
                             	; No variables - zero the count
f32d : 85b3             [ 3] 	sta df_varcnt
                             
                             	; Variable value table
                             	; Grows down from mem top
f32f : ada70c           [ 4] 	lda df_memtop
f332 : 85af             [ 3] 	sta df_vvtstrt
f334 : 85b1             [ 3] 	sta df_vvtend
f336 : ada80c           [ 4] 	lda df_memtop+1
f339 : 85b0             [ 3] 	sta df_vvtstrt+1
f33b : 85b2             [ 3] 	sta df_vvtend+1
                             
                             	; Variable name table
                             	; Grows down from mem top
f33d : a5af             [ 3] 	lda df_vvtstrt
f33f : 85ab             [ 3] 	sta df_vntstrt
f341 : 85ad             [ 3] 	sta df_vntend
f343 : a5b0             [ 3] 	lda df_vvtstrt+1
f345 : 85ac             [ 3] 	sta df_vntstrt+1
f347 : 85ae             [ 3] 	sta df_vntend+1
                             
                             	; String accumulator
f349 : a900             [ 2] 	lda #lo(scratch)
f34b : 85bc             [ 3] 	sta df_sevalptr
AS65 Assembler for R6502 [1.42].                                     Page  197
---------------------------------- bank1.s -----------------------------------

f34d : a909             [ 2] 	lda #hi(scratch)
f34f : 85bd             [ 3] 	sta df_sevalptr+1
                             
f351 : 60               [ 6] 	rts
                             
f352 :                       mod_sz_dflat_e
                             
                             	include "dflat\error.s"
                             ;************************************************
                             ;*
                             ;*	BBC128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.S
                             ;*  Error handling module.
                             ;*  Whan an error is thrown using BRK, this modul
                             ;*  displaying the error plus any associated line
                             ;*  if it was running a program.  It then resets 
                             ;*  settings and takes the system back to program
                             ;*  mode.  The message uses the general IO handle
                             ;*  output must be set to the right place else fo
                             ;*	the error message will be written to tape!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             	include "dflat/error.i"
                             ;************************************************
                             ;*
                             ;*	BBC128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  It issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_SYNTAX	=	1
0002 =                       DFERR_TYPEMISM	=	2
0003 =                       DFERR_DIM		=	3
0004 =                       DFERR_UNTIL		=	4
0005 =                       DFERR_NOPROC	=	5
0006 =                       DFERR_PROCPARM	=	6
0007 =                       DFERR_IMMEDIATE	=	7
0008 =                       DFERR_UNCLOSEDIF=	8
AS65 Assembler for R6502 [1.42].                                     Page  198
---------------------------------- bank1.s -----------------------------------

0009 =                       DFERR_NOIF		=	9
000a =                       DFERR_NEXTFOR	=	10
000b =                       DFERR_FNAME		=	11
000c =                       DFERR_STRLONG	=	12
000d =                       DFERR_BREAK		=	13
000e =                       DFERR_NODATA	=	14
000f =                       DFERR_WEND		=	15
0010 =                       DFERR_NOLINE	=	16
0011 =                       DFERR_RETURN	=	17
0012 =                       DFERR_ABORT		=	18
0013 =                       DFERR_QUANTITY	=	19
0014 =                       DFERR_NOORG		=	20
                             
                             
                             
                             
                             
                             ; Error message table, each msg null terminated
f352 :                       df_tk_errortab
f352 : 4f6b00                	db	"Ok", 0
f355 : 53796e74617800        	db	"Syntax", 0
f35c : 5479706500            	db	"Type", 0
f361 : 52652d64696d00        	db	"Re-dim", 0
f368 : 4e6f2072657065..      	db	"No repeat", 0
f372 : 4e6f206465666e00      	db	"No defn", 0
f37a : 5061726d00            	db	"Parm", 0
f37f : 456e64656400          	db	"Ended", 0
f385 : 4e6f20656e6469..      	db	"No endif", 0
f38e : 4e6f20696600          	db	"No if", 0
f394 : 4e6f20666f7200        	db	"No for", 0
f39b : 4e6f7420666f75..      	db	"Not found", 0
f3a5 : 546f6f206c6f6e..      	db	"Too long", 0
f3ae : 427265616b00          	db	"Break", 0
f3b4 : 4e6f206461746100      	db	"No data", 0
f3bc : 4e6f207768696c..      	db	"No while", 0
f3c5 : 4e6f206c696e6500      	db	"No line", 0
f3cd : 4e6f2072657475..      	db	"No return ", 0
f3d8 : 41626f7274656400      	db	"Aborted", 0
f3e0 : 426f756e647300        	db	"Bounds", 0
f3e7 : 4e6f206f726700        	db	"No org", 0
f3ee : 00                    	db	0
                             
f3ef :                       df_tk_error_inline
f3ef : 20696e206c696e..      	db	" in line ", 0
f3f9 :                       df_tk_error_atpos
f3f9 : 20706f732000          	db	" pos ", 0
f3ff :                       df_tk_error_error
f3ff : 206572726f7200        	db	" error", 0
                             
                             ;****************************************
                             ;* df_trap_error
                             ;* Show an error message
                             ;* errno is error number
                             ;* currlin = Line number
                             ;* exeoff = offset
                             ;* at the end jump to program editor
                             ;****************************************
f406 :                       df_trap_error
                             	; set IO back to normal
f406 : 20a2c5           [ 6] 	jsr io_set_default
f409 : 58               [ 2] 	cli
                             
AS65 Assembler for R6502 [1.42].                                     Page  199
---------------------------------- bank1.s -----------------------------------

f40a : a952             [ 2] 	lda #lo(df_tk_errortab)
f40c : 85e3             [ 3] 	sta df_tmpptra
f40e : a9f3             [ 2] 	lda #hi(df_tk_errortab)
f410 : 85e4             [ 3] 	sta df_tmpptra+1
f412 : a69f             [ 3] 	ldx errno				; 0 or >=128 goes to monitor
f414 : f002             [ 3] 	beq df_trap_go_monitor
f416 : 1003             [ 3] 	bpl df_trap_normal
f418 :                       df_trap_go_monitor
f418 : 4c97f4           [ 3] 	jmp df_trap_monitor
f41b :                       df_trap_normal
f41b : a000             [ 2] 	ldy #0
f41d :                       df_show_err_find
                             	; If on a zero, then error table exhausted
                             	; so drop in to the monitor
f41d : b1e3             [ 5] 	lda (df_tmpptra),y
f41f : f076             [ 3] 	beq df_trap_monitor
                             	; Skip over this error text including zero termi
f421 :                       df_show_err_skip
                             	_incZPWord df_tmpptra
                             
f427 : b1e3             [ 5] 	lda (df_tmpptra),y
f429 : d0f6             [ 3] 	bne df_show_err_skip
                             	_incZPWord df_tmpptra
                             
f431 : ca               [ 2] 	dex
f432 : d0e9             [ 3] 	bne df_show_err_find
                             	; Error message found
f434 : a6e3             [ 3] 	ldx df_tmpptra
f436 : a5e4             [ 3] 	lda df_tmpptra+1
f438 : 200bc6           [ 6] 	jsr io_print_line
f43b : a2ff             [ 2] 	ldx #lo(df_tk_error_error)
f43d : a9f3             [ 2] 	lda #hi(df_tk_error_error)
f43f : 200bc6           [ 6] 	jsr io_print_line
                             	; if line number <> 0 then print it
f442 : a001             [ 2] 	ldy #DFTK_LINNUM
f444 : b1c8             [ 5] 	lda (df_currlin),y
f446 : aa               [ 2] 	tax
f447 : c8               [ 2] 	iny
f448 : b1c8             [ 5] 	lda (df_currlin),y
f44a : d004             [ 3] 	bne df_show_err_linnum
f44c : e000             [ 2] 	cpx #0x00
f44e : f011             [ 3] 	beq df_show_err_fin
f450 :                       df_show_err_linnum
                             	_println df_tk_error_inline
                             
f45d : 18               [ 2] 	clc
f45e : 205acb           [ 6] 	jsr print_a_to_d
f461 :                       df_show_err_fin
f461 : a4be             [ 3] 	ldy df_linoff
f463 : f02b             [ 3] 	beq df_show_err_done
                             	_println df_tk_error_atpos
                             
f472 : 98               [ 2] 	tya
f473 : aa               [ 2] 	tax
f474 : a900             [ 2] 	lda #0
f476 : 18               [ 2] 	clc
f477 : 205acb           [ 6] 	jsr print_a_to_d
f47a : 20a3c8           [ 6] 	jsr utilPrintCRLF
f47d : a000             [ 2] 	ldy #0
                             	; Show the error line with error pos inverse
f47f :                       def_show_err_line
f47f : b9000a           [ 4] 	lda df_linbuff,y
AS65 Assembler for R6502 [1.42].                                     Page  200
---------------------------------- bank1.s -----------------------------------

f482 : f00c             [ 3] 	beq df_show_err_done
f484 : c4be             [ 3] 	cpy df_linoff
f486 : d002             [ 3] 	bne def_show_err_line_skip
f488 : 0980             [ 2] 	ora #0x80
f48a :                       def_show_err_line_skip
f48a : 20c0c5           [ 6] 	jsr io_put_ch
f48d : c8               [ 2] 	iny
f48e : d0ef             [ 3] 	bne def_show_err_line	; Always
f490 :                       df_show_err_done
f490 : 20a3c8           [ 6] 	jsr utilPrintCRLF
f493 : 18               [ 2] 	clc
                             	; back to editor
f494 : 4c25d8           [ 3] 	jmp df_pg_dflat
                             
                             
                             ; For unknown errors, jump to monitor
f497 :                       df_trap_monitor
                             	; Print PC
                             	_println_low df_msg_pc
                             
f49e : a5a5             [ 3] 	lda df_brkpc+1
f4a0 : 20abc8           [ 6] 	jsr utilPrintA
f4a3 : a5a4             [ 3] 	lda df_brkpc
f4a5 : 20abc8           [ 6] 	jsr utilPrintA
f4a8 : 209bc8           [ 6] 	jsr utilPrintSPC
                             
                             	; Print A
                             	_println_low df_msg_acc
                             
f4b2 : a585             [ 3] 	lda num_a
f4b4 : 20abc8           [ 6] 	jsr utilPrintA
f4b7 : 209bc8           [ 6] 	jsr utilPrintSPC
                             
                             	; Print X
                             	_println_low df_msg_xreg
                             
f4c1 : a586             [ 3] 	lda num_a+1
f4c3 : 20abc8           [ 6] 	jsr utilPrintA
f4c6 : 209bc8           [ 6] 	jsr utilPrintSPC
                             
                             	; Print Y
                             	_println_low df_msg_yreg
                             
f4d0 : a587             [ 3] 	lda num_a+2
f4d2 : 20abc8           [ 6] 	jsr utilPrintA
f4d5 : 20a3c8           [ 6] 	jsr utilPrintCRLF
                             
f4d8 : 20abe0           [ 6] 	jsr df_rt_monitor
                             	; back to editor
f4db : 4c25d8           [ 3] 	jmp df_pg_dflat
                             
f4de :                       df_msg_pc
f4de : 50433a00              	db "PC:\x0"
f4e2 :                       df_msg_acc
f4e2 : 413a00                	db "A:\x0"
f4e5 :                       df_msg_xreg
f4e5 : 583a00                	db "X:\x0"
f4e8 :                       df_msg_yreg
f4e8 : 593a00                	db "Y:\x0"
                             
                             	include	"dflat\asm.s"
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page  201
---------------------------------- bank1.s -----------------------------------

                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ASM.S
                             ;*  This is the main controller code file for the
                             ;*  This file includes all the required source fi
                             ;*	in addition to dflat.s
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f4eb :                       mod_sz_asm_s
                             
                             	;	dflat.s is already included, so just the addit
                             	include "dflat\asm.i"
                             ;*	BBC-128 BREADBOARD COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             
                             ;* Addressing modes - 15 in total, 16 with direct
                             ;*  0   Nothing
                             ;*	1 	Absolute			XXX <word>
                             ;*	2 	Absolute,X			XXX <word>,x
                             ;*	3 	Absolute,Y			XXX <word>,y
                             ;*	4	Zeropage			XXX	<byte>
                             ;*	5	Zeropage,X			XXX	<byte>,x
                             ;*	6	Zeropage,Y			XXX	<byte>,y
                             ;*	7	Indirect			XXX	(<byte>)
                             ;*	8	Indirect,X			XXX	(<byte>,x)
                             ;*	9	Indirect,Y			XXX	(<byte>),y
                             ;*	A	Absolute indirect	XXX	(<word>)
                             ;*	B	Absolute indirect,x	XXX	(<word>,x)
                             ;*	C	Immediate			XXX #<byte>
                             ;*	D	Accumulator			XXX (same as implied)
                             ;*	E	Implied				XXX
                             ;*	F	Relative			XXX	<byte>
                             ;*	10	Assembler directive	XXX .......
                             
0000 =                       AM_NONE		= 0
0001 =                       AM_ABS	 	= 1
0002 =                       AM_ABSX		= 2
0003 =                       AM_ABSY		= 3
0004 =                       AM_ZP		= 4
0005 =                       AM_ZPX		= 5
0006 =                       AM_ZPY		= 6
0007 =                       AM_ZPIND	= 7
0008 =                       AM_ZPINDX	= 8
0009 =                       AM_ZPINDY	= 9
000a =                       AM_ABSIND	= 10
000b =                       AM_ABSINDX	= 11
000c =                       AM_IMM		= 12
000d =                       AM_ACC		= 13
000d =                       AM_IMP		= AM_ACC
000f =                       AM_REL		= 15
AS65 Assembler for R6502 [1.42].                                     Page  202
---------------------------------- bank1.s -----------------------------------

0010 =                       AM_DIR		= 16
                             
                             
                             
                             	include "dflat\tkasm.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ASM.S
                             ;*	Module that implements tokenisation of the ass
                             ;* 	The assembler is an extension to dflat, almos
                             ;*	almost a language within a language, as it has
                             ;*	own symbol tables to allow adding new keywords
                             ;*	running out of space in the main symtol table 
                             ;*	for normal 6502 asembler syntax which is at od
                             ;*	regular dflat.
                             ;*	Hence, this module has to do its own additiona
                             ;*	to tokenise the assembly.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f4eb :                       mod_sz_tkasm_s
                             
                             	; if didn't find regular keywords then try assen
f4eb :                       df_tk_asm_parse_command
                             ;	; skip the white space after the dot
                             ;	jsr df_tk_skip_ws
                             	; find the assembler symbol
f4eb : 2020f5           [ 6] 	jsr df_tk_asm_matchtok
                             	; if no match with asm token they maybe a label?
f4ee : b01d             [ 4] 	bcs df_tk_asm_label
f4f0 :                       df_tk_asm_found_command
                             	; Before asm keyword, put the asm handler token
f4f0 : a997             [ 2] 	lda #DFRT_ASM
f4f2 : 205dce           [ 6] 	jsr df_tk_put_tok
                             	; Set the MSB of found symbol index
f4f5 : a5c5             [ 3] 	lda df_symoff
f4f7 : 0980             [ 2] 	ora #0x80
f4f9 : 205dce           [ 6] 	jsr df_tk_put_tok
                             	; check the first addressing mode code
                             	; remember to jump over the offset byte
f4fc : a001             [ 2] 	ldy #1
f4fe : b1c3             [ 5] 	lda (df_symtab),y
                             	; Directive?
f500 : c910             [ 2] 	cmp #AM_DIR
f502 : d006             [ 3] 	bne df_tk_asm_mnemonic
                             	; if directive then process it
f504 : a5c5             [ 3] 	lda df_symoff
f506 : 4c77f5           [ 3] 	jmp df_tk_asm_exec_parser
f509 :                       df_tk_asm_parse_command_err
f509 : 60               [ 6] 	rts
f50a :                       df_tk_asm_mnemonic
                             	; for all nmemonics, work out the addressing mod
f50a : 4c7cf5           [ 3] 	jmp df_tk_asm_addr_mode
AS65 Assembler for R6502 [1.42].                                     Page  203
---------------------------------- bank1.s -----------------------------------

                             
                             ; try to tokenise a label
f50d :                       df_tk_asm_label
                             	; labels must start with '.'
f50d : a92e             [ 2] 	lda #'.'
f50f : 20d0ce           [ 6] 	jsr df_tk_expect
f512 : b0f5             [ 3] 	bcs df_tk_asm_parse_command_err
                             	; Before asm label, put the asm handler token
f514 : a997             [ 2] 	lda #DFRT_ASM
f516 : 205dce           [ 6] 	jsr df_tk_put_tok
f519 : e6be             [ 5] 	inc df_linoff			;Skip the '.'
                             	; Tokenise a variable
f51b : a900             [ 2] 	lda #0
f51d : 4c94cf           [ 3] 	jmp df_tk_var
                             
                             
                             ;****************************************
                             ;* df_tk_asm_matchtok
                             ;* Try and find a token match against the table d
                             ;* Input:
                             ;*			Current df_linbuff and df_linoff
                             ;* Return: 	CC = No Error, CS = Error
                             ;*			df_linoff points to next char if CC else unc
                             ;****************************************
f520 :                       df_tk_asm_matchtok
                             	; Start at token symbols beginning
f520 : a90a             [ 2] 	lda #lo(df_asm_tokensyms)
f522 : 85c3             [ 3] 	sta df_symtab
f524 : a9f9             [ 2] 	lda #hi(df_asm_tokensyms)
f526 : 85c4             [ 3] 	sta df_symtab+1
f528 : a900             [ 2] 	lda #0
f52a : 85c5             [ 3] 	sta df_symoff
f52c : a200             [ 2] 	ldx #0
f52e :                       df_tk_asm_checknexttok
                             	; From the line buffer current pointer
                             	; Check for a token match
f52e : a4be             [ 3] 	ldy df_linoff
f530 :                       df_tk_asm_checktokch
                             	; Get symtable char
f530 : a1c3             [ 6] 	lda (df_symtab,x)
                             	; if less than ascii ' ' then reached end of
                             	; this symbol and everything matched so found!
f532 : c920             [ 2] 	cmp #' '
f534 : 9033             [ 3] 	bcc df_tk_asm_symfound
                             	; Else compare with current line buffer char
f536 : d9000a           [ 4] 	cmp df_linbuff,y
                             	; If chars not match then this symbol fails
f539 : d00a             [ 3] 	bne df_tk_asm_symnomatch
                             	; else more chars to match
                             	; so increment line buffer pointers
                             	_incZPWord df_symtab
                             
f541 : c8               [ 2] 	iny
f542 : 4c30f5           [ 3] 	jmp df_tk_asm_checktokch
f545 :                       df_tk_asm_symnomatch
                             	; Increment symbol counter to next symbol
f545 : e6c5             [ 5] 	inc df_symoff
f547 :                       df_tk_asm_symnextentry
f547 : a1c3             [ 6] 	lda (df_symtab,x)
                             	; End of symbol is < ' '
f549 : c920             [ 2] 	cmp #' '
f54b : 9009             [ 3] 	bcc  df_tk_asm_foundsymend
AS65 Assembler for R6502 [1.42].                                     Page  204
---------------------------------- bank1.s -----------------------------------

                             	_incZPWord df_symtab
                             
f553 : 4c47f5           [ 3] 	jmp df_tk_asm_symnextentry
f556 :                       df_tk_asm_foundsymend
                             	; Now at the offset to jump over addressing
                             	; mode and opcode values. Add offset to ptr
                             	; remember than C is clear and A has offset
                             	; set C so always jump over the offset
f556 : 38               [ 2] 	sec
f557 : 65c3             [ 3] 	adc df_symtab
f559 : 85c3             [ 3] 	sta df_symtab
f55b : a5c4             [ 3] 	lda df_symtab+1
f55d : 6900             [ 2] 	adc #0
f55f : 85c4             [ 3] 	sta df_symtab+1
                             	; If next char is not zero then
                             	; try and match with line buffer
f561 : a1c3             [ 6] 	lda (df_symtab,x)
f563 : d0c9             [ 3] 	bne df_tk_asm_checknexttok
                             	; else symbol table exhausted
                             	; so no match found
                             	; Zero symbol counter
f565 : 85c5             [ 3] 	sta df_symoff		; Relies on A=0
                             	; Set C to indicate error (no match)
f567 : 38               [ 2] 	sec
f568 : 60               [ 6] 	rts
f569 :                       df_tk_asm_symfound
                             	; Full match with keyword in symtable but
                             	; check the next buffer char is not alphanum
                             	; as this could be part of a symbol
                             	; Point to next buffer char in any case
                             	; y already points to char after keyword
f569 : b9000a           [ 4] 	lda df_linbuff,y
                             	; if it is an alphanum then
f56c : 20a2ce           [ 6] 	jsr df_tk_isalphanum
                             	; do not count as a match
f56f : b0d4             [ 3] 	bcs df_tk_asm_symnomatch
                             	; Save line buffer pointer (points to next char)
                             	; Clear C to indicate success (match)
f571 : 84be             [ 3] 	sty df_linoff
f573 : a5c5             [ 3] 	lda df_symoff
                             	; df_symtab points to the offset
f575 :                       df_tk_asm_addr_mode_ok
f575 : 18               [ 2] 	clc
f576 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_asm_exec_parser
                             ;* Execute parse routine for this statement
                             ;* Input: a is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
f577 :                       df_tk_asm_exec_parser
f577 : 0a               [ 2] 	asl a
f578 : aa               [ 2] 	tax
f579 : 7c7bfc           [ 6] 	jmp (df_tk_asm_tokenjmp,x)
                             
                             
                             ;****************************************
                             ;* df_tk_asm_addr_mode
                             ;* Tokenise the addressing mode
                             ;* Input: a is the token found
                             ;* Return: CC = Parsed ok, CS = Error
AS65 Assembler for R6502 [1.42].                                     Page  205
---------------------------------- bank1.s -----------------------------------

                             ;****************************************
f57c :                       df_tk_asm_addr_mode
f57c : 20aece           [ 6] 	jsr df_tk_skip_ws		;Skip whitespace
f57f : c900             [ 2] 	cmp #0					;End of line?
f581 : f0f2             [ 3] 	beq df_tk_asm_addr_mode_ok
f583 : c93a             [ 2] 	cmp #':'				;End of statement?
f585 : f0ee             [ 3] 	beq df_tk_asm_addr_mode_ok
f587 : a923             [ 2] 	lda #'#'				; Check for immediate
f589 : 20dece           [ 6] 	jsr df_tk_expect_tok
f58c : b003             [ 3] 	bcs df_tk_asm_addr_mode_1
f58e : 4cb3f5           [ 3] 	jmp df_tk_imm		; Process immediate
f591 :                       df_tk_asm_addr_mode_1
f591 : a928             [ 2] 	lda #'('				; One of indirect modes?
f593 : 20dece           [ 6] 	jsr df_tk_expect_tok
f596 : b003             [ 3] 	bcs df_tk_asm_addr_mode_2
f598 : 4cb8f5           [ 3] 	jmp df_tk_indirect
f59b :                       df_tk_asm_addr_mode_2
                             	; here just a regular address
                             	; Just one expression expected
f59b : 20dbd0           [ 6] 	jsr df_tk_expression
                             	; Is there a comma after the expression
f59e : a92c             [ 2] 	lda #','
f5a0 : 20dece           [ 6] 	jsr df_tk_expect_tok
f5a3 : b0d0             [ 3] 	bcs df_tk_asm_addr_mode_ok
                             	; must be x or y
f5a5 : a978             [ 2] 	lda #'x'
f5a7 : 20dece           [ 6] 	jsr df_tk_expect_tok
f5aa : 90c9             [ 3] 	bcc df_tk_asm_addr_mode_ok
                             	; got to here, must be y
f5ac : a979             [ 2] 	lda #'y'
f5ae : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
f5b1 : 18               [ 2] 	clc
f5b2 : 60               [ 6] 	rts
                             	
                             	
                             ;* Toeknise immediate addressing mode	
f5b3 :                       df_tk_imm
                             	; Just one expression expected
f5b3 : 20dbd0           [ 6] 	jsr df_tk_expression
f5b6 : 18               [ 2] 	clc
f5b7 : 60               [ 6] 	rts
                             	
                             ;* Tokenise indirect
f5b8 :                       df_tk_indirect
                             	; Just one expression expected
f5b8 : 20dbd0           [ 6] 	jsr df_tk_expression
                             	; Is there a comma after the expression
f5bb : a92c             [ 2] 	lda #','
f5bd : 20dece           [ 6] 	jsr df_tk_expect_tok
                             	; if not then might be indirect Y
f5c0 : b00c             [ 3] 	bcs df_tk_indirect_y
                             	; Else must have be indirect "x)"
f5c2 : a978             [ 2] 	lda #'x'
f5c4 : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
f5c7 : a929             [ 2] 	lda #')'
f5c9 : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
f5cc : 18               [ 2] 	clc
f5cd : 60               [ 6] 	rts
                             	
f5ce :                       df_tk_indirect_y
                             	; Definitely has a close bracket
f5ce : a929             [ 2] 	lda #')'
AS65 Assembler for R6502 [1.42].                                     Page  206
---------------------------------- bank1.s -----------------------------------

f5d0 : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
                             	; Is there a comma after the expression
f5d3 : a92c             [ 2] 	lda #','
f5d5 : 20dece           [ 6] 	jsr df_tk_expect_tok
f5d8 : b007             [ 3] 	bcs df_tk_indirect_done
                             	; if comma then must be indirect y
f5da : a979             [ 2] 	lda #'y'
f5dc : 20e9ce           [ 6] 	jsr df_tk_expect_tok_err
f5df : 18               [ 2] 	clc
f5e0 : 60               [ 6] 	rts
                             
f5e1 :                       df_tk_indirect_done
f5e1 : 18               [ 2] 	clc
f5e2 : 60               [ 6] 	rts
                             	
                             
                             	
                             
                             
                             ;************************************************
                             ;*           TOKENISATION SUBROUTINES
                             ;************************************************
                             
                             
                             ;* HANDLE DIRECTIVES
                             
                             ;* All tokenisation is part of regular toksub rou
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
f5e3 :                       mod_sz_tkasm_e
                             
                             
                             	include "dflat\rtasm.s"
                             ;************************************************
                             ;*
                             ;*	BBC128
AS65 Assembler for R6502 [1.42].                                     Page  207
---------------------------------- bank1.s -----------------------------------

                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTASM.S
                             ;*  Module that implements the runtime execution 
                             ;*  assembler.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f5e3 :                       mod_sz_rtasm_s
                             
f5e3 :                       df_rt_asm_assemble
                             	; check if >=0x80 (directive or mnemonic)
f5e3 : a4ca             [ 3] 	ldy df_exeoff
f5e5 : b1c8             [ 5] 	lda (df_currlin),y
f5e7 : 1009             [ 3] 	bpl df_rt_asm_do_label
f5e9 : 20f6f5           [ 6] 	jsr df_rt_asm_command
f5ec : 20eef7           [ 6] 	jsr df_rt_asm_printCR
f5ef : 4cf5f5           [ 3] 	jmp df_rt_asm_assemble_done
f5f2 :                       df_rt_asm_do_label
f5f2 : 201af6           [ 6] 	jsr df_rt_asm_label
f5f5 :                       df_rt_asm_assemble_done
                             	; any clean up here
f5f5 : 60               [ 6] 	rts
                             
                             ; Jump to mnemonic or 
                             ; directive with index in A ignoring MSB
f5f6 :                       df_rt_asm_command
f5f6 : 297f             [ 2] 	and #0x7f
f5f8 : 48               [ 3] 	pha
f5f9 : aa               [ 2] 	tax
                             	; Point to Xth symtable entry of addr modes and 
f5fa : 20bcf8           [ 6] 	jsr df_rt_asm_skip_to_sym
                             
                             	; Get first addressing mode (ignoring offset byt
f5fd : a001             [ 2] 	ldy #1
f5ff : b1c3             [ 5] 	lda (df_symtab),y
                             	; is it a directive?
f601 : c910             [ 2] 	cmp #AM_DIR
                             	; if directive
f603 : f003             [ 3] 	beq df_rt_asm_dir
                             	; Else must be a normal mnemonic
f605 : 4ce2f6           [ 3] 	jmp df_rt_asm_mnem
                             
                             ; Jump to the appropriate directive
f608 :                       df_rt_asm_dir
                             	; Get the index and *2
                             	; to get jump vector
f608 : 68               [ 4] 	pla
f609 : 0a               [ 2] 	asl a
f60a : aa               [ 2] 	tax
                             	; jump over directive code
f60b : e6ca             [ 5] 	inc df_exeoff
                             	; jump to directive handler
f60d : bd85fc           [ 4] 	lda df_rt_asm_tokenjmp,x
f610 : 85e3             [ 3] 	sta df_tmpptra
f612 : bd86fc           [ 4] 	lda df_rt_asm_tokenjmp+1,x
AS65 Assembler for R6502 [1.42].                                     Page  208
---------------------------------- bank1.s -----------------------------------

f615 : 85e4             [ 3] 	sta df_tmpptra+1
f617 : 6ce300           [ 6] 	jmp (df_tmpptra)
                             
                             ; Process label
                             ; Set the label to the PC
f61a :                       df_rt_asm_label
                             	; Get the address of the variable in A,X
f61a : 200ce6           [ 6] 	jsr df_rt_generate_lvar
f61d : 86e0             [ 3] 	stx df_asmoprnd
f61f : 85e1             [ 3] 	sta df_asmoprnd+1
                             	; Assign to value of PC
f621 : a000             [ 2] 	ldy #0
f623 : a5db             [ 3] 	lda df_asmpc
f625 : 91e0             [ 5] 	sta (df_asmoprnd),y
f627 : a5dc             [ 3] 	lda df_asmpc+1
f629 : c8               [ 2] 	iny
f62a : 91e0             [ 5] 	sta (df_asmoprnd),y
f62c : 60               [ 6] 	rts	
                             
                             ;* Set the code origin
f62d :                       df_rt_asm_org
                             	; Get the address from expression
f62d : 2099f8           [ 6] 	jsr df_rt_asm_get_operand
                             	; Put this in to PC
f630 : a5e0             [ 3] 	lda df_asmoprnd
f632 : 85db             [ 3] 	sta df_asmpc
f634 : a5e1             [ 3] 	lda df_asmoprnd+1
f636 : 85dc             [ 3] 	sta df_asmpc+1
f638 : a903             [ 2] 	lda #3
f63a : 85e2             [ 3] 	sta df_asmlen
f63c : 4cb0f7           [ 3] 	jmp df_rt_asm_printPC
                             
                             ; Set the assembly option
                             ; Bit 0 set = Print code to console
                             ; But 1 set = Write code to memory
                             ; Be sure to run 2 non-write passes
                             ; before a write pass
                             ; First pass may result in ZP used a lot
                             ; Second pass resolves forward refs to ABS
                             ; Final write pass then stores the code
f63f :                       df_rt_asm_opt
                             	; Get the value from expression
f63f : 2099f8           [ 6] 	jsr df_rt_asm_get_operand
                             	; Put this in to OPT
f642 : a5e0             [ 3] 	lda df_asmoprnd
f644 : 85dd             [ 3] 	sta df_asmopt
f646 : 60               [ 6] 	rts
                             
                             ; dw and db handled here
                             ; keep going through comma separated
                             ; list and write bytes or words
                             ; string expansion also handled
f647 :                       df_rt_asm_db
f647 : a902             [ 2] 	lda #2
f649 : 2c                    	db	0x2c			; BIT abs to ignore next 2 bytes
f64a :                       df_rt_asm_dw
f64a : a903             [ 2] 	lda #3
f64c :                       df_rt_asm_db_start
f64c : 85e2             [ 3] 	sta df_asmlen
f64e : 20b0f7           [ 6] 	jsr df_rt_asm_printPC
f651 : 20cbf7           [ 6] 	jsr df_rt_asm_printSPC
f654 :                       df_rt_asm_data
AS65 Assembler for R6502 [1.42].                                     Page  209
---------------------------------- bank1.s -----------------------------------

f654 : 2048d9           [ 6] 	jsr df_rt_neval		; Evaluate expression
                             	_df_ost_peekType	; What is the type
                             
f65c : 2904             [ 2] 	and #DFST_STR
f65e : d00d             [ 3] 	bne df_rt_asm_string; If string
f660 : 20daf2           [ 6] 	jsr df_ost_popInt	; else get number in A,X
f663 : 86e0             [ 3] 	stx df_asmoprnd		; store low value
f665 : 85e1             [ 3] 	sta df_asmoprnd+1	; store high value
f667 : 2095f6           [ 6] 	jsr df_rt_asm_data_write
f66a : 4c8af6           [ 3] 	jmp df_rt_asm_data_next
f66d :                       df_rt_asm_string
f66d : 20d6f2           [ 6] 	jsr df_ost_popPtr	; pop string pointer
f670 : 86e3             [ 3] 	stx df_tmpptra		; save pointer to tmpa
f672 : 85e4             [ 3] 	sta df_tmpptra+1
f674 :                       df_rt_asm_string_ch
f674 : a000             [ 2] 	ldy #0
f676 : b1e3             [ 5] 	lda (df_tmpptra),y	; Get string char, 0=done
f678 : f010             [ 3] 	beq df_rt_asm_data_next
f67a : 85e0             [ 3] 	sta df_asmoprnd		; Save as operand
f67c : 84e1             [ 3] 	sty df_asmoprnd+1	; High is always zero
f67e : 2095f6           [ 6] 	jsr df_rt_asm_data_write
                             	_incZPWord df_tmpptra
                             
f687 : 4c74f6           [ 3] 	jmp df_rt_asm_string_ch
f68a :                       df_rt_asm_data_next
f68a : 203ee6           [ 6] 	jsr df_rt_eos		; End?
f68d : b005             [ 3] 	bcs df_rt_asm_data_done
f68f : e6ca             [ 5] 	inc df_exeoff		; Jump over ','
f691 : 4c54f6           [ 3] 	jmp df_rt_asm_data
f694 :                       df_rt_asm_data_done
f694 : 60               [ 6] 	rts	
                             
                             ; Write one db or dw value
                             ; Check for value too big for db
                             ; Advance PC by df_asmlen
f695 :                       df_rt_asm_data_write
f695 : 20d4f7           [ 6] 	jsr df_rt_asm_printOPR
f698 :                       df_rt_asm_data_write_skip1
f698 : a902             [ 2] 	lda #2
f69a : 25dd             [ 3] 	and df_asmopt
f69c : f017             [ 3] 	beq df_rt_asm_data_write_skip2
f69e : a5e0             [ 3] 	lda df_asmoprnd
f6a0 : a000             [ 2] 	ldy #0
f6a2 : 91db             [ 5] 	sta (df_asmpc),y
f6a4 : c8               [ 2] 	iny
f6a5 : a902             [ 2] 	lda #2
f6a7 : c5e2             [ 3] 	cmp df_asmlen
f6a9 : d006             [ 3] 	bne df_rt_asm_data_write_hi
f6ab : a5e1             [ 3] 	lda df_asmoprnd+1
f6ad : d014             [ 3] 	bne df_rt_asm_data_write_err
f6af : f004             [ 3] 	beq df_rt_asm_data_write_skip2
f6b1 :                       df_rt_asm_data_write_hi
f6b1 : a5e1             [ 3] 	lda df_asmoprnd+1
f6b3 : 91db             [ 5] 	sta (df_asmpc),y
f6b5 :                       df_rt_asm_data_write_skip2
f6b5 : a4e2             [ 3] 	ldy df_asmlen
f6b7 : 88               [ 2] 	dey					; Add 1 less!
f6b8 : 98               [ 2] 	tya
f6b9 : 18               [ 2] 	clc
f6ba : 65db             [ 3] 	adc df_asmpc
f6bc : 85db             [ 3] 	sta df_asmpc
                             	_bcc 2
AS65 Assembler for R6502 [1.42].                                     Page  210
---------------------------------- bank1.s -----------------------------------

                             
f6c0 : e6dc             [ 5] 	inc df_asmpc+1
f6c2 : 60               [ 6] 	rts
f6c3 :                       df_rt_asm_data_write_err	
                             	SWBRK DFERR_QUANTITY
                             
                             	
                             	
f6c5 :                       df_rt_asm_ds
f6c5 : 20b0f7           [ 6] 	jsr df_rt_asm_printPC
f6c8 : 20cbf7           [ 6] 	jsr df_rt_asm_printSPC
                             	; Get the address from expression
f6cb : 2099f8           [ 6] 	jsr df_rt_asm_get_operand
                             	; ADD this in to PC
f6ce : 18               [ 2] 	clc
f6cf : a5e0             [ 3] 	lda df_asmoprnd
f6d1 : 65db             [ 3] 	adc df_asmpc
f6d3 : 85db             [ 3] 	sta df_asmpc
f6d5 : a5e1             [ 3] 	lda df_asmoprnd+1
f6d7 : 65dc             [ 3] 	adc df_asmpc+1
f6d9 : 85dc             [ 3] 	sta df_asmpc+1
                             	; len=1 for printing
f6db : a903             [ 2] 	lda #3
f6dd : 85e2             [ 3] 	sta df_asmlen
f6df : 4cd4f7           [ 3] 	jmp df_rt_asm_printOPR
                             
                             
                             ; Process a normal assembler mnemonic
f6e2 :                       df_rt_asm_mnem
f6e2 : 68               [ 4] 	pla				; Throw away previous temp variable
                             	; jump over mnemonic code
f6e3 : e6ca             [ 5] 	inc df_exeoff
                             	; work out the addressing mode and get operand
f6e5 : 201cf8           [ 6] 	jsr df_rt_asm_addrmode
                             
f6e8 :                       df_rt_asm_mnem_try
f6e8 : a5de             [ 3] 	lda df_asmadmd					; With the addressing mode
f6ea : 20a4f8           [ 6] 	jsr df_rt_asm_find_addr_mode	; Find it for this 
f6ed : c900             [ 2] 	cmp #AM_NONE					; Exists?
f6ef : d014             [ 4] 	bne	df_rt_asm_mnem_chk			; If does then check it
f6f1 :                       df_rt_asm_check_alt
f6f1 : a6de             [ 3] 	ldx df_asmadmd					; Use ad mode as an index
f6f3 : bdf9f8           [ 4] 	lda df_asm_altaddrmode,x		; Else get alternate
f6f6 : c900             [ 2] 	cmp #AM_NONE					; Is there an alternate?
f6f8 : f02d             [ 4] 	beq df_rt_asm_mnem_err			; If no then error
f6fa : 20a4f8           [ 6] 	jsr df_rt_asm_find_addr_mode	; Check does mode e
f6fd : c900             [ 2] 	cmp #AM_NONE					; this instruction
f6ff : f026             [ 4] 	beq df_rt_asm_mnem_err			; if no then error
f701 : c5de             [ 3] 	cmp df_asmadmd					; Same as the original?
f703 : f00e             [ 3] 	beq df_rt_asm_mnem_done			; if so then done
f705 :                       df_rt_asm_mnem_chk
f705 : 85de             [ 3] 	sta df_asmadmd					; This is the final mode
f707 : aa               [ 2] 	tax								; Get the length
f708 : bde8f8           [ 4] 	lda df_asm_length,x
f70b : a6e1             [ 3] 	ldx df_asmoprnd+1				; Is operand hi non-zero?
f70d : f004             [ 3] 	beq df_rt_asm_mnem_done			; If zero then done
f70f : c903             [ 2] 	cmp #3							; Else must be len 3?
f711 : d0de             [ 4] 	bne df_rt_asm_check_alt			; Try an alternate
f713 :                       df_rt_asm_mnem_done
f713 : a6de             [ 3] 	ldx df_asmadmd					; Get the final mode index
f715 : bde8f8           [ 4] 	lda df_asm_length,x				; Get the length
f718 : 85e2             [ 3] 	sta df_asmlen
AS65 Assembler for R6502 [1.42].                                     Page  211
---------------------------------- bank1.s -----------------------------------

f71a : a5de             [ 3] 	lda df_asmadmd					; Get the final mode
f71c : 20a4f8           [ 6] 	jsr df_rt_asm_find_addr_mode	; Get the Y index o
                             	; Ok now get the opcode
f71f : c8               [ 2] 	iny
f720 : b1c3             [ 5] 	lda (df_symtab),y
f722 : 85df             [ 3] 	sta df_asmopcde
                             	; Now have all information to assemble
f724 : 4c29f7           [ 3] 	jmp df_rt_asm_encode
                             	
f727 :                       df_rt_asm_mnem_err
                             	SWBRK DFERR_SYNTAX
                             
                             	
                             ; Take assembler data and encode it
                             ; depending on the current option
                             ; Option 0 = No write
                             ; Option 1 = No write, Print
                             ; Option 2 = Write
                             ; Option 3 = Write, Print
f729 :                       df_rt_asm_encode
                             	; If relative then need to calculate offset
f729 : a5de             [ 3] 	lda df_asmadmd
f72b : c90f             [ 2] 	cmp #AM_REL
f72d : d033             [ 3] 	bne df_rt_asm_encode_skiprel
                             	; If high byte is 0 then do nothing
f72f : a5e1             [ 3] 	lda df_asmoprnd+1
f731 : f02f             [ 3] 	beq df_rt_asm_encode_skiprel
                             	; else calculate distance from PC
                             	; first take 2 off operand
f733 : 38               [ 2] 	sec
f734 : a5e0             [ 3] 	lda df_asmoprnd
f736 : e902             [ 2] 	sbc #2
f738 : 85e0             [ 3] 	sta df_asmoprnd
f73a : a5e1             [ 3] 	lda df_asmoprnd+1
f73c : e900             [ 2] 	sbc #0
f73e : 85e1             [ 3] 	sta df_asmoprnd+1
                             	; now calculate current operand-PC
f740 : 38               [ 2] 	sec
f741 : a5e0             [ 3] 	lda df_asmoprnd
f743 : e5db             [ 3] 	sbc df_asmpc
f745 : 85e0             [ 3] 	sta df_asmoprnd
f747 : a5e1             [ 3] 	lda df_asmoprnd+1
f749 : e5dc             [ 3] 	sbc df_asmpc+1
                             	; put 0 in high operand storage
                             	; but A contains result of subtraction
                             	; so check that for out of range
f74b : a000             [ 2] 	ldy #0
f74d : 84e1             [ 3] 	sty df_asmoprnd+1
                             	; detect too far; high byte is either 0 or 255
                             	; else it's an error
f74f : a8               [ 2] 	tay
f750 : f00a             [ 3] 	beq df_rt_asm_encode_relpos
f752 : c9ff             [ 2] 	cmp #0xff
f754 : d00a             [ 3] 	bne df_rt_asm_encode_relfar
                             	; if high is ff then low must be same -ve
f756 : a5e0             [ 3] 	lda df_asmoprnd
f758 : 3008             [ 3] 	bmi df_rt_asm_encode_skiprel
                             	; else error
f75a : 1004             [ 3] 	bpl df_rt_asm_encode_relfar
f75c :                       df_rt_asm_encode_relpos
                             	; if high is 00 then low must be same +ve
f75c : a5e0             [ 3] 	lda df_asmoprnd
AS65 Assembler for R6502 [1.42].                                     Page  212
---------------------------------- bank1.s -----------------------------------

f75e : 1002             [ 3] 	bpl df_rt_asm_encode_skiprel
                             	; else error
f760 :                       df_rt_asm_encode_relfar
                             	; set to non-zero value, dec because it is zero 
f760 : c6e1             [ 5] 	dec df_asmoprnd+1
f762 :                       df_rt_asm_encode_skiprel
                             	; Only write the code if bit 1=1
f762 : a902             [ 2] 	lda #0x02
f764 : 25dd             [ 3] 	and df_asmopt
f766 : f028             [ 3] 	beq df_rt_asm_encode_print
f768 : a000             [ 2] 	ldy #0
f76a : a5df             [ 3] 	lda df_asmopcde
f76c : 91db             [ 5] 	sta (df_asmpc),y
f76e : a5e2             [ 3] 	lda df_asmlen
f770 : c901             [ 2] 	cmp #1						; No operand
f772 : f01c             [ 3] 	beq df_rt_asm_encode_print
f774 : c903             [ 2] 	cmp #3						; Word operand
f776 : f00e             [ 3] 	beq df_rt_asm_encode_writeword
                             	; byte operand, high byte must be zero
f778 : a5e1             [ 3] 	lda df_asmoprnd+1
f77a : f002             [ 3] 	beq df_rt_asm_encode_writebyte
                             	SWBRK DFERR_QUANTITY
                             
f77e :                       df_rt_asm_encode_writebyte
f77e : c8               [ 2] 	iny 
f77f : a5e0             [ 3] 	lda df_asmoprnd
f781 : 91db             [ 5] 	sta (df_asmpc),y
f783 : 4c90f7           [ 3] 	jmp df_rt_asm_encode_print
f786 :                       df_rt_asm_encode_writeword
f786 : c8               [ 2] 	iny 
f787 : a5e0             [ 3] 	lda df_asmoprnd
f789 : 91db             [ 5] 	sta (df_asmpc),y
f78b : c8               [ 2] 	iny 
f78c : a5e1             [ 3] 	lda df_asmoprnd+1
f78e : 91db             [ 5] 	sta (df_asmpc),y	
f790 :                       df_rt_asm_encode_print
f790 : 20a0f7           [ 6] 	jsr df_rt_asm_print_mmen
                             	; advance pc
f793 : 18               [ 2] 	clc
f794 : a5db             [ 3] 	lda df_asmpc
f796 : 65e2             [ 3] 	adc df_asmlen
f798 : 85db             [ 3] 	sta df_asmpc
                             	_bcc 2
                             
f79c : e6dc             [ 5] 	inc df_asmpc+1
f79e : 18               [ 2] 	clc
f79f : 60               [ 6] 	rts
                             
                             
                             ; Print the full 1,2,3 byte instruction
                             ; depends on df_asmopt
f7a0 :                       df_rt_asm_print_mmen
f7a0 : 20b0f7           [ 6] 	jsr df_rt_asm_printPC
f7a3 : 20cbf7           [ 6] 	jsr df_rt_asm_printSPC
f7a6 : 20c0f7           [ 6] 	jsr df_rt_asm_printOPC
f7a9 : 20cbf7           [ 6] 	jsr df_rt_asm_printSPC
f7ac : 20d4f7           [ 6] 	jsr df_rt_asm_printOPR
f7af :                       df_rt_asm_print_rts			; Hopefully subs can get he
f7af : 60               [ 6] 	rts
                             
f7b0 :                       df_rt_asm_printPC
                             	; Check the option bit 0 (Print)
AS65 Assembler for R6502 [1.42].                                     Page  213
---------------------------------- bank1.s -----------------------------------

f7b0 : a901             [ 2] 	lda #0x01
f7b2 : 25dd             [ 3] 	and df_asmopt
f7b4 : f0f9             [ 3] 	beq df_rt_asm_print_rts
                             	; Print current PC
f7b6 : a5dc             [ 3] 	lda df_asmpc+1
f7b8 : 20abc8           [ 6] 	jsr utilPrintA
f7bb : a5db             [ 3] 	lda df_asmpc
f7bd : 4cabc8           [ 3] 	jmp utilPrintA
                             
f7c0 :                       df_rt_asm_printOPC
                             	; Check the option bit 0 (Print)
f7c0 : a901             [ 2] 	lda #0x01
f7c2 : 25dd             [ 3] 	and df_asmopt
f7c4 : f0e9             [ 3] 	beq df_rt_asm_print_rts
f7c6 : a5df             [ 3] 	lda df_asmopcde
f7c8 : 4cabc8           [ 3] 	jmp utilPrintA
                             
f7cb :                       df_rt_asm_printSPC
                             	; Check the option bit 0 (Print)
f7cb : a901             [ 2] 	lda #0x01
f7cd : 25dd             [ 3] 	and df_asmopt
f7cf : f0de             [ 3] 	beq df_rt_asm_print_rts
f7d1 : 4c9bc8           [ 3] 	jmp utilPrintSPC
                             	
f7d4 :                       df_rt_asm_printOPR
                             	; Check the option bit 0 (Print)
f7d4 : a901             [ 2] 	lda #0x01
f7d6 : 25dd             [ 3] 	and df_asmopt
f7d8 : f0d5             [ 3] 	beq df_rt_asm_print_rts	
f7da : a5e2             [ 3] 	lda df_asmlen				; check how may operand bytes
f7dc : c901             [ 2] 	cmp #1						; if only opcode, done
f7de : f0cf             [ 3] 	beq df_rt_asm_print_rts	
f7e0 : c902             [ 2] 	cmp #2
f7e2 : f005             [ 3] 	beq df_rt_asm_printOPR_1	; if only 2 do low byte
f7e4 : a5e1             [ 3] 	lda df_asmoprnd+1
f7e6 : 20abc8           [ 6] 	jsr utilPrintA
f7e9 :                       df_rt_asm_printOPR_1
f7e9 : a5e0             [ 3] 	lda df_asmoprnd
f7eb : 4cabc8           [ 3] 	jmp utilPrintA
                             
f7ee :                       df_rt_asm_printCR
                             	; Check the option bit 0 (Print)
f7ee : a901             [ 2] 	lda #0x01
f7f0 : 25dd             [ 3] 	and df_asmopt
f7f2 : f0bb             [ 3] 	beq df_rt_asm_print_rts
f7f4 : 4ca3c8           [ 3] 	jmp utilPrintCRLF
                             
f7f7 :                       df_rt_asm_printCH
f7f7 : 8545             [ 3] 	sta tmp_d
                             	; Check the option bit 0 (Print)
f7f9 : a901             [ 2] 	lda #0x01
f7fb : 25dd             [ 3] 	and df_asmopt
f7fd : f0b0             [ 3] 	beq df_rt_asm_print_rts
f7ff : a545             [ 3] 	lda tmp_d
f801 : 4cc0c5           [ 3] 	jmp io_put_ch
                             
                             ; Print an entire line, but save df_exeoff
f804 :                       df_rt_asm_printline
                             	; Check the option bit 0 (Print)
f804 : a901             [ 2] 	lda #0x01
f806 : 25dd             [ 3] 	and df_asmopt
f808 : f0a5             [ 4] 	beq df_rt_asm_print_rts
AS65 Assembler for R6502 [1.42].                                     Page  214
---------------------------------- bank1.s -----------------------------------

f80a : a5ca             [ 3] 	lda df_exeoff
f80c : 48               [ 3] 	pha
                             	; use df_tmpptra
                             	_cpyZPWord df_currlin, df_tmpptra
                             
f815 : 20ace7           [ 6] 	jsr df_rt_list_line_only
f818 : 68               [ 4] 	pla
f819 : 85ca             [ 3] 	sta df_exeoff
f81b : 60               [ 6] 	rts
                             
                             
                             ; Calculate the addressing mode
                             ; Populate the operand as needed
                             ; A and df_asmadmd contain Addressing Mode
f81c :                       df_rt_asm_addrmode	
                             	; Store nothing in address mode
f81c : a900             [ 2] 	lda #AM_NONE
f81e : 85de             [ 3] 	sta df_asmadmd
                             	; zero out the operand
f820 : a900             [ 2] 	lda #0
f822 : 85e0             [ 3] 	sta df_asmoprnd
f824 : 85e1             [ 3] 	sta df_asmoprnd+1
f826 : 203ee6           [ 6] 	jsr df_rt_eos			; End of statement?
f829 : b00d             [ 3] 	bcs df_rt_asm_AM_IMP
                             	; jump over whitespace
f82b : 2084dd           [ 6] 	jsr df_rt_skip_ws
                             	; Check what it is
f82e : c923             [ 2] 	cmp #'#'				; Immediate?
f830 : f034             [ 3] 	beq df_rt_asm_AM_IMM
f832 : c928             [ 2] 	cmp #'('				; Indirect something?
f834 : f03a             [ 3] 	beq df_rt_asm_AM_INDIRECT
                             	; Must be ABS,ZP or REL
f836 : d005             [ 3] 	bne df_rt_asm_ABSREL
                             ; Process IMP/ACC
f838 :                       df_rt_asm_AM_IMP
f838 : a90d             [ 2] 	lda #AM_IMP
f83a : 85de             [ 3] 	sta df_asmadmd
f83c : 60               [ 6] 	rts
                             ; Process ABS or REL
f83d :                       df_rt_asm_ABSREL	
                             	; Evaluate operand
f83d : 2099f8           [ 6] 	jsr df_rt_asm_get_operand
                             
f840 : 203ee6           [ 6] 	jsr df_rt_eos			; End of statement?
f843 : b00f             [ 3] 	bcs df_rt_asm_AM_ABS
f845 : c8               [ 2] 	iny						; Jump over ","
f846 : b1c8             [ 5] 	lda (df_currlin),y		; Load X or Y
f848 : c8               [ 2] 	iny						; Jump over index reg
f849 : 85ca             [ 3] 	sta df_exeoff			; Save exe offset
f84b : c978             [ 2] 	cmp #'x'				; Indirect X?
f84d : f012             [ 3] 	beq df_rt_asm_AM_ABSX
                             ; Process ABSY
f84f :                       df_rt_asm_AM_ABSY
f84f : a906             [ 2] 	lda #AM_ZPY				; Go for smallest modes
f851 : 85de             [ 3] 	sta df_asmadmd
f853 : 60               [ 6] 	rts
                             ; Process what looks like pure ABS, could be REL
f854 :                       df_rt_asm_AM_ABS
f854 : a001             [ 2] 	ldy #1					; Check first addressing mode
f856 : b1c3             [ 5] 	lda (df_symtab),y
f858 : c90f             [ 2] 	cmp #AM_REL
f85a : f002             [ 3] 	beq df_rt_asm_AM_REL
AS65 Assembler for R6502 [1.42].                                     Page  215
---------------------------------- bank1.s -----------------------------------

f85c : a904             [ 2] 	lda #AM_ZP				; Go for smallest modes
f85e :                       df_rt_asm_AM_REL
f85e : 85de             [ 3] 	sta df_asmadmd
f860 : 60               [ 6] 	rts
                             ; Process ABSX
f861 :                       df_rt_asm_AM_ABSX
f861 : a905             [ 2] 	lda #AM_ZPX				; Go for smallest modes
f863 : 85de             [ 3] 	sta df_asmadmd
f865 : 60               [ 6] 	rts
                             ; Process Immediate
f866 :                       df_rt_asm_AM_IMM
                             	; skip over #
f866 : e6ca             [ 5] 	inc df_exeoff
                             	; Get operand
f868 : 2099f8           [ 6] 	jsr df_rt_asm_get_operand
                             	; Mark as immediate
f86b : a90c             [ 2] 	lda #AM_IMM
f86d : 85de             [ 3] 	sta df_asmadmd
f86f : 60               [ 6] 	rts
                             ; Process indirect
f870 :                       df_rt_asm_AM_INDIRECT
                             	; skip over (
f870 : e6ca             [ 5] 	inc df_exeoff
                             	; Calculate the operand
f872 : 2099f8           [ 6] 	jsr df_rt_asm_get_operand
                             	; what is next char?
f875 : a4ca             [ 3] 	ldy df_exeoff
f877 : b1c8             [ 5] 	lda (df_currlin),y
f879 : c929             [ 2] 	cmp #')'			; Could be IND or INDY
f87b : f009             [ 3] 	beq df_rt_asm_AM_ZPINDORY
                             	; else must be INDX
                             	; skip 'x)'
f87d : c8               [ 2] 	iny
f87e : c8               [ 2] 	iny
f87f : 84ca             [ 3] 	sty df_exeoff
f881 : a908             [ 2] 	lda #AM_ZPINDX
f883 : 85de             [ 3] 	sta df_asmadmd
f885 : 60               [ 6] 	rts
                             ; Pure indirect mode found
f886 :                       df_rt_asm_AM_ZPINDORY
f886 : a907             [ 2] 	lda #AM_ZPIND			; Assume ZPIND
f888 : c8               [ 2] 	iny
f889 : 84ca             [ 3] 	sty df_exeoff
                             	; if at end of line/statement then pure indirect
f88b : 203ee6           [ 6] 	jsr df_rt_eos			; End of statement?
f88e : b006             [ 3] 	bcs df_rt_asm_AM_ZPIND
                             	; else must be INDY
f890 : a909             [ 2] 	lda #AM_ZPINDY
                             	; skip ',Y'
f892 : c8               [ 2] 	iny
f893 : c8               [ 2] 	iny
f894 : 84ca             [ 3] 	sty df_exeoff
f896 :                       df_rt_asm_AM_ZPIND
f896 : 85de             [ 3] 	sta df_asmadmd
f898 : 60               [ 6] 	rts
                             
                             ; Get and save the operand
                             ; df_asmoprnd contains the result
f899 :                       df_rt_asm_get_operand
                             	; evaluate
f899 : 2048d9           [ 6] 	jsr df_rt_neval
                             	; Get the parameter from stack
AS65 Assembler for R6502 [1.42].                                     Page  216
---------------------------------- bank1.s -----------------------------------

f89c : 20daf2           [ 6] 	jsr df_ost_popInt
                             	; put in the operand
f89f : 86e0             [ 3] 	stx df_asmoprnd
f8a1 : 85e1             [ 3] 	sta df_asmoprnd+1
f8a3 : 60               [ 6] 	rts
                             	
                             ; From current symtab entry, find addressing
                             ; mode in A.  AM_NONE=Not found, Y=index
f8a4 :                       df_rt_asm_find_addr_mode
                             	; save A in tmp
f8a4 : 8545             [ 3] 	sta tmp_d
                             	; Start first entry (1) - 2 = 0xff
f8a6 : a0ff             [ 2] 	ldy #0xff
f8a8 : a200             [ 2] 	ldx #0
f8aa :                       df_rt_asm_find_addr_mode_loop
                             	; next entry
f8aa : c8               [ 2] 	iny
f8ab : c8               [ 2] 	iny
                             	; if current index > num entries then error
f8ac : 98               [ 2] 	tya
f8ad : 38               [ 2] 	sec
f8ae : e1c3             [ 6] 	sbc (df_symtab,x)
f8b0 : b007             [ 3] 	bcs df_rt_asm_find_addr_mode_err
                             	; is symtab addressing mode what we want?
f8b2 : b1c3             [ 5] 	lda (df_symtab),y
f8b4 : c545             [ 3] 	cmp tmp_d
f8b6 : d0f2             [ 3] 	bne df_rt_asm_find_addr_mode_loop
                             	; done A=mode, y=index in to df_symtab
f8b8 : 60               [ 6] 	rts
f8b9 :                       df_rt_asm_find_addr_mode_err
f8b9 : a900             [ 2] 	lda #AM_NONE
f8bb :                       df_rt_asm_skip_to_sym_done; Used by function belo
f8bb : 60               [ 6] 	rts
                             
                             
                             ; Skip X amount of symbols in table
                             ; A contains how many addr mode and op code bytes
                             ; df_symtab points to offset byte
f8bc :                       df_rt_asm_skip_to_sym
f8bc : e8               [ 2] 	inx				; so done when X=0
                             	; Start at token symbols beginning
f8bd : a90a             [ 2] 	lda #lo(df_asm_tokensyms)
f8bf : 85c3             [ 3] 	sta df_symtab
f8c1 : a9f9             [ 2] 	lda #hi(df_asm_tokensyms)
f8c3 : 85c4             [ 3] 	sta df_symtab+1
f8c5 : a900             [ 2] 	lda #0
f8c7 : 85c5             [ 3] 	sta df_symoff
f8c9 : a8               [ 2] 	tay
f8ca :                       df_rt_asm_skip_to_sym_next
                             	; Get symtable char
f8ca : b1c3             [ 5] 	lda (df_symtab),y
                             	; if < ' ' then jumped over symbol chars
f8cc : c920             [ 2] 	cmp #' '
f8ce : 9009             [ 3] 	bcc df_rt_asm_skip_to_sym_end
                             	;else next smy tab char
                             	_incZPWord df_symtab
                             
f8d6 : 4ccaf8           [ 3] 	jmp df_rt_asm_skip_to_sym_next
                             	; Found end of symbol
f8d9 :                       df_rt_asm_skip_to_sym_end
                             	;if done then return
f8d9 : ca               [ 2] 	dex
AS65 Assembler for R6502 [1.42].                                     Page  217
---------------------------------- bank1.s -----------------------------------

f8da : f0df             [ 3] 	beq df_rt_asm_skip_to_sym_done
                             	;jump over addr and op code by A bytes
f8dc : 38               [ 2] 	sec
f8dd : 65c3             [ 3] 	adc df_symtab
f8df : 85c3             [ 3] 	sta df_symtab
                             	_bcc 2
                             
f8e3 : e6c4             [ 5] 	inc df_symtab+1
f8e5 : 4ccaf8           [ 3] 	jmp df_rt_asm_skip_to_sym_next
                             
f8e8 :                       mod_sz_rtasm_e
                             
                             
                             	include "dflat\asmsymtab.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ASMSYMTAB.S
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             	;* Length of each addressing mode
                             	;* ORDER significant!
f8e8 :                       df_asm_length
f8e8 : 00030303020202..      	db	0,3,3,3,2,2,2,2,2,2,3,3,2,1,1,2,0
                             
                             	; Always try for lowest addressing mode, but
                             	; this table maps to alternative
f8f9 :                       df_asm_altaddrmode
f8f9 : 00                    	db AM_NONE		;AM_NONE	= 0
f8fa : 00                    	db AM_NONE		;AM_ABS	 	= 1
f8fb : 00                    	db AM_NONE		;AM_ABSX	= 2
f8fc : 00                    	db AM_NONE		;AM_ABSY	= 3
f8fd : 01                    	db AM_ABS		;AM_ZP		= 4
f8fe : 02                    	db AM_ABSX		;AM_ZPX		= 5
f8ff : 03                    	db AM_ABSY		;AM_ZPY		= 6
f900 : 0a                    	db AM_ABSIND	;AM_ZPIND	= 7
f901 : 0b                    	db AM_ABSINDX	;AM_ZPINDX	= 8
f902 : 09                    	db AM_ZPINDY	;AM_ZPINDY	= 9
f903 : 00                    	db AM_NONE		;AM_ABSIND	= 10
f904 : 00                    	db AM_NONE		;AM_ABSINDX	= 11
f905 : 00                    	db AM_NONE		;AM_IMM		= 12
f906 : 00                    	db AM_NONE		;AM_ACC		= 13
f907 : 00                    	db AM_NONE		;AM_IMP		= AM_ACC
f908 : 0f                    	db AM_REL		;AM_REL		= 15
f909 : 00                    	db AM_NONE		;AM_DIR		= 16
                             
                             
                             	;*	Mnemonic/	How many addressing modes /
                             	;* 	Mode		Opcode for mode
f90a :                       df_asm_tokensyms
                             	;* Start with directives
f90a : 2e6f726702            	db	".org",		1*2
f90f : 1000                  	db	AM_DIR,		0x00
AS65 Assembler for R6502 [1.42].                                     Page  218
---------------------------------- bank1.s -----------------------------------

f911 : 2e6f707402            	db	".opt",		1*2
f916 : 1000                  	db	AM_DIR,		0x00
f918 : 2e646202              	db	".db",		1*2
f91c : 1000                  	db	AM_DIR,		0x00
f91e : 2e647702              	db	".dw",		1*2
f922 : 1000                  	db	AM_DIR,		0x00
f924 : 2e647302              	db	".ds",		1*2
f928 : 1000                  	db	AM_DIR,		0x00	
                             
f92a : 61646312              	db	"adc",		9*2
f92e : 0c69                  	db	AM_IMM,		0x69
f930 : 0465                  	db	AM_ZP,		0x65
f932 : 0575                  	db	AM_ZPX,		0x75
f934 : 016d                  	db	AM_ABS,		0x6d
f936 : 027d                  	db	AM_ABSX,	0x7d
f938 : 0379                  	db	AM_ABSY,	0x79
f93a : 0861                  	db	AM_ZPINDX,	0x61
f93c : 0971                  	db	AM_ZPINDY,	0x71
f93e : 0772                  	db	AM_ZPIND,	0x72
                             	
f940 : 616e6412              	db	"and",		9*2
f944 : 0c29                  	db	AM_IMM,		0x29
f946 : 0425                  	db	AM_ZP,		0x25
f948 : 0535                  	db	AM_ZPX,		0x35
f94a : 012d                  	db	AM_ABS,		0x2d
f94c : 023d                  	db	AM_ABSX,	0x3d
f94e : 0339                  	db	AM_ABSY,	0x39
f950 : 0821                  	db	AM_ZPINDX,	0x21
f952 : 0931                  	db	AM_ZPINDY,	0x31
f954 : 0732                  	db	AM_ZPIND,	0x32
                             
f956 : 636d7012              	db	"cmp",		9*2
f95a : 0cc9                  	db	AM_IMM,		0xc9
f95c : 04c5                  	db	AM_ZP,		0xc5
f95e : 05d5                  	db	AM_ZPX,		0xd5
f960 : 01cd                  	db	AM_ABS,		0xcd
f962 : 02dd                  	db	AM_ABSX,	0xdd
f964 : 03d9                  	db	AM_ABSY,	0xd9
f966 : 08c1                  	db	AM_ZPINDX,	0xc1
f968 : 09d1                  	db	AM_ZPINDY,	0xd1
f96a : 07d2                  	db	AM_ZPIND,	0xd2
                             
f96c : 656f7212              	db	"eor",		9*2
f970 : 0c49                  	db	AM_IMM,		0x49
f972 : 0445                  	db	AM_ZP,		0x45
f974 : 0555                  	db	AM_ZPX,		0x55
f976 : 014d                  	db	AM_ABS,		0x4d
f978 : 025d                  	db	AM_ABSX,	0x5d
f97a : 0359                  	db	AM_ABSY,	0x59
f97c : 0841                  	db	AM_ZPINDX,	0x41
f97e : 0951                  	db	AM_ZPINDY,	0x51
f980 : 0752                  	db	AM_ZPIND,	0x52
                             
f982 : 6c646112              	db	"lda",		9*2
f986 : 0ca9                  	db	AM_IMM,		0xa9
f988 : 04a5                  	db	AM_ZP,		0xa5
f98a : 05b5                  	db	AM_ZPX,		0xb5
f98c : 01ad                  	db	AM_ABS,		0xad
f98e : 02bd                  	db	AM_ABSX,	0xbd
f990 : 03b9                  	db	AM_ABSY,	0xb9
f992 : 08a1                  	db	AM_ZPINDX,	0xa1
f994 : 09b1                  	db	AM_ZPINDY,	0xb1
AS65 Assembler for R6502 [1.42].                                     Page  219
---------------------------------- bank1.s -----------------------------------

f996 : 07b2                  	db	AM_ZPIND,	0xb2
                             
f998 : 6f726112              	db	"ora",		9*2
f99c : 0c09                  	db	AM_IMM,		0x09
f99e : 0405                  	db	AM_ZP,		0x05
f9a0 : 0515                  	db	AM_ZPX,		0x15
f9a2 : 010d                  	db	AM_ABS,		0x0d
f9a4 : 021d                  	db	AM_ABSX,	0x1d
f9a6 : 0319                  	db	AM_ABSY,	0x19
f9a8 : 0801                  	db	AM_ZPINDX,	0x01
f9aa : 0911                  	db	AM_ZPINDY,	0x11
f9ac : 0712                  	db	AM_ZPIND,	0x12
                             
f9ae : 73626312              	db	"sbc",		9*2
f9b2 : 0ce9                  	db	AM_IMM,		0xe9
f9b4 : 04e5                  	db	AM_ZP,		0xe5
f9b6 : 05f5                  	db	AM_ZPX,		0xf5
f9b8 : 01ed                  	db	AM_ABS,		0xed
f9ba : 02fd                  	db	AM_ABSX,	0xfd
f9bc : 03f9                  	db	AM_ABSY,	0xf9
f9be : 08e1                  	db	AM_ZPINDX,	0xe1
f9c0 : 09f1                  	db	AM_ZPINDY,	0xf1
f9c2 : 07f2                  	db	AM_ZPIND,	0xf2
                             
f9c4 : 73746110              	db	"sta",		8*2
f9c8 : 0485                  	db	AM_ZP,		0x85
f9ca : 0595                  	db	AM_ZPX,		0x95
f9cc : 018d                  	db	AM_ABS,		0x8d
f9ce : 029d                  	db	AM_ABSX,	0x9d
f9d0 : 0399                  	db	AM_ABSY,	0x99
f9d2 : 0881                  	db	AM_ZPINDX,	0x81
f9d4 : 0991                  	db	AM_ZPINDY,	0x91
f9d6 : 0792                  	db	AM_ZPIND,	0x92
                             
f9d8 : 61736c0a              	db	"asl",		5*2
f9dc : 0d0a                  	db	AM_IMP,		0x0a
f9de : 0406                  	db	AM_ZP,		0x06
f9e0 : 0516                  	db	AM_ZPX,		0x16
f9e2 : 010e                  	db	AM_ABS,		0x0e
f9e4 : 021e                  	db	AM_ABSX,	0x1e
f9e6 : 6465630a              	db	"dec",		5*2
f9ea : 0d3a                  	db	AM_IMP,		0x3a
f9ec : 04c6                  	db	AM_ZP,		0xc6
f9ee : 05d6                  	db	AM_ZPX,		0xd6
f9f0 : 01ce                  	db	AM_ABS,		0xce
f9f2 : 02de                  	db	AM_ABSX,	0xde
f9f4 : 696e630a              	db	"inc",		5*2
f9f8 : 0d1a                  	db	AM_IMP,		0x1a
f9fa : 04e6                  	db	AM_ZP,		0xe6
f9fc : 05f6                  	db	AM_ZPX,		0xf6
f9fe : 01ee                  	db	AM_ABS,		0xee
fa00 : 02fe                  	db	AM_ABSX,	0xfe
fa02 : 6c73720a              	db	"lsr",		5*2
fa06 : 0d4a                  	db	AM_IMP,		0x4a
fa08 : 0446                  	db	AM_ZP,		0x46
fa0a : 0556                  	db	AM_ZPX,		0x56
fa0c : 014e                  	db	AM_ABS,		0x4e
fa0e : 025e                  	db	AM_ABSX,	0x5e
fa10 : 726f6c0a              	db	"rol",		5*2
fa14 : 0d2a                  	db	AM_IMP,		0x2a
fa16 : 0426                  	db	AM_ZP,		0x26
fa18 : 0536                  	db	AM_ZPX,		0x36
AS65 Assembler for R6502 [1.42].                                     Page  220
---------------------------------- bank1.s -----------------------------------

fa1a : 012e                  	db	AM_ABS,		0x2e
fa1c : 023e                  	db	AM_ABSX,	0x3e
fa1e : 726f720a              	db	"ror",		5*2
fa22 : 0d6a                  	db	AM_IMP,		0x6a
fa24 : 0466                  	db	AM_ZP,		0x66
fa26 : 0576                  	db	AM_ZPX,		0x76
fa28 : 016e                  	db	AM_ABS,		0x6e
fa2a : 027e                  	db	AM_ABSX,	0x7e
                             
fa2c : 6269740a              	db	"bit",		5*2
fa30 : 0c89                  	db	AM_IMM,		0x89
fa32 : 0424                  	db	AM_ZP,		0x24
fa34 : 0534                  	db	AM_ZPX,		0x34
fa36 : 012c                  	db	AM_ABS,		0x2c
fa38 : 023c                  	db	AM_ABSX,	0x3c
                             	
fa3a : 62726b02              	db	"brk",		1*2
fa3e : 0d00                  	db	AM_IMP,		0x00
fa40 : 73747002              	db	"stp",		1*2
fa44 : 0ddb                  	db	AM_IMP,		0xdb
fa46 : 77616902              	db	"wai",		1*2
fa4a : 0dcb                  	db	AM_IMP,		0xcb
                             	
fa4c : 636c6302              	db	"clc",		1*2
fa50 : 0d18                  	db	AM_IMP,		0x18
fa52 : 636c6402              	db	"cld",		1*2
fa56 : 0dd8                  	db	AM_IMP,		0xd8
fa58 : 636c6902              	db	"cli",		1*2
fa5c : 0d58                  	db	AM_IMP,		0x58
fa5e : 636c7602              	db	"clv",		1*2
fa62 : 0db8                  	db	AM_IMP,		0xb8
fa64 : 73656302              	db	"sec",		1*2
fa68 : 0d38                  	db	AM_IMP,		0x38
fa6a : 73656402              	db	"sed",		1*2
fa6e : 0df8                  	db	AM_IMP,		0xf8
fa70 : 73656902              	db	"sei",		1*2
fa74 : 0d78                  	db	AM_IMP,		0x78
                             	
fa76 : 63707806              	db	"cpx",		3*2
fa7a : 0ce0                  	db	AM_IMM,		0xe0
fa7c : 04e4                  	db	AM_ZP,		0xe4
fa7e : 01ec                  	db	AM_ABS,		0xec
fa80 : 63707906              	db	"cpy",		3*2
fa84 : 0cc0                  	db	AM_IMM,		0xc0
fa86 : 04c4                  	db	AM_ZP,		0xc4
fa88 : 01cc                  	db	AM_ABS,		0xcc
fa8a : 64657802              	db	"dex",		1*2
fa8e : 0dca                  	db	AM_IMP,		0xca
fa90 : 64657902              	db	"dey",		1*2
fa94 : 0d88                  	db	AM_IMP,		0x88
fa96 : 696e7802              	db	"inx",		1*2
fa9a : 0de8                  	db	AM_IMP,		0xe8
fa9c : 696e7902              	db	"iny",		1*2
faa0 : 0dc8                  	db	AM_IMP,		0xc8
faa2 : 6c64780a              	db	"ldx",		5*2
faa6 : 0ca2                  	db	AM_IMM,		0xa2
faa8 : 04a6                  	db	AM_ZP,		0xa6
faaa : 06b6                  	db	AM_ZPY,		0xb6
faac : 01ae                  	db	AM_ABS,		0xae
faae : 03be                  	db	AM_ABSY,	0xbe
fab0 : 6c64790a              	db	"ldy",		5*2
fab4 : 0ca0                  	db	AM_IMM,		0xa0
AS65 Assembler for R6502 [1.42].                                     Page  221
---------------------------------- bank1.s -----------------------------------

fab6 : 04a4                  	db	AM_ZP,		0xa4
fab8 : 05b4                  	db	AM_ZPX,		0xb4
faba : 01ac                  	db	AM_ABS,		0xac
fabc : 02bc                  	db	AM_ABSX,	0xbc
fabe : 73747806              	db	"stx",		3*2
fac2 : 0486                  	db	AM_ZP,		0x86
fac4 : 0696                  	db	AM_ZPY,		0x96
fac6 : 018e                  	db	AM_ABS,		0x8e
fac8 : 73747906              	db	"sty",		3*2
facc : 0484                  	db	AM_ZP,		0x84
face : 0594                  	db	AM_ZPX,		0x94
fad0 : 018c                  	db	AM_ABS,		0x8c
fad2 : 73747a08              	db	"stz",		4*2
fad6 : 0464                  	db	AM_ZP,		0x64
fad8 : 0574                  	db	AM_ZPX,		0x74
fada : 019c                  	db	AM_ABS,		0x9c
fadc : 029e                  	db	AM_ABSX,	0x9e
                             	
                             
fade : 62636302              	db	"bcc",		1*2
fae2 : 0f90                  	db	AM_REL,		0x90
fae4 : 62637302              	db	"bcs",		1*2
fae8 : 0fb0                  	db	AM_REL,		0xb0
faea : 62657102              	db	"beq",		1*2
faee : 0ff0                  	db	AM_REL,		0xf0
faf0 : 626d6902              	db	"bmi",		1*2
faf4 : 0f30                  	db	AM_REL,		0x30
faf6 : 626e6502              	db	"bne",		1*2
fafa : 0fd0                  	db	AM_REL,		0xd0
fafc : 62706c02              	db	"bpl",		1*2
fb00 : 0f10                  	db	AM_REL,		0x10
fb02 : 62726102              	db	"bra",		1*2
fb06 : 0f80                  	db	AM_REL,		0x80
fb08 : 62766302              	db	"bvc",		1*2
fb0c : 0f50                  	db	AM_REL,		0x50
fb0e : 62767302              	db	"bvs",		1*2
fb12 : 0f70                  	db	AM_REL,		0x70
fb14 : 6a6d7006              	db	"jmp",		3*2
fb18 : 014c                  	db	AM_ABS,		0x4c
fb1a : 0a6c                  	db	AM_ABSIND,	0x6c
fb1c : 0b7c                  	db	AM_ABSINDX,	0x7c
fb1e : 6a737202              	db	"jsr",		1*2
fb22 : 0120                  	db	AM_ABS,		0x20
                             	
fb24 : 6e6f7002              	db	"nop",		1*2
fb28 : 0dea                  	db	AM_IMP,		0xea
fb2a : 70686102              	db	"pha",		1*2
fb2e : 0d48                  	db	AM_IMP,		0x48
fb30 : 70687002              	db	"php",		1*2
fb34 : 0d08                  	db	AM_IMP,		0x08
fb36 : 70687802              	db	"phx",		1*2
fb3a : 0dda                  	db	AM_IMP,		0xda
fb3c : 70687902              	db	"phy",		1*2
fb40 : 0d5a                  	db	AM_IMP,		0x5a
fb42 : 706c6102              	db	"pla",		1*2
fb46 : 0d68                  	db	AM_IMP,		0x68
fb48 : 706c7002              	db	"plp",		1*2
fb4c : 0d28                  	db	AM_IMP,		0x28
fb4e : 706c7802              	db	"plx",		1*2
fb52 : 0dfa                  	db	AM_IMP,		0xfa
fb54 : 706c7902              	db	"ply",		1*2
fb58 : 0d7a                  	db	AM_IMP,		0x7a
AS65 Assembler for R6502 [1.42].                                     Page  222
---------------------------------- bank1.s -----------------------------------

fb5a : 72746902              	db	"rti",		1*2
fb5e : 0d40                  	db	AM_IMP,		0x40
fb60 : 72747302              	db	"rts",		1*2
fb64 : 0d60                  	db	AM_IMP,		0x60
fb66 : 74617802              	db	"tax",		1*2
fb6a : 0daa                  	db	AM_IMP,		0xaa
fb6c : 74617902              	db	"tay",		1*2
fb70 : 0da8                  	db	AM_IMP,		0xa8
fb72 : 74737802              	db	"tsx",		1*2
fb76 : 0dba                  	db	AM_IMP,		0xba
fb78 : 74786102              	db	"txa",		1*2
fb7c : 0d8a                  	db	AM_IMP,		0x8a
fb7e : 74787302              	db	"txs",		1*2
fb82 : 0d9a                  	db	AM_IMP,		0x9a
fb84 : 74796102              	db	"tya",		1*2
fb88 : 0d98                  	db	AM_IMP,		0x98
                             	
fb8a : 74726204              	db	"trb",		2*2
fb8e : 0414                  	db	AM_ZP,		0x14
fb90 : 011c                  	db	AM_ABS,		0x1c
fb92 : 74736204              	db	"tsb",		2*2
fb96 : 0404                  	db	AM_ZP,		0x04
fb98 : 010c                  	db	AM_ABS,		0x0c
                             	
fb9a : 6262723002            	db	"bbr0",		1*2
fb9f : 0f0f                  	db	AM_REL,		0x0f
fba1 : 6262723102            	db	"bbr1",		1*2
fba6 : 0f1f                  	db	AM_REL,		0x1f
fba8 : 6262723202            	db	"bbr2",		1*2
fbad : 0f2f                  	db	AM_REL,		0x2f
fbaf : 6262723302            	db	"bbr3",		1*2
fbb4 : 0f3f                  	db	AM_REL,		0x3f
fbb6 : 6262723402            	db	"bbr4",		1*2
fbbb : 0f4f                  	db	AM_REL,		0x4f
fbbd : 6262723502            	db	"bbr5",		1*2
fbc2 : 0f5f                  	db	AM_REL,		0x5f
fbc4 : 6262723602            	db	"bbr6",		1*2
fbc9 : 0f6f                  	db	AM_REL,		0x6f
fbcb : 6262723702            	db	"bbr7",		1*2
fbd0 : 0f7f                  	db	AM_REL,		0x7f
fbd2 : 6262733002            	db	"bbs0",		1*2
fbd7 : 0f8f                  	db	AM_REL,		0x8f
fbd9 : 6262733102            	db	"bbs1",		1*2
fbde : 0f9f                  	db	AM_REL,		0x9f
fbe0 : 6262733202            	db	"bbs2",		1*2
fbe5 : 0faf                  	db	AM_REL,		0xaf
fbe7 : 6262733302            	db	"bbs3",		1*2
fbec : 0fbf                  	db	AM_REL,		0xbf
fbee : 6262733402            	db	"bbs4",		1*2
fbf3 : 0fcf                  	db	AM_REL,		0xcf
fbf5 : 6262733502            	db	"bbs5",		1*2
fbfa : 0fdf                  	db	AM_REL,		0xdf
fbfc : 6262733602            	db	"bbs6",		1*2
fc01 : 0fef                  	db	AM_REL,		0xef
fc03 : 6262733702            	db	"bbs7",		1*2
fc08 : 0fff                  	db	AM_REL,		0xff
fc0a : 726d623002            	db	"rmb0",		1*2
fc0f : 0f07                  	db	AM_REL,		0x07
fc11 : 726d623102            	db	"rmb1",		1*2
fc16 : 0f17                  	db	AM_REL,		0x17
fc18 : 726d623202            	db	"rmb2",		1*2
fc1d : 0f27                  	db	AM_REL,		0x27
AS65 Assembler for R6502 [1.42].                                     Page  223
---------------------------------- bank1.s -----------------------------------

fc1f : 726d623302            	db	"rmb3",		1*2
fc24 : 0f37                  	db	AM_REL,		0x37
fc26 : 726d623402            	db	"rmb4",		1*2
fc2b : 0f47                  	db	AM_REL,		0x47
fc2d : 726d623502            	db	"rmb5",		1*2
fc32 : 0f57                  	db	AM_REL,		0x57
fc34 : 726d623602            	db	"rmb6",		1*2
fc39 : 0f67                  	db	AM_REL,		0x67
fc3b : 726d623702            	db	"rmb7",		1*2
fc40 : 0f77                  	db	AM_REL,		0x77
fc42 : 736d623002            	db	"smb0",		1*2
fc47 : 0f87                  	db	AM_REL,		0x87
fc49 : 736d623102            	db	"smb1",		1*2
fc4e : 0f97                  	db	AM_REL,		0x97
fc50 : 736d623202            	db	"smb2",		1*2
fc55 : 0fa7                  	db	AM_REL,		0xa7
fc57 : 736d623302            	db	"smb3",		1*2
fc5c : 0fb7                  	db	AM_REL,		0xb7
fc5e : 736d623402            	db	"smb4",		1*2
fc63 : 0fc7                  	db	AM_REL,		0xc7
fc65 : 736d623502            	db	"smb5",		1*2
fc6a : 0fd7                  	db	AM_REL,		0xd7
fc6c : 736d623602            	db	"smb6",		1*2
fc71 : 0fe7                  	db	AM_REL,		0xe7
fc73 : 736d623702            	db	"smb7",		1*2
fc78 : 0ff7                  	db	AM_REL,		0xf7
                             	
                             	;* Terminates with a zero
fc7a : 00                    	db	0
                             
                             	include	"dflat\asmjmptab.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ASMJUMPTAB.S
                             ;*  Runtime token jump table for assembler.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; Only directives needed as all opcodes are handl
                             ; through a single routine
fc7b :                       df_tk_asm_tokenjmp
fc7b : 26d7                  	dw	df_tk_asm_org
AS65 Assembler for R6502 [1.42].                                     Page  224
---------------------------------- bank1.s -----------------------------------

fc7d : 26d7                  	dw	df_tk_asm_opt
fc7f : 71d6                  	dw	df_tk_asm_db
fc81 : 71d6                  	dw	df_tk_asm_dw
fc83 : 26d7                  	dw	df_tk_asm_ds
                             
fc85 :                       df_rt_asm_tokenjmp
fc85 : 2df6                  	dw	df_rt_asm_org
fc87 : 3ff6                  	dw	df_rt_asm_opt
fc89 : 47f6                  	dw	df_rt_asm_db
fc8b : 4af6                  	dw	df_rt_asm_dw
fc8d : c5f6                  	dw	df_rt_asm_ds
                             
                             
                             ;****************************************
                             ;* as_init
                             ;* Initialise assembler settings
                             ;****************************************
fc8f :                       asm_init
                             	; Zero the PC
fc8f : 64db             [ 3] 	stz df_asmpc
fc91 : 64dc             [ 3] 	stz df_asmpc+1
                             	; Zero the option
fc93 : 64dd             [ 3] 	stz df_asmopt
fc95 : 60               [ 6] 	rts
                             	
fc96 :                       mod_sz_asm_e
                             
                             
                             	; End of Code
fc96 :                       _code_end
fc96 :                       _bank1_end
                             	
                             
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
