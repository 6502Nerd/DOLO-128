AS65 Assembler for R6502 [1.42].                                     Page    1
---------------------------------- bank2.s -----------------------------------

5779 lines read, no errors in pass 1.
c000 =                       _bank2_start=0xc000
                             	include "kernel\kernel.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  KERNEL.S
                             ;*	The 'kernel' routine includes code and data wh
                             ;* 	be in every ROM bank.  In the auto-generated 
                             ;*  files, the kernel is added before the bank sp
                             ;*	code.  See bank0.s as an example.
                             ;*
                             ;************************************************
                             
                             ;* Include all definition and code files in the r
                             	include "inc\includes.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  INCLUDES.S
                             ;*  Main include file for key definitions and mac
                             ;*  Many of the settings here are exremely machin
                             ;*  Defines : IO block addresses, VIA port usage,
                             ;*  settings, useful macros, sound chip registers
                             ;*  VDP registers, ACIA registers.
                             ;*
                             ;************************************************
                             
                             ;* The IO block is at 0x04000 and decodes up to
                             ;* eight IO addresses, at 0x0080 intervals
                             ;* All eight are not used at the present time:
                             ;* - 0 : VIA 1 (Keyboard)
                             ;* - 1 : VIA 2 (Sound and SD card interface)
                             ;* - 2 : VDP (Video)
                             ;* - 3 : ACIA (Serial)
                             ;* - 4 : RTC (DS12887 real time clock + RAM)
0400 =                       IO_0		= 0x0400
0480 =                       IO_1		= 0x0480
0500 =                       IO_2		= 0x0500
0580 =                       IO_3		= 0x0580
0600 =                       IO_4		= 0x0600
0680 =                       IO_5		= 0x0680
0700 =                       IO_6		= 0x0700
0780 =                       IO_7		= 0x0780
                             
                             ;* VDP is accessed through IO_2
0500 =                       VDP_MODE0		= IO_2
0501 =                       VDP_MODE1		= IO_2+1
0501 =                       VDP_STATUS		= IO_2+1
0501 =                       VDP_ADDR		= IO_2+1
0500 =                       VDP_VRAM		= IO_2
0001 =                       VDP_SHORTDELAY	= 1
AS65 Assembler for R6502 [1.42].                                     Page    2
---------------------------------- bank2.s -----------------------------------

0003 =                       VDP_LONGDELAY 	= 3
0010 =                       VDP_FLASH		= 0x10				;* Must be a power of 2 *
                             
                             ;* This structure defines the key information
                             ;* kept about the VDP current mode
0000 =                       	struct vdp_addr_struct
0000 =                       	dw vdp_addr_nme				;* Address of name table
0002 =                       	dw vdp_addr_col				;* Address of colour table
0004 =                       	dw vdp_addr_pat				;* Address of pattern table
0006 =                       	dw vdp_addr_spa				;* Address of sprite pattern 
0008 =                       	dw vdp_addr_spp				;* Address of sprite position
000a =                       	db vdp_bord_col				;* Value of border colour
000b =                       	db vdp_gmode				;* Graphics mode 0,1,2 or 0x80 (
                             	end struct
                             
                             ;* Standard definitions of 6522 registers
                             ;* As found in the datasheets
0000 =                       PRB			= 0x00
0001 =                       PRA			= 0x01
0002 =                       DDRB		= 0x02
0003 =                       DDRA		= 0x03
0004 =                       T1CL		= 0x04
0005 =                       T1CH		= 0x05
0006 =                       T1LL		= 0x06
0007 =                       T1LH		= 0x07
0008 =                       T2CL		= 0x08
0009 =                       T2CH		= 0x09
000a =                       SR			= 0x0a
000b =                       ACR			= 0x0b
000c =                       PCR			= 0x0c
000d =                       IFR			= 0x0d
000e =                       IER			= 0x0e
000f =                       PRAH		= 0x0f
                             
0001 =                       IFR_CA2		= 0x01
0002 =                       IFR_CA1		= 0x02
                             
                             ;* AY-3-8910 definitions
                             ;* The sound chip is accessed through VIA 2
0481 =                       SND_ADBUS	= IO_1+PRA
0480 =                       SND_MODE	= IO_1+PRB
                             
0040 =                       SND_SELREAD			= 0x40
0002 =                       SND_SELWRITE		= 0x02
0042 =                       SND_SELSETADDR		= (SND_SELREAD|SND_SELWRITE)
00bd =                       SND_DESELECT_MASK	= (0xff-SND_SELREAD-SND_SELWRIT
                             
0000 =                       SND_REG_CHAPL	= 0x00
0001 =                       SND_REG_CHAPH	= 0x01
0002 =                       SND_REG_CHBPL	= 0x02
0003 =                       SND_REG_CHBPH	= 0x03
0004 =                       SND_REG_CHCPL	= 0x04
0005 =                       SND_REG_CHCPH	= 0x05
0006 =                       SND_REG_CHNP	= 0x06
0007 =                       SND_REG_CTL		= 0x07
0008 =                       SND_REG_CHAVOL	= 0x08
0009 =                       SND_REG_CHBVOL	= 0x09
000a =                       SND_REG_CHBVOL	= 0x0a
000b =                       SND_REG_ENVPL	= 0x0b
000c =                       SND_REG_ENVPH	= 0x0c
000d =                       SND_REG_ENVCYC	= 0x0d
                             
AS65 Assembler for R6502 [1.42].                                     Page    3
---------------------------------- bank2.s -----------------------------------

000e =                       SND_REG_IOA	= 0x0e
000f =                       SND_REG_IOB	= 0x0f
                             
                             ;* 6551 ACIA definitions
                             ;* As found in the datasheets
0580 =                       SER_DATA	= (IO_3+0)
0581 =                       SER_STATUS	= (IO_3+1)
0581 =                       SER_RESET	= (IO_3+1)
0582 =                       SER_CMD		= (IO_3+2)
0583 =                       SER_CTL		= (IO_3+3)
                             
0080 =                       SER_IRQ		= 0x80
0040 =                       SER_DSRB	= 0x40
0020 =                       SER_DCDB	= 0x20
0010 =                       SER_TDRE	= 0x10
0008 =                       SER_RDRF	= 0x08
0004 =                       SER_OVRN	= 0x04
0002 =                       SER_FE		= 0x02
0001 =                       SER_PE		= 0x01
0080 =                       SER_SBN		= 0x80
0040 =                       SER_WL1		= 0x40
0020 =                       SER_WL0		= 0x20
0060 =                       SER_WL		= (SER_WL1|SER_WL0)
0010 =                       SER_RCS		= 0x10
0008 =                       SER_SBR3	= 0x08
0004 =                       SER_SBR2	= 0x04
0002 =                       SER_SBR1	= 0x02
0001 =                       SER_SBR0	= 0x01
000f =                       SER_SBR		= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0)
000f =                       SER_19200B	= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0
000e =                       SER_9600B	= (SER_SBR3|SER_SBR2|SER_SBR1)
0080 =                       SER_PMC1	= 0x80
0040 =                       SER_PMC0	= 0x40
00c0 =                       SER_PMC		= (SER_PMC1|SER_PMC0)
0020 =                       SER_PME		= 0x20
0010 =                       SER_REM		= 0x10
0008 =                       SER_TIC1	= 0x08
0004 =                       SER_TIC0	= 0x04
000c =                       SER_TIC		= (SER_TIC1|SER_TIC0)
0002 =                       SER_IRD		= 0x02
0001 =                       SER_DTR		= 0x01
                             
                             ;* BBC keyboard definitions
                             ;* The keyboard is accessed through VIA 1
                             ;* Port A - all output
0001 =                       KB_ROWA		= 0x01
0002 =                       KB_ROWB		= 0x02
0004 =                       KB_ROWC		= 0x04
0008 =                       KB_COLA		= 0x08
0010 =                       KB_COLB		= 0x10
0020 =                       KB_COLC		= 0x20
0040 =                       KB_COLD		= 0x40
0080 =                       KB_EN		= 0x80
                             ;* Port B
0001 =                       KB_W		= 0x01			; Input - BBC keyboard hardware se
0002 =                       KB_LED0		= 0x02			; Output - led 0
0004 =                       KB_LED1		= 0x04			; Output - led 1
0008 =                       KB_LED2		= 0x08			; Output - led 2
0001 =                       KB_CAPSLK	= 0x01			; Id of Caps Lock - maps to Le
0002 =                       KB_SHIFTLK	= 0x02			; Id of Shift lock - maps to 
                             
0003 =                       KB_REP_TIM	= 3				; Number of VB periods for the 
AS65 Assembler for R6502 [1.42].                                     Page    4
---------------------------------- bank2.s -----------------------------------

0014 =                       KB_REP_DEL	= 20			; Number of VB periods before r
0002 =                       KB_DEBOUNCE	= 2				; Number of VB periods before 
                             
0001 =                       UTF_SOH		= 0x01
0003 =                       UTF_ETX		= 0x03			; Break character
0007 =                       UTF_BEL		= 0x07
0008 =                       CRSR_LEFT	= 0x08
0009 =                       CRSR_RIGHT	= 0x09
000a =                       CRSR_DOWN	= 0x0a
000b =                       CRSR_UP		= 0x0b
0006 =                       UTF_ACK		= 0x06			; Used for the copy key in this
000c =                       UTF_FF		= 0x0c
000d =                       UTF_CR		= 0x0d
0015 =                       UTF_NACK	= 0x15
0017 =                       UTF_ETB		= 0x17
001a =                       UTF_BRK		= 0x1a			; Debug - drop in to monitor
007f =                       UTF_DEL		= 0x7f
0020 =                       UTF_SPECIAL = 0x20
                             
                             ;* SD Card interface definitions
                             ;* The card is accessed through port B of VIA 2
0001 =                       SD_CLK		= 0x01			; Clock output to SD card
0004 =                       SD_CD		= 0x04			; Card detect input
0008 =                       SD_CS		= 0x08			; Card select output
0010 =                       SD_DI		= 0x10			; Data output from VIA to SD Card
0080 =                       SD_DO		= 0x80			; Data input to VIA from SD card
                             
0010 =                       SD_MOSI		= SD_DI
0080 =                       SD_MISO		= SD_DO
0480 =                       SD_REG		= IO_1+PRB
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
                             
                             ;* Memory management definitions
                             ;* Y1,Y0 = ROM bank selection CIA1 PORTB
0080 =                       MM_Y1					= 0x80
0040 =                       MM_Y0					= 0x40
                             ;* X1,X0 = RAM bank selection CIA1 PORTB
0020 =                       MM_X1					= 0x20
0010 =                       MM_X0					= 0x10
                             ;* DIS = ROM disable *CIA2* PORTB
0020 =                       MM_DIS					= 0x20
                             
                             ;* Number formats for conversion routines
0000 =                       NUM_ANY		= 0x00
0001 =                       NUM_DEC		= 0x01
0002 =                       NUM_HEX		= 0x02
0003 =                       NUM_BIN		= 0x03
                             
                             	
                             ;* SD Card Master Boot Record (MBR) definitions
                             ;* The MBR contains the essential information
                             ;* needed to access the data on the card
                             ;* MBR is usually sector 0, but not always
                             ;* however the card I am using does work ok.
0000 =                       MBR_Code				=	0x0000
0003 =                       MBR_OEMName				=	0x0003
000b =                       MBR_BytesPerSect		=	0x000b
000d =                       MBR_SectPerClust		=	0x000d
AS65 Assembler for R6502 [1.42].                                     Page    5
---------------------------------- bank2.s -----------------------------------

000e =                       MBR_ResvSect			=	0x000e
0010 =                       MBR_FATCopies			=	0x0010
0011 =                       MBR_RootEntries			=	0x0011
0013 =                       MBR_SmlSect				=	0x0013
0015 =                       MBR_MediaDesc			=	0x0015
0016 =                       MBR_SectPerFAT			=	0x0016
0018 =                       MBR_SectPerTrk			=	0x0018
001a =                       MBR_NumHeads			=	0x001a
001c =                       MBR_NumHidSect			=	0x001c
0020 =                       MBR_NumSect				=	0x0020
0024 =                       MBR_DrvNum				=	0x0024
0026 =                       MBR_ExtSig				=	0x0026
0027 =                       MBR_SerNo				=	0x0027
002b =                       MBR_VolName				=	0x002b
0036 =                       MBR_FATName				=	0x0036
003e =                       MBR_ExeCode				=	0x003e
01c6 =                       MBR_BootPart1			=	(0x01be+0x08)
01fe =                       MBR_ExeMark				=	0x01fe
                             
                             ;* FAT16 definitions - these are offsets
                             ;* in to a FAT table entry which is
                             ;* 32 bytes in length.
0000 =                       	struct FATFileDesc
0000 =                       	ds FAT_Name,8
0008 =                       	ds FAT_Ext,3
000b =                       	ds FAT_Attr,1
000c =                       	ds FAT_Resv,1
000d =                       	ds FAT_Createms,1
000e =                       	ds FAT_CreateTime,2
0010 =                       	ds FAT_CreateDate,2
0012 =                       	ds FAT_AccessDate,2
0014 =                       	ds FAT_EAIndex,2
0016 =                       	ds FAT_ModTime,2
0018 =                       	ds FAT_ModDate,2
001a =                       	ds FAT_FirstClust,2
001c =                       	ds FAT_FileSize,4
                             	end struct
                             
                             ;* Flag to mark file as a directory
0010 =                       FAT_Attr_Dir			=	0x10
                             
                             ;* The FileHandle stucture is key to
                             ;* accessing the file system
0000 =                       	struct FileHandle
0000 =                       	ds FH_Name, 13				; 8 name, 3 extension, 1 separ
000d =                       	ds FH_Attr, 1				; What kind of file ** keep str
000e =                       	ds FH_Size, 4				; File size
0012 =                       	ds FH_CurrClust, 2			; Current cluster
0014 =                       	ds FH_SectCounter, 1		; Sector counter to know w
0015 =                       	ds FH_CurrSec, 4			; Current sector
0019 =                        	ds FH_Pointer, 4			; Pointer in to file for nex
001d =                       	ds FH_DirSect, 4			; Parent directory sector
0021 =                       	ds FH_DirOffset, 2			; Offset of this entry in t
0023 =                       	ds FH_FirstClust, 2			; First cluster of file da
0025 =                       	ds FH_LastClust, 2			; Last cluster accessed
0027 =                       	ds FH_TimeDate, 5			; Time-Date created (ms, tim
002c =                       	ds FH_FileMode, 1			; File mode (0=read, else wr
002d =                       	ds FH_FSpecPtr, 2			; Pointer to file spec being
                             	end struct
                             
0001 =                       FS_BLK_FLG_LOAD		 	= 	0x01		; On next byte, load 
0002 =                       FS_BLK_FLG_FLUSH		=	0x02		; Block has changed, ne
AS65 Assembler for R6502 [1.42].                                     Page    6
---------------------------------- bank2.s -----------------------------------

                             	
0001 =                       FS_ERR_EOF				=	0x01
                             
                             
                             ;* USEFUL MACROS HERE
                             
                             ;* Software break to throw errors
                             ;* use like this : SWBRK XX
                             ;* Where XX is the error code
                             SWBRK macro sig
                             	brk
                             	db sig
                             	endm
                             
                             _pushAXY macro
                             	pha
                             	phx
                             	phy
                             	endm
                             
                             _pullAXY macro
                             	ply
                             	plx
                             	pla
                             	endm
                             
                             _println macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	_pullAXY
                             	endm
                             
                             _println_low macro msg
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	endm
                             
                             _printmsgA macro msg
                             	phx
                             	phy
                             	pha
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	pla
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printA macro
                             	phx
AS65 Assembler for R6502 [1.42].                                     Page    7
---------------------------------- bank2.s -----------------------------------

                             	phy
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printCRLF macro
                             	pha
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printC macro ch
                             	pha
                             	lda #ch
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printCA macro
                             	pha
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _sendcmd macro cmd
                             	_pushAXY
                             	ldx #lo(cmd)
                             	lda #hi(cmd)
                             	jsr sd_sendcmd
                             	_pullAXY
                             	endm
                             
                             _incZPWord macro wordp
                             	inc wordp
                             	db	0xd0, 0x02
                             	inc wordp+1
                             	endm
                             
                             _decZPWord macro wordp
                             	pha
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	pla
                             	endm
                             
                             _decZPWordA macro wordp
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
AS65 Assembler for R6502 [1.42].                                     Page    8
---------------------------------- bank2.s -----------------------------------

                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	endm
                             
                             _cpyZPWord macro worda,wordb
                             	lda worda
                             	sta wordb
                             	lda worda+1
                             	sta wordb+1
                             	endm
                             	
                             _addZPWord macro worda, wordb
                             	clc
                             	lda worda
                             	adc wordb
                             	sta worda
                             	lda worda+1
                             	adc wordb+1
                             	sta worda+1
                             	endm
                             
                             _subZPWord macro worda, wordb
                             	sec
                             	lda worda
                             	sbc wordb
                             	sta worda
                             	lda worda+1
                             	sbc wordb+1
                             	sta worda+1
                             	endm
                             	
                             _adcZPWord macro worda,const
                             	clc
                             	lda worda
                             	adc #const
                             	sta worda
                             	lda worda+1
                             	adc #0
                             	sta worda+1
                             	endm
                             
                             _adcZPByte macro worda, byte
                             	clc
                             	lda worda
                             	adc byte
                             	sta worda
                             	db 0x90, 0x02		; bcc 2
                             	inc worda+1
                             	endm
                             
                             _sbcZPByte macro worda, byte
                             	sec
                             	lda worda
                             	sbc byte
                             	sta worda
                             	db 0xb0, 0x02		; bcs 2
                             	inc worda+1
                             	endm
                             
                             _bcc macro skip
                             	db 0x90, skip
AS65 Assembler for R6502 [1.42].                                     Page    9
---------------------------------- bank2.s -----------------------------------

                             	endm
                             
                             _bcs macro skip
                             	db 0xb0, skip
                             	endm
                             
                             _df_ost_peekType macro
                             	ldy df_parmtop
                             	lda df_rtstck-1,y
                             	endm
                             
                             	include "inc\graph.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  GRAPH.I
                             ;*  This is the definition file for graphics, spe
                             ;*  The graphics screen handling module.  It is j
                             ;*  structure definition - but this structure is 
                             ;*  record the important attributes of a text scr
                             ;*  Needed because there is both a 40 and 32 colu
                             ;*  supported by the VDP, and the screens are not
                             ;*  same location.
                             ;*
                             ;************************************************
                             
0000 =                       	struct gr_screen
0000 =                       	dw gr_screen_start			; Start of screen memory in
0002 =                       	dw gr_screen_size			; Number of bytes screen occ
0004 =                       	db gr_screen_w				; Number of columns
0005 =                       	db gr_screen_h				; Number of rows
0006 =                       	db gr_cur_off				; Y offset of cursor image from
0007 =                       	db gr_cur_x					; Current X position of cursor
0008 =                       	db gr_cur_y					; Current Y position of cursor
0009 =                       	dw gr_cur_ptr				; VDP address of cursor
000b =                       	db gr_pixmode				; Pixel plot mode (0=Erase, 1=P
000c =                       	db gr_pixmask				; Pixel plot mask
000d =                       	db gr_pixcol				; Pixel colour
000e =                       	dw gr_geom_tmp				; One word of temp storage for
                             	end struct
                             	include "io\io.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.I
                             ;*  Definitions file for the IO module.  The key 
                             ;*  used by the IO system is defined here.
                             ;*
                             ;************************************************
                             
                             ;* General IO structure allows the system to swap
                             ;* different IO devices by using indirect calls t
AS65 Assembler for R6502 [1.42].                                     Page   10
---------------------------------- bank2.s -----------------------------------

                             ;* the appropriate routines.
0000 =                       	struct io_struct
0000 =                       	ds	io_get_byte,	2			;* Address of get byte
0002 =                       	ds	io_put_byte,	2			;* Address of put byte
0004 =                       	ds	io_open_r,		2			;* Address of open file for r
0006 =                       	ds	io_open_w,		2			;* Address of open file for w
0008 =                       	ds	io_close_f,		2			;* Address of close file
000a =                       	ds	io_del_f,		2			;* Address of delete file
000c =                       	ds	io_ext1,		2			;* Address of extended function
000e =                       	ds	io_ext2,		2			;* Address of extended function
                             	end struct
                             	include "rtc\rtc.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTC.I
                             ;*  Definitions file for the RTC module.  The key
                             ;*  used by the real time clock is defined here.
                             ;*  It is a DS1288
                             ;*
                             ;************************************************
                             
0000 =                       RTC_SEC		= 0x00
0001 =                       RTC_SECA	= 0x01
0002 =                       RTC_MIN		= 0x02
0003 =                       RTC_MINA	= 0x03
0004 =                       RTC_HR		= 0x04
0005 =                       RTC_HRA		= 0x05
0006 =                       RTC_DOW		= 0x06
0007 =                       RTC_DAY		= 0x07
0008 =                       RTC_MTH		= 0x08
0009 =                       RTC_YR		= 0x09
000a =                       RTC_REGA	= 0x0a
000b =                       RTC_REGB	= 0x0b
000c =                       RTC_REGC	= 0x0c
000d =                       RTC_REGD	= 0x0d
                             
0080 =                       RTC_UIP		= 0x80
0040 =                       RTC_DV2		= 0x40
0020 =                       RTC_DV1		= 0x20
0010 =                       RTC_DV0		= 0x10
0080 =                       RTC_RS3		= 0x80
0040 =                       RTC_RS2		= 0x40
0020 =                       RTC_RS1		= 0x20
0010 =                       RTC_RS0		= 0x10
                             
0080 =                       RTC_SET		= 0x80
0040 =                       RTC_PIE		= 0x40
0020 =                       RTC_AIE		= 0x20
0010 =                       RTC_UIE		= 0x10
0080 =                       RTC_SQWE	= 0x80
0004 =                       RTC_DM		= 0x04
0002 =                       RTC_2412	= 0x02
0001 =                       RTC_DSE		= 0x01
                             
0080 =                       RTC_IRQF	= 0x80
0040 =                       RTC_PF		= 0x40
AS65 Assembler for R6502 [1.42].                                     Page   11
---------------------------------- bank2.s -----------------------------------

0020 =                       RTC_AF		= 0x20
0010 =                       RTC_UF		= 0x10
                             
0080 =                       RTC_VRT		= 0x80
                             
0600 =                       RTC_ADDR	= 0x600
0601 =                       RTC_DATA	= 0x601
                             
000e =                       NV_MODE     = 0x0e          ; Default boot up scr
000f =                       NV_COLOUR   = 0x0f          ; Default boot up col
                             
003f =                       NV_RAMSZ    = 63            ; Checksum byte in NV
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0c69 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
AS65 Assembler for R6502 [1.42].                                     Page   12
---------------------------------- bank2.s -----------------------------------

000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_PTR	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0003 =                       DFST_INT	=	DFVVT_INT|DFVVT_BYT
0004 =                       DFST_STR	=	DFVVT_STR
00ff =                       DFST_PTR	=	0xff
AS65 Assembler for R6502 [1.42].                                     Page   13
---------------------------------- bank2.s -----------------------------------

                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0c69 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
AS65 Assembler for R6502 [1.42].                                     Page   14
---------------------------------- bank2.s -----------------------------------

                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_PTR	=	0x80
                             
                             ;* Flags indicating the meaning of a token
AS65 Assembler for R6502 [1.42].                                     Page   15
---------------------------------- bank2.s -----------------------------------

                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0003 =                       DFST_INT	=	DFVVT_INT|DFVVT_BYT
0004 =                       DFST_STR	=	DFVVT_STR
00ff =                       DFST_PTR	=	0xff
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_ost_pushInt
                             	endm
                             
                             	include "dflat\error.i"
                             ;************************************************
                             ;*
                             ;*	BBC128
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.I
AS65 Assembler for R6502 [1.42].                                     Page   16
---------------------------------- bank2.s -----------------------------------

                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  It issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_SYNTAX	=	1
0002 =                       DFERR_TYPEMISM	=	2
0003 =                       DFERR_DIM		=	3
0004 =                       DFERR_UNTIL		=	4
0005 =                       DFERR_NOPROC	=	5
0006 =                       DFERR_PROCPARM	=	6
0007 =                       DFERR_IMMEDIATE	=	7
0008 =                       DFERR_UNCLOSEDIF=	8
0009 =                       DFERR_NOIF		=	9
000a =                       DFERR_NEXTFOR	=	10
000b =                       DFERR_FNAME		=	11
000c =                       DFERR_STRLONG	=	12
000d =                       DFERR_BREAK		=	13
000e =                       DFERR_NODATA	=	14
000f =                       DFERR_WEND		=	15
0010 =                       DFERR_NOLINE	=	16
0011 =                       DFERR_RETURN	=	17
0012 =                       DFERR_ABORT		=	18
0013 =                       DFERR_QUANTITY	=	19
0014 =                       DFERR_NOORG		=	20
                             
                             
                             
                             	include "bank\bank.i"
c000 =                       bankjsr_nul_addr	=	0xc000
0000 =                       bankjsr_nul_bank	=	0x00
003f =                       ROM_ZMASK			=	0x3f
00cf =                       RAM_ZMASK			=	0xcf
                             
                             _bankjsr	macro	addr,bank
                             	; Save A
                             	sta tmp_bank1
                             	
                             	; Save current bank
                             	lda bank_num
                             	pha
                             	
                             	; Switch to new bank
                             	lda IO_0+PRB
                             	and #ROM_ZMASK
                             	ora #(bank^3) << 6			; Shift left 6 bits
                             	sta IO_0+PRB
                             
                             	; Restore A
                             	lda tmp_bank1
                             	; JSR to the routine
                             	jsr addr
                             	
AS65 Assembler for R6502 [1.42].                                     Page   17
---------------------------------- bank2.s -----------------------------------

                             	jmp _restore_bank
                             	; 62 clock cycles inc restore vs 6 for a near js
                             
                             	endm
                             	
                             _bankram macro bank
                             	pha
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
                             	sta IO_0+PRB
                             	pla
                             	endm
                             	
                             _bankram_fast macro bank
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
                             	sta IO_0+PRB
                             	endm
                             	
                             
                             	include "kernel\zeropage.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ZEROPAGE.I
                             ;*  This module name is misleading it is not only
                             ;*  allocations, but also page 2, 3, 4, 5, 6, 7 a
                             ;*  Basically, this module defines:
                             ;*  - All zero page variables for system and dfla
                             ;*  - Page 1 is stack so no need to worry about t
                             ;*  - Page 2 is the serial IO buffer for the 6551
                             ;*  - Page 3 and 4 is a 512 buffer for SD card se
                             ;*  - Page 5 onwards is mainly for dflat working 
                             ;*    but also non-zero page storage for general 
                             ;*    system and scratch usage.
                             ;*  memstart is a handy label that indicates the 
                             ;*  location that we can store dflat programs fro
                             ;*  Zero page is a valuable asset as the 6502 can
                             ;*  this page one cycle quicker than the rest of 
                             ;*  and infact some addressing modes can only use
                             ;*  Due to the value of zero page, a lot of syste
                             ;*  dflat variables are put here.  But we don't h
                             ;*  luxury for single use variables - so you will
                             ;*  see a lot of temporary sounding names which a
                             ;*  have multiple used across the code base.
                             ;*
                             ;************************************************
                             
                             	; Zero page declarations
                             	bss
0000 =                       	org 0x0000
                             
0000 =                       tmp_bank1	ds	1		; Temp storage ONLY FOR USE BY BA
0001 =                       tmp_bank2	ds	1		; Temp storage ONLY FOR USE BY BA
                             
AS65 Assembler for R6502 [1.42].                                     Page   18
---------------------------------- bank2.s -----------------------------------

                             ; Interrupt routine addresses
0002 =                       int_nmi		 ds 2		; Master NMI handler
0004 =                       int_irq		 ds	2		; Master IRQ handler
0006 =                       int_brk		 ds	2		; Master BRK handler
0008 =                       int_uservdp	 ds	2		; Where to jump for VDP interr
000a =                       int_usercia0 ds	2		; Where to jump for CIA0 inter
000c =                       int_usercia1 ds	2		; Where to jump for CIA1 inter
                             
                             ; Serial FIFO buffer pointers
000e =                       ser_first	ds	1		; Pointer to first byte in buffer
000f =                       ser_last	ds	1		; Pointer to last byte in buffer
                             ; VDP parameters
0010 =                       vdp_int_cnt	ds  2		; VDP interrupt counter
0012 =                       vdp_curoff	ds	1		; Cursor off (0 = On)
0013 =                       vdp_curstat	ds	1		; Cursor status
0014 =                       vdp_curval	ds	1		; Cursor value on screen
0015 =                       vdp_blank	ds	1		; Screen blank value normally 32
0016 =                       vdp_delay	ds	1		; Delay counter for VRAM access
                             
                             ; vdp settings
0017 =                       vdp_base	ds	vdp_addr_struct
                             
                             ; Screen geometry
0023 =                       gr_scrngeom	ds	gr_screen
                             
                             ;Keyboard parameters
0033 =                       kb_raw  	ds	1		; Raw keyboard code
0034 =                       kb_last		ds	1		; Raw code of last key
0035 =                       kb_code 	ds	1		; Converted keyboard code
0036 =                       kb_stat		ds	1		; Keyboard status for caps and shi
0037 =                       kb_deb		ds	1		; VB periods since last KB spike
0038 =                       kb_rep		ds	1		; Keyboard repeat timer
0039 =                       kb_rep_tim 	ds	1		; Default repeat speed
003a =                       kb_rep_del 	ds	1		; Default repeat delay timing
003b =                       kb_debounce ds	1		; Default repeat debounce
003c =                       kb_pressed	ds	1		; Set by the interrupt handler i
                             
003d =                       tmp_c		ds	2		; Temp address c
003f =                       tmp_v1		ds	2		; VDP temp addresses
0041 =                       tmp_a		ds	2		; Temp storage a
0043 =                       tmp_b 		ds	2		; Temp address b
0045 =                       tmp_d		ds	2		; Temp storage d
                             
                             ; Raw input/output parameters
0047 =                       buf_adr		ds	2		; Line buffer address
0049 =                       buf_sz		ds	1		; Buffer size
004a =                       buf_ef		ds	1		; End file / line marker
                             
                             ; SD card driver parameters
004b =                       sd_status	ds	1		; SD card status
004c =                       sd_slo		ds	1		; Sector pointer low
004d =                       sd_shi		ds	1		; Sector pointer high
004e =                       sd_sect		ds	4		; SD Card sector address
0052 =                       sd_addr		ds	4		; SD Card byte address
                             
                             ; File system zp parameters
0056 =                       fh_handle	ds	FileHandle ; File handle parameters
                             
                             ; ** Integer function storage **
0085 =                       ztmp_16					; Start of 16 byte scratch area (all 
0085 =                       num_a		ds	4		; 4 byte primary accumulator
0089 =                       num_b		ds	4		; 4 byte secondary accumulator
AS65 Assembler for R6502 [1.42].                                     Page   19
---------------------------------- bank2.s -----------------------------------

008d =                       num_x		ds	4		; 4 byte x register
0091 =                       num_tmp		ds	4		; 4 byte temp space
0095 =                       num_buf		ds	8		; 8 byte string buffer
                             
                             ;
                             ; **** INTERPRETER ZERO PAGE ****
                             ;
009d =                       dflat_zp_s
009d =                       dflat_zp_save_s			; ZP save dflat from here
009d =                       df_checkkey	ds	1		; Key check interval counter
009e =                       df_checkmsk	ds	1		; Mask for check key
009f =                       errno		ds	1		; General error condition status
00a0 =                       df_immed	ds	1		; Immediate mode (0 = not immediat
00a1 =                       df_sp		ds	1		; Stack pointer after error to resto
00a2 =                       df_pc		ds	2		; PC after error to return to
00a4 =                       df_brkpc	ds	2		; PC pushed on the stack for BRK
00a6 =                       df_brkval	ds	1		; Byte after BRK instruction
00a7 =                       df_prgstrt	ds	2		; Start of program code
00a9 =                       df_prgend	ds	2		; End of program code
00ab =                       df_vntstrt	ds	2		; Variable name table start
00ad =                       df_vntend	ds	2		; Variable name table end
00af =                       df_vvtstrt	ds	2		; Variable value table start
00b1 =                       df_vvtend	ds	2		; Variable value table end
00b3 =                       df_varcnt	ds	1		; Variable counter
00b4 =                       df_starstrt	ds	2		; String and array table start
00b6 =                       df_starend	ds	2		; String and array table end
00b8 =                       df_rtstop	ds	1		; Runtime stack pointer
00b9 =                       df_parmtop	ds	1		; Top of parameter stack (grows 
00ba =                       df_strbuff	ds	1		; String expression buffer
00bb =                       df_stridx	ds	1		; Top of string buffer (grows dow
00bc =                       df_sevalptr	ds	2		; Pointer to next free char in 
                             
00be =                       df_linoff	ds	1		; Offset in to line buffer
00bf =                       df_tokoff	ds	1		; Offset in to tokenised buffer
00c0 =                       df_eolidx	ds	1		; End of line index (i.e length)
00c1 =                       df_nxtstidx	ds	1		; Offset to the next statement 
00c2 =                       df_curstidx	ds	1		; Offset to the start of curren
00c3 =                       df_symtab	ds	2		; Pointer to next free symtab ent
00c5 =                       df_symoff	ds	1		; Offset in to token table
00c6 =                       df_symini	ds	2		; Start of symtab
00c8 =                       df_currlin	ds	2		; Execution current line pointer
00ca =                       df_exeoff	ds	1		; Execution line buffer offset
00cb =                       df_nextlin	ds	2		; Next line to execute
00cd =                       df_procmode	ds	1		; Only used during tokenisation
00ce =                       df_procargs	ds	1		; Only used during tokenisation
00cf =                       df_procloc	ds	1		; Counts the number of local par
00d0 =                       df_procptr	ds	2		; Pointer to proc vvt slot
00d2 =                       df_lineptr	ds	2		; Pointer to line during searche
00d4 =                       df_lineidx	ds	1		; Pointer to line index during s
00d5 =                       df_ifnest	ds	1		; Global nested if counter
00d6 =                       df_currdat	ds	2		; Data current line pointer
00d8 =                       df_datoff	ds	1		; Data line buffer offset
00d9 =                       df_rnd		ds	2		; Random number seed
                             
00db =                       df_asmpc	ds	2		; Assembler program counter
00dd =                       df_asmopt	ds	1		; Assembler current option
00de =                       df_asmadmd	ds	1		; Addressing mode
00df =                       df_asmopcde	ds	1		; Current opcode
00e0 =                       df_asmoprnd	ds	2		; Current operand
00e2 =                       df_asmlen	ds	1		; Instruction length
                             
00e3 =                       dflat_zp_save_e			; Save up to this place
AS65 Assembler for R6502 [1.42].                                     Page   20
---------------------------------- bank2.s -----------------------------------

                             
                             ; Temp space for dflat
00e3 =                       df_tmpptra	ds	2		; Temp pointer a
00e5 =                       df_tmpptrb	ds	2		; Temp pointer b
00e7 =                       df_tmpptrc	ds	2		; Temp pointer c
00e9 =                       df_tmpptrd	ds	2		; Temp pointer d
00eb =                       df_tmpptre	ds	2		; Temp pointer e
                             
                             
                             ;***** END OF ZERO PAGE *****
00ed =                       _end_zero_page
                             
                             ;***** Page 1 is CPU stack ****
0100 =                       	org 0x0100
0100 =                       _cpu_stack
0100 =                       			ds	256		; All of page 1
                             
                             ;***** Page 2 and 3 is SD card buffer
0200 =                       	org 0x0200			; SD Card data buffer 512 bytes
0200 =                       sd_buf		ds	512
                             
                             ;***** Page 4,5,6,7 is IO space
0400 =                       	org 0x0400
0400 =                       			ds	1024	; 1 k area divided in to 8x128 byte de
                             
                             
                             ;***** Page 8 is serial buffer *****
0800 =                       	org 0x0800
0800 =                       ser_buf		ds	256		; Serial input / output line buf
                             
                             ;***** Scratch area, used by many things - do not
                             ; string and numeric expression evaluation, scree
0900 =                       	org 0x0900
0900 =                       scratch		ds	256
                             
                             ;***** Dflat space *****
0a00 =                       	org 0x0a00			; Page 9 = dflat space
0a00 =                       df_linbuff
0a00 =                       df_raw		ds	128		; untokenised input line
0a80 =                       df_tokbuff
0a80 =                       df_tok		ds 	128		; tokenised output line
                             
0b00 =                       	org 0x0b00			; Page 10 = fixed space for runtime
0b00 =                       df_rtstck				; operator stack grows up, runtime g
0b00 =                       df_rtspace	ds	256
                             
                             ;***** NON-ZERO PAGE VARIABLES *****
                             
                             ; Active IO device settings
0c00 =                       io_default	ds	1		; The default device number - es
                             ; Copy of jump tables to active device io routine
0c01 =                       io_block	ds	io_struct
                             
                             ; Copy of FAT16 directory
0c11 =                       fs_direntry	ds	FATFileDesc ; copy of dir entry - 
                             
                             ; Filesystem parameters
0c31 =                       fs_bootsect	ds	4		; Start of partition (usually 0
0c35 =                       fs_fatsect	ds	4		; Start of FAT tables
0c39 =                       fs_rootsect	ds	4		; Start of Root Directory
0c3d =                       fs_datasect	ds	4		; Start of Data Area
0c41 =                       fs_dirsect	ds	4		; Current directory sector numbe
AS65 Assembler for R6502 [1.42].                                     Page   21
---------------------------------- bank2.s -----------------------------------

0c45 =                       fs_dirclust	ds	2		; Current directory cluster num
                             
                             ; Working and scratch for filesystem - some data 
0c47 =                       fs_scratch	ds	32		; 32 bytes should be more than 
                             
                             ; Dflat top of memory+1 - normally initialised to
0c67 =                       df_memtop	ds	2
                             
                             ;***** THIS IS THE START OF FREE SPACE for DFLAT 
0c69 =                       mem_start
                             
                             
                             
                             
                             ;****************************************
                             ;*	Set 6502 default vectors	*
                             ;****************************************
                             	data				; Set vectors
fffa =                       	org 0xfffa			; Vectors lie at addresses
fffa : 63c7                  	fcw call_nmi_master	; 0xfffa : NMI Vector
fffc : 6bcb                  	fcw init			; 0xfffc : Reset Vector
fffe : c3c7                  	fcw call_irq_master	; 0xfffe : IRQ Vector
                             	
                             	; ROM code
                             	code				;  
c000 =                       	org 0xc000			; Start of ROM
                             
                             	; The bank number is hardwired and aligned to PB
c000 :                       bank_num
                             	if BANK0
                             	  db 192
                             	endif
                             	if BANK1
                             	  db 128
                             	endif
                             	if BANK2
c000 : 40                    	  db 64
                             	endif
                             	if BANK3
                             	  db 0
                             	endif
                             
c001 :                       _code_start
                             	; Restore current bank always at address c001
c001 :                       _OSVectors
                             	include "kernel\osvec.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  OSVEC.S
                             ;*  Simply this is a bunch of JMP XXXX the order 
                             ;*  will always be maintained.  This is to allow 
                             ;*  code programs to be able to rely on fixed loc
                             ;*  some key low-level functions.
                             ;*  Only low level functions are needed, the idea
                             ;*  as the assembler is part of the BASIC, one ca
                             ;*  level slow stuff using BASIC then switch to M
AS65 Assembler for R6502 [1.42].                                     Page   22
---------------------------------- bank2.s -----------------------------------

                             ;*  speed up.
                             ;*  This code goes straight after the bank number
                             ;*  Each JMP is at 0xc001+3*(vector #)
                             ;*
                             ;************************************************
                             
c001 : 4cc0c5           [ 3] 	jmp	io_put_ch			; Vec 0
c004 : 4cbdc5           [ 3] 	jmp io_get_ch			; Vec 1
c007 : 4c50c6           [ 3] 	jmp vdp_wr_reg			; Vec 2
c00a : 4c8ac6           [ 3] 	jmp vdp_poke			; Vec 3
c00d : 4c97c6           [ 3] 	jmp vdp_peek			; Vec 4
c010 : 4cf9c6           [ 3] 	jmp snd_get_joy0		; Vec 5
c013 : 4ca1c6           [ 3] 	jmp snd_set				; Vec 6
c016 : 4c5dc6           [ 3] 	jmp vdp_wr_addr			; Vec 7
c019 : 4c75c6           [ 3] 	jmp	vdp_rd_addr			; Vec 8
c01c :                       _restore_bank
                             	; Save A
c01c : 8500             [ 3] 	sta tmp_bank1
                             	; Get old bank from stack
c01e : 68               [ 4] 	pla
c01f : 8501             [ 3] 	sta tmp_bank2
c021 : ad0004           [ 4] 	lda IO_0+PRB
c024 : 293f             [ 2] 	and #ROM_ZMASK
c026 : 0501             [ 3] 	ora tmp_bank2
c028 : 8d0004           [ 4] 	sta IO_0+PRB
                             	
                             	; Restore A
c02b : a500             [ 3] 	lda tmp_bank1
                             
c02d : 60               [ 6] 	rts
                             
                             	; include cross-bank functions (see extern.mak)
                             	include "bank\autogen.s"	
                             ;
c02e :                       mod_sz_autogen_s
c02e :                       _df_init
                              _bankjsr $f267, 1
                             
c046 :                       _df_pg_dflat
                              _bankjsr $d80b, 1
                             
c05e :                       _fs_chdir_w
                              _bankjsr $d59b, 2
                             
c076 :                       _fs_mkdir_w
                              _bankjsr $d62e, 2
                             
c08e :                       _fs_delete_w
                              _bankjsr $d537, 2
                             
c0a6 :                       _fs_close_w
                              _bankjsr $d4f6, 2
                             
c0be :                       _fs_get_byte_w
                              _bankjsr $d213, 2
                             
c0d6 :                       _fs_open_read_w
                              _bankjsr $d3e2, 2
                             
c0ee :                       _fs_open_write_w
                              _bankjsr $d4a6, 2
                             
AS65 Assembler for R6502 [1.42].                                     Page   23
---------------------------------- bank2.s -----------------------------------

c106 :                       _fs_put_byte_w
                              _bankjsr $d36f, 2
                             
c11e :                       _fs_dir_find_entry_w
                              _bankjsr $d056, 2
                             
c136 :                       _fs_dir_entry_next_w
                              _bankjsr $d08c, 2
                             
c14e :                       _fs_dir_root_start_w
                              _bankjsr $d011, 2
                             
c166 :                       _get_byte
                              _bankjsr $d25b, 0
                             
c17e :                       _put_byte
                              _bankjsr $d270, 0
                             
c196 :                       _gr_get_key
                              _bankjsr $e390, 0
                             
c1ae :                       _gr_put_byte
                              _bankjsr $e39d, 0
                             
c1c6 :                       _gr_init_screen
                              _bankjsr $de59, 0
                             
c1de :                       _init_acia
                              _bankjsr $d27d, 0
                             
c1f6 :                       _init_cia0
                              _bankjsr $d208, 0
                             
c20e :                       _init_cia1
                              _bankjsr $d239, 0
                             
c226 :                       _init_fs
                              _bankjsr $ceee, 2
                             
c23e :                       _init_sdcard
                              _bankjsr $cbe8, 2
                             
c256 :                       _init_snd
                              _bankjsr $d646, 0
                             
c26e :                       _init_keyboard
                              _bankjsr $d28f, 0
                             
c286 :                       _kb_read_raw
                              _bankjsr $d29e, 0
                             
c29e :                       _kb_read_dip
                              _bankjsr $d309, 0
                             
c2b6 :                       _command_line
                              _bankjsr $cbf1, 0
                             
c2ce :                       _gr_cls
                              _bankjsr $de6c, 0
                             
c2e6 :                       _gr_init_hires
                              _bankjsr $de16, 0
AS65 Assembler for R6502 [1.42].                                     Page   24
---------------------------------- bank2.s -----------------------------------

                             
c2fe :                       _gr_line
                              _bankjsr $e1ca, 0
                             
c316 :                       _gr_box
                              _bankjsr $e00a, 0
                             
c32e :                       _gr_circle
                              _bankjsr $e115, 0
                             
c346 :                       _gr_plot
                              _bankjsr $ded7, 0
                             
c35e :                       _gr_hchar
                              _bankjsr $df15, 0
                             
c376 :                       _gr_point
                              _bankjsr $dfbb, 0
                             
c38e :                       _gr_get
                              _bankjsr $def2, 0
                             
c3a6 :                       _gr_set_cur
                              _bankjsr $defa, 0
                             
c3be :                       _snd_get_note
                              _bankjsr $d63f, 0
                             
c3d6 :                       _snd_get_joy0
                              _bankjsr $c6f9, 0
                             
c3ee :                       _snd_set
                              _bankjsr $c6a1, 0
                             
c406 :                       _vdp_peek
                              _bankjsr $c697, 0
                             
c41e :                       _vdp_poke
                              _bankjsr $c68a, 0
                             
c436 :                       _vdp_init
                              _bankjsr $dc00, 0
                             
c44e :                       _rtc_init
                              _bankjsr $d465, 0
                             
c466 :                       _rtc_gettimedate
                              _bankjsr $d5cb, 0
                             
c47e :                       _rtc_setdatetime
                              _bankjsr $d51c, 0
                             
c496 :                       _rtc_nvread
                              _bankjsr $d636, 0
                             
c4ae :                       _rtc_nvwrite
                              _bankjsr $d61e, 0
                             
c4c6 :                       _fs_dir_fhandle_str
                              _bankjsr $d642, 2
                             
c4de :                       _sd_sendcmd17
AS65 Assembler for R6502 [1.42].                                     Page   25
---------------------------------- bank2.s -----------------------------------

                              _bankjsr $cdc0, 2
                             
c4f6 :                       _sd_sendcmd24
                              _bankjsr $ce39, 2
                             
c50e :                       _cmd_immediate
                              _bankjsr $cbe8, 0
                             
c526 :                       _PT3INIT
                              _bankjsr $e009, 3
                             
c53e :                       _PT3START
                              _bankjsr $e000, 3
                             
c556 :                       _PT3PAUSE
                              _bankjsr $e003, 3
                             
c56e :                       _PT3RESUME
                              _bankjsr $e006, 3
                             
c586 :                       mod_sz_autogen_e
                             
                             	
c586 :                       mod_sz_kernel_s
                             
                             ;* Include all common code in the right order
                             	include "io\io.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.S
                             ;*  General IO module.  Allows different IO devic
                             ;*  utilised transparently by the rest of the cod
                             ;*  Other code should use "io_" commands so that 
                             ;*  do not need to know what specific device is p
                             ;*  input and output capabilities.  On startup, t
                             ;*  examines the BBC DIP switch to decide whether
                             ;*  initialise the IO to serial through the ACIA 
                             ;*  the BBC keyboard for input with the VDP for o
                             ;*  Loading and saving files from the SD card is 
                             ;*  achieved by pointing to SD card get and put b
                             ;*  routines.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c586 :                       mod_sz_io_s
                             
                             ;****************************************
                             ;* io_init
                             ;* Initialise the default device and make active
                             ;* No keys pressed = serial (default)
                             ;* F0 pressed = KB/VDP
                             ;* F1 pressed = Serial
                             ;* Keyboard and screen or serial port
AS65 Assembler for R6502 [1.42].                                     Page   26
---------------------------------- bank2.s -----------------------------------

                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c586 :                       io_init
c586 : a900             [ 2] 	lda #0				; Assume it's serial
c588 : 48               [ 3] 	pha
c589 : 209ec2           [ 6] 	jsr _kb_read_dip	; Check DIPs if 0xff then assum
c58c : 2910             [ 2] 	and #0x10
c58e : d00b             [ 3] 	bne io_init_set_default
c590 : 2086c2           [ 6] 	jsr _kb_read_raw	; Check pressed key
c593 : e081             [ 2] 	cpx #0x81			; f1 key pressed (i.e. boot up in se
c595 : f004             [ 3] 	beq io_init_set_default
                             	; Else set to KB/screen for IO
c597 : 68               [ 4] 	pla
c598 : a901             [ 2] 	lda #1
c59a : 48               [ 3] 	pha
c59b :                       io_init_set_default
c59b : 68               [ 4] 	pla
c59c : 8d000c           [ 4] 	sta io_default
c59f : 4ca2c5           [ 3] 	jmp io_set_default	; Activate the default device
                             
                             ;****************************************
                             ;* io_set_default, io_active_device
                             ;* Activate device based on default or A
                             ;* Input : A = Device number
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c5a2 :                       io_set_default			; Entry point for default
c5a2 : ad000c           [ 4] 	lda io_default
c5a5 :                       io_active_device		; Entry point for A set
c5a5 : 0a               [ 2] 	asl	a				; x16 the Block number
c5a6 : 0a               [ 2] 	asl a
c5a7 : 0a               [ 2] 	asl a
c5a8 : 0a               [ 2] 	asl a
c5a9 : a8               [ 2] 	tay
c5aa : a200             [ 2] 	ldx #0
                             	; Copy device settings to io block
c5ac :                       io_copy_data
c5ac : b920c6           [ 4] 	lda io_devices,y
c5af : 9d010c           [ 5] 	sta io_block,x
c5b2 : c8               [ 2] 	iny
c5b3 : e8               [ 2] 	inx
c5b4 : e010             [ 2] 	cpx #io_struct
c5b6 : d0f4             [ 3] 	bne io_copy_data
                             	
c5b8 : a90d             [ 2] 	lda #UTF_CR		; Line terminator is CR
c5ba : 854a             [ 3] 	sta buf_ef
c5bc : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* io_get_ch
                             ;* Get a char (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 0 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
c5bd :                       io_get_ch
c5bd : 6c010c           [ 6] 	jmp (io_block+io_get_byte)
                             	
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   27
---------------------------------- bank2.s -----------------------------------

                             ;* io_put_ch
                             ;* Put a char
                             ;* Input : A = char
                             ;* Regs affected : P, A
                             ;****************************************
c5c0 :                       io_put_ch
c5c0 : 6c030c           [ 6] 	jmp (io_block+io_put_byte)
                             	
                             ;****************************************
                             ;* io_open_read
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c5c3 :                       io_open_read
c5c3 : 6c050c           [ 6] 	jmp (io_block+io_open_r)
                             	
                             ;****************************************
                             ;* io_open_write
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c5c6 :                       io_open_write
c5c6 : 6c070c           [ 6] 	jmp (io_block+io_open_w)
                             
                             ;****************************************
                             ;* io_close
                             ;* Close a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c5c9 :                       io_close
c5c9 : 6c090c           [ 6] 	jmp (io_block+io_close_f)
                             	
                             ;****************************************
                             ;* io_delete
                             ;* Delete a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c5cc :                       io_delete
c5cc : 6c0b0c           [ 6] 	jmp (io_block+io_del_f)
                             	
                             ;****************************************
                             ;* io_read_line
                             ;* Read a line, terminated by terminating char or
                             ;* Input : buf_(sz/ef) : Address, Max size, end m
                             ;*		    X,A = destination (uses buf_adr)
                             ;*		    Y=max line length
                             ;* Output : Y = Line length C = Buffer limit reac
                             ;* Regs affected : None
                             ;****************************************
c5cf :                       io_read_line
c5cf : 8647             [ 3] 	stx buf_adr			; Save pointer to storage
c5d1 : 8548             [ 3] 	sta buf_adr+1
c5d3 : 8449             [ 3] 	sty buf_sz			; Max length
c5d5 : 08               [ 3] 	php					; Save echo state
AS65 Assembler for R6502 [1.42].                                     Page   28
---------------------------------- bank2.s -----------------------------------

c5d6 : a000             [ 2] 	ldy #0x00			; Starting at first byte
c5d8 :                       io_get_line_byte
c5d8 : 38               [ 2] 	sec					; Getting bytes synchronously
c5d9 : 20bdc5           [ 6] 	jsr io_get_ch		; Get a byte
c5dc : b026             [ 4] 	bcs io_get_line_done; Got nothing then finish
c5de : 28               [ 4] 	plp					; Get echo state
c5df : 08               [ 3] 	php					; Instantly save it back
c5e0 : 900c             [ 3] 	bcc io_skip_echo	; Carry not set = don't echo
c5e2 : c97f             [ 2] 	cmp #UTF_DEL		; Delete?
c5e4 : d005             [ 3] 	bne io_do_echo
c5e6 : c000             [ 2] 	cpy #0				; Already at beginning?
c5e8 : f004             [ 3] 	beq io_skip_echo	; Don't echo delete
c5ea : 88               [ 2] 	dey					; Else decrement length
c5eb :                       io_do_echo
c5eb : 20c0c5           [ 6] 	jsr io_put_ch		; Echo it
c5ee :                       io_skip_echo
c5ee : c920             [ 2] 	cmp #UTF_SPECIAL	; Special character?
c5f0 : 9007             [ 3] 	bcc io_skip_special	; Skip if so (don't add to b
c5f2 : c97f             [ 2] 	cmp #UTF_DEL		; Don't proces DEL either
c5f4 : f003             [ 3] 	beq io_skip_special
c5f6 : 9147             [ 5] 	sta (buf_adr),y		; Save it
c5f8 : c8               [ 2] 	iny					; Increase length
c5f9 :                       io_skip_special
c5f9 : c54a             [ 3] 	cmp buf_ef			; Is it the terminating char?
c5fb : f007             [ 4] 	beq io_get_line_done	; If yes then done
c5fd : c449             [ 3] 	cpy buf_sz			; Reached the buffer max size?
c5ff : d0d7             [ 3] 	bne io_get_line_byte	; No, get another byte
c601 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c602 : 38               [ 2] 	sec					; Yes, set carry flag
c603 : 60               [ 6] 	rts					; And done
c604 :                       io_get_line_done
c604 : a900             [ 2] 	lda #0
c606 : 9147             [ 5] 	sta (buf_adr),y		; Terminate with 0
c608 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c609 : 18               [ 2] 	clc					; Clear carry flag
c60a : 60               [ 6] 	rts					; Fin
                             
                             ;****************************************
                             ;* io_print_line
                             ;* Print a line (when data is not already in seri
                             ;* Input : X = Address Lo, A = Address Hi
                             ;* Output : Y=number chars output
                             ;* Regs affected : All
                             ;****************************************
c60b :                       io_print_line
c60b : 48               [ 3] 	pha
                             
c60c : 863d             [ 3] 	stx tmp_c					; Store the string pointer
c60e : 853e             [ 3] 	sta tmp_c+1					; lo and hi
c610 : a000             [ 2] 	ldy #0						; Start at the beginning!
c612 :                       io_print_line_byte
c612 : b13d             [ 5] 	lda (tmp_c),y				; Copy byte to
c614 : f006             [ 3] 	beq io_print_done			; If zero then done - print
c616 : 20c0c5           [ 6] 	jsr io_put_ch				; Transmit
c619 : c8               [ 2] 	iny
c61a : d0f6             [ 3] 	bne io_print_line_byte		; Carry on until zero fo
c61c :                       io_print_done
c61c : 68               [ 4] 	pla
c61d : 60               [ 6] 	rts
                             
                             
                             ;*** Null operation just clc and return ***
AS65 Assembler for R6502 [1.42].                                     Page   29
---------------------------------- bank2.s -----------------------------------

c61e :                       io_null_op
c61e : 18               [ 2] 	clc
c61f : 60               [ 6] 	rts
                             	
                             ;* IO devices defined here
c620 :                       io_devices
                             ;* Device zero is the serial port
                             ;* only offers get and put
c620 :                       io_device0					; Serial device, input = Ser, outp
c620 : 66c1                  	dw	_get_byte			; io_get_ch
c622 : 7ec1                  	dw	_put_byte			; io_put_ch
c624 : 1ec6                  	dw	io_null_op			; io_open_r
c626 : 1ec6                  	dw	io_null_op			; io_open_w
c628 : 1ec6                  	dw	io_null_op			; io_close_f
c62a : 1ec6                  	dw	io_null_op			; io_del_f
c62c : 1ec6                  	dw	io_null_op			; io_ext1
c62e : 1ec6                  	dw	io_null_op			; io_ext2
                             ;* Device one is keyboard / screen
                             ;* only offers get and put
c630 :                       io_device1					; Default device, input = screen e
c630 : 96c1                  	dw	_gr_get_key			; io_get_ch
c632 : aec1                  	dw	_gr_put_byte		; io_put_ch
c634 : 1ec6                  	dw	io_null_op			; io_open_r
c636 : 1ec6                  	dw	io_null_op			; io_open_w
c638 : 1ec6                  	dw	io_null_op			; io_close_f
c63a : 1ec6                  	dw	io_null_op			; io_del_f
c63c : 1ec6                  	dw	io_null_op			; io_ext1
c63e : 1ec6                  	dw	io_null_op			; io_ext2
                             ;* Device two is the file system on SD card
                             ;* Offers all IO functions
c640 :                       io_device2					; SD device, input = SD, output = 
c640 : bec0                  	dw	_fs_get_byte_w		; io_get_ch
c642 : 06c1                  	dw	_fs_put_byte_w		; io_put_ch
c644 : d6c0                  	dw	_fs_open_read_w		; io_open_r
c646 : eec0                  	dw	_fs_open_write_w	; io_open_w
c648 : a6c0                  	dw	_fs_close_w			; io_close_f
c64a : 8ec0                  	dw	_fs_delete_w		; io_del_f
c64c : 1ec6                  	dw	io_null_op			; io_ext1
c64e : 1ec6                  	dw	io_null_op			; io_ext2
                             
c650 :                       mod_sz_io_e
                             
                             
                             	include "kernel\vdp-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  VDP-LOW.S
                             ;*  Low level VDP routines which will always be p
                             ;*  every ROM bank.  This is to ensure if IRQ nee
                             ;*  no slow bank switching is needed, but also to
                             ;*	OS vectored access to VDP routines for M/C fro
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* vdp_wr_reg
AS65 Assembler for R6502 [1.42].                                     Page   30
---------------------------------- bank2.s -----------------------------------

                             ;* Write to Register A the value X
                             ;* Input : A - Register Number, X - Data
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c650 :                       vdp_wr_reg
c650 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c653 : ea               [ 2] 	nop
c654 : ea               [ 2] 	nop
c655 : 0980             [ 2] 	ora #0x80
c657 : 8d0105           [ 4] 	sta VDP_MODE1
c65a : 4980             [ 2] 	eor #0x80
c65c : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* vdp_wr_addr
                             ;* Write to address in X (low) and A (high) - for
                             ;* Input : A - Address high byte, X - Address low
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c65d :                       vdp_wr_addr
c65d : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c660 : ea               [ 2] 	nop
c661 : ea               [ 2] 	nop
c662 : ea               [ 2] 	nop
c663 : 0940             [ 2] 	ora #0x40		; Required by VDP
c665 : 8d0105           [ 4] 	sta VDP_MODE1
c668 : 4940             [ 2] 	eor #0x40		; Undo that bit
c66a : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* vdp_mem_wait
                             ;* Delay some time before a memory access,
                             ;* taking in to account mode 9918 needs up
                             ;* to 3.1uS for text mode, 8uS for graphics
                             ;* I and II
                             ;* @ 5.35Mhz	= 16 cycles for 3.1uS
                             ;*				= 43 cycles for 8uS
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c66b :                       vdp_mem_wait
c66b : da               [ 3] 	phx								; 3
c66c : a616             [ 3] 	ldx vdp_delay					; 3
c66e : f003             [ 3] 	beq vdp_mem_wait_end			; 3
c670 :                       vdp_mem_wait_loop
c670 : ca               [ 2] 	dex								; 2
c671 : d0fd             [ 3] 	bne	vdp_mem_wait_loop			; 3
c673 :                       vdp_mem_wait_end
c673 : fa               [ 4] 	plx								; 3
c674 : 60               [ 6] 	rts								; 6
                             	
                             ;****************************************
                             ;* vdp_rd_addr
                             ;* Set read address 
                             ;* Input : A - high, X - low 
                             ;* Output : None
AS65 Assembler for R6502 [1.42].                                     Page   31
---------------------------------- bank2.s -----------------------------------

                             ;* Regs affected : None
                             ;****************************************
c675 :                       vdp_rd_addr
c675 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; These nops are needed for fast CPU
c678 : ea               [ 2] 	nop
c679 : ea               [ 2] 	nop
c67a : ea               [ 2] 	nop
c67b : 8d0105           [ 4] 	sta VDP_MODE1
c67e : 80eb             [ 3] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_rd_vram
                             ;* Read VRAM byte, result in A
                             ;* Input : None
                             ;* Output : A - Byte from VRAM
                             ;* Regs affected : P
                             ;****************************************
c680 :                       vdp_rd_vram
c680 : ad0005           [ 4] 	lda VDP_VRAM
c683 : 80e6             [ 3] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_wr_vram
                             ;* Write VRAM byte in A
                             ;* Input : A - Byte to write
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c685 :                       vdp_wr_vram
c685 : 8d0005           [ 4] 	sta VDP_VRAM
c688 : 80e1             [ 3] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_poke
                             ;* Write VRAM byte in A, (YX)
                             ;* Input : A - Byte to write
                             ;*		   X = Low Address
                             ;*		   Y = High Address
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c68a :                       vdp_poke
c68a : 08               [ 3] 	php
c68b : 48               [ 3] 	pha
c68c : 98               [ 2] 	tya
c68d : 78               [ 2] 	sei
c68e : 205dc6           [ 6] 	jsr vdp_wr_addr
c691 : 68               [ 4] 	pla
c692 : 2085c6           [ 6] 	jsr vdp_wr_vram
c695 : 28               [ 4] 	plp
c696 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* vdp_peek
                             ;* Get VRAM byte in (AX)
                             ;*		   X = Low Address
                             ;*		   A = High Address
                             ;* Output : A = byte read
                             ;* Regs affected : None
                             ;****************************************
c697 :                       vdp_peek
AS65 Assembler for R6502 [1.42].                                     Page   32
---------------------------------- bank2.s -----------------------------------

c697 : 08               [ 3] 	php
c698 : 78               [ 2] 	sei
c699 : 2075c6           [ 6] 	jsr vdp_rd_addr
c69c : 2080c6           [ 6] 	jsr vdp_rd_vram
c69f : 28               [ 4] 	plp
c6a0 : 60               [ 6] 	rts
                             
                             	include "kernel\snd-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SND-LOW.S
                             ;*  Low level sound routines which will always be
                             ;*  in every ROM bank.  Mainly to provide fast OS
                             ;*	access to VDP routines for M/C from BASIC
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* snd_set
                             ;* Set AY register X to value Y
                             ;* Input : X = Reg no, Y = Value
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c6a1 :                       snd_set
c6a1 : 48               [ 3] 	pha
                             
c6a2 : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c6a4 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c6a7 : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c6aa : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c6ad : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6af : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c6b1 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c6b4 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6b6 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             	
c6b9 : 8c8104           [ 4] 	sty SND_ADBUS			; Put Y on the sound bus (Y = va
c6bc : 0902             [ 2] 	ora #SND_SELWRITE		; Select mode for writing dat
c6be : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             	
c6c1 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6c3 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c6c6 : 68               [ 4] 	pla
                             	
c6c7 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get
                             ;* Get AY register X to Y
                             ;* Input : X = Reg no
                             ;* Output : Y = Value
AS65 Assembler for R6502 [1.42].                                     Page   33
---------------------------------- bank2.s -----------------------------------

                             ;* Regs affected : None
                             ;****************************************
c6c8 :                       snd_get
c6c8 : 48               [ 3] 	pha
                             
c6c9 : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c6cb : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c6ce : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c6d1 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c6d4 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6d6 : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c6d8 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c6db : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6dd : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c6e0 : a900             [ 2] 	lda #0x00				; Set Port A to input
c6e2 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c6e5 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c6e8 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6ea : 0940             [ 2] 	ora #SND_SELREAD		; Select mode for reading data
c6ec : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c6ef : ac8104           [ 4] 	ldy SND_ADBUS			; Get value in to Y
                             	
c6f2 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c6f4 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c6f7 : 68               [ 4] 	pla
                             	
c6f8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get_joy0
                             ;* Return value of joystick 0
                             ;* Input : None
                             ;* Output : Y = Value
                             ;* Regs affected : X
                             ;****************************************
c6f9 :                       snd_get_joy0
c6f9 : a20f             [ 2] 	ldx #SND_REG_IOB		; Joystick is plugged in to IO
c6fb : 20c8c6           [ 6] 	jsr snd_get				; Get IOB, result in Y
c6fe : 60               [ 6] 	rts
                             
                             	include "kernel\main.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  MAIN.S
                             ;*  This is where the main user program is execut
                             ;*  the 'kernel' once the system is initialised a
                             ;*  Today, main does very little - first shows th
                             ;*  boot up message, and then passes control to d
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   34
---------------------------------- bank2.s -----------------------------------

                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
c6ff :                       main
                             
c6ff :                       infinity
c6ff : 2046c0           [ 6] 	jsr _df_pg_dflat
c702 : 4cffc6           [ 3] 	jmp infinity
                             
c705 :                       msg_hello_world
                             	;* build.s is generated by the assemble.bat file
                             	;* all it does is echo an assembler line to
                             	;* including the build date in the message.
                             	include "kernel\build.s"
c705 : 4275696c64203a..       db "Build : 19-01-2025\r"
c718 : 3132384b204272..       db "128K Breadboard Computer\r"
c731 : 42792040363530..       db "By @6502Nerd\r"
c73e : 436f7079726967..       db "Copyright (c) 2025\r",0
                             
                             
                             	include "kernel\irq.s"
                             	
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IRQ.S
                             ;*	This is the IRQ handler - handles both the ver
                             ;*  blank interrupt from the VDP as well as softw
                             ;*  
                             ;*  As the handler has to be in every bank and it
                             ;*  accesses the VDP, then low level VDP routines
                             ;*  bundled in this file to ensure they are alway
                             ;*  without a bank switch being needed (which is 
                             ;************************************************
                             
                             ;* NMI handler installs to handle serial receive 
c752 :                       init_nmi
                             	; Core IRQ handler
c752 : a963             [ 2] 	lda #lo(nmi)
c754 : 8502             [ 3] 	sta int_nmi
c756 : a9c7             [ 2] 	lda #hi(nmi)
c758 : 8503             [ 3] 	sta int_nmi+1
                             
c75a : a9d3             [ 2] 	lda #lo(null_handler)
c75c : 850c             [ 3] 	sta int_usercia1
c75e : a9c7             [ 2] 	lda #hi(null_handler)
c760 : 850d             [ 3] 	sta int_usercia1+1
                             
c762 : 60               [ 6] 	rts
                             
                             ;* Calls the master IRQ handler
c763 :                       call_nmi_master
                             ;	jmp (int_nmi)
                             
                             ;* Master NMI handler
AS65 Assembler for R6502 [1.42].                                     Page   35
---------------------------------- bank2.s -----------------------------------

                             ;* 6551 uses this - fills the receive buffer
                             ;* VIA 2 uses this- user interrupt
c763 :                       nmi
c763 : 48               [ 3] 	pha
                             
c764 : ad8105           [ 4] 	lda SER_STATUS				; Read status register (clears
c767 : 100c             [ 3] 	bpl	nmi_skip_acia			; If no interrupt don't do a
                             
c769 : 5a               [ 3] 	phy
c76a : ad8005           [ 4] 	lda SER_DATA				; Read the data register of 6551
c76d : a40f             [ 3] 	ldy ser_last				; Put byte in last position of F
c76f : 990008           [ 5] 	sta ser_buf,y
c772 : e60f             [ 5] 	inc ser_last				; Advance position of last
                             
c774 : 7a               [ 4] 	ply
c775 :                       nmi_skip_acia
                             	;* Try PIA1 first for rapid Timer handling
c775 : ad8d04           [ 4] 	lda IO_1 + IFR
c778 : 1026             [ 3] 	bpl nmi_fin
c77a : 5a               [ 3] 	phy
c77b : da               [ 3] 	phx
                             	; Reset interrupt by reading T1C-L
c77c : ad8404           [ 4] 	lda IO_1+T1CL
                             	; Swtich to RAM bank 2 don't touch anything else
c77f : ad0004           [ 4] 	lda IO_0+PRB
c782 : 48               [ 3] 	pha                     ; Remember the bank #
c783 : 29cf             [ 2] 	and #0b11001111
c785 : 0920             [ 2] 	ora #0b00100000
c787 : 8d0004           [ 4] 	sta IO_0+PRB
                             	; Switch out ROM for RAM
c78a : ad8004           [ 4] 	lda IO_1+PRB                    ; Get current RO
c78d : 48               [ 3] 	pha
c78e : 29df             [ 2] 	and #(0xff ^ MM_DIS)            ; Switch off ROM
c790 : 8d8004           [ 4] 	sta IO_1+PRB                    ; Update port to
c793 : 20cfc7           [ 6] 	jsr call_irq_usercia1			; Call user cia1 handler
                             	; Restore ROM
c796 : 68               [ 4] 	pla                             ; Get original p
c797 : 8d8004           [ 4] 	sta IO_1+PRB                    ; Update port to
                             	; Restore RAM bank
c79a : 68               [ 4] 	pla                             ; Get original p
c79b : 8d0004           [ 4] 	sta IO_0+PRB                    ; Update port to
c79e : fa               [ 4] 	plx
c79f : 7a               [ 4] 	ply
c7a0 :                       nmi_fin
c7a0 : 68               [ 4] 	pla
c7a1 : 40               [ 6] 	rti
                             
                             
                             ;* Obviously this can only be done with
                             ;* interrupts disabled!
c7a2 :                       init_irq
                             	; Core IRQ handler
c7a2 : a9d4             [ 2] 	lda #lo(irq)
c7a4 : 8504             [ 3] 	sta int_irq
c7a6 : a9c7             [ 2] 	lda #hi(irq)
c7a8 : 8505             [ 3] 	sta int_irq+1
                             	
                             	; Core BRK handler
c7aa : a9fa             [ 2] 	lda #lo(irq_brk)
c7ac : 8506             [ 3] 	sta int_brk
c7ae : a9c7             [ 2] 	lda #hi(irq_brk)
c7b0 : 8507             [ 3] 	sta int_brk+1
AS65 Assembler for R6502 [1.42].                                     Page   36
---------------------------------- bank2.s -----------------------------------

                             
                             	; User handlers for VDP, PIA0 interrupts
c7b2 : a9d3             [ 2] 	lda #lo(null_handler)
c7b4 : 8508             [ 3] 	sta int_uservdp
c7b6 : a9c7             [ 2] 	lda #hi(null_handler)
c7b8 : 8509             [ 3] 	sta int_uservdp+1
                             
c7ba : a9d3             [ 2] 	lda #lo(null_handler)
c7bc : 850a             [ 3] 	sta int_usercia0
c7be : a9c7             [ 2] 	lda #hi(null_handler)
c7c0 : 850b             [ 3] 	sta int_usercia0+1
                             
c7c2 : 60               [ 6] 	rts
                             
                             ;* Calls the master IRQ handler
c7c3 :                       call_irq_master
c7c3 : 6c0400           [ 6] 	jmp (int_irq)
                             	
                             ;* Calls the BRK handler
c7c6 :                       call_irq_brk
c7c6 : 6c0600           [ 6] 	jmp (int_brk)
                             
                             ;* Call the userVDP handler
c7c9 :                       call_irq_uservdp
c7c9 : 6c0800           [ 6] 	jmp (int_uservdp)
                             	
                             ;* Call the user CIA0 handler
c7cc :                       call_irq_usercia0
c7cc : 6c0a00           [ 6] 	jmp (int_usercia0)
                             
                             ;* Call the user CIA1 handler
c7cf :                       call_irq_usercia1
c7cf : 6c0c00           [ 6] 	jmp (int_usercia1)
                             	
                             ;* null interrupt
c7d2 :                       null_irq
c7d2 : 40               [ 6] 	rti
                             
                             ;* null handler
c7d3 :                       null_handler
c7d3 : 60               [ 6] 	rts
                             	
                             
                             ;* Master IRQ handler
c7d4 :                       irq
                             	_pushAXY
                             
                             
                             	; Check if IRQ or BRK
                             	; load P from stack in to A
c7d7 : ba               [ 2] 	tsx
c7d8 : bd0401           [ 4] 	lda 0x104,x
                             	; BRK bit set?
c7db : 2910             [ 2] 	and #0x10
c7dd : d0e7             [ 3] 	bne call_irq_brk
                             	
c7df : 18               [ 2] 	clc						; Standard behaviour
                             	
                             	;* Try VDP next
c7e0 :                       irq_check_vdp	
c7e0 : ad0105           [ 4] 	lda VDP_STATUS			; Read status register
c7e3 : 1009             [ 3] 	bpl	irq_check_cia0		; Skip if not VBLANK
AS65 Assembler for R6502 [1.42].                                     Page   37
---------------------------------- bank2.s -----------------------------------

c7e5 : 20c9c7           [ 6] 	jsr call_irq_uservdp	; Call use VDP handler
c7e8 : 2047c8           [ 6] 	jsr int_vdp_handler		; Call  OS VDP handler
c7eb : 2025c8           [ 6] 	jsr int_kb_handler		; Call OS cia0 handler (keyb
                             
                             	;* Try VIA0 last as it's keyboard (low speed)
c7ee :                       irq_check_cia0
c7ee : ad0d04           [ 4] 	lda IO_0 + IFR
c7f1 : 1003             [ 3] 	bpl irq_fin
c7f3 : 20ccc7           [ 6] 	jsr call_irq_usercia0	; Call user cia0 handler
                             
c7f6 :                       irq_fin
                             	_pullAXY
                             
c7f9 : 40               [ 6] 	rti
                             	
                             ;* Handle BRK
c7fa :                       irq_brk
                             	; Handle BRK
                             	; Get PCL,H minus 2 gives the BRK instruction ad
c7fa : 38               [ 2] 	sec
c7fb : bd0501           [ 4] 	lda 0x0105,x
c7fe : e902             [ 2] 	sbc #2
c800 : 85a4             [ 3] 	sta df_brkpc
c802 : bd0601           [ 4] 	lda 0x0106,x
c805 : e900             [ 2] 	sbc #0
c807 : 85a5             [ 3] 	sta df_brkpc+1
                             	; Get the byte pointed to by old PC
                             	; which is 1 on from the BRK
c809 : a001             [ 2] 	ldy #1
c80b : b1a4             [ 5] 	lda (df_brkpc),y
c80d : 85a6             [ 3] 	sta df_brkval
c80f : 859f             [ 3] 	sta errno
                             	; now update the return address
c811 : a5a2             [ 3] 	lda df_pc
c813 : 9d0501           [ 5] 	sta 0x105,x
c816 : a5a3             [ 3] 	lda df_pc+1
c818 : 9d0601           [ 5] 	sta 0x106,x
                             	
                             	_pullAXY
                             
                             	; Save the registers in temp area
c81e : 8585             [ 3] 	sta num_a
c820 : 8686             [ 3] 	stx num_a+1
c822 : 8487             [ 3] 	sty num_a+2
                             	; when RTI occurs:
                             	;  will return to error handler
                             	;  df_brkval will contain signature
c824 : 40               [ 6] 	rti
                             	
                             ;****************************************
                             ;* int_kb_handler
                             ;* Keyboard interrupt handler
                             ;****************************************
c825 :                       int_kb_handler	
c825 : a537             [ 3] 	lda kb_deb				; If keyboard pressed is debounce 
c827 : d00d             [ 3] 	bne int_skip_scan		; If not zero, then don't che
c829 : ad0d04           [ 4] 	lda IO_0 + IFR			; Check status register CIA0
c82c : 2901             [ 2] 	and #IFR_CA2			; Keyboard pressed?
c82e : f00c             [ 3] 	beq int_keys_up
c830 :                       int_do_read
c830 : 853c             [ 3] 	sta kb_pressed			; Put non-zero in to this flag
c832 : a53b             [ 3] 	lda kb_debounce			; Set debounce
AS65 Assembler for R6502 [1.42].                                     Page   38
---------------------------------- bank2.s -----------------------------------

c834 : 8537             [ 3] 	sta kb_deb
c836 :                       int_skip_scan
c836 : a901             [ 2] 	lda #IFR_CA2			; Clear CA2
c838 : 8d0d04           [ 4] 	sta IO_0 + IFR
c83b : 60               [ 6] 	rts
c83c :                       int_keys_up					; No key pressed
c83c : 6433             [ 3] 	stz kb_raw				; Using 65c02 stz opcode
c83e : 6434             [ 3] 	stz kb_last
c840 : 6435             [ 3] 	stz kb_code
c842 : 6437             [ 3] 	stz kb_deb
c844 : 6438             [ 3] 	stz kb_rep
c846 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* int_vdp_handler
                             ;* VDP interrupt handler
                             ;****************************************
c847 :                       int_vdp_handler
c847 : 2073c8           [ 6] 	jsr update_timers	; If it is then update system 
                             
c84a : a512             [ 3] 	lda vdp_curoff		; Is cursor enabled?
c84c : d024             [ 3] 	bne int_vdp_fin		; Skip if not
                             
c84e : c613             [ 5] 	dec vdp_curstat		; Decrement VDP counter
c850 : a513             [ 3] 	lda vdp_curstat		; Check it
c852 : 297f             [ 2] 	and #0x7f			; If bottom 7 bits !=0
c854 : d01c             [ 3] 	bne int_vdp_fin		; No flashing to be done
c856 : a513             [ 3] 	lda vdp_curstat		; Invert top bit (bottoms bits=
c858 : 4990             [ 2] 	eor #0x80+VDP_FLASH	; Start counter again
c85a : 8513             [ 3] 	sta vdp_curstat		
                             
c85c : 18               [ 2] 	clc					; Add offset for cursor address in vram
c85d : a52c             [ 3] 	lda gr_scrngeom+gr_cur_ptr
c85f : 6529             [ 3] 	adc gr_scrngeom+gr_cur_off
c861 : aa               [ 2] 	tax
c862 : a52d             [ 3] 	lda gr_scrngeom+gr_cur_ptr+1
c864 : 6900             [ 2] 	adc #0
                             
c866 : 205dc6           [ 6] 	jsr vdp_wr_addr
                             	
c869 : a513             [ 3] 	lda vdp_curstat
c86b : 2980             [ 2] 	and #0x80
c86d : 4514             [ 3] 	eor vdp_curval		; EOR top bit with what is under
c86f : 2085c6           [ 6] 	jsr vdp_wr_vram
c872 :                       int_vdp_fin	
c872 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* update_timers
                             ;* Update 24 bit timer and debounce counters
                             ;****************************************
c873 :                       update_timers
c873 : e610             [ 5] 	inc vdp_int_cnt
c875 : d002             [ 3] 	bne inc_kb_timers
c877 : e611             [ 5] 	inc vdp_int_cnt+1
c879 :                       inc_kb_timers
c879 : a637             [ 3] 	ldx kb_deb			; Is debounce 0?
c87b : f002             [ 3] 	beq skip_kb_deb
c87d : c637             [ 5] 	dec kb_deb
c87f :                       skip_kb_deb
c87f : a638             [ 3] 	ldx kb_rep			; Is repeat timer 0?
AS65 Assembler for R6502 [1.42].                                     Page   39
---------------------------------- bank2.s -----------------------------------

c881 : f002             [ 3] 	beq skip_kb_rep
c883 : c638             [ 5] 	dec kb_rep
c885 :                       skip_kb_rep
c885 : 60               [ 6] 	rts
                             	
                             
                             	include "utils\misc.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  MISC.S
                             ;*  Miscellaneous module for commmon utility func
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* long_delay
                             ;* Long delay (X decremented every 0.125ms)
                             ;* Input : X = number of 0.125ms ticks to wait (m
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c886 :                       long_delay
c886 : 08               [ 3] 	php
                             	_pushAXY
                             
                             	
c88a : a000             [ 2] 	ldy #0x00
c88c :                       long_delay_1
c88c : ea               [ 2] 	nop
c88d : ea               [ 2] 	nop
c88e : ea               [ 2] 	nop
c88f : ea               [ 2] 	nop
c890 : 88               [ 2] 	dey
c891 : d0f9             [ 3] 	bne long_delay_1
c893 : ca               [ 2] 	dex
c894 : d0f6             [ 3] 	bne long_delay_1
                             
                             	_pullAXY
                             
c899 : 28               [ 4] 	plp
                             	
c89a : 60               [ 6] 	rts
                             
                             
                             	include "utils\utils.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   40
---------------------------------- bank2.s -----------------------------------

                             ;*  UTILS.S
                             ;*  This module implements various utility functi
                             ;*  converting from ASCII to binary form for numb
                             ;*  vice-versa to allow humans to actually be abl
                             ;*  and read numbers in their prefered form!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c89b :                       utilPrintSPC
c89b : 48               [ 3] 	pha
c89c : a920             [ 2] 	lda #' '
c89e : 20c0c5           [ 6] 	jsr io_put_ch
c8a1 : 68               [ 4] 	pla
c8a2 : 60               [ 6] 	rts
                             
c8a3 :                       utilPrintCRLF
c8a3 : 48               [ 3] 	pha
c8a4 : a90d             [ 2] 	lda #UTF_CR
c8a6 : 20c0c5           [ 6] 	jsr io_put_ch
c8a9 : 68               [ 4] 	pla
c8aa : 60               [ 6] 	rts
                             
c8ab :                       utilPrintA
c8ab : 8545             [ 3] 	sta tmp_d
c8ad : 48               [ 3] 	pha
c8ae : 8a               [ 2] 	txa
c8af : 48               [ 3] 	pha
c8b0 : a545             [ 3] 	lda tmp_d
c8b2 : 20d0c8           [ 6] 	jsr str_a_to_x
c8b5 : 20c0c5           [ 6] 	jsr io_put_ch
c8b8 : 8a               [ 2] 	txa
c8b9 : 20c0c5           [ 6] 	jsr io_put_ch
c8bc : 68               [ 4] 	pla
c8bd : aa               [ 2] 	tax
c8be : 68               [ 4] 	pla
c8bf : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* util_clr_mem
                             ;* Clear a block of main ram
                             ;* Input : X, A = Block start, Y = Block size
                             ;* Regs affected : P
                             ;****************************************
c8c0 :                       util_clr_mem
c8c0 : 48               [ 3] 	pha
c8c1 : 5a               [ 3] 	phy
c8c2 : 863f             [ 3] 	stx tmp_v1
c8c4 : 8540             [ 3] 	sta tmp_v1+1
c8c6 : a900             [ 2] 	lda #0
c8c8 :                       mem_clr_byte
c8c8 : 88               [ 2] 	dey
c8c9 : 913f             [ 5] 	sta (tmp_v1),y
c8cb : d0fb             [ 3] 	bne mem_clr_byte
c8cd : 7a               [ 4] 	ply
c8ce : 68               [ 4] 	pla
c8cf : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* str_a_to_x
AS65 Assembler for R6502 [1.42].                                     Page   41
---------------------------------- bank2.s -----------------------------------

                             ;* Convert accumulator to hex string
                             ;* Input : A = Byte to convert
                             ;* Output : A = High Char, X = Low Char
                             ;* Regs affected : P
                             ;****************************************
c8d0 :                       str_a_to_x
c8d0 : 48               [ 3] 	pha					; Save the byte using later on
c8d1 : 290f             [ 2] 	and #0x0f			; Mask low nibble
c8d3 : 18               [ 2] 	clc
c8d4 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c8d6 : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c8d8 : 9002             [ 3] 	bcc skip_a_f_1		; skip a-f adjustment
c8da : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c8dc :                       skip_a_f_1
c8dc : aa               [ 2] 	tax					; Low char is in X
c8dd : 68               [ 4] 	pla					; Get byte back
c8de : 4a               [ 2] 	lsr a				; Make high nibble low
c8df : 4a               [ 2] 	lsr a
c8e0 : 4a               [ 2] 	lsr a
c8e1 : 4a               [ 2] 	lsr a
c8e2 : 18               [ 2] 	clc
c8e3 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c8e5 : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c8e7 : 9002             [ 3] 	bcc skip_a_f_2		; skip a-f adjustment
c8e9 : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c8eb :                       skip_a_f_2
                             
c8eb : 18               [ 2] 	clc					; No error
c8ec : 60               [ 6] 	rts					; A high nibble
                             
                             ;****************************************
                             ;* str_x_to_a
                             ;* Convert hex string to accumulator
                             ;* Input : A = High Char, X = Low Char
                             ;* Output : A = Value
                             ;* Regs affected : P
                             ;****************************************
c8ed :                       str_x_to_a
c8ed : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c8ef : 38               [ 2] 	sec					; Process high char in A
c8f0 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c8f2 : c90a             [ 2] 	cmp #10				; If A < 10 then
c8f4 : 9002             [ 3] 	bcc skip_x_f_1		; skip a-f adjustment
c8f6 : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c8f8 :                       skip_x_f_1
c8f8 : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c8fa : b01d             [ 4] 	bcs	str_x_to_a_err	; Error if not
                             
c8fc : 0a               [ 2] 	asl a				; This is the high nibble
c8fd : 0a               [ 2] 	asl a
c8fe : 0a               [ 2] 	asl a
c8ff : 0a               [ 2] 	asl a
c900 : 48               [ 3] 	pha					; Save the high nibble
c901 : 8a               [ 2] 	txa					; Now process the low char in X
c902 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c904 : 38               [ 2] 	sec
c905 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c907 : c90a             [ 2] 	cmp #10				; If A < 10 then
c909 : 9002             [ 3] 	bcc skip_x_f_2		; skip a-f adjustment
c90b : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c90d :                       skip_x_f_2
c90d : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
AS65 Assembler for R6502 [1.42].                                     Page   42
---------------------------------- bank2.s -----------------------------------

c90f : b007             [ 3] 	bcs	str_x_to_a_errl	; Error if not
                             
c911 : 8585             [ 3] 	sta num_a			; Store low nibble in temp
c913 : 68               [ 4] 	pla					; Get high nibble
c914 : 0585             [ 3] 	ora num_a			; OR with low nibble
                             
c916 : 18               [ 2] 	clc					; No error
c917 : 60               [ 6] 	rts					; A contains value
                             
c918 :                       str_x_to_a_errl
c918 : 68               [ 4] 	pla
c919 :                       str_x_to_a_err
                             	SWBRK CMD_ERR_VAL
                             
                             
                             ;****************************************
                             ;* con_n_to_a
                             ;* Convert numeric string to accumulator (unsigne
                             ;* Input : Pointer to string (X=L, A=H), Y = Sour
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* A = Source type detected
                             ;* Regs affected : CS = Error
                             ;****************************************
c91b :                       con_n_to_a
c91b : 8691             [ 3] 	stx num_tmp
c91d : 8592             [ 3] 	sta num_tmp+1
c91f : 6485             [ 3] 	stz num_a
c921 : 6486             [ 3] 	stz num_a+1
c923 : c000             [ 2] 	cpy #NUM_ANY
c925 : f014             [ 3] 	beq con_n_to_a_detect
c927 : 88               [ 2] 	dey
c928 : d003             [ 3] 	bne con_n_not_dec
c92a :                       con_dec_jmp
c92a : 4cbec9           [ 3] 	jmp con_dec_to_a_int
c92d :                       con_n_not_dec
c92d : 88               [ 2] 	dey
c92e : d003             [ 3] 	bne con_n_not_hex
c930 :                       con_hex_jmp
c930 : 4c55c9           [ 3] 	jmp con_hex_to_a_int
c933 :                       con_n_not_hex
c933 : 88               [ 2] 	dey
c934 : d003             [ 3] 	bne con_n_err
c936 :                       con_bin_jmp
c936 : 4c94c9           [ 3] 	jmp con_bin_to_a_int
c939 :                       con_n_err
c939 : 38               [ 2] 	sec
c93a : 60               [ 6] 	rts
c93b :                       con_n_to_a_detect
c93b : b291             [ 5] 	lda (num_tmp)
c93d : c930             [ 2] 	cmp #'0'
c93f : d0e9             [ 3] 	bne con_dec_jmp
c941 : a001             [ 2] 	ldy #1
c943 : b191             [ 5] 	lda (num_tmp),y
c945 : 0920             [ 2] 	ora #0x20
c947 : c978             [ 2] 	cmp #'x'
c949 : f0e5             [ 3] 	beq con_hex_jmp
c94b : c962             [ 2] 	cmp #'b'
c94d : f0e7             [ 3] 	beq con_bin_jmp
c94f : 80d9             [ 3] 	bra con_dec_jmp
                             
                             ;****************************************
                             ;* con_hex_to_a
AS65 Assembler for R6502 [1.42].                                     Page   43
---------------------------------- bank2.s -----------------------------------

                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c951 :                       con_hex_to_a
c951 : 8691             [ 3] 	stx num_tmp
c953 : 8592             [ 3] 	sta num_tmp+1
c955 :                       con_hex_to_a_int
c955 : a205             [ 2] 	ldx #5			; > 4 digits will cause error
c957 : a002             [ 2] 	ldy #2			; start at first digit
c959 :                       con_hex_digit
c959 : b191             [ 5] 	lda (num_tmp),y
c95b : 0920             [ 2] 	ora #0x20					; Make alpha in to lower case
c95d : 38               [ 2] 	sec							; Process high char in A
c95e : e930             [ 2] 	sbc #'0'					; Convert to hex nibble
c960 : c90a             [ 2] 	cmp #10						; If A < 10 then
c962 : 9002             [ 3] 	bcc con_hex_skip_x_f_1		; skip a-f adjustment
c964 : e927             [ 2] 	sbc #0x27					; Sub 7 to get in to A-F range
c966 :                       con_hex_skip_x_f_1
c966 : c910             [ 2] 	cmp #0x10					; Nibble should be <= 0x0f
c968 : b01c             [ 3] 	bcs	con_hex_done			; Potentially done if not
c96a : 48               [ 3] 	pha
                             	; make room for lo nibble
c96b : 0685             [ 5] 	asl num_a
c96d : 2686             [ 5] 	rol num_a+1
c96f : 0685             [ 5] 	asl num_a
c971 : 2686             [ 5] 	rol num_a+1
c973 : 0685             [ 5] 	asl num_a
c975 : 2686             [ 5] 	rol num_a+1
c977 : 0685             [ 5] 	asl num_a
c979 : 2686             [ 5] 	rol num_a+1
                             	; save in low nibble
c97b : 68               [ 4] 	pla
c97c : 0585             [ 3] 	ora num_a
c97e : 8585             [ 3] 	sta num_a
c980 : c8               [ 2] 	iny
c981 : ca               [ 2] 	dex
c982 : d0d5             [ 3] 	bne con_hex_digit
                             	; if got to a 5th digit then error
c984 :                       con_hex_err
c984 : 38               [ 2] 	sec
c985 : 60               [ 6] 	rts
                             	; found a non-hex digit
c986 :                       con_hex_done
                             	; if no digits processed then error
c986 : c002             [ 2] 	cpy #2
c988 : f0fa             [ 3] 	beq con_hex_err
                             	; move y to x for digits processed
c98a : 98               [ 2] 	tya
c98b : aa               [ 2] 	tax
c98c : a902             [ 2] 	lda #NUM_HEX
c98e : 18               [ 2] 	clc
c98f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_bin_to_a
                             ;* Convert binary string to accumulator (unsigned
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   44
---------------------------------- bank2.s -----------------------------------

c990 :                       con_bin_to_a
c990 : 8691             [ 3] 	stx num_tmp
c992 : 8592             [ 3] 	sta num_tmp+1
c994 :                       con_bin_to_a_int
c994 : a002             [ 2] 	ldy #2
c996 : a211             [ 2] 	ldx #17						; Max 16 binary digits allowed
c998 :                       con_bin_digit
c998 : b191             [ 5] 	lda (num_tmp),y
c99a : c930             [ 2] 	cmp #'0'
c99c : 9010             [ 3] 	bcc con_bin_done
c99e : c932             [ 2] 	cmp #'1'+1
c9a0 : b00c             [ 3] 	bcs con_bin_done
                             	; sets C if '1' else resets C
c9a2 : 69cf             [ 2] 	adc #0xff-'0'
                             	; shift in digit
c9a4 : 2685             [ 5] 	rol num_a
c9a6 : 2686             [ 5] 	rol num_a+1
c9a8 : c8               [ 2] 	iny
c9a9 : ca               [ 2] 	dex
c9aa : d0ec             [ 3] 	bne con_bin_digit
                             	; on the 17th digit is too much, error
c9ac : 800a             [ 3] 	bra con_bin_err
c9ae :                       con_bin_done
                             	; didn't process any digit = error
c9ae : c002             [ 2] 	cpy #2
c9b0 : f006             [ 3] 	beq con_bin_err
                             	; put digits processed in to X
c9b2 : 98               [ 2] 	tya
c9b3 : aa               [ 2] 	tax
c9b4 : a903             [ 2] 	lda #NUM_BIN
c9b6 : 18               [ 2] 	clc
c9b7 : 60               [ 6] 	rts
c9b8 :                       con_bin_err
c9b8 : 38               [ 2] 	sec
c9b9 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_d_to_a
                             ;* Convert decimal string to accumulator (SIGNED)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c9ba :                       con_dec_to_a
c9ba : 8691             [ 3] 	stx num_tmp
c9bc : 8592             [ 3] 	sta num_tmp+1
c9be :                       con_dec_to_a_int
c9be : a000             [ 2] 	ldy #0
                             	; Detect if leading minus sign
c9c0 : b291             [ 5] 	lda (num_tmp)
c9c2 : c92d             [ 2] 	cmp #'-'
c9c4 : d001             [ 3] 	bne str_d_find_end
                             	; skip over minus if found
c9c6 : c8               [ 2] 	iny
c9c7 :                       str_d_find_end
c9c7 : b191             [ 5] 	lda (num_tmp),y
c9c9 : c930             [ 2] 	cmp #'0'
c9cb : 9007             [ 3] 	bcc str_d_found_end
c9cd : c93a             [ 2] 	cmp #'9'+1
c9cf : b003             [ 3] 	bcs str_d_found_end
c9d1 : c8               [ 2] 	iny
c9d2 : 80f3             [ 3] 	bra str_d_find_end
AS65 Assembler for R6502 [1.42].                                     Page   45
---------------------------------- bank2.s -----------------------------------

c9d4 :                       str_d_found_end
c9d4 : c007             [ 2] 	cpy #6+1			; Biggest int is 6 chars
c9d6 : b052             [ 4] 	bcs str_d_error		; e.g. -32767 including minus
c9d8 : 8494             [ 3] 	sty num_tmp+3
c9da : 6493             [ 3] 	stz num_tmp+2
c9dc : 6485             [ 3] 	stz num_a
c9de : 6486             [ 3] 	stz num_a+1
c9e0 :                       str_d_process_digit
c9e0 : 88               [ 2] 	dey
c9e1 : 3026             [ 4] 	bmi str_d_digits_done
                             
c9e3 : b191             [ 5] 	lda (num_tmp),y
                             
c9e5 : c92d             [ 2] 	cmp #'-'			; Got to minus sign?
c9e7 : f020             [ 4] 	beq str_d_digits_done ; also done
                             
c9e9 : 38               [ 2] 	sec
c9ea : e930             [ 2] 	sbc #'0'
                             	; Convert digit to number
                             	; and then offset in to
                             	; look up table of powers
c9ec : 18               [ 2] 	clc
c9ed : 0a               [ 2] 	asl a
c9ee : 6593             [ 3] 	adc num_tmp+2
                             	; X contains index to powers
c9f0 : aa               [ 2] 	tax
c9f1 : a585             [ 3] 	lda num_a
c9f3 : 7d2cca           [ 4] 	adc str_d_powers,x
c9f6 : 8585             [ 3] 	sta num_a
c9f8 : a586             [ 3] 	lda num_a+1
c9fa : 7d2dca           [ 4] 	adc str_d_powers+1,x
c9fd : 8586             [ 3] 	sta num_a+1
c9ff : b029             [ 4] 	bcs str_d_error
                             	; Move to next power of 10 index
ca01 : a593             [ 3] 	lda num_tmp+2
ca03 : 6914             [ 2] 	adc #20
ca05 : 8593             [ 3] 	sta num_tmp+2
ca07 : 80d7             [ 4] 	bra str_d_process_digit
ca09 :                       str_d_digits_done
                             	; check if minus
ca09 : b291             [ 5] 	lda (num_tmp)
ca0b : c92d             [ 2] 	cmp #'-'
ca0d : d011             [ 3] 	bne str_d_skip_neg
ca0f : a694             [ 3] 	ldx num_tmp+3		; Must have >= 2 chars
ca11 : e002             [ 2] 	cpx #2				; else it's an error
ca13 : 9015             [ 3] 	bcc str_d_error
ca15 : a685             [ 3] 	ldx num_a
ca17 : a586             [ 3] 	lda num_a+1
ca19 : 2090ca           [ 6] 	jsr twos_complement
ca1c : 8685             [ 3] 	stx num_a
ca1e : 8586             [ 3] 	sta num_a+1
ca20 :                       str_d_skip_neg
ca20 : a694             [ 3] 	ldx num_tmp+3
ca22 : e001             [ 2] 	cpx #1				; must be at least 1 char
ca24 : 9004             [ 3] 	bcc str_d_error
ca26 : a901             [ 2] 	lda #NUM_DEC
ca28 : 18               [ 2] 	clc
ca29 : 60               [ 6] 	rts
ca2a :                       str_d_error
ca2a : 38               [ 2] 	sec
ca2b : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page   46
---------------------------------- bank2.s -----------------------------------

ca2c :                       str_d_powers
ca2c : 00000100020003..      	dw	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
ca40 : 00000a0014001e..      	dw	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
ca54 : 00006400c8002c..      	dw	0, 100, 200, 300, 400, 500, 600, 700, 800, 90
ca68 : 0000e803d007b8..      	dw	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 
ca7c : 00001027204e30..      	dw	0, 10000, 20000, 30000, 40000, 50000, 60000, 
                             	
                             
                             ;****************************************
                             ;* twos_complement
                             ;* Twos complement of X,A (X=low)
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : X,A in 2's complement
                             ;* Regs affected : P
                             ;****************************************
ca90 :                       twos_complement
ca90 : 49ff             [ 2] 	eor #0xff
ca92 : 48               [ 3] 	pha
ca93 : 8a               [ 2] 	txa
ca94 : 49ff             [ 2] 	eor #0xff
ca96 : aa               [ 2] 	tax
ca97 : 68               [ 4] 	pla
ca98 : e8               [ 2] 	inx
ca99 : d001             [ 3] 	bne twos_complement_skip_X
ca9b : 1a               [ 2] 	inc a
ca9c :                       twos_complement_skip_X
ca9c : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* int_to_bcd
                             ;* Convert A,X (signed int) to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated
                             ;* Regs affected : None
                             ;****************************************
ca9d :                       int_to_bcd
ca9d : 08               [ 3] 	php
ca9e : 48               [ 3] 	pha
ca9f : da               [ 3] 	phx
                             
caa0 : 8691             [ 3] 	stx num_tmp
caa2 : 8592             [ 3] 	sta num_tmp+1
caa4 : c980             [ 2] 	cmp #0x80			; Negative?
caa6 : 9003             [ 3] 	bcc int_to_bcd_skip_neg
caa8 : 2090ca           [ 6] 	jsr twos_complement
caab :                       int_to_bcd_skip_neg
caab : 6485             [ 3] 	stz num_a
caad : 6486             [ 3] 	stz num_a+1
caaf : 6487             [ 3] 	stz num_a+2
cab1 : 6488             [ 3] 	stz num_a+3
cab3 : a210             [ 2] 	ldx #16
cab5 : f8               [ 2] 	sed
cab6 :                       int_to_bcd_bit
cab6 : 0691             [ 5] 	asl num_tmp
cab8 : 2692             [ 5] 	rol num_tmp+1
caba : a585             [ 3] 	lda num_a
cabc : 6585             [ 3] 	adc num_a
cabe : 8585             [ 3] 	sta num_a
cac0 : a586             [ 3] 	lda num_a+1
cac2 : 6586             [ 3] 	adc num_a+1
cac4 : 8586             [ 3] 	sta num_a+1
AS65 Assembler for R6502 [1.42].                                     Page   47
---------------------------------- bank2.s -----------------------------------

cac6 : a587             [ 3] 	lda num_a+2
cac8 : 6587             [ 3] 	adc num_a+2
caca : 8587             [ 3] 	sta num_a+2
cacc : ca               [ 2] 	dex
cacd : d0e7             [ 3] 	bne int_to_bcd_bit
                             	
cacf : fa               [ 4] 	plx
cad0 : 68               [ 4] 	pla
cad1 : 28               [ 4] 	plp
cad2 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* word_to_bcd
                             ;* Convert A,X (unsighed word) to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated as BCD
                             ;* Regs affected : None
                             ;****************************************
cad3 :                       word_to_bcd
cad3 : 08               [ 3] 	php
cad4 : 48               [ 3] 	pha
cad5 : da               [ 3] 	phx
                             
cad6 : 8691             [ 3] 	stx num_tmp
cad8 : 8592             [ 3] 	sta num_tmp+1
cada : 6485             [ 3] 	stz num_a
cadc : 6486             [ 3] 	stz num_a+1
cade : 6487             [ 3] 	stz num_a+2
cae0 : 6488             [ 3] 	stz num_a+3
cae2 : a210             [ 2] 	ldx #16			; 16 binary bits
cae4 : f8               [ 2] 	sed
cae5 :                       word_to_bcd_bit
cae5 : 0691             [ 5] 	asl num_tmp
cae7 : 2692             [ 5] 	rol num_tmp+1
cae9 : a585             [ 3] 	lda num_a
caeb : 6585             [ 3] 	adc num_a
caed : 8585             [ 3] 	sta num_a
caef : a586             [ 3] 	lda num_a+1
caf1 : 6586             [ 3] 	adc num_a+1
caf3 : 8586             [ 3] 	sta num_a+1
caf5 : a587             [ 3] 	lda num_a+2
caf7 : 6587             [ 3] 	adc num_a+2
caf9 : 8587             [ 3] 	sta num_a+2
cafb : ca               [ 2] 	dex
cafc : d0e7             [ 3] 	bne word_to_bcd_bit
                             	
cafe : fa               [ 4] 	plx
caff : 68               [ 4] 	pla
cb00 : 28               [ 4] 	plp
cb01 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* int_to_str_ch
                             ;* Helper routine to stuff decimal char in to num
                             ;* Input : A=BCD digit, Y=num_buf index, C=insert
                             ;* Output : num_buf in ASCII, A=ASCII digit
                             ;* Regs affected : C cleared if non-zero
                             ;****************************************
cb02 :                       int_to_str_ch
cb02 : 290f             [ 2] 	and #0xf
cb04 : 0930             [ 2] 	ora #0x30					; Convert to ascii
cb06 : 4930             [ 2] 	eor #0x30					; Check if zero digit
AS65 Assembler for R6502 [1.42].                                     Page   48
---------------------------------- bank2.s -----------------------------------

cb08 : d005             [ 3] 	bne int_to_str_nz			; If not zero definitely sto
cb0a : b003             [ 3] 	bcs int_to_str_nz			; Also if C=1
cb0c : 4930             [ 2] 	eor #0x30					; Restore A
cb0e : 60               [ 6] 	rts							; Return without storing anything
cb0f :                       int_to_str_nz
cb0f : 4930             [ 2] 	eor #0x30					; Restore A
cb11 : 999500           [ 5] 	sta num_buf,y
cb14 : c8               [ 2] 	iny
cb15 : 38               [ 2] 	sec							; Set C as a non-zero encountered
cb16 :                       int_to_str_ch_fin
cb16 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* int_to_str
                             ;* Convert int to string
                             ;* Input : in X,A (low,high), C=leading zeros wan
                             ;* Output : num_buf in ASCII 6 digits + zero term
                             ;* Regs affected : P
                             ;****************************************
cb17 :                       int_to_str
                             	_pushAXY
                             
cb1a : a000             [ 2] 	ldy #0						; first pos of num_buf
cb1c : 0900             [ 2] 	ora #0						; Test A for sign bit
cb1e : 08               [ 3] 	php							; Remember C bit of P
cb1f : 100a             [ 3] 	bpl int_to_str_skip_neg		; Skip if not (postive 
cb21 : 2090ca           [ 6] 	jsr twos_complement			; Flip X,A from 2s complem
cb24 : 48               [ 3] 	pha							; Remember A
cb25 : a92d             [ 2] 	lda #'-'					; Put in negative sign
cb27 : 8595             [ 3] 	sta num_buf
cb29 : c8               [ 2] 	iny							; Start at second buffer pos
cb2a : 68               [ 4] 	pla							; Restore A
cb2b :                       int_to_str_skip_neg
cb2b : 20d3ca           [ 6]  	jsr word_to_bcd				; Convert X,A to BCD
cb2e : a202             [ 2] 	ldx #2						; Start at BCD high byte
cb30 :                       int_str
cb30 : 28               [ 4] 	plp							; Get C but immediately
cb31 : 08               [ 3] 	php							; Save C (due to loop check later)
cb32 : b585             [ 4] 	lda num_a,x					; Get BCD digit
cb34 : 859c             [ 3] 	sta num_buf+7				; Save A it for the units later
cb36 : 4a               [ 2] 	lsr a						; Tens - shift to lower nibble
cb37 : 4a               [ 2] 	lsr a
cb38 : 4a               [ 2] 	lsr a
cb39 : 4a               [ 2] 	lsr a
cb3a : 28               [ 4] 	plp							; Get C
cb3b : 2002cb           [ 6] 	jsr int_to_str_ch			; Put ASCII code in num_buf
cb3e : a59c             [ 3] 	lda num_buf+7				; Get A for the units
cb40 : 2002cb           [ 6] 	jsr int_to_str_ch			; Put ASCII code in num_buf
cb43 : 08               [ 3] 	php							; Save C
cb44 : ca               [ 2] 	dex
cb45 : 10e9             [ 3] 	bpl int_str
cb47 : 28               [ 4] 	plp							; Check C
cb48 : b005             [ 3] 	bcs	int_to_str_fin			; If set then something pri
cb4a : a930             [ 2] 	lda #'0'					; Stuff a zero
cb4c : 8595             [ 3] 	sta num_buf					; Must be in first position..
cb4e : c8               [ 2] 	iny
cb4f :                       int_to_str_fin
cb4f : a900             [ 2] 	lda #0						; Terminator
cb51 : 999500           [ 5] 	sta num_buf,y
cb54 : c8               [ 2] 	iny
                             	_pullAXY
                             
AS65 Assembler for R6502 [1.42].                                     Page   49
---------------------------------- bank2.s -----------------------------------

cb58 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* bcd_to_str
                             ;* Convert num_buf to chars
                             ;* Input : num_a in BCD format
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
                             ;bcd_to_str
                             ;	pha
                             ;	phx
                             ;	phy
                             ;
                             ;	ldx #5						; Index in to string
                             ;	ldy #0						; Current BCD digit
                             ;bcd_str
                             ;	lda num_a,y
                             ;	; Convert 1s digit of byte
                             ;	pha
                             ;	and #0xf
                             ;	clc
                             ;	adc #0x30
                             ;	sta num_buf,x
                             ;	; Convert 10s digit of byte
                             ;	pla
                             ;	lsr a
                             ;	lsr a
                             ;	lsr a
                             ;	lsr a
                             ;	clc
                             ;	adc #0x30					; Convert to ASCII
                             ;	sta num_buf-1,x
                             ;	dex
                             ;	dex
                             ;	iny
                             ;	cpy #3						; 3 BCD digits max
                             ;	bne bcd_str
                             ;
                             ;	ply
                             ;	plx
                             ;	pla
                             ;	rts
                             	
                             ;****************************************
                             ;* out_bcd
                             ;* Output a bcd string in num_buf
                             ;* Input : num_buf has the ASCII
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not, Y=digits p
                             ;* Regs affected : P
                             ;****************************************
                             ;out_bcd
                             ;	pha
                             ;	phx
                             ;	php
                             ;	ldy #0						; How many digits printed
                             ;	ldx #0						; Index in to string
                             ;out_bcd_digit
AS65 Assembler for R6502 [1.42].                                     Page   50
---------------------------------- bank2.s -----------------------------------

                             ;	lda num_buf,x
                             ;	cpy #0						; If not in leading zero mode
                             ;	bne out_bcd_print			; No then go print
                             ;
                             ;	cmp #'0'					; else check if zero
                             ;	bne out_bcd_print			; No then go print
                             ;
                             ;	plp
                             ;	php
                             ;	bcc out_bcd_next			; If C=0 go to next digit, e
                             ;out_bcd_print
                             ;	iny
                             ;	jsr io_put_ch
                             ;out_bcd_next
                             ;	inx
                             ;	cpx #6
                             ;	bne out_bcd_digit
                             ;	cpy #0						; If nothing printed
                             ;	bne out_bcd_fin
                             ;	lda #'0'					; Need to put out 1 zero
                             ;	jsr io_put_ch
                             ;	iny
                             ;out_bcd_fin
                             ;	plp
                             ;	plx
                             ;	pla
                             ;	clc
                             ;	rts
                             	
                             ;****************************************
                             ;* str_a_to_d
                             ;* Convert X,A to decimal string in sevalptr
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 keep leading zeros else not
                             ;* Output : sevalptr in ASCII max 6 digits
                             ;*          Y=length including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
cb59 :                       str_a_to_d
cb59 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* print_a_to_d
                             ;* Convert X,A to decimal string
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII max 6 digits
                             ;*          Y=digits printed including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
cb5a :                       print_a_to_d
cb5a : 2017cb           [ 6] 	jsr int_to_str
cb5d : a000             [ 2] 	ldy #0
cb5f :                       print_a_to_d_ch
cb5f : b99500           [ 4] 	lda num_buf,y
cb62 : f006             [ 3] 	beq print_a_to_d_fin
cb64 : 20c0c5           [ 6] 	jsr io_put_ch
cb67 : c8               [ 2] 	iny
cb68 : d0f5             [ 3] 	bne print_a_to_d_ch
cb6a :                       print_a_to_d_fin
AS65 Assembler for R6502 [1.42].                                     Page   51
---------------------------------- bank2.s -----------------------------------

cb6a : 60               [ 6] 	rts
                             	
                             
                             ;* Reset vector points here - 6502 starts here
cb6b :                       init
                             ;	jmp init_test
                             	; First clear ram
                             ;	sei					; No need as disabled on startup
                             ;	cld					; No need as disabled on startup
cb6b : a2ff             [ 2] 	ldx #0xff			; Initialise stack pointer
cb6d : 9a               [ 2] 	txs
cb6e : 4cc9cb           [ 3] 	jmp init_ram		; jmp not jsr to ram initialiser
cb71 :                       init_2					; init_ram will jump back to here
                             	
cb71 : 2077cb           [ 6] 	jsr kernel_init
                             
cb74 : 4cffc6           [ 3] 	jmp main
                             
cb77 :                       kernel_init
cb77 : 2052c7           [ 6] 	jsr init_nmi		; Initialise NMI handling
cb7a : 20a2c7           [ 6] 	jsr init_irq		; Initialise IRQ handling
cb7d : 20dec1           [ 6] 	jsr _init_acia		; initialise the serial chip
                             	
cb80 : 20f6c1           [ 6] 	jsr _init_cia0		; initialise cia 0
cb83 : 200ec2           [ 6] 	jsr _init_cia1		; initialise cia 1
cb86 : 2026c5           [ 6] 	jsr _PT3INIT		; Load PT3 player code into shadow
cb89 :                       kernel_test
cb89 : 2056c2           [ 6] 	jsr _init_snd		; initialise the sound chip
cb8c : 206ec2           [ 6] 	jsr _init_keyboard	; initialise keyboard timer s
cb8f : 2036c4           [ 6] 	jsr _vdp_init		; initialise vdp
cb92 : a900             [ 2] 	lda #0				; Default = 40 column mode - put on st
cb94 : 48               [ 3] 	pha
cb95 : a20e             [ 2] 	ldx #NV_MODE		; NV location for default text mod
cb97 : 2096c4           [ 6] 	jsr _rtc_nvread		; Try to read location
cb9a : b00b             [ 3] 	bcs kernel_skip_nv	; If bad NV ram then skip try
cb9c : aa               [ 2] 	tax					; Save the mode temporarily
cb9d : 68               [ 4] 	pla					; Get the default mode from stack
cb9e : 8a               [ 2] 	txa					; And push the NV mode that was read
cb9f : 48               [ 3] 	pha
cba0 : a20f             [ 2] 	ldx #NV_COLOUR		; NV location for the default co
cba2 : 2096c4           [ 6] 	jsr _rtc_nvread		; Try to read location (assumed
cba5 : 8521             [ 3] 	sta vdp_base+vdp_bord_col	; Save it to the borde
cba7 :                       kernel_skip_nv	
cba7 : 68               [ 4] 	pla					; Get the mode (either default or the NV
cba8 : 20c6c1           [ 6] 	jsr _gr_init_screen
cbab : 2086c5           [ 6] 	jsr io_init			; Set default input/output device
cbae : 58               [ 2] 	cli					; irq interrupts enable
                             
                             	; Print the boot up message - requires IO and IR
                             	_println msg_hello_world
                             
                             
                             
cbbc : 204ec4           [ 6] 	jsr _rtc_init		; Initialise RTC - * AFTER INTERR
cbbf : 203ec2           [ 6] 	jsr _init_sdcard	; initialise the sd card interf
cbc2 : 2026c2           [ 6] 	jsr _init_fs		; initialise the filesystem
cbc5 : 202ec0           [ 6] 	jsr _df_init		; Initialise interpreter
                             
cbc8 : 60               [ 6] 	rts
                             
                             	
                             ;* Initialises RAM, skipping pages 4-8 which are 
AS65 Assembler for R6502 [1.42].                                     Page   52
---------------------------------- bank2.s -----------------------------------

                             ;* Zeroes all addressable RAM in the default bank
cbc9 :                       init_ram
cbc9 : 6400             [ 3] 	stz 0x00			; Start at page 0
cbcb : 6401             [ 3] 	stz 0x01
cbcd : a002             [ 2] 	ldy #0x02			; But Y initially at 2 to not overwr
cbcf : a200             [ 2] 	ldx #0x00			; Page counter starts at zero
cbd1 : a900             [ 2] 	lda #0				; Normal RAM filled with zero
cbd3 :                       init_ram_1
cbd3 : e005             [ 2] 	cpx	#5				; Page <5 is ok (zeroes out VIA0 and 1
cbd5 : 9004             [ 3] 	bcc init_ram_fill
cbd7 : e008             [ 2] 	cpx #8				; Page >=8 is ok
cbd9 : 9005             [ 3] 	bcc init_ram_skip	; But >=5 and <8 do not initia
cbdb :                       init_ram_fill
cbdb : 9100             [ 5] 	sta (0x00),y		; Write initialisation value to RA
cbdd : c8               [ 2] 	iny
cbde : d0fb             [ 3] 	bne init_ram_fill	; Do a whole page
cbe0 :                       init_ram_skip
cbe0 : e8               [ 2] 	inx					; Increment page counter
cbe1 : 8601             [ 3] 	stx 0x01			; Save to address pointer
cbe3 : d0ee             [ 3] 	bne init_ram_1		; Do all pages until page 0xff d
                             	
cbe5 : 4c71cb           [ 3] 	jmp init_2			; Carry on initialisation
                             
cbe8 :                       mod_sz_kernel_e
                             
                             
                             	
                             ; Bank specific code goes here
                             	include "sdcard\sdcard.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SDCARD.S
                             ;*  Low level SD card driver routines.  This modu
                             ;*  software bit banging through VIA 2 port B of 
                             ;*  interface.  So the card is clocked in softwar
                             ;*  not great for performance but fast enough for
                             ;*  purposes.  I think we can get around 8.5KB/s 
                             ;*  read/write speed, translating to around 5.5KB
                             ;*  throughput using the filesystem.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
cbe8 :                       mod_sz_sdcard_s
                             
                             ;****************************************
                             ;* init_sdcard
                             ;* Initialise SD card interface after CIA2!
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cbe8 :                       init_sdcard
cbe8 : ad8004           [ 4] 	lda IO_1+PRB					; Detect card
AS65 Assembler for R6502 [1.42].                                     Page   53
---------------------------------- bank2.s -----------------------------------

cbeb : 2904             [ 2] 	and #0x04						; Bit 2 of PRB = 0
cbed : 854b             [ 3] 	sta sd_status
cbef : d046             [ 4] 	bne init_sd_failed				; If not zero then no card
                             	_println sd_msg_initialising
                             
cbfe :                       init_sdcard_try
cbfe : a908             [ 2] 	lda #SD_CS						; Unselect device
cc00 : 0c8004           [ 3] 	tsb SD_REG
cc03 : a901             [ 2] 	lda #SD_CLK						; Set clock low
cc05 : 1c8004           [ 3] 	trb SD_REG
cc08 : a910             [ 2] 	lda #SD_MOSI					; DI/MOSI high
cc0a : 0c8004           [ 3] 	tsb SD_REG
cc0d : a208             [ 2] 	ldx #8							; 8*0.125ms = 1ms
cc0f : 2086c8           [ 6] 	jsr long_delay
                             
cc12 : a208             [ 2] 	ldx #8							; 10 bytes of 0xff
cc14 : a9ff             [ 2] 	lda #0xff
cc16 :                       init_sd_pulse
cc16 : 206fcc           [ 6] 	jsr sd_sendbyte					; Send the 0xff byte
cc19 : ca               [ 2] 	dex
cc1a : d0fa             [ 3] 	bne init_sd_pulse
cc1c : a908             [ 2] 	lda #SD_CS						; Unselect device
cc1e : 0c8004           [ 3] 	tsb SD_REG
                             
cc21 :                       init_cmd0
cc21 : 2030cd           [ 6] 	jsr sd_sendcmd0
cc24 : c9ff             [ 2] 	cmp #0xff						; 0xff is not a valid response
cc26 : d002             [ 3] 	bne init_sd_next
cc28 : f0d4             [ 4] 	beq init_sdcard_try
                             	
cc2a :                       init_sd_next
cc2a :                       init_acmd41
cc2a : 2052cd           [ 6] 	jsr sd_sendcmd55
                             
cc2d : 2074cd           [ 6] 	jsr sd_sendcmd41
                             	
cc30 : c900             [ 2] 	cmp #0							; Was R1 = 0
cc32 : d0f6             [ 3] 	bne init_acmd41					; Retry if not
                             	
cc34 :                       init_cmd16
cc34 : 4c96cd           [ 3] 	jmp sd_sendcmd16
cc37 :                       init_sd_failed
                             	; Got here then the card didn't initialise
                             	_println sd_msg_failed
                             
cc44 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_startcmd
                             ;* Start a cmd frame by sending CS high to low
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cc45 :                       sd_startcmd
cc45 : 48               [ 3] 	pha								; Save A
cc46 : ad0004           [ 4] 	lda IO_0 + PRB					; Get current led status
cc49 : 0902             [ 2] 	ora #KB_LED0					; Initially assume off
cc4b : 4902             [ 2] 	eor #KB_LED0					; Switch on if C=1
cc4d : 8d0004           [ 4] 	sta IO_0 + PRB					; Set the leds
                             
cc50 : a9ff             [ 2] 	lda #0xff						; Send 0xff
AS65 Assembler for R6502 [1.42].                                     Page   54
---------------------------------- bank2.s -----------------------------------

cc52 : 206fcc           [ 6] 	jsr sd_sendbyte					; Delay / synch pulses
cc55 : 206fcc           [ 6] 	jsr sd_sendbyte					; With CS not asserted
                             
cc58 : a908             [ 2] 	lda #SD_CS						; Chip select bit
cc5a : 1c8004           [ 3] 	trb SD_REG						; Now set it low
                             
cc5d : 68               [ 4] 	pla								; Restore A
cc5e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_endcmd
                             ;* End a cmd frame by sending CS high
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cc5f :                       sd_endcmd
cc5f : 48               [ 3] 	pha
                             
cc60 : ad0004           [ 4] 	lda IO_0 + PRB					; Get current led status
cc63 : 0902             [ 2] 	ora #KB_LED0					; Initially assume off
cc65 : 8d0004           [ 4] 	sta IO_0 + PRB					; Set the leds
                             
cc68 : a908             [ 2] 	lda #SD_CS						; Chip select bit
cc6a : 0c8004           [ 3] 	tsb SD_REG						; First set it high
                             
cc6d : 68               [ 4] 	pla
cc6e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_sendbyte
                             ;* Low level byte send routine
                             ;* Input : A = byte to send
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cc6f :                       sd_sendbyte
cc6f : 48               [ 3] 	pha
cc70 : 5a               [ 3] 	phy
                             
cc71 : 8541             [ 3] 	sta tmp_a						; For shifting out
                             
cc73 : a008             [ 2] 	ldy #8							; 8 bits to shift out
cc75 : ad8004           [ 4] 	lda SD_REG						; Load the SD register to A
cc78 :                       sd_shiftoutbit
cc78 : 0910             [ 2] 	ora #SD_MOSI					; And initially set output bit 
cc7a : 0641             [ 5] 	asl tmp_a						; Unless the bit to transmit is '
cc7c : b002             [ 3] 	bcs sd_shiftskiplo				; so then EOR the bit back
cc7e : 4910             [ 2] 	eor #SD_MOSI
cc80 :                       sd_shiftskiplo
cc80 : 8d8004           [ 4] 	sta SD_REG						; Save data bit first, it seems,
                             	
cc83 : ee8004           [ 6] 	inc SD_REG						; Set bit 1 of clock
                             ;	dec SD_REG						; Reset bit 1 of clock
cc86 : 8d8004           [ 4] 	sta SD_REG						; Reset bit 1 of clock
                             
cc89 : 88               [ 2] 	dey								; Count bits
cc8a : d0ec             [ 3] 	bne sd_shiftoutbit				; Until no more bits to se
                             
cc8c : 7a               [ 4] 	ply
cc8d : 68               [ 4] 	pla
                             
AS65 Assembler for R6502 [1.42].                                     Page   55
---------------------------------- bank2.s -----------------------------------

cc8e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_getbyte
                             ;* Low level get a byte
                             ;* Input : A = response byte received
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
                             
cc8f :                       sd_getbyte
cc8f : 5a               [ 3] 	phy
cc90 : da               [ 3] 	phx
                             
cc91 : ad8004           [ 4] 	lda SD_REG
cc94 : 0910             [ 2] 	ora #SD_MOSI					; Set MOSI high
cc96 : 8d8004           [ 4] 	sta SD_REG
cc99 : a8               [ 2] 	tay								; Same as A with clock high
cc9a : c8               [ 2] 	iny
cc9b : aa               [ 2] 	tax								; Same as A with clock low
                             	
                             	; Unroll the code almost 20% faster than looping
                             	; bit 7
cc9c : 8c8004           [ 4] 	sty SD_REG
cc9f : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
cca2 : 8e8004           [ 4] 	stx SD_REG
cca5 : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
cca7 : 2641             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 6
cca9 : 8c8004           [ 4] 	sty SD_REG
ccac : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
ccaf : 8e8004           [ 4] 	stx SD_REG
ccb2 : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
ccb4 : 2641             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 5
ccb6 : 8c8004           [ 4] 	sty SD_REG
ccb9 : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
ccbc : 8e8004           [ 4] 	stx SD_REG
ccbf : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
ccc1 : 2641             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 4
ccc3 : 8c8004           [ 4] 	sty SD_REG
ccc6 : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
ccc9 : 8e8004           [ 4] 	stx SD_REG
cccc : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
ccce : 2641             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 3
ccd0 : 8c8004           [ 4] 	sty SD_REG
ccd3 : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
ccd6 : 8e8004           [ 4] 	stx SD_REG
ccd9 : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
ccdb : 2641             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 2
ccdd : 8c8004           [ 4] 	sty SD_REG
cce0 : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
cce3 : 8e8004           [ 4] 	stx SD_REG
cce6 : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
cce8 : 2641             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 1
ccea : 8c8004           [ 4] 	sty SD_REG
cced : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
ccf0 : 8e8004           [ 4] 	stx SD_REG
AS65 Assembler for R6502 [1.42].                                     Page   56
---------------------------------- bank2.s -----------------------------------

ccf3 : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
ccf5 : 2641             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 0
ccf7 : 8c8004           [ 4] 	sty SD_REG
ccfa : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
ccfd : 8e8004           [ 4] 	stx SD_REG
cd00 : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
cd02 : 2641             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             
cd04 : a541             [ 3] 	lda tmp_a						; Return response in A
                             
cd06 : fa               [ 4] 	plx
cd07 : 7a               [ 4] 	ply
                             
cd08 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_getrespbyte
                             ;* Low level get response routine
                             ;* Input : A = response byte received
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cd09 :                       sd_getrespbyte
cd09 : da               [ 3] 	phx
cd0a : a200             [ 2] 	ldx #0							; Try up to 256 times
cd0c :                       sd_respff
cd0c : e8               [ 2] 	inx								; Retry counter
cd0d : f007             [ 3] 	beq sd_resptimeout
cd0f : 208fcc           [ 6] 	jsr sd_getbyte
cd12 : c9ff             [ 2] 	cmp #0xff						; Keep reading MISO until not FF
cd14 : f0f6             [ 3] 	beq sd_respff
cd16 :                       sd_resptimeout
cd16 : fa               [ 4] 	plx
cd17 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_busy
                             ;* Low level busy check routine
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cd18 :                       sd_busy
cd18 : 48               [ 3] 	pha
cd19 : a54b             [ 3] 	lda sd_status					; If no card then fall out
cd1b : d007             [ 3] 	bne sd_isbusy_fin
cd1d :                       sd_isbusy
cd1d : 208fcc           [ 6] 	jsr sd_getbyte
cd20 : c9ff             [ 2] 	cmp #0xff						; Keep reading MISO until FF
cd22 : d0f9             [ 3] 	bne sd_isbusy
cd24 :                       sd_isbusy_fin
cd24 : 68               [ 4] 	pla
cd25 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_waitforn0byte
                             ;* Low level routine waits for card to be ready
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   57
---------------------------------- bank2.s -----------------------------------

cd26 :                       sd_waitforn0byte
cd26 : a54b             [ 3] 	lda sd_status
cd28 : d005             [ 3] 	bne sd_waitforn0byte_fin
cd2a : 2009cd           [ 6] 	jsr sd_getrespbyte
cd2d : f0f7             [ 3] 	beq sd_waitforn0byte					; Zero byte means not r
cd2f :                       sd_waitforn0byte_fin
cd2f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_sendcmd0
                             ;* Send CMD0
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cd30 :                       sd_sendcmd0
cd30 : 2045cc           [ 6] 	jsr sd_startcmd
                             
                             	; Send 0x40, 0x00, 0x00, 0x00, 0x00, 0x95
cd33 : a940             [ 2] 	lda #0x40
cd35 : 206fcc           [ 6] 	jsr sd_sendbyte
cd38 : a900             [ 2] 	lda #0x00
cd3a : 206fcc           [ 6] 	jsr sd_sendbyte
cd3d : 206fcc           [ 6] 	jsr sd_sendbyte
cd40 : 206fcc           [ 6] 	jsr sd_sendbyte
cd43 : 206fcc           [ 6] 	jsr sd_sendbyte
cd46 : a995             [ 2] 	lda #0x95						; Checksum needs to be right
cd48 : 206fcc           [ 6] 	jsr sd_sendbyte
                             
cd4b : 20bccd           [ 6] 	jsr sd_getrespR1				; Get the response
                             
cd4e : 205fcc           [ 6] 	jsr sd_endcmd
                             	
cd51 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_sendcmd55
                             ;* Send CMD55
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cd52 :                       sd_sendcmd55
cd52 : 2045cc           [ 6] 	jsr sd_startcmd
                             
                             	; Send 0x40+55, 0x00, 0x00, 0x00, 0x00, 0x95
cd55 : a977             [ 2] 	lda #0x40+55
cd57 : 206fcc           [ 6] 	jsr sd_sendbyte
cd5a : a900             [ 2] 	lda #0x00
cd5c : 206fcc           [ 6] 	jsr sd_sendbyte
cd5f : 206fcc           [ 6] 	jsr sd_sendbyte
cd62 : 206fcc           [ 6] 	jsr sd_sendbyte
cd65 : 206fcc           [ 6] 	jsr sd_sendbyte
cd68 : a995             [ 2] 	lda #0x95						; Checksum needs to be right
cd6a : 206fcc           [ 6] 	jsr sd_sendbyte
                             
cd6d : 20bccd           [ 6] 	jsr sd_getrespR1				; Get the response
                             
cd70 : 205fcc           [ 6] 	jsr sd_endcmd
                             	
cd73 : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page   58
---------------------------------- bank2.s -----------------------------------

                             ;****************************************
                             ;* sd_sendcmd41
                             ;* Send ACMD41
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cd74 :                       sd_sendcmd41
cd74 : 2045cc           [ 6] 	jsr sd_startcmd
                             
                             	; Send 0x40+41, 0x00, 0x00, 0x00, 0x00, 0x95
cd77 : a969             [ 2] 	lda #0x40+41
cd79 : 206fcc           [ 6] 	jsr sd_sendbyte
cd7c : a900             [ 2] 	lda #0x00
cd7e : 206fcc           [ 6] 	jsr sd_sendbyte
cd81 : 206fcc           [ 6] 	jsr sd_sendbyte
cd84 : 206fcc           [ 6] 	jsr sd_sendbyte
cd87 : 206fcc           [ 6] 	jsr sd_sendbyte
cd8a : a995             [ 2] 	lda #0x95						; Checksum needs to be right
cd8c : 206fcc           [ 6] 	jsr sd_sendbyte
                             
cd8f : 20bccd           [ 6] 	jsr sd_getrespR1				; Get the response
                             
cd92 : 205fcc           [ 6] 	jsr sd_endcmd
                             	
cd95 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_sendcmd16
                             ;* Send CMD16
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cd96 :                       sd_sendcmd16
cd96 : 2045cc           [ 6] 	jsr sd_startcmd
                             
                             	; Send 0x40+16, 0x00, 0x00, 0x02, 0x00, 0x95
cd99 : a950             [ 2] 	lda #0x40+16
cd9b : 206fcc           [ 6] 	jsr sd_sendbyte
cd9e : a900             [ 2] 	lda #0x00
cda0 : 206fcc           [ 6] 	jsr sd_sendbyte
cda3 : 206fcc           [ 6] 	jsr sd_sendbyte
cda6 : a902             [ 2] 	lda #0x02						; 0x200 block size = 512 bytes
cda8 : 206fcc           [ 6] 	jsr sd_sendbyte
cdab : a900             [ 2] 	lda #0x00
cdad : 206fcc           [ 6] 	jsr sd_sendbyte
cdb0 : a995             [ 2] 	lda #0x95						; Checksum needs to be right
cdb2 : 206fcc           [ 6] 	jsr sd_sendbyte
                             
cdb5 : 20bccd           [ 6] 	jsr sd_getrespR1				; Get the response
                             
cdb8 : 205fcc           [ 6] 	jsr sd_endcmd
                             	
cdbb : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_getrespR1
                             ;* Low level get response R1
                             ;* Input : A = response byte received
                             ;* Output : None
                             ;* Regs affected : None
AS65 Assembler for R6502 [1.42].                                     Page   59
---------------------------------- bank2.s -----------------------------------

                             ;****************************************
cdbc :                       sd_getrespR1
cdbc : 2009cd           [ 6] 	jsr sd_getrespbyte
cdbf : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_sendcmd17
                             ;* Send CMD17
                             ;* Input : sd_sect = 4 bytes of sector offset lit
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cdc0 :                       sd_sendcmd17
cdc0 : da               [ 3] 	phx
cdc1 : 48               [ 3] 	pha								; A is the page to write to
                             	
cdc2 : 2045cc           [ 6] 	jsr sd_startcmd
                             
                             	; Convert sector address to byte address
                             	; Sector address is little endian
                             	; Byte address is big endian
cdc5 : 6455             [ 3] 	stz sd_addr+3					; LSB of address is always 0
cdc7 : a54e             [ 3] 	lda sd_sect+0					; LSB of sector goes to addres
cdc9 : 8554             [ 3] 	sta sd_addr+2					; Equivalent of * 256
cdcb : a54f             [ 3] 	lda sd_sect+1
cdcd : 8553             [ 3] 	sta sd_addr+1
cdcf : a550             [ 3] 	lda sd_sect+2
cdd1 : 8552             [ 3] 	sta sd_addr+0
cdd3 : 18               [ 2] 	clc								; Now addr*2 so equiv to sect*512
cdd4 : 0655             [ 5] 	asl sd_addr+3
cdd6 : 2654             [ 5] 	rol sd_addr+2
cdd8 : 2653             [ 5] 	rol sd_addr+1
cdda : 2652             [ 5] 	rol sd_addr+0
                             
cddc :                       sd_cmd17addr
                             	; Send 0x40+17, 0xA3, 0xA2, 0xA1, 0xA0, 0x95
cddc : a951             [ 2] 	lda #0x40+17
cdde : 206fcc           [ 6] 	jsr sd_sendbyte
cde1 : a552             [ 3] 	lda sd_addr+0
cde3 : 206fcc           [ 6] 	jsr sd_sendbyte
cde6 : a553             [ 3] 	lda sd_addr+1
cde8 : 206fcc           [ 6] 	jsr sd_sendbyte
cdeb : a554             [ 3] 	lda sd_addr+2
cded : 206fcc           [ 6] 	jsr sd_sendbyte
cdf0 : a555             [ 3] 	lda sd_addr+3
cdf2 : 206fcc           [ 6] 	jsr sd_sendbyte
cdf5 : a995             [ 2] 	lda #0x95						; Checksum needs to be right
cdf7 : 206fcc           [ 6] 	jsr sd_sendbyte
                             
cdfa : 2009cd           [ 6] 	jsr sd_getrespbyte
cdfd : aa               [ 2] 	tax								; Save response in X for return
                             
cdfe : 68               [ 4] 	pla								; Get the A param
cdff : 200bce           [ 6] 	jsr sd_getrespR17				; Get the response
                             
ce02 : 2018cd           [ 6] 	jsr sd_busy						; Wait for card to be ready
                             	
ce05 : 205fcc           [ 6] 	jsr sd_endcmd
                             
ce08 : 8a               [ 2] 	txa								; Restore the response byte
ce09 : fa               [ 4] 	plx
                             	
AS65 Assembler for R6502 [1.42].                                     Page   60
---------------------------------- bank2.s -----------------------------------

ce0a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_getrespR17
                             ;* Low level get response R17
                             ;* Input : A = R1 response byte received
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ce0b :                       sd_getrespR17
ce0b : 48               [ 3] 	pha
ce0c : 5a               [ 3] 	phy
                             
ce0d : a44b             [ 3] 	ldy sd_status
ce0f : d025             [ 3] 	bne sd_getrespR17_fin
                             
ce11 : 8540             [ 3] 	sta tmp_v1+1					; Page to read in to
ce13 : 643f             [ 3] 	stz tmp_v1						; Always a page boundary
ce15 :                       sd_getrespR17token
ce15 : 208fcc           [ 6] 	jsr sd_getbyte					; Get a byte
ce18 : c9fe             [ 2] 	cmp #0xfe						; Is it the token?
ce1a : d0f9             [ 3] 	bne sd_getrespR17token			; No
                             	
ce1c : a000             [ 2] 	ldy #0							; read 1st 256 bytes
ce1e :                       sd_getrespR17block1
ce1e : 208fcc           [ 6] 	jsr sd_getbyte					; get a byte
ce21 : 913f             [ 5] 	sta (tmp_v1),y					; Save the byte
ce23 : c8               [ 2] 	iny								; Keep going
ce24 : d0f8             [ 3] 	bne sd_getrespR17block1			; Until all bytes read
                             
ce26 : e640             [ 5] 	inc tmp_v1+1					; Next page
ce28 :                       sd_getrespR17block2
ce28 : 208fcc           [ 6] 	jsr sd_getbyte					; get a byet
ce2b : 913f             [ 5] 	sta (tmp_v1),y					; Save the byte
ce2d : c8               [ 2] 	iny								; Keep going
ce2e : d0f8             [ 3] 	bne sd_getrespR17block2			; Until all bytes read
                             
ce30 : 208fcc           [ 6] 	jsr sd_getbyte					; CRC
ce33 : 208fcc           [ 6] 	jsr sd_getbyte					; CRC
                             	
ce36 :                       sd_getrespR17_fin
ce36 : 7a               [ 4] 	ply
ce37 : 68               [ 4] 	pla
                             
ce38 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* sd_sendcmd24
                             ;* Send CMD24
                             ;* Input : sd_sect = 4 bytes of sector offset lit
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ce39 :                       sd_sendcmd24
ce39 : 5a               [ 3] 	phy
ce3a : 48               [ 3] 	pha
                             
ce3b : 2045cc           [ 6] 	jsr sd_startcmd
                             
                             	; Convert sector address to byte address
                             	; Sector address is little endian
AS65 Assembler for R6502 [1.42].                                     Page   61
---------------------------------- bank2.s -----------------------------------

                             	; Byte address is big endian
ce3e : 6455             [ 3] 	stz sd_addr+3					; LSB of address is always 0
ce40 : a54e             [ 3] 	lda sd_sect+0					; LSB of sector goes to addres
ce42 : 8554             [ 3] 	sta sd_addr+2					; Equivalent of * 256
ce44 : a54f             [ 3] 	lda sd_sect+1
ce46 : 8553             [ 3] 	sta sd_addr+1
ce48 : a551             [ 3] 	lda sd_sect+3
ce4a : 8552             [ 3] 	sta sd_addr+0
ce4c : 18               [ 2] 	clc								; Now addr*2 so equiv to sect*512
ce4d : 0655             [ 5] 	asl sd_addr+3
ce4f : 2654             [ 5] 	rol sd_addr+2
ce51 : 2653             [ 5] 	rol sd_addr+1
ce53 : 2652             [ 5] 	rol sd_addr+0
                             
                             	; Send 0x40+24, 0xA0, 0xA1, 0xA2, 0xA3, 0x95
ce55 : a958             [ 2] 	lda #0x40+24
ce57 : 206fcc           [ 6] 	jsr sd_sendbyte
ce5a : a552             [ 3] 	lda sd_addr+0
ce5c : 206fcc           [ 6] 	jsr sd_sendbyte
ce5f : a553             [ 3] 	lda sd_addr+1
ce61 : 206fcc           [ 6] 	jsr sd_sendbyte
ce64 : a554             [ 3] 	lda sd_addr+2
ce66 : 206fcc           [ 6] 	jsr sd_sendbyte
ce69 : a555             [ 3] 	lda sd_addr+3
ce6b : 206fcc           [ 6] 	jsr sd_sendbyte
ce6e : a995             [ 2] 	lda #0x95					; Checksum needs to be right
ce70 : 206fcc           [ 6] 	jsr sd_sendbyte
                             
ce73 : 2009cd           [ 6] 	jsr sd_getrespbyte			; Get response
                             
ce76 : 208fcc           [ 6] 	jsr sd_getbyte
                             	
ce79 : a9fe             [ 2] 	lda #0xfe					; Start of data token
ce7b : 206fcc           [ 6] 	jsr sd_sendbyte
                             
ce7e : 68               [ 4] 	pla							; Retrieve the address high byte
ce7f : 8540             [ 3] 	sta tmp_v1+1
ce81 : 643f             [ 3] 	stz tmp_v1					; Address is always page boundary
                             
ce83 : a000             [ 2] 	ldy #00
ce85 :                       sd_writeblock_1					; Send first 256 bytes
ce85 : b13f             [ 5] 	lda (tmp_v1), y
ce87 : 206fcc           [ 6] 	jsr sd_sendbyte
ce8a : c8               [ 2] 	iny
ce8b : d0f8             [ 3] 	bne sd_writeblock_1
ce8d : e640             [ 5] 	inc tmp_v1+1				; Next page for second 256 bytes
ce8f :                       sd_writeblock_2					; Send second 256 bytes
ce8f : b13f             [ 5] 	lda (tmp_v1), y
ce91 : 206fcc           [ 6] 	jsr sd_sendbyte
ce94 : c8               [ 2] 	iny
ce95 : d0f8             [ 3] 	bne sd_writeblock_2
                             
ce97 : a9aa             [ 2] 	lda #0xaa					; Arbitrary CRC bytes
ce99 : 206fcc           [ 6] 	jsr sd_sendbyte
ce9c : 206fcc           [ 6] 	jsr sd_sendbyte
                             
ce9f : 208fcc           [ 6] 	jsr sd_getbyte				; Get data response byte
cea2 : 48               [ 3] 	pha							; Save it to return
                             
cea3 :                       sd_waitforwritecomplete
cea3 : 2018cd           [ 6] 	jsr sd_busy					; Wait for card to be ready
                             	
AS65 Assembler for R6502 [1.42].                                     Page   62
---------------------------------- bank2.s -----------------------------------

cea6 : 205fcc           [ 6] 	jsr sd_endcmd				; Release the card
                             
cea9 : 68               [ 4] 	pla
ceaa : 7a               [ 4] 	ply
ceab : 60               [ 6] 	rts
                             
                             	
ceac :                       sd_msg_initialising
ceac : 0d496e69746961..      	db "\rInitialising SD Card\r", 0
cec3 :                       sd_msg_failed
cec3 : 0d426164206f72..      	db "\rBad or missing SD Card\r", 0
                             
cedc :                       sd_cmd55
cedc : 770000000095          	db (0x40+55), 0x00, 0x00, 0x00, 0x00, 0x95
cee2 :                       sd_cmd58
cee2 : 7a0000000095          	db (0x40+58), 0x00, 0x00, 0x00, 0x00, 0x95
cee8 :                       sd_acmd41
cee8 : 690000000095          	db (0x40+41), 0x00, 0x00, 0x00, 0x00, 0x95
                             	
ceee :                       mod_sz_sdcard_e
                             
                             	include "sdcard\sd_fs.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SD_FS.S
                             ;*  FAT16 filesystem module.  Implements a basic 
                             ;*  filesystem to enable mass storage support.
                             ;*  I've been a bit naughty in that I have assume
                             ;*  sd card size and sector 0 is the MBR.  This i
                             ;*  always the case, but it works for me so I cou
                             ;*  the time be asked to sort it out. I may fix t
                             ;*  more general use at some point..
                             ;*  The filesystem now supports sub directories a
                             ;*  implements the folling:
                             ;*  - load a file
                             ;*  - save a file
                             ;*  - delete a file from the card
                             ;*  - perform a directory listing
                             ;*  - change to subdirectory
                             ;*  I have to say I am pretty pleased with this, 
                             ;*  of reading and research!
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code
                             
ceee :                       mod_sz_sd_fs_s
                             
                             	include "sdcard\sd_fs.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
AS65 Assembler for R6502 [1.42].                                     Page   63
---------------------------------- bank2.s -----------------------------------

                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SD_FS.I
                             ;*  FAT16 filesystem definitions.  Nothing to see
                             ;*
                             ;************************************************
0001 =                       FS_FILEMODER    =   0x01
0080 =                       FS_FILEMODEW    =   0x80
002f =                       FS_FOLDERCH     =   '/'
                             
                             
                             ;****************************************
                             ;* init_fs
                             ;* Initialise filesystem - after sd card!
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ceee :                       init_fs
ceee : a64b             [ 3] 	ldx sd_status
cef0 : f00e             [ 4] 	beq init_fs_do
                             	_println msg_noinit_fs
                             
ceff : 60               [ 6] 	rts
                             
cf00 :                       init_fs_do
                             	_println msg_initialising_fs
                             
                             
                             	;Load MBR sector 0
cf0d : a203             [ 2] 	ldx #0x03					; Init sector to 0 (MBR)
cf0f :                       init_fs_clr_sect
cf0f : 744e             [ 4] 	stz sd_sect,x
cf11 : ca               [ 2] 	dex
cf12 : 10fb             [ 3] 	bpl init_fs_clr_sect
                             
cf14 : a902             [ 2] 	lda #hi(sd_buf)				; Read in to the buffer
cf16 : 20c0cd           [ 6] 	jsr sd_sendcmd17			; Call read block
                             
                             	;Find sector of partition 1
cf19 : a203             [ 2] 	ldx #0x03					; Get partition 1
cf1b :                       init_fs_get_part1
cf1b : bdc603           [ 4] 	lda sd_buf+MBR_BootPart1,x
cf1e : 954e             [ 4] 	sta sd_sect,x
cf20 : 9d310c           [ 5] 	sta fs_bootsect,x			; This is also the 'bootsect
cf23 : ca               [ 2] 	dex
cf24 : 10f5             [ 3] 	bpl init_fs_get_part1
                             	; Get partition 1 sector
cf26 : a902             [ 2] 	lda #hi(sd_buf)				; Read in to the buffer
cf28 : 20c0cd           [ 6] 	jsr sd_sendcmd17			; Call read block
                             
                             	; Calculate start of FAT tables
                             	; Assuming there are about 64k clusters
                             	; Each cluster assumed to be 32k sectors
                             	; Each sector is 512 bytes (0.5k)
                             	; Giving 64k x 32k x 0.5 ~ 1GB storage
cf2b : 18               [ 2] 	clc
cf2c : ad310c           [ 4] 	lda fs_bootsect
cf2f : 6d0e02           [ 4] 	adc sd_buf+MBR_ResvSect
cf32 : 8d350c           [ 4] 	sta fs_fatsect
cf35 : ad320c           [ 4] 	lda fs_bootsect+1
AS65 Assembler for R6502 [1.42].                                     Page   64
---------------------------------- bank2.s -----------------------------------

cf38 : 6d0f02           [ 4] 	adc sd_buf+MBR_ResvSect+1
cf3b : 8d360c           [ 4] 	sta fs_fatsect+1
cf3e : 9c370c           [ 4] 	stz fs_fatsect+2
cf41 : 9c380c           [ 4] 	stz fs_fatsect+3
                             	
                             	; Calculate start of Root Directory
cf44 : ad1602           [ 4] 	lda sd_buf+MBR_SectPerFAT	; Initialise to 2 * Se
cf47 : 0a               [ 2] 	asl a
cf48 : 8d390c           [ 4] 	sta fs_rootsect
cf4b : ad1702           [ 4] 	lda sd_buf+MBR_SectPerFAT+1
cf4e : 2a               [ 2] 	rol a
cf4f : 8d3a0c           [ 4] 	sta fs_rootsect+1
cf52 : 9c3b0c           [ 4] 	stz fs_rootsect+2
cf55 : 9c3c0c           [ 4] 	stz fs_rootsect+3
                             
                             	; Now add FAT offset
cf58 : 18               [ 2] 	clc
cf59 : a200             [ 2] 	ldx #0x00
cf5b : a004             [ 2] 	ldy #4
cf5d :                       fs_init_add_fat
cf5d : bd350c           [ 4] 	lda fs_fatsect,x
cf60 : 7d390c           [ 4] 	adc fs_rootsect,x
cf63 : 9d390c           [ 5] 	sta fs_rootsect,x
cf66 : e8               [ 2] 	inx
cf67 : 88               [ 2] 	dey
cf68 : d0f3             [ 3] 	bne fs_init_add_fat
                             	
                             	; Calculate start of data area
                             	; Assuming 512 root dir entries
                             	; Each entry = 32 bytes
                             	; Divided by bytes per sector
                             	; to get sector count
cf6a : a920             [ 2] 	lda #32						; (512*32)/512 = 32
cf6c : 8d3d0c           [ 4] 	sta fs_datasect
cf6f : 9c3e0c           [ 4] 	stz fs_datasect+1
cf72 : 9c3f0c           [ 4] 	stz fs_datasect+2
cf75 : 9c400c           [ 4] 	stz fs_datasect+3
                             
                             	; Now add root directory offset
cf78 : 18               [ 2] 	clc
cf79 : a200             [ 2] 	ldx #0x00
cf7b : a004             [ 2] 	ldy #4
cf7d :                       fs_init_data
cf7d : bd390c           [ 4] 	lda fs_rootsect,x
cf80 : 7d3d0c           [ 4] 	adc fs_datasect,x
cf83 : 9d3d0c           [ 5] 	sta fs_datasect,x
cf86 : e8               [ 2] 	inx
cf87 : 88               [ 2] 	dey
cf88 : d0f3             [ 3] 	bne fs_init_data
                             
cf8a : 38               [ 2] 	sec							; Now subtract 2 clusters worth of sec
cf8b : ad3d0c           [ 4] 	lda fs_datasect+0			; to enable easy use of clus
cf8e : e940             [ 2] 	sbc #0x40					; FS handling routines
cf90 : 8d3d0c           [ 4] 	sta fs_datasect+0			; Each cluster = 32 sectors
cf93 : ad3e0c           [ 4] 	lda fs_datasect+1			; Therefore take off 0x40 se
cf96 : e900             [ 2] 	sbc #0
cf98 : 8d3e0c           [ 4] 	sta fs_datasect+1
cf9b : ad3f0c           [ 4] 	lda fs_datasect+2
cf9e : e900             [ 2] 	sbc #0
cfa0 : 8d3f0c           [ 4] 	sta fs_datasect+2
cfa3 : ad400c           [ 4] 	lda fs_datasect+3
cfa6 : e900             [ 2] 	sbc #0
AS65 Assembler for R6502 [1.42].                                     Page   65
---------------------------------- bank2.s -----------------------------------

cfa8 : 8d400c           [ 4] 	sta fs_datasect+3
                             
                             	; Go to root directory using zero cluster #
cfab : 6479             [ 3] 	stz fh_handle+FH_FirstClust
cfad : 647a             [ 3] 	stz fh_handle+FH_FirstClust+1
cfaf : 2045d5           [ 6] 	jsr fs_chdir_direct
                             	
cfb2 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_getbyte_sd_buf
                             ;* Given a populated SD buffer, get byte
                             ;* Indexed by X,Y (X=lo,Y=hi) 
                             ;* Input : X,Y make 9 bit index
                             ;* Output : A=Byte
                             ;* Regs affected : None
                             ;****************************************
cfb3 :                       fs_getbyte_sd_buf
                             	; if bit 9<>0 then 2nd half of sd_buf
cfb3 : 98               [ 2] 	tya
cfb4 : 2901             [ 2] 	and #1
cfb6 : d004             [ 3] 	bne fs_getbyte_sd_buf_hi
cfb8 : bd0002           [ 4] 	lda sd_buf,x
cfbb : 60               [ 6] 	rts
cfbc :                       fs_getbyte_sd_buf_hi
cfbc : bd0003           [ 4] 	lda sd_buf+0x100,x
cfbf : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_putbyte_sd_buf
                             ;* Given a populated SD buffer, put byte
                             ;* Indexed by X,Y (X=lo,Y=hi), A=Val 
                             ;* Input : X,Y make 9 bit index, A=byte
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cfc0 :                       fs_putbyte_sd_buf
cfc0 : 48               [ 3] 	pha
                             	; if bit 9<>0 then 2nd half of sd_buf
cfc1 : 98               [ 2] 	tya
cfc2 : 2901             [ 2] 	and #1
cfc4 : d005             [ 3] 	bne fs_putbyte_sd_buf_hi
cfc6 : 68               [ 4] 	pla
cfc7 : 9d0002           [ 5] 	sta sd_buf,x
cfca : 60               [ 6] 	rts
cfcb :                       fs_putbyte_sd_buf_hi
cfcb : 68               [ 4] 	pla
cfcc : 9d0003           [ 5] 	sta sd_buf+0x100,x
cfcf : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_getword_sd_buf
                             ;* Given a populated SD buffer, get word
                             ;* Indexed by Y which is word aligned 
                             ;* Input : Y=Word offset in to sd_buf
                             ;* Output : X,A=Word
                             ;* Regs affected : Y
                             ;****************************************
cfd0 :                       fs_getword_sd_buf
cfd0 : 98               [ 2] 	tya
AS65 Assembler for R6502 [1.42].                                     Page   66
---------------------------------- bank2.s -----------------------------------

cfd1 : 0a               [ 2] 	asl a
cfd2 : a8               [ 2] 	tay
cfd3 : b007             [ 3] 	bcs fs_getword_sd_buf_hi
cfd5 : be0002           [ 4] 	ldx sd_buf,y
cfd8 : b90102           [ 4] 	lda sd_buf+1,y
cfdb : 60               [ 6] 	rts
cfdc :                       fs_getword_sd_buf_hi
cfdc : be0003           [ 4] 	ldx sd_buf+0x100,y
cfdf : b90103           [ 4] 	lda sd_buf+0x100+1,y
cfe2 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_putword_sd_buf
                             ;* Given a populated SD buffer, put word
                             ;* Indexed by Y which is word aligned 
                             ;* Input : Y=Word offset in to sd_buf
                             ;*         X,A=Word
                             ;* Regs affected : Y
                             ;****************************************
cfe3 :                       fs_putword_sd_buf
cfe3 : 48               [ 3] 	pha
cfe4 : 98               [ 2] 	tya
cfe5 : 0a               [ 2] 	asl a
cfe6 : a8               [ 2] 	tay
cfe7 : b009             [ 3] 	bcs fs_putword_sd_buf_hi
cfe9 : 8a               [ 2] 	txa
cfea : 990002           [ 5] 	sta sd_buf,y
cfed : 68               [ 4] 	pla
cfee : 990102           [ 5] 	sta sd_buf+1,y
cff1 : 60               [ 6] 	rts
cff2 :                       fs_putword_sd_buf_hi
cff2 : 8a               [ 2] 	txa
cff3 : 990003           [ 5] 	sta sd_buf+0x100,y
cff6 : 68               [ 4] 	pla
cff7 : 990103           [ 5] 	sta sd_buf+0x100+1,y
cffa : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_dir_root_start
                             ;* Initialise ready to read root directory
                             ;* Input : dirsect is current directory pointer
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cffb :                       fs_dir_root_start
                             	; Set SD sector to root directory
cffb : a203             [ 2] 	ldx #0x03
cffd :                       fs_dir_set_sd
cffd : bd410c           [ 4] 	lda fs_dirsect,x
d000 : 954e             [ 4] 	sta sd_sect,x
d002 : ca               [ 2] 	dex
d003 : 10f8             [ 4] 	bpl fs_dir_set_sd
                             
                             	; SD buffer is where blocks will be read to
d005 : 644c             [ 3] 	stz sd_slo
d007 : a902             [ 2] 	lda #hi(sd_buf)
d009 : 854d             [ 3] 	sta sd_shi
                             
                             	; Load up first sector in to SD buf
d00b : a902             [ 2] 	lda #hi(sd_buf)
AS65 Assembler for R6502 [1.42].                                     Page   67
---------------------------------- bank2.s -----------------------------------

d00d : 20c0cd           [ 6] 	jsr sd_sendcmd17
                             
d010 : 60               [ 6] 	rts
                             
                             
                             ;* Wrapper function preserving A,X,Y
d011 :                       fs_dir_root_start_w
d011 : 48               [ 3] 	pha
d012 : da               [ 3] 	phx
d013 : 5a               [ 3] 	phy
                             	
d014 : 20fbcf           [ 6] 	jsr fs_dir_root_start
                             	
d017 : 7a               [ 4] 	ply
d018 : fa               [ 4] 	plx
d019 : 68               [ 4] 	pla
d01a : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_dir_find_entry
                             ;* Read directory entry
                             ;* Input : sd_slo, sd_shi : Pointer to directory 
                             ;* Input : C = 0 only find active files.  C = 1 f
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d01b :                       fs_dir_find_entry
d01b : 08               [ 3] 	php							; Save C state for checking later
d01c :                       fs_dir_check_entry
                             	; Not LFN aware
d01c : a00b             [ 2] 	ldy #FAT_Attr				; Check attribute
d01e : a9ce             [ 2] 	lda #0xce					; Any of H, S, V, I then skip
d020 : 314c             [ 5] 	and (sd_slo),y
d022 : d01a             [ 3] 	bne fs_dir_find_another
d024 : a000             [ 2] 	ldy #FAT_Name				; Examine 1st byte of name
d026 : b14c             [ 5] 	lda (sd_slo),y
d028 : 28               [ 4] 	plp							; Check C
d029 : 08               [ 3] 	php
d02a : 900a             [ 3] 	bcc	fs_find_active_slot		; Looking to find an ac
d02c : c900             [ 2] 	cmp #0						; Else looking for 0 or 0xe5
d02e : f020             [ 3] 	beq fs_dir_found_empty
d030 : c9e5             [ 2] 	cmp #0xe5
d032 : f01c             [ 3] 	beq fs_dir_found_empty
d034 : 8008             [ 3] 	bra fs_dir_find_another		; Else not an entry we'
d036 :                       fs_find_active_slot
d036 : c900             [ 2] 	cmp #0
d038 : f009             [ 3] 	beq fs_dir_notfound			; If zero then no more ent
d03a : c9e5             [ 2] 	cmp #0xe5					; Deleted entry?
d03c : d008             [ 3] 	bne fs_dir_found_active
d03e :                       fs_dir_find_another
d03e : 2060d0           [ 6] 	jsr fs_dir_next_entry		; Advance read for next i
d041 : 80d9             [ 3] 	bra fs_dir_check_entry
                             
d043 :                       fs_dir_notfound					; No more entries
d043 : 28               [ 4] 	plp							; Remove temp P from stack
d044 : 38               [ 2] 	sec							; Set carry to indicate no more
d045 : 60               [ 6] 	rts
                             
d046 :                       fs_dir_found_active
d046 : a01f             [ 2] 	ldy #FATFileDesc-1			; Cache the sd entry to fs_
d048 :                       fs_dir_copy_sd_entry_byte
AS65 Assembler for R6502 [1.42].                                     Page   68
---------------------------------- bank2.s -----------------------------------

d048 : b14c             [ 5] 	lda (sd_slo),y
d04a : 99110c           [ 5] 	sta fs_direntry,y
d04d : 88               [ 2] 	dey
d04e : 10f8             [ 3] 	bpl fs_dir_copy_sd_entry_byte
d050 :                       fs_dir_found_empty
d050 : 2096d0           [ 6] 	jsr fs_dir_entry_to_fhandle	; Now copy to file h
d053 : 28               [ 4] 	plp							; Remove temp P from stack
d054 : 18               [ 2] 	clc							; Clear carry to indicate found
d055 :                       fs_dir_fin						; Finalise
d055 : 60               [ 6] 	rts
                             
                             ;* Wrapper function preserving A,X,Y
d056 :                       fs_dir_find_entry_w
d056 : 48               [ 3] 	pha
d057 : da               [ 3] 	phx
d058 : 5a               [ 3] 	phy
                             	
d059 : 201bd0           [ 6] 	jsr fs_dir_find_entry
                             	
d05c : 7a               [ 4] 	ply
d05d : fa               [ 4] 	plx
d05e : 68               [ 4] 	pla
d05f : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* fs_dir_next_entry
                             ;* Jump to next directory entry (32 bytes)
                             ;* Load next sector if required
                             ;* Input : sd_slo, sd_shi : Pointer to directory 
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d060 :                       fs_dir_next_entry
d060 : 18               [ 2] 	clc							; Jump to next 32 byte entry
d061 : a54c             [ 3] 	lda sd_slo					; Update sd_slo, sd_shi
d063 : 6920             [ 2] 	adc #32
d065 : 854c             [ 3] 	sta sd_slo
d067 : a54d             [ 3] 	lda sd_shi
d069 : 6900             [ 2] 	adc #0
d06b : 854d             [ 3] 	sta sd_shi
d06d : c904             [ 2] 	cmp #hi(sd_buf+0x200)		; If not at end of sector
d06f : d01a             [ 3] 	bne fs_dir_next_done		; then don't load next sec
                             
                             	; Advance the sector
d071 : a200             [ 2] 	ldx #0x00
d073 : a004             [ 2] 	ldy #0x04
d075 : 38               [ 2] 	sec
d076 :                       fs_dir_inc_sect
d076 : b54e             [ 4] 	lda sd_sect,x
d078 : 6900             [ 2] 	adc #0
d07a : 954e             [ 4] 	sta sd_sect,x
d07c : e8               [ 2] 	inx
d07d : 88               [ 2] 	dey
d07e : d0f6             [ 3] 	bne fs_dir_inc_sect
                             	
                             	; Reset SD buffer  where blocks will be read to
d080 : 644c             [ 3] 	stz sd_slo
d082 : a902             [ 2] 	lda #hi(sd_buf)
d084 : 854d             [ 3] 	sta sd_shi
                             
d086 : a902             [ 2] 	lda #hi(sd_buf)				; Goes in to sd_buf
AS65 Assembler for R6502 [1.42].                                     Page   69
---------------------------------- bank2.s -----------------------------------

d088 : 20c0cd           [ 6] 	jsr sd_sendcmd17			; Load it
                             
d08b :                       fs_dir_next_done
d08b : 60               [ 6] 	rts
                             
                             ;* Wrapper function preserving A,X,Y
d08c :                       fs_dir_entry_next_w
d08c : 48               [ 3] 	pha
d08d : da               [ 3] 	phx
d08e : 5a               [ 3] 	phy
                             	
d08f : 2060d0           [ 6] 	jsr fs_dir_next_entry
                             	
d092 : 7a               [ 4] 	ply
d093 : fa               [ 4] 	plx
d094 : 68               [ 4] 	pla
d095 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_dir_entry_to_fhandle
                             ;* Copy directory entry from fs_direntry to fh_ha
                             ;* Input : fs_direntry (32 bytes file descriptor 
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d096 :                       fs_dir_entry_to_fhandle
                             	;* Translate name to a string in fhandle
d096 : a200             [ 2] 	ldx #FH_Name				; Destination
d098 : a000             [ 2] 	ldy #FAT_Name				; Source
d09a :                       fs_dir_get_fs_name_ch
d09a : b9110c           [ 4] 	lda fs_direntry,y			; Get name char
d09d : c920             [ 2] 	cmp #' '					; Don't copy space
d09f : f00e             [ 3] 	beq	fs_dir_skip_fs_name_ch
d0a1 : c008             [ 2] 	cpy #FAT_Ext				; At extension?
d0a3 : d007             [ 3] 	bne fs_dir_skip_fs_dot_ch
d0a5 : 48               [ 3] 	pha
d0a6 : a92e             [ 2] 	lda #'.'					; Inject dot into handle
d0a8 : 9556             [ 4] 	sta fh_handle,x
d0aa : 68               [ 4] 	pla
d0ab : e8               [ 2] 	inx							; Advance past dot separator
d0ac :                       fs_dir_skip_fs_dot_ch
d0ac : 9556             [ 4] 	sta fh_handle,x				; Copy char to handle
d0ae : e8               [ 2] 	inx							; Advance handle
d0af :                       fs_dir_skip_fs_name_ch
d0af : c8               [ 2] 	iny							; Source
d0b0 : c00b             [ 2] 	cpy #FAT_Attr				; Passed end of name?
d0b2 : d0e6             [ 3] 	bne fs_dir_get_fs_name_ch
d0b4 : 7456             [ 4] 	stz fh_handle,x				; Put 0 (terminator)
                             
                             	;* Attribute byte
d0b6 : a20d             [ 2] 	ldx #FH_Attr				; Point to where attribute will 
d0b8 : a00b             [ 2] 	ldy #FAT_Attr				; Point to where attribute come
d0ba : 20fdd0           [ 6] 	jsr fs_dir_entry_to_fh_byte
                             
                             	;* File size
d0bd : a20e             [ 2] 	ldx #FH_Size				; Point to where size will go
d0bf : a01c             [ 2] 	ldy #FAT_FileSize			; Point to get size from
d0c1 : 20fdd0           [ 6] 	jsr fs_dir_entry_to_fh_byte	; Copy 4 bytes
d0c4 : 20fdd0           [ 6] 	jsr fs_dir_entry_to_fh_byte
d0c7 : 20fdd0           [ 6] 	jsr fs_dir_entry_to_fh_byte
d0ca : 20fdd0           [ 6] 	jsr fs_dir_entry_to_fh_byte
AS65 Assembler for R6502 [1.42].                                     Page   70
---------------------------------- bank2.s -----------------------------------

                             
                             	;* First cluster
d0cd : a223             [ 2] 	ldx #FH_FirstClust
d0cf : a01a             [ 2] 	ldy	#FAT_FirstClust
d0d1 : 20fdd0           [ 6] 	jsr fs_dir_entry_to_fh_byte	; Copy 2 bytes
d0d4 : 20fdd0           [ 6] 	jsr fs_dir_entry_to_fh_byte
                             
                             	;* Time and date - ignore ms and use modified da
d0d7 : a227             [ 2] 	ldx #FH_TimeDate
d0d9 : 7456             [ 4] 	stz fh_handle,x
d0db : e8               [ 2] 	inx							; Skip ms to time/date 4 bytes
d0dc : a016             [ 2] 	ldy	#FAT_ModTime			; Get modified time/date entr
d0de : 20fdd0           [ 6] 	jsr fs_dir_entry_to_fh_byte	; Copy 4 bytes (2 by
d0e1 : 20fdd0           [ 6] 	jsr fs_dir_entry_to_fh_byte 
d0e4 : 20fdd0           [ 6] 	jsr fs_dir_entry_to_fh_byte ; (2 bytes for date)
d0e7 : 20fdd0           [ 6] 	jsr fs_dir_entry_to_fh_byte
                             	
                             	; Meta data - remember the parent directory
d0ea : a203             [ 2] 	ldx #0x03
d0ec :                       fs_dir_dirsect_fh_byte
d0ec : bd410c           [ 4] 	lda fs_dirsect,x
d0ef : 9573             [ 4] 	sta fh_handle+FH_DirSect,x
d0f1 : ca               [ 2] 	dex
d0f2 : 10f8             [ 3] 	bpl fs_dir_dirsect_fh_byte
                             
                             	; Meta data - remember the offset in to the sd b
d0f4 : a54c             [ 3] 	lda sd_slo
d0f6 : 8577             [ 3] 	sta fh_handle+FH_DirOffset
d0f8 : a54d             [ 3] 	lda sd_shi
d0fa : 8578             [ 3] 	sta fh_handle+FH_DirOffset+1
                             	
d0fc : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* fs_dir_entry_to_fh_byte
                             ;* Copy fs_direntry bytes to fh_handle area
                             ;* Input 	: y = offset in directory entry
                             ;*		 	: x = offset in handle entry
                             ;* Output 	: None
                             ;* Regs affected : All
                             ;****************************************
d0fd :                       fs_dir_entry_to_fh_byte
d0fd : b9110c           [ 4] 	lda fs_direntry,y
d100 : 9556             [ 4] 	sta fh_handle,x
d102 : c8               [ 2] 	iny
d103 : e8               [ 2] 	inx
d104 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_dir_entry_to_sd
                             ;* Copy fs_direntry bytes to sd card area
                             ;* Index by sd_lo, sd_hi
                             ;* Input	: None
                             ;* Output 	: None
                             ;* Regs affected : All
                             ;****************************************
d105 :                       fs_dir_entry_to_sd
d105 : a21f             [ 2] 	ldx #FATFileDesc-1
d107 :                       fs_dir_entry_to_sd_byte
d107 : b9110c           [ 4] 	lda fs_direntry,y
d10a : 9556             [ 4] 	sta fh_handle,x
AS65 Assembler for R6502 [1.42].                                     Page   71
---------------------------------- bank2.s -----------------------------------

d10c : c8               [ 2] 	iny
d10d : e8               [ 2] 	inx
d10e : 60               [ 6] 	rts
                             
                             
                             
                             ;****************************************
                             ;* fs_dir_fhandle_to_entry
                             ;* Copy directory entry from fh_handle to fs_dire
                             ;* Input : fs_fhandle 
                             ;* Output : fs_direntry updated
                             ;* Regs affected : None
                             ;****************************************
d10f :                       fs_dir_fhandle_to_entry
                             	; Set to spaces (11 in total)
d10f : a00a             [ 2] 	ldy #10
d111 : a920             [ 2] 	lda #' '
d113 :                       fs_dir_clear_entry
d113 : 99110c           [ 5] 	sta fs_direntry+FAT_Name,y
d116 : 88               [ 2] 	dey
d117 : 10fa             [ 3] 	bpl fs_dir_clear_entry
                             	;* Translate name to a string in direntry
d119 : a200             [ 2] 	ldx #FH_Name				; Source
d11b : a000             [ 2] 	ldy #FAT_Name				; Destination
d11d :                       fs_dir_get_fh_name_ch
d11d : b556             [ 4] 	lda fh_handle,x				; Get name char
d11f : f021             [ 3] 	beq	fs_dir_do_attr			; Process attribute if end 
d121 : 201bd2           [ 6] 	jsr fs_to_upper				; Case insensitive
d124 : c92e             [ 2] 	cmp #'.'					; Extension separator?
d126 : d011             [ 3] 	bne fs_dir_skip_ext			; No, then normal char
d128 : e000             [ 2] 	cpx #0						; If dot is first char
d12a : f00d             [ 3] 	beq fs_dir_skip_ext			; Then treat as normal cha
d12c : e001             [ 2] 	cpx #1						; If dot is not second char
d12e : d004             [ 3] 	bne fs_dir_get_fh_dot		; Then treat as dot
d130 : c556             [ 3] 	cmp fh_handle				; Was the first char dot?
d132 : f005             [ 3] 	beq fs_dir_skip_ext			; Yes then treat as normal
d134 :                       fs_dir_get_fh_dot
d134 : a008             [ 2] 	ldy #FAT_Ext				; Move to ext position
d136 : e8               [ 2] 	inx							; Jump over the dot
d137 : 80e4             [ 3] 	bra fs_dir_get_fh_name_ch	; Try more chars
d139 :                       fs_dir_skip_ext					; Normal char processing
d139 : 99110c           [ 5] 	sta fs_direntry,y			; Save it to direntry
d13c : c8               [ 2] 	iny							; Advance entry index
d13d : e8               [ 2] 	inx							; Advance string index
d13e : c00b             [ 2] 	cpy #FAT_Attr				; All name + ext done?
d140 : d0db             [ 3] 	bne fs_dir_get_fh_name_ch	; Try for another norm
                             	;* Attribute byte
d142 :                       fs_dir_do_attr
d142 : a20d             [ 2] 	ldx #FH_Attr				; Point to where attribute will 
d144 : a00b             [ 2] 	ldy #FAT_Attr				; Point to where attribute come
d146 : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte
                             
                             	;* File size
d149 :                       fs_dir_fh_size
d149 : a20e             [ 2] 	ldx #FH_Size				; Point to where size will go
d14b : a01c             [ 2] 	ldy #FAT_FileSize			; Point to get size from
d14d : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte	; Copy 4 bytes
d150 : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte
d153 : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte
d156 : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte
                             
                             	;* First cluster
AS65 Assembler for R6502 [1.42].                                     Page   72
---------------------------------- bank2.s -----------------------------------

d159 :                       fs_dir_entry_clust
d159 : a223             [ 2] 	ldx #FH_FirstClust
d15b : a01a             [ 2] 	ldy	#FAT_FirstClust
d15d : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte	; Copy 2 bytes
d160 : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte
                             
                             	;* Time and date
d163 : a227             [ 2] 	ldx #FH_TimeDate
d165 : a00d             [ 2] 	ldy	#FAT_Createms
d167 : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte	; ms
d16a : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte ; time
d16d : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte
d170 : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte ; date
d173 : 2088d1           [ 6] 	jsr fs_dir_fh_to_entry_byte
                             	
                             	; Meta data - remember the parent directory
d176 : a203             [ 2] 	ldx #0x03
d178 :                       fs_dir_fh_dirsect_byte
d178 : b573             [ 4] 	lda fh_handle+FH_DirSect,x
d17a : 954e             [ 4] 	sta sd_sect,x
d17c : ca               [ 2] 	dex
d17d : 10f9             [ 3] 	bpl fs_dir_fh_dirsect_byte
                             
                             	; Meta data - remember the offset in to the sd b
d17f : a577             [ 3] 	lda fh_handle+FH_DirOffset
d181 : 854c             [ 3] 	sta sd_slo
d183 : a578             [ 3] 	lda fh_handle+FH_DirOffset+1
d185 : 854d             [ 3] 	sta sd_shi
                             	
d187 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* fs_dir_fh_to_entry_byte
                             ;* Copy fh_handle byte to fs_direntry area
                             ;* Input 	: y = offset in directory entry
                             ;*		 	: x = offset in handle entry
                             ;* Output 	: None
                             ;* Regs affected : All
                             ;****************************************
d188 :                       fs_dir_fh_to_entry_byte
d188 : b556             [ 4] 	lda fh_handle,x
d18a : 99110c           [ 5] 	sta fs_direntry,y
d18d : e8               [ 2] 	inx
d18e : c8               [ 2] 	iny
d18f : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_get_next_cluster
                             ;* Given current cluster, find the next
                             ;* Input : fh_handle
                             ;* Output : 
                             ;* Regs affected : None
                             ;****************************************
d190 :                       fs_get_next_cluster
                             	; Get the FAT sector that current clust is in
d190 : 20e0d2           [ 6] 	jsr fs_get_FAT_clust_sect
                             
                             	; Get next from this cluster index need low byte
                             	; as each FAT cluster contains 256 cluster entri
d193 : a468             [ 3] 	ldy fh_handle+FH_CurrClust
AS65 Assembler for R6502 [1.42].                                     Page   73
---------------------------------- bank2.s -----------------------------------

                             	; X = Low byte, A = High byte of cluster
d195 : 20d0cf           [ 6] 	jsr fs_getword_sd_buf
                             
                             	; Calculate the sector address and make current 
d198 : 202dd2           [ 6] 	jsr fs_get_start_sect_data
d19b : a920             [ 2] 	lda #0x20					; 32 sector per cluster countdown	
d19d : 856a             [ 3] 	sta fh_handle+FH_SectCounter
                             
d19f : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* fs_IsEOF
                             ;* End of File check (compare file pointer to fil
                             ;* Input : fh_handle
                             ;* Output : C=1 if EOF
                             ;* Regs affected : None
                             ;****************************************
d1a0 :                       fs_isEOF
d1a0 : a203             [ 2] 	ldx #0x03
d1a2 :                       fs_is_eof_cmp
d1a2 : b56f             [ 4] 	lda fh_handle+FH_Pointer,x
d1a4 : d564             [ 4] 	cmp fh_handle+FH_Size,x
d1a6 : d005             [ 3] 	bne fs_notEOF
d1a8 : ca               [ 2] 	dex
d1a9 : 10f7             [ 3] 	bpl fs_is_eof_cmp
d1ab :                       fs_setEOF	
d1ab : 38               [ 2] 	sec							; C = 1 for EOF
d1ac : 60               [ 6] 	rts
d1ad :                       fs_notEOF	
d1ad : 18               [ 2] 	clc							; C = 0 for not EOF
d1ae : 60               [ 6] 	rts
                             
                             
                             ;* Wrapper than preserves A,X,Y
d1af :                       fs_isEOF_w
d1af : 48               [ 3] 	pha
d1b0 : da               [ 3] 	phx
d1b1 : 5a               [ 3] 	phy
                             	
d1b2 : 20a0d1           [ 6] 	jsr fs_isEOF
                             
d1b5 : 7a               [ 4] 	ply
d1b6 : fa               [ 4] 	plx
d1b7 : 68               [ 4] 	pla
d1b8 : 60               [ 6] 	rts
                             	
                             	
                             	
                             ;****************************************
                             ;* fs_inc_pointer
                             ;* Increment file point, loading sectors and clus
                             ;* This results in sd_buf containing the sector t
                             ;* Input : fh_handle
                             ;* Output : 
                             ;* Regs affected : None
                             ;****************************************
d1b9 :                       fs_inc_pointer
                             	;Increment pointer
d1b9 : a200             [ 2] 	ldx #0x00
d1bb : a004             [ 2] 	ldy #0x04
d1bd : 38               [ 2] 	sec									; Always adds 1 first
d1be :                       fs_inc_pointer_byte
AS65 Assembler for R6502 [1.42].                                     Page   74
---------------------------------- bank2.s -----------------------------------

d1be : b56f             [ 4] 	lda fh_handle+FH_Pointer,x
d1c0 : 6900             [ 2] 	adc #0x00
d1c2 : 956f             [ 4] 	sta fh_handle+FH_Pointer,x
d1c4 : e8               [ 2] 	inx
d1c5 : 88               [ 2] 	dey
d1c6 : d0f6             [ 3] 	bne fs_inc_pointer_byte
                             
d1c8 : a56f             [ 3] 	lda fh_handle+FH_Pointer			; If low order == 0
d1ca : f001             [ 3] 	beq fs_inc_sector_ov				; Then sector 8 bits has
d1cc :                       fs_inc_fin
d1cc : 60               [ 6] 	rts
d1cd :                       fs_inc_sector_ov						; Check if sector bit 8 has
d1cd : a570             [ 3] 	lda fh_handle+FH_Pointer+1			; Load up next high
d1cf : 2901             [ 2] 	and #1								; If bit zero = 0 then must have
d1d1 : d0f9             [ 3] 	bne fs_inc_fin						; overflowed.
                             	;Sector change required
d1d3 : a200             [ 2] 	ldx #0x00
d1d5 : a004             [ 2] 	ldy #0x04
d1d7 : 38               [ 2] 	sec									; Always adds 1 first
d1d8 :                       fs_inc_fh_sect
d1d8 : b56b             [ 4] 	lda fh_handle+FH_CurrSec,x
d1da : 6900             [ 2] 	adc #0x00
d1dc : 956b             [ 4] 	sta fh_handle+FH_CurrSec,x
d1de : e8               [ 2] 	inx
d1df : 88               [ 2] 	dey
d1e0 : d0f6             [ 3] 	bne fs_inc_fh_sect
d1e2 :                       fs_inc_skip_sec_wrap
d1e2 : c66a             [ 5] 	dec fh_handle+FH_SectCounter		; If reached the e
d1e4 : d003             [ 3] 	bne fs_inc_load_sector				; Then get next cluste
                             	; Cluster change required
d1e6 : 2090d1           [ 6] 	jsr fs_get_next_cluster				; Get next cluster ba
d1e9 :                       fs_inc_load_sector
d1e9 : 20a0d1           [ 6] 	jsr fs_isEOF						; Check not EOF
d1ec : b003             [ 3] 	bcs fs_skip_load_sect				; if so then don't load
d1ee : 2067d2           [ 6] 	jsr fs_load_curr_sect				; Load the sector
d1f1 :                       fs_skip_load_sect
d1f1 : 60               [ 6] 	rts
                             
                             
                             	
                             ;****************************************
                             ;* fs_get_byte
                             ;* Get a byte and advance pointer
                             ;* Input : fh_handle
                             ;* Output : A = char, C = 1 (EOF or file not open
                             ;* Regs affected : None
                             ;****************************************
d1f2 :                       fs_get_byte
                             	; First check that file is open to read
d1f2 : a901             [ 2] 	lda #FS_FILEMODER
d1f4 : 2582             [ 3] 	and fh_handle+FH_FileMode
d1f6 : f005             [ 3] 	beq fs_get_set_EOF
                             
d1f8 : 20a0d1           [ 6] 	jsr fs_isEOF						; If at EOF then error
d1fb : 9006             [ 4] 	bcc fs_get_skip_EOF
                             
d1fd :                       fs_get_set_EOF
d1fd : a901             [ 2] 	lda #FS_ERR_EOF
d1ff : 859f             [ 3] 	sta errno
d201 : 38               [ 2] 	sec
d202 : 60               [ 6] 	rts
d203 :                       fs_get_skip_EOF
AS65 Assembler for R6502 [1.42].                                     Page   75
---------------------------------- bank2.s -----------------------------------

d203 : a66f             [ 3] 	ldx fh_handle+FH_Pointer			; Low 8 bits of secto
d205 : a470             [ 3] 	ldy fh_handle+FH_Pointer+1			; Which half of sec
                             	; A=SD buffer byte
d207 : 20b3cf           [ 6] 	jsr fs_getbyte_sd_buf
d20a : 48               [ 3] 	pha									; Remember the byte!
d20b : 20b9d1           [ 6] 	jsr fs_inc_pointer					; Increment file pointers
d20e : 68               [ 4] 	pla
                             
d20f : 18               [ 2] 	clc									; No error
d210 : 649f             [ 3] 	stz errno
d212 : 60               [ 6] 	rts
                             
                             ;* Wrapper function that preserves X,Y (A=return 
d213 :                       fs_get_byte_w
d213 : da               [ 3] 	phx
d214 : 5a               [ 3] 	phy
                             
d215 : 20f2d1           [ 6] 	jsr fs_get_byte
                             	
d218 : 7a               [ 4] 	ply
d219 : fa               [ 4] 	plx
d21a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; With ASCII code in A, make upper
                             ;****************************************
d21b :                       fs_to_upper
d21b : c92f             [ 2] 	cmp #FS_FOLDERCH
d21d : d003             [ 3] 	bne fs_to_upper_nz
d21f : a900             [ 2] 	lda #0
d221 : 60               [ 6] 	rts
d222 :                       fs_to_upper_nz
d222 : c961             [ 2] 	cmp #'a'				; If >='a'
d224 : 9006             [ 3] 	bcc fs_to_upper_done
d226 : c97b             [ 2] 	cmp #'z'+1				; If <='z'
d228 : b002             [ 3] 	bcs fs_to_upper_done
d22a : e91f             [ 2] 	sbc #0x1f				; Sub 0x1f+1 (C=0)
d22c :                       fs_to_upper_done
d22c : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ; Given the cluster #, find sector #
                             ; Given clust in X,A
                             ; Outputs to fh_handle->FH_CurrSec
                             ;            fh_handle->FH_CurrClust
                             ; Special case if X,A==0 then sector is
                             ; the root sector
                             ;****************************************
d22d :                       fs_get_start_sect_data
d22d : 8668             [ 3] 	stx fh_handle+FH_CurrClust
d22f : 866b             [ 3] 	stx fh_handle+FH_CurrSec+0
d231 : 8569             [ 3] 	sta fh_handle+FH_CurrClust+1
d233 : 856c             [ 3] 	sta fh_handle+FH_CurrSec+1
                             	
                             	; If cluster # == 0 then root directory
d235 : 056b             [ 3] 	ora fh_handle+FH_CurrSec+0
d237 : f023             [ 3] 	beq fs_get_start_sect_root
                             	
                             	; Initialise to input sector
d239 : 646d             [ 3] 	stz fh_handle+FH_CurrSec+2
d23b : 646e             [ 3] 	stz fh_handle+FH_CurrSec+3
AS65 Assembler for R6502 [1.42].                                     Page   76
---------------------------------- bank2.s -----------------------------------

                             	
                             	; Sector = Cluster * 32
                             	; Shift left 5 times
d23d : a005             [ 2] 	ldy #5
d23f :                       fs_get_data_sect_m5
d23f : 18               [ 2] 	clc
d240 : 066b             [ 5] 	asl fh_handle+FH_CurrSec+0
d242 : 266c             [ 5] 	rol fh_handle+FH_CurrSec+1
d244 : 266d             [ 5] 	rol fh_handle+FH_CurrSec+2
d246 : 266e             [ 5] 	rol fh_handle+FH_CurrSec+3
d248 : 88               [ 2] 	dey
d249 : d0f4             [ 3] 	bne fs_get_data_sect_m5
                             
                             	; Add data sector offset
d24b : a200             [ 2] 	ldx #0x00
d24d : a004             [ 2] 	ldy #0x04
d24f : 18               [ 2] 	clc
d250 :                       fs_get_start_data
d250 : b56b             [ 4] 	lda fh_handle+FH_CurrSec,x
d252 : 7d3d0c           [ 4] 	adc fs_datasect,x
d255 : 956b             [ 4] 	sta fh_handle+FH_CurrSec,x
d257 : e8               [ 2] 	inx
d258 : 88               [ 2] 	dey
d259 : d0f5             [ 3] 	bne fs_get_start_data
d25b : 60               [ 6] 	rts
d25c :                       fs_get_start_sect_root
d25c : a203             [ 2] 	ldx #3
d25e :                       fs_get_root_sect
d25e : bd390c           [ 4] 	lda fs_rootsect,x
d261 : 956b             [ 4] 	sta fh_handle+FH_CurrSec,x
d263 : ca               [ 2] 	dex
d264 : 10f8             [ 3] 	bpl fs_get_root_sect
d266 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ; Load the current sector in FH
                             ;****************************************
d267 :                       fs_load_curr_sect
d267 : 48               [ 3] 	pha
d268 : da               [ 3] 	phx
                             
d269 : a203             [ 2] 	ldx #0x03
d26b :                       fs_load_cpy_sect
d26b : b56b             [ 4] 	lda fh_handle+FH_CurrSec,x
d26d : 954e             [ 4] 	sta sd_sect,x
d26f : ca               [ 2] 	dex
d270 : 10f9             [ 3] 	bpl fs_load_cpy_sect
d272 : a902             [ 2] 	lda #hi(sd_buf)
d274 : 20c0cd           [ 6] 	jsr sd_sendcmd17
                             
d277 : fa               [ 4] 	plx
d278 : 68               [ 4] 	pla
d279 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; Flush the current sector
                             ;****************************************
d27a :                       fs_flush_curr_sect
d27a : 48               [ 3] 	pha
d27b : da               [ 3] 	phx
                             
AS65 Assembler for R6502 [1.42].                                     Page   77
---------------------------------- bank2.s -----------------------------------

d27c : a203             [ 2] 	ldx #0x03
d27e :                       fs_flush_cpy_sect
d27e : b56b             [ 4] 	lda fh_handle+FH_CurrSec,x
d280 : 954e             [ 4] 	sta sd_sect,x
d282 : ca               [ 2] 	dex
d283 : 10f9             [ 3] 	bpl fs_flush_cpy_sect
d285 : a902             [ 2] 	lda #hi(sd_buf)				; Sending data in sd_buf
d287 : 2039ce           [ 6] 	jsr sd_sendcmd24
                             	
d28a : fa               [ 4] 	plx
d28b : 68               [ 4] 	pla
d28c : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_find_empty_clust
                             ;* Find an empty cluster to write to
                             ;* Input : None
                             ;* Output : fh_handle->FH_CurrClust is the empty 
                             ;* Regs affected : None
                             ;****************************************
d28d :                       fs_find_empty_clust
                             	; Starting at cluster 0x0002
d28d : a902             [ 2] 	lda #02
d28f : 8568             [ 3] 	sta fh_handle+FH_CurrClust
d291 : 6469             [ 3] 	stz fh_handle+FH_CurrClust+1
                             
                             	; Start at the first FAT sector
d293 : a203             [ 2] 	ldx #0x03
d295 :                       fs_find_init_fat
d295 : bd350c           [ 4] 	lda fs_fatsect,x
d298 : 956b             [ 4] 	sta fh_handle+FH_CurrSec,x
d29a : ca               [ 2] 	dex
d29b : 10f8             [ 3] 	bpl fs_find_init_fat
                             
                             	; There is only enough room for 512/2 = 256 clus
                             	; There are 256 sectors of FAT entries
                             
d29d :                       fs_check_empty_sector
d29d : 2067d2           [ 6] 	jsr fs_load_curr_sect			; Load a FAT sector
d2a0 :                       fs_check_curr_clust
d2a0 : a468             [ 3] 	ldy fh_handle+FH_CurrClust		; Index in to this F
d2a2 : 20d0cf           [ 6] 	jsr fs_getword_sd_buf
d2a5 : e000             [ 2] 	cpx #0
d2a7 : d018             [ 3] 	bne fs_next_fat_entry
d2a9 : c900             [ 2] 	cmp #0
d2ab : d014             [ 3] 	bne fs_next_fat_entry
                             	
                             	; If got here then empty cluster found
                             	; fh_handle->FH_CurrClust is the empty cluster
                             	
                             	; Mark this cluster as used
d2ad : a2ff             [ 2] 	ldx #0xff
d2af : a9ff             [ 2] 	lda #0xff
d2b1 : 20e3cf           [ 6] 	jsr fs_putword_sd_buf
                             
                             	; flush this FAT entry back so this cluster is s
d2b4 : 207ad2           [ 6] 	jsr fs_flush_curr_sect
                             	
d2b7 : 646a             [ 3] 	stz fh_handle+FH_SectCounter	; Zero the sector c
d2b9 : a668             [ 3] 	ldx fh_handle+FH_CurrClust
d2bb : a569             [ 3] 	lda fh_handle+FH_CurrClust+1
AS65 Assembler for R6502 [1.42].                                     Page   78
---------------------------------- bank2.s -----------------------------------

d2bd : 202dd2           [ 6] 	jsr fs_get_start_sect_data		; Initialise the sec
d2c0 : 60               [ 6] 	rts
                             	; If got here then need to find another cluster
d2c1 :                       fs_next_fat_entry
                             	_incZPWord fh_handle+FH_CurrClust	; Increment th
                             
                             	; Only 256 FAT entries in a sector of 512 bytes
d2c7 : a568             [ 3] 	lda fh_handle+FH_CurrClust		; Check low byte of 
d2c9 : d0d5             [ 3] 	bne fs_check_curr_clust			; Else keep checking c
                             	; Every 256 FAT entries, need to get a new FAT s
d2cb :                       fs_next_fat_sect
d2cb : 20d0d2           [ 6] 	jsr fs_inc_curr_sec				; Increment to the next F
d2ce : 80cd             [ 3] 	bra fs_check_empty_sector		; Go an load the new 
                             	
                             
                             ;****************************************
                             ;* fs_inc_curr_sec
                             ;* Increment sector by 1
                             ;* Input : fh_handle has the sector
                             ;****************************************
d2d0 :                       fs_inc_curr_sec
                             	; add 1 to LSB as sector address is little endia
d2d0 : a200             [ 2] 	ldx #0x00
d2d2 : a004             [ 2] 	ldy #0x04
d2d4 : 38               [ 2] 	sec
d2d5 :                       fs_inc_sec_byte
d2d5 : b56b             [ 4] 	lda fh_handle+FH_CurrSec,x
d2d7 : 6900             [ 2] 	adc #0x00
d2d9 : 956b             [ 4] 	sta fh_handle+FH_CurrSec,x
d2db : e8               [ 2] 	inx
d2dc : 88               [ 2] 	dey
d2dd : d0f6             [ 3] 	bne fs_inc_sec_byte
                             
d2df : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* fs_get_FAT_clust_sect
                             ;* Given FH_CurrClust, set FH_CurrSec so that
                             ;* the sector contains the FAT entry
                             ;* Input : fh_handle has the details
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d2e0 :                       fs_get_FAT_clust_sect
                             	; Sector offset in to FAT = high byte
                             	; because a sector can hold 256 FAT entries
d2e0 : a569             [ 3] 	lda fh_handle+FH_CurrClust+1
d2e2 : 856b             [ 3] 	sta fh_handle+FH_CurrSec
d2e4 : 646c             [ 3] 	stz fh_handle+FH_CurrSec+1
d2e6 : 646d             [ 3] 	stz fh_handle+FH_CurrSec+2
d2e8 : 646e             [ 3] 	stz fh_handle+FH_CurrSec+3
                             	
                             	; Add the FAT offset
d2ea : 18               [ 2] 	clc
d2eb : a200             [ 2] 	ldx #0x00
d2ed : a004             [ 2] 	ldy #0x04
d2ef :                       fs_get_add_fat
d2ef : b56b             [ 4] 	lda fh_handle+FH_CurrSec,x
d2f1 : 7d350c           [ 4] 	adc fs_fatsect,x
d2f4 : 956b             [ 4] 	sta fh_handle+FH_CurrSec,x
d2f6 : e8               [ 2] 	inx
AS65 Assembler for R6502 [1.42].                                     Page   79
---------------------------------- bank2.s -----------------------------------

d2f7 : 88               [ 2] 	dey
d2f8 : d0f5             [ 3] 	bne fs_get_add_fat
                             
                             	; Now load the sector containing this cluster en
d2fa : 2067d2           [ 6] 	jsr fs_load_curr_sect
                             
d2fd : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* fs_update_FAT_entry
                             ;* FH_LastClust updated with FH_CurrClust
                             ;* Input : fh_handle has the details
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d2fe :                       fs_update_FAT_entry
d2fe : 48               [ 3] 	pha
d2ff : da               [ 3] 	phx
d300 : 5a               [ 3] 	phy
                             	
d301 : a568             [ 3] 	lda fh_handle+FH_CurrClust+0	; Save current clus
d303 : 48               [ 3] 	pha
d304 : a569             [ 3] 	lda fh_handle+FH_CurrClust+1	; Save current clus
d306 : 48               [ 3] 	pha
                             	; Move back to the last cluster entry
                             	_cpyZPWord fh_handle+FH_LastClust,fh_handle+FH_C
                             
                             
d30f : 20e0d2           [ 6] 	jsr fs_get_FAT_clust_sect		; Get the FAT sector 
                             	; Index in to the FAT sector
d312 : a47b             [ 3] 	ldy fh_handle+FH_LastClust
                             	; Get current cluster hi,lo from stack
d314 : 68               [ 4] 	pla
d315 : fa               [ 4] 	plx
d316 : 8668             [ 3] 	stx fh_handle+FH_CurrClust		; Make it the curren
d318 : 8569             [ 3] 	sta fh_handle+FH_CurrClust+1	; Make it the curre
                             
                             	; Update FAT entry Y with current cluster X,A
d31a : 20e3cf           [ 6] 	jsr fs_putword_sd_buf
                             
                             	; The appropriate FAT sector has been updated
                             	; Now flush that sector back	
d31d : 207ad2           [ 6] 	jsr fs_flush_curr_sect
                             	
d320 : 7a               [ 4] 	ply
d321 : fa               [ 4] 	plx
d322 : 68               [ 4] 	pla
d323 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* fs_put_byte
                             ;* Put out a byte, incrementing size
                             ;* and committing clusters as necessary
                             ;* including reflecting this in the FAT table
                             ;* Input : fh_handle has the details, A = Byte to
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d324 :                       fs_put_byte
d324 : 48               [ 3] 	pha			; Save A until needed later
AS65 Assembler for R6502 [1.42].                                     Page   80
---------------------------------- bank2.s -----------------------------------

                             	; First check that file is open to write
d325 : a980             [ 2] 	lda #FS_FILEMODEW
d327 : 2582             [ 3] 	and fh_handle+FH_FileMode
d329 : d003             [ 3] 	bne fs_put_skip_err
                             	; C=1 means error
d32b : 68               [ 4] 	pla
d32c : 38               [ 2] 	sec
d32d : 60               [ 6] 	rts
d32e :                       fs_put_skip_err
                             	; Before writing a byte, need to check if the cu
                             	; sector is full.
                             	; Check low 9 bits of size and if zero size (i.e
d32e : a564             [ 3] 	lda fh_handle+FH_Size
d330 : d024             [ 3] 	bne fs_put_do_put
d332 : a565             [ 3] 	lda fh_handle+FH_Size+1
d334 : f020             [ 3] 	beq fs_put_do_put
d336 : 2901             [ 2] 	and #1
d338 : d01c             [ 3] 	bne fs_put_do_put
                             	; Got here then current sector is full
                             	; We need to flush this sector to disk
d33a : 207ad2           [ 6] 	jsr fs_flush_curr_sect
                             	; Move to next sector in the cluster
d33d : 20d0d2           [ 6] 	jsr fs_inc_curr_sec
                             	; Bump the sector counter
d340 : e66a             [ 5] 	inc fh_handle+FH_SectCounter
                             	; Check if counter at sectors per cluster limit
d342 : a56a             [ 3] 	lda fh_handle+FH_SectCounter
d344 : c920             [ 2] 	cmp #0x20
d346 : d00e             [ 3] 	bne fs_put_do_put
                             	; We need to find a new cluster now
                             	; But first update the FAT chain
                             	; so that the last cluster points to this
d348 : 20fed2           [ 6] 	jsr fs_update_FAT_entry
                             	; Before finding a new cluster
                             	; make the current the last
                             	_cpyZPWord fh_handle+FH_CurrClust,fh_handle+FH_L
                             
                             	; Go find a new empty clust
                             	; starts at sector 0
d353 : 208dd2           [ 6] 	jsr fs_find_empty_clust
                             	; Finally, can write a byte to the
                             	; SD buffer in memory
d356 :                       fs_put_do_put	
d356 : a664             [ 3] 	ldx fh_handle+FH_Size			; Load size low as index
d358 : a465             [ 3] 	ldy fh_handle+FH_Size+1			; Check which half
d35a : 68               [ 4] 	pla								; Get A off stack
d35b : 20c0cf           [ 6] 	jsr fs_putbyte_sd_buf
d35e :                       fs_put_inc_size
d35e : 38               [ 2] 	sec
d35f : a200             [ 2] 	ldx #0x00
d361 : a004             [ 2] 	ldy #0x04
d363 :                       fs_put_inc_size_byte
d363 : b564             [ 4] 	lda fh_handle+FH_Size,x
d365 : 6900             [ 2] 	adc #0
d367 : 9564             [ 4] 	sta fh_handle+FH_Size,x
d369 : e8               [ 2] 	inx
d36a : 88               [ 2] 	dey
d36b : d0f6             [ 3] 	bne fs_put_inc_size_byte
d36d :                       fs_put_fin
d36d : 18               [ 2] 	clc
d36e : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page   81
---------------------------------- bank2.s -----------------------------------

                             
                             ;* Wrapper function to save A,X,Y
d36f :                       fs_put_byte_w
d36f : da               [ 3] 	phx
d370 : 5a               [ 3] 	phy
d371 : 48               [ 3] 	pha
                             
d372 : 2024d3           [ 6] 	jsr fs_put_byte
                             	
d375 : 68               [ 4] 	pla
d376 : 7a               [ 4] 	ply
d377 : fa               [ 4] 	plx
d378 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_dir_save_entry
                             ;* Save dir entry back to disk
                             ;* Input : fh_handle has all the details
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d379 :                       fs_dir_save_entry
                             	; Retrieve the sector where the file entry goes
d379 : a203             [ 2] 	ldx #0x03
d37b :                       fs_dir_curr_sect
d37b : b573             [ 4] 	lda fh_handle+FH_DirSect,x
d37d : 956b             [ 4] 	sta fh_handle+FH_CurrSec,x
d37f : ca               [ 2] 	dex
d380 : 10f9             [ 3] 	bpl fs_dir_curr_sect
                             	
d382 : 2067d2           [ 6] 	jsr fs_load_curr_sect
                             
                             	; Restore index in to the correct entry
d385 : a577             [ 3] 	lda fh_handle+FH_DirOffset
d387 : 854c             [ 3] 	sta sd_slo
d389 : a578             [ 3] 	lda fh_handle+FH_DirOffset+1
d38b : 854d             [ 3] 	sta sd_shi
                             	
                             	; Copy FAT file desc cache to sd position
d38d : a01f             [ 2] 	ldy #FATFileDesc-1			; Cache the fs_direntry sd_
d38f :                       fs_dir_copy_entry_sd_byte
d38f : b9110c           [ 4] 	lda fs_direntry,y
d392 : 914c             [ 5] 	sta (sd_slo),y
d394 : 88               [ 2] 	dey
d395 : 10f8             [ 3] 	bpl fs_dir_copy_entry_sd_byte
                             	
                             	; Now flush this back to disk
                             	
d397 : 207ad2           [ 6] 	jsr fs_flush_curr_sect
                             	
                             	; Phew we are done
d39a : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_find_named
                             ;* Find named file in current directory
                             ;* Input : fh_handle has the name
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d39b :                       fs_find_named
AS65 Assembler for R6502 [1.42].                                     Page   82
---------------------------------- bank2.s -----------------------------------

d39b : 18               [ 2] 	clc								; Find active file
d39c : 201bd0           [ 6] 	jsr fs_dir_find_entry			; Find entry from curren
d39f : b01c             [ 3] 	bcs	fs_name_not_found			; If C then no more entr
d3a1 : a000             [ 2] 	ldy #0							; Index to filespec
d3a3 : a200             [ 2] 	ldx #0							; Index to filename
d3a5 :                       fs_find_check_name
d3a5 : b183             [ 5] 	lda (fh_handle+FH_FSpecPtr),y	; File spec char
d3a7 : 201bd2           [ 6] 	jsr fs_to_upper					; Case insensitive
d3aa : d556             [ 4] 	cmp fh_handle,x					; compare with this filehand
d3ac : d008             [ 3] 	bne fs_find_next
d3ae : c900             [ 2] 	cmp #0							; If no more bytes in name to check
d3b0 : f009             [ 3] 	beq fs_name_found
d3b2 : e8               [ 2] 	inx
d3b3 : c8               [ 2] 	iny
d3b4 : 80ef             [ 3] 	bra fs_find_check_name
d3b6 :                       fs_find_next
d3b6 : 2060d0           [ 6] 	jsr fs_dir_next_entry			; Get next entry to chec
d3b9 : 80e0             [ 3] 	bra fs_find_named
d3bb :                       fs_name_found
d3bb : 18               [ 2] 	clc								; C=0 file found
                             	; Y=index to terminating ch, A=terminating ch
d3bc : 60               [ 6] 	rts
d3bd :                       fs_name_not_found					; If C already set then not
d3bd : 38               [ 2] 	sec
d3be : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* fs_open_read
                             ;* Open a file for reading
                             ;* Input : fh_handle has the name
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d3bf :                       fs_open_read
d3bf : 20fbcf           [ 6] 	jsr fs_dir_root_start		; Start at root of curren
d3c2 : 209bd3           [ 6] 	jsr fs_find_named			; Try to find the file
d3c5 : b01a             [ 3] 	bcs fs_open_not_found		; C=1 not found
d3c7 :                       fs_open_found
d3c7 : a920             [ 2] 	lda #0x20					; 32 sector per cluster countdown	
d3c9 : 856a             [ 3] 	sta fh_handle+FH_SectCounter
                             
d3cb : a679             [ 3] 	ldx fh_handle+FH_FirstClust	; Load up first clus
d3cd : a57a             [ 3] 	lda fh_handle+FH_FirstClust+1
                             
d3cf : 202dd2           [ 6] 	jsr fs_get_start_sect_data	; Calc the first sect
d3d2 : 2067d2           [ 6] 	jsr fs_load_curr_sect		; Load it in to sd_buf
                             
                             
d3d5 : a203             [ 2] 	ldx #0x03					; Initialise pointer to beginning
d3d7 :                       fs_open_init_pointer
d3d7 : 746f             [ 4] 	stz fh_handle+FH_Pointer,x
d3d9 : ca               [ 2] 	dex
d3da : 10fb             [ 3] 	bpl fs_open_init_pointer
                             
                             	; Set file mode to read
d3dc : a901             [ 2] 	lda #FS_FILEMODER
d3de : 8582             [ 3] 	sta fh_handle+FH_FileMode
                             
d3e0 : 18               [ 2] 	clc
d3e1 :                       fs_open_not_found
d3e1 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   83
---------------------------------- bank2.s -----------------------------------

                             
                             ;* Wrapper function that saves A,X,Y *
                             ;* X,A = file spec ptr
d3e2 :                       fs_open_read_w
d3e2 : 48               [ 3] 	pha
d3e3 : da               [ 3] 	phx
d3e4 : 5a               [ 3] 	phy
                             
                             	; Save file name pointer
d3e5 : 8683             [ 3] 	stx fh_handle+FH_FSpecPtr
d3e7 : 8584             [ 3] 	sta fh_handle+FH_FSpecPtr+1
d3e9 : 20bfd3           [ 6] 	jsr fs_open_read
                             	
d3ec : 7a               [ 4] 	ply
d3ed : fa               [ 4] 	plx
d3ee : 68               [ 4] 	pla
d3ef : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_stamptimedate
                             ;* Stamp date and time to fhandle
                             ;* Input : None (reads RTC)
                             ;* Output : None
                             ;* Regs affected : all
                             ;****************************************
d3f0 :                       fs_stamptimedate
                             	; Point to temp space
d3f0 : a247             [ 2] 	ldx #lo(fs_scratch)
d3f2 : a90c             [ 2] 	lda #hi(fs_scratch)
                             	; Get the current time and date - 6 bytes
d3f4 : 2066c4           [ 6] 	jsr _rtc_gettimedate
                             	; Now convert from hhmmssddmmyy format to FAT16
                             	; Byte bit and byte order as follows
                             	; byte 0 = milliseconds
                             	; byte 1 = mmmsssss
                             	; byte 2 = hhhhhmmm
                             	; byte 3 = MMMDDDDD
                             	; byte 4 = YYYYYYYM
                             	; First decide on milliseconds
d3f7 : a200             [ 2] 	ldx #0								; Assume 0 milliseconds
d3f9 : ad490c           [ 4] 	lda fs_scratch+2					; Seconds
d3fc : 2901             [ 2] 	and #1
d3fe : d002             [ 4] 	bne fs_stamptimedate_ms
d400 : a264             [ 2] 	ldx #100							; 10x100 milliseconds = 1 second
d402 :                       fs_stamptimedate_ms
d402 : 867d             [ 3] 	stx fh_handle+FH_TimeDate			; Save milliseconds
                             	
d404 : ad470c           [ 4] 	lda fs_scratch+0					; Get hours
d407 : 0a               [ 2] 	asl a								; Move to top 5 bits
d408 : 0a               [ 2] 	asl a
d409 : 0a               [ 2] 	asl a
d40a : 857f             [ 3] 	sta fh_handle+FH_TimeDate+2			; Put in time fiel
                             
d40c : ad480c           [ 4] 	lda fs_scratch+1					; Get minutes
d40f : 4a               [ 2] 	lsr a								; Put top 3 bits in to LSB
d410 : 4a               [ 2] 	lsr a
d411 : 4a               [ 2] 	lsr a
d412 : 057f             [ 3] 	ora fh_handle+FH_TimeDate+2			; Combine with hou
d414 : 857f             [ 3] 	sta fh_handle+FH_TimeDate+2			; Put in time fiel
                             
d416 : ad480c           [ 4] 	lda fs_scratch+1					; Get minutes
AS65 Assembler for R6502 [1.42].                                     Page   84
---------------------------------- bank2.s -----------------------------------

d419 : 0a               [ 2] 	asl a								; Get bottom 3 bits of mins to top 
d41a : 0a               [ 2] 	asl a
d41b : 0a               [ 2] 	asl a
d41c : 0a               [ 2] 	asl a
d41d : 0a               [ 2] 	asl a
d41e : 857e             [ 3] 	sta fh_handle+FH_TimeDate+1			; Save in time fie
                             	
d420 : ad490c           [ 4] 	lda fs_scratch+2					; Get seconds again
d423 : 4a               [ 2] 	lsr a								; Divide by 2
d424 : 057e             [ 3] 	ora fh_handle+FH_TimeDate+1			; Combine with tim
d426 : 857e             [ 3] 	sta fh_handle+FH_TimeDate+1			; Save back to tim
                             	
d428 : ad4c0c           [ 4] 	lda fs_scratch+5					; Get year
d42b : 18               [ 2] 	clc									; Add 20 to get offset from 1980
d42c : 6914             [ 2] 	adc #20
d42e : 0a               [ 2] 	asl a								; Shift up
d42f : 8581             [ 3] 	sta fh_handle+FH_TimeDate+4			; Put in date fiel
                             
d431 : ad4b0c           [ 4] 	lda fs_scratch+4					; Get months
d434 : 4a               [ 2] 	lsr a								; Bit 3 in to bit 0
d435 : 4a               [ 2] 	lsr a
d436 : 4a               [ 2] 	lsr a
d437 : 0581             [ 3] 	ora fh_handle+FH_TimeDate+4			; Combine with dat
d439 : 8581             [ 3] 	sta fh_handle+FH_TimeDate+4			; Put in date fiel
                             
d43b : ad4b0c           [ 4] 	lda fs_scratch+4					; Get months
d43e : 0a               [ 2] 	asl a								; 3 LSBs in to MSB of A (discard MS
d43f : 0a               [ 2] 	asl a
d440 : 0a               [ 2] 	asl a
d441 : 0a               [ 2] 	asl a
d442 : 0a               [ 2] 	asl a
d443 : 0d4a0c           [ 4] 	ora fs_scratch+3					; Combine with day
d446 : 8580             [ 3] 	sta fh_handle+FH_TimeDate+3			; And save in date
                             
d448 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* fs_create_filedir
                             ;* Create a file or directory
                             ;* Input : fh_handle has the name and type attrib
                             ;*		 : new file / directory will be created.
                             ;*		 : Careful to check filename is *unique*
                             ;*		 : before calling this routine.
                             ;*		 : File will be in write mode, needs to be
                             ;*		 : closed to be properly saved
                             ;*		 : C=0 means file, C=1 meand directory
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d449 :                       fs_create_filedir
d449 : 48               [ 3] 	pha
d44a : da               [ 3] 	phx
d44b : 5a               [ 3] 	phy
d44c : 08               [ 3] 	php							; Save file or dir request for later
                             
d44d : 20fbcf           [ 6] 	jsr fs_dir_root_start		; Start at root of curren
d450 : 38               [ 2] 	sec							; Find an empty file entry
d451 : 201bd0           [ 6] 	jsr fs_dir_find_entry		; Find a valid entry
d454 : b036             [ 3] 	bcs	fs_create_fd_err		; Error, didn't find!
                             
d456 : a900             [ 2] 	lda #0						; Assume creating file
AS65 Assembler for R6502 [1.42].                                     Page   85
---------------------------------- bank2.s -----------------------------------

d458 : 28               [ 4] 	plp							; Unless C=1
d459 : 9002             [ 3] 	bcc fh_create_skip_dir
                             	; Set attribute for directory
d45b : a910             [ 2] 	lda #FAT_Attr_Dir
d45d :                       fh_create_skip_dir
d45d : 8563             [ 3] 	sta fh_handle+FH_Attr
                             
                             	; Copy filespec to file handle
d45f : a000             [ 2] 	ldy #0
d461 : a200             [ 2] 	ldx #FH_Name
d463 :                       fs_create_copy_fspec
d463 : b183             [ 5] 	lda (fh_handle+FH_FSpecPtr),y
d465 : 9556             [ 4] 	sta fh_handle,x
d467 : f004             [ 3] 	beq fs_create_copy_fspec_done
d469 : e8               [ 2] 	inx
d46a : c8               [ 2] 	iny
d46b : 80f6             [ 3] 	bra fs_create_copy_fspec
                             
d46d :                       fs_create_copy_fspec_done
d46d : 6464             [ 3] 	stz fh_handle+FH_Size+0		; Size is zero
d46f : 6465             [ 3] 	stz fh_handle+FH_Size+1
d471 : 6466             [ 3] 	stz fh_handle+FH_Size+2
d473 : 6467             [ 3] 	stz fh_handle+FH_Size+3
                             
d475 : 20f0d3           [ 6] 	jsr fs_stamptimedate		; Put date time stamp in t
                             	
d478 : 208dd2           [ 6] 	jsr fs_find_empty_clust		; Find + record its fir
                             	
                             	; Set current, last and first cluster to the sam
d47b : a568             [ 3] 	lda fh_handle+FH_CurrClust
d47d : 8579             [ 3] 	sta fh_handle+FH_FirstClust
d47f : 857b             [ 3] 	sta fh_handle+FH_LastClust
d481 : a569             [ 3] 	lda fh_handle+FH_CurrClust+1
d483 : 857a             [ 3] 	sta fh_handle+FH_FirstClust+1
d485 : 857c             [ 3] 	sta fh_handle+FH_LastClust+1
                             
                             	; Set file mode to write
d487 : a980             [ 2] 	lda #FS_FILEMODEW
d489 : 8582             [ 3] 	sta fh_handle+FH_FileMode
                             
d48b : 18               [ 2] 	clc
d48c :                       fs_create_fd_err
d48c : 7a               [ 4] 	ply
d48d : fa               [ 4] 	plx
d48e : 68               [ 4] 	pla
d48f : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_create_dirptr
                             ;* Create a file that is a pointer to a directory
                             ;* Input : fh_handle has the name and type attrib
                             ;*		 : Entry will be created pointing tp the
                             ;*		 : cluster in FH_CurrClust.
                             ;*		 : Careful to check filename is *unique*
                             ;*		 : before calling this routine.
                             ;*		 : File will be in write mode, needs to be
                             ;*		 : closed to be properly saved
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d490 :                       fs_create_dirptr
AS65 Assembler for R6502 [1.42].                                     Page   86
---------------------------------- bank2.s -----------------------------------

d490 : a910             [ 2] 	lda #FAT_Attr_Dir
d492 : 8563             [ 3] 	sta fh_handle+FH_Attr		; Make it a directory
                             
d494 : 6464             [ 3] 	stz fh_handle+FH_Size+0		; Size is zero
d496 : 6465             [ 3] 	stz fh_handle+FH_Size+1
d498 : 6466             [ 3] 	stz fh_handle+FH_Size+2
d49a : 6467             [ 3] 	stz fh_handle+FH_Size+3
                             
d49c : 18               [ 2] 	clc
d49d : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_open_write
                             ;* Open a file for writing
                             ;* Input : fh_handle has the name
                             ;*		 : existing file will overwritten
                             ;*		 : new file will be created
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d49e :                       fs_open_write
                             	; try and delete any file with the same name fir
d49e : 2000d5           [ 6] 	jsr fs_delete
d4a1 : 18               [ 2] 	clc
d4a2 : 2049d4           [ 6] 	jsr fs_create_filedir		; Ok go create this file 
                             
d4a5 : 60               [ 6] 	rts
                             
                             ;* Wrapper function that saves A,X,Y *
d4a6 :                       fs_open_write_w
d4a6 : 48               [ 3] 	pha
d4a7 : da               [ 3] 	phx
d4a8 : 5a               [ 3] 	phy
                             
d4a9 : 8683             [ 3] 	stx fh_handle+FH_FSpecPtr
d4ab : 8584             [ 3] 	sta fh_handle+FH_FSpecPtr+1
d4ad : 209ed4           [ 6] 	jsr fs_open_write
                             	
d4b0 : 7a               [ 4] 	ply
d4b1 : fa               [ 4] 	plx
d4b2 : 68               [ 4] 	pla
d4b3 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_close_filedir
                             ;* Close a file/dir, important for new files
                             ;* Input : fh_handle details
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d4b4 :                       fs_close_filedir
                             	; Only need to close down stuff in write mode
d4b4 : a582             [ 3] 	lda fh_handle+FH_FileMode
                             	; Zero out file mode
d4b6 : 6482             [ 3] 	stz fh_handle+FH_FileMode
                             	; If filemode N bit clear then done
d4b8 : 103b             [ 3] 	bpl fs_close_done
                             		
                             	; Flush the current sector
d4ba : 207ad2           [ 6] 	jsr fs_flush_curr_sect
AS65 Assembler for R6502 [1.42].                                     Page   87
---------------------------------- bank2.s -----------------------------------

                             
                             	; Update the chain from the last cluster
d4bd : 20fed2           [ 6] 	jsr fs_update_FAT_entry
                             
                             	; Make current sector = last
d4c0 : a568             [ 3] 	lda fh_handle+FH_CurrClust
d4c2 : 857b             [ 3] 	sta fh_handle+FH_LastClust
d4c4 : a569             [ 3] 	lda fh_handle+FH_CurrClust+1
d4c6 : 857c             [ 3] 	sta fh_handle+FH_LastClust+1
                             	; Need to update the FAT entry
                             	; to show this cluster is last
d4c8 : a9ff             [ 2] 	lda #0xff
d4ca : 8568             [ 3] 	sta fh_handle+FH_CurrClust
d4cc : 8569             [ 3] 	sta fh_handle+FH_CurrClust+1
                             	; Now update the FAT entry to mark the last clus
d4ce : 20fed2           [ 6] 	jsr fs_update_FAT_entry
                             	; Then finally save the directory entry
                             	; First fhandle to FATFileDesc
d4d1 : 200fd1           [ 6] 	jsr fs_dir_fhandle_to_entry
                             
                             	; Update modified date and time to be same as cr
d4d4 : ad210c           [ 4] 	lda fs_direntry+FAT_CreateDate
d4d7 : 8d290c           [ 4] 	sta fs_direntry+FAT_ModDate
d4da : 8d230c           [ 4] 	sta fs_direntry+FAT_AccessDate
d4dd : ad220c           [ 4] 	lda fs_direntry+FAT_CreateDate+1
d4e0 : 8d2a0c           [ 4] 	sta fs_direntry+FAT_ModDate+1
d4e3 : 8d240c           [ 4] 	sta fs_direntry+FAT_AccessDate+1
d4e6 : ad1f0c           [ 4] 	lda fs_direntry+FAT_CreateTime
d4e9 : 8d270c           [ 4] 	sta fs_direntry+FAT_ModTime
d4ec : ad200c           [ 4] 	lda fs_direntry+FAT_CreateTime+1
d4ef : 8d280c           [ 4] 	sta fs_direntry+FAT_ModTime+1
                             	
d4f2 : 2079d3           [ 6] 	jsr fs_dir_save_entry
                             
d4f5 :                       fs_close_done
d4f5 : 60               [ 6] 	rts
                             
                             
                             ;* Wrapper function preserving A,X,Y *
d4f6 :                       fs_close_w
d4f6 : 48               [ 3] 	pha
d4f7 : da               [ 3] 	phx
d4f8 : 5a               [ 3] 	phy
                             	
d4f9 : 20b4d4           [ 6] 	jsr fs_close_filedir
                             	
d4fc : 7a               [ 4] 	ply
d4fd : fa               [ 4] 	plx
d4fe : 68               [ 4] 	pla
d4ff : 60               [ 6] 	rts
                             	
                             	
                             
                             
                             ;****************************************
                             ;* fs_delete
                             ;* Delete a file
                             ;* Input : fh_handle has the name
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d500 :                       fs_delete
AS65 Assembler for R6502 [1.42].                                     Page   88
---------------------------------- bank2.s -----------------------------------

d500 : 20bfd3           [ 6] 	jsr fs_open_read			; Try and open the file
d503 : b031             [ 3] 	bcs fs_delete_fin			; If not found then fin
                             	
                             	; Mark first char with deleted indicator
d505 : a9e5             [ 2] 	lda #0xe5
d507 : 8556             [ 3] 	sta fh_handle+FH_Name
                             
                             	; Save this back to directory table
                             	; First fhandle to FATFileDesc
d509 : 200fd1           [ 6] 	jsr fs_dir_fhandle_to_entry	
d50c : 2079d3           [ 6] 	jsr fs_dir_save_entry
                             
                             	; Now mark all related clusters as free
d50f : a679             [ 3] 	ldx fh_handle+FH_FirstClust
d511 : 8668             [ 3] 	stx fh_handle+FH_CurrClust
d513 : a47a             [ 3] 	ldy fh_handle+FH_FirstClust+1
d515 : 8469             [ 3] 	sty fh_handle+FH_CurrClust+1
d517 :                       fs_delete_clust
                             	; X and Y always contain current cluster
                             	; Make last = current
d517 : 867b             [ 3] 	stx fh_handle+FH_LastClust
d519 : 847c             [ 3] 	sty fh_handle+FH_LastClust+1
                             
                             	; Given current cluster, find next
                             	; save in X,Y
d51b : 2090d1           [ 6] 	jsr fs_get_next_cluster
                             	; load X,Y with the next cluster
d51e : a668             [ 3] 	ldx fh_handle+FH_CurrClust
d520 : a469             [ 3] 	ldy fh_handle+FH_CurrClust+1
                             	
                             	; Zero out the cluster number
d522 : 6468             [ 3] 	stz fh_handle+FH_CurrClust
d524 : 6469             [ 3] 	stz fh_handle+FH_CurrClust+1
                             
                             	; Update FAT entry of Last Cluster with zero
d526 : 20fed2           [ 6] 	jsr fs_update_FAT_entry
                             
                             	; Restore the next cluster found earlier
d529 : 8668             [ 3] 	stx fh_handle+FH_CurrClust
d52b : 8469             [ 3] 	sty fh_handle+FH_CurrClust+1
                             
                             	; If the next cluster is not 0xffff
                             	; then continue
d52d : e0ff             [ 2] 	cpx #0xff
d52f : d0e6             [ 3] 	bne fs_delete_clust
d531 : c0ff             [ 2] 	cpy #0xff
d533 : d0e2             [ 3] 	bne fs_delete_clust
d535 : 18               [ 2] 	clc
d536 :                       fs_delete_fin
d536 : 60               [ 6] 	rts
                             
                             ;** Wrapper function which saves A,X,Y **
d537 :                       fs_delete_w
d537 : 48               [ 3] 	pha
d538 : da               [ 3] 	phx
d539 : 5a               [ 3] 	phy
                             
d53a : 8683             [ 3] 	stx fh_handle+FH_FSpecPtr
d53c : 8584             [ 3] 	sta fh_handle+FH_FSpecPtr+1
d53e : 2000d5           [ 6] 	jsr fs_delete
                             	
d541 : 7a               [ 4] 	ply
AS65 Assembler for R6502 [1.42].                                     Page   89
---------------------------------- bank2.s -----------------------------------

d542 : fa               [ 4] 	plx
d543 : 68               [ 4] 	pla
d544 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* fs_chdir_direct
                             ;* Change root directory directly using cluster
                             ;* Input : FH_FirstClust has cluster number of di
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d545 :                       fs_chdir_direct
                             	; Calculate sector from this directory cluster
d545 : a679             [ 3] 	ldx fh_handle+FH_FirstClust
d547 : a57a             [ 3] 	lda fh_handle+FH_FirstClust+1
                             	
                             	; Also record the directory cluster #
d549 : 8e450c           [ 4] 	stx fs_dirclust
d54c : 8d460c           [ 4] 	sta fs_dirclust+1
                             	
d54f : 202dd2           [ 6] 	jsr fs_get_start_sect_data	; Calc the first sect
                             	
d552 : a203             [ 2] 	ldx #3						; Copy sector to dirsect
d554 :                       fs_chdir_direct_sect
d554 : b56b             [ 4] 	lda fh_handle+FH_CurrSec,x
d556 : 9d410c           [ 5] 	sta fs_dirsect,x
d559 : ca               [ 2] 	dex
d55a : 10f8             [ 3] 	bpl fs_chdir_direct_sect
d55c : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* fs_chdir
                             ;* Change root directory
                             ;* Input : fh_handle has the name
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d55d :                       fs_chdir
d55d : b283             [ 5] 	lda (fh_handle+FH_FSpecPtr)		; First byte of nam
d55f : f004             [ 3] 	beq fs_chdir_root				; If zero then goto root fo
d561 : c92f             [ 2] 	cmp #FS_FOLDERCH				; Is it '/'
d563 : d016             [ 3] 	bne fs_chdir_find				; If not then find the file
d565 :                       fs_chdir_root
d565 : 48               [ 3] 	pha								; Remember the 1st char
d566 : 6479             [ 3] 	stz fh_handle+FH_FirstClust		; Else use zero to 
d568 : 647a             [ 3] 	stz fh_handle+FH_FirstClust+1
d56a : 2045d5           [ 6] 	jsr fs_chdir_direct
d56d : 68               [ 4] 	pla								; If 1st char is zero then done
d56e : f029             [ 3] 	beq fs_chdir_fin
d570 : 18               [ 2] 	clc								; Add 1 to filespec pointer base
d571 : a583             [ 3] 	lda fh_handle+FH_FSpecPtr
d573 : 6901             [ 2] 	adc #1
d575 : 8583             [ 3] 	sta fh_handle+FH_FSpecPtr
d577 : a584             [ 3] 	lda fh_handle+FH_FSpecPtr+1
d579 : 8584             [ 3] 	sta fh_handle+FH_FSpecPtr+1
                             	; Drop through to processing rest of file spec
                             	
d57b :                       fs_chdir_find
d57b : 20fbcf           [ 6] 	jsr fs_dir_root_start			; Start at root of curre
d57e : 209bd3           [ 6] 	jsr fs_find_named				; Try to find the file
d581 : b017             [ 3] 	bcs fs_chdir_not_found			; C=1 not found
AS65 Assembler for R6502 [1.42].                                     Page   90
---------------------------------- bank2.s -----------------------------------

d583 : 5a               [ 3] 	phy								; Remember where we got to in filespe
d584 : 2045d5           [ 6] 	jsr fs_chdir_direct				; Go to the found folder
d587 : 7a               [ 4] 	ply
d588 : b183             [ 5] 	lda (fh_handle+FH_FSpecPtr),y	; What was the las
d58a : f00d             [ 3] 	beq fs_chdir_fin				; If an actual zero then we'
d58c : c8               [ 2] 	iny								; Else move past '/'
d58d : 98               [ 2] 	tya								; Pull index but into A
d58e : 18               [ 2] 	clc								; Add this index to filespec pointer 
d58f : 6583             [ 3] 	adc fh_handle+FH_FSpecPtr
d591 : 8583             [ 3] 	sta fh_handle+FH_FSpecPtr
d593 : a584             [ 3] 	lda fh_handle+FH_FSpecPtr+1
d595 : 8584             [ 3] 	sta fh_handle+FH_FSpecPtr+1
d597 : 80e2             [ 3] 	bra fs_chdir_find				; And go and try to navigat
                             
d599 :                       fs_chdir_fin
d599 : 18               [ 2] 	clc
d59a :                       fs_chdir_not_found
d59a : 60               [ 6] 	rts
                             
                             ;** Wrapper function which saves A,X,Y **
d59b :                       fs_chdir_w
d59b : 48               [ 3] 	pha
d59c : da               [ 3] 	phx
d59d : 5a               [ 3] 	phy
                             	
d59e : 8683             [ 3] 	stx fh_handle+FH_FSpecPtr
d5a0 : 8584             [ 3] 	sta fh_handle+FH_FSpecPtr+1
d5a2 : 205dd5           [ 6] 	jsr fs_chdir
                             	
d5a5 : 7a               [ 4] 	ply
d5a6 : fa               [ 4] 	plx
d5a7 : 68               [ 4] 	pla
d5a8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_mkdir
                             ;* Create a file
                             ;* Input : fh_handle has the name
                             ;*		 : checks if file already exists
                             ;*		 : new directory will be created
                             ;*       : including . and .. entries
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d5a9 :                       fs_mkdir
d5a9 : 20fbcf           [ 6] 	jsr fs_dir_root_start		; Start at root of curren
                             
                             	; If file or directory with same name exists, th
d5ac : 209bd3           [ 6] 	jsr fs_find_named			; Try to find the file
d5af : b002             [ 3] 	bcs fs_mkdir_ok				; C=1 then no file found - ok
                             
d5b1 : 38               [ 2] 	sec							; Indicate fail
d5b2 : 60               [ 6] 	rts
                             
d5b3 :                       fs_mkdir_ok	
                             	; Remember parent directory ".." cluster #
d5b3 : ad450c           [ 4] 	lda fs_dirclust
d5b6 : 48               [ 3] 	pha
d5b7 : ad460c           [ 4] 	lda fs_dirclust+1
d5ba : 48               [ 3] 	pha
                             
d5bb : 38               [ 2] 	sec
AS65 Assembler for R6502 [1.42].                                     Page   91
---------------------------------- bank2.s -----------------------------------

d5bc : 2049d4           [ 6] 	jsr fs_create_filedir		; Go create the directory
d5bf : 20b4d4           [ 6] 	jsr fs_close_filedir		; Commit
                             	
                             	; Remember this directory "." cluster #
d5c2 : a579             [ 3] 	lda fh_handle+FH_FirstClust
d5c4 : 48               [ 3] 	pha
d5c5 : a57a             [ 3] 	lda fh_handle+FH_FirstClust+1
d5c7 : 48               [ 3] 	pha
                             	
                             	; Need to zero the directory cluster
                             	; First create a zero filled buffer 512 bytes
d5c8 : a900             [ 2] 	lda #0
d5ca : aa               [ 2] 	tax
d5cb : a000             [ 2] 	ldy #0
d5cd :                       fs_mkdir_zero_sector
d5cd : 20c0cf           [ 6] 	jsr fs_putbyte_sd_buf
d5d0 : ca               [ 2] 	dex 
d5d1 : d0fa             [ 3] 	bne fs_mkdir_zero_sector
d5d3 : c8               [ 2] 	iny
d5d4 : c002             [ 2] 	cpy #2
d5d6 : d0f5             [ 3] 	bne fs_mkdir_zero_sector
                             	; Now fill a cluster's worth of sectors with zer
                             	; Cluster = 16k, buffer = 512 bytes => 32 sector
                             	
                             	; Get directory cluster # in to X,A and calculat
d5d8 : a679             [ 3] 	ldx fh_handle+FH_FirstClust
d5da : a57a             [ 3] 	lda fh_handle+FH_FirstClust+1
d5dc : 202dd2           [ 6] 	jsr fs_get_start_sect_data
                             	
                             	; Now write cluster worth of sectors
d5df : a220             [ 2] 	ldx #32
d5e1 :                       fs_mkdir_zero_cluster
d5e1 : da               [ 3] 	phx
d5e2 : 207ad2           [ 6] 	jsr fs_flush_curr_sect
d5e5 : 20d0d2           [ 6] 	jsr fs_inc_curr_sec
d5e8 : fa               [ 4] 	plx
d5e9 : ca               [ 2] 	dex
d5ea : d0f5             [ 3] 	bne fs_mkdir_zero_cluster
                             	
                             	; Goto newly created directory (it's empty)
                             	; Use cluster number
d5ec : 205dd5           [ 6] 	jsr fs_chdir
d5ef : 20fbcf           [ 6] 	jsr fs_dir_root_start		; Start at root of curren
                             	; Go and find first available slot in directory 
d5f2 : 38               [ 2] 	sec
d5f3 : 201bd0           [ 6] 	jsr fs_dir_find_entry
                             	; Restore current directory cluster - it's rever
d5f6 : 68               [ 4] 	pla
d5f7 : 857a             [ 3] 	sta fh_handle+FH_FirstClust+1
d5f9 : 68               [ 4] 	pla
d5fa : 8579             [ 3] 	sta fh_handle+FH_FirstClust
d5fc : 2090d4           [ 6] 	jsr fs_create_dirptr		; Go create the '.' file e
                             	; Create name for entry "."
d5ff : a92e             [ 2] 	lda #'.'
d601 : 8556             [ 3] 	sta fh_handle+0
d603 : 6457             [ 3] 	stz fh_handle+1
                             	; Convert fhandle to FATFileDesc
d605 : 200fd1           [ 6] 	jsr fs_dir_fhandle_to_entry	
d608 : 2079d3           [ 6] 	jsr fs_dir_save_entry		; Save it to to the direc
                             
                             	; Go and find next available slot in directory C
d60b : 2060d0           [ 6] 	jsr fs_dir_next_entry
AS65 Assembler for R6502 [1.42].                                     Page   92
---------------------------------- bank2.s -----------------------------------

d60e : 38               [ 2] 	sec
d60f : 201bd0           [ 6] 	jsr fs_dir_find_entry
                             	; Restore parent directory cluster - it's revers
d612 : 68               [ 4] 	pla
d613 : 857a             [ 3] 	sta fh_handle+FH_FirstClust+1
d615 : 68               [ 4] 	pla
d616 : 8579             [ 3] 	sta fh_handle+FH_FirstClust
d618 : 2090d4           [ 6] 	jsr fs_create_dirptr		; Go create the '..' file 
                             	; Create name for entry ".."
d61b : a92e             [ 2] 	lda #'.'
d61d : 8556             [ 3] 	sta fh_handle+0
d61f : 8557             [ 3] 	sta fh_handle+1
d621 : 6458             [ 3] 	stz fh_handle+2
                             	; Convert fhandle to FATFileDesc
d623 : 200fd1           [ 6] 	jsr fs_dir_fhandle_to_entry	
d626 : 2079d3           [ 6] 	jsr fs_dir_save_entry		; Save it to to the direc
                             
                             	; FH_FirstClust points to parent - go to it
d629 : 2045d5           [ 6] 	jsr fs_chdir_direct
                             	
d62c : 18               [ 2] 	clc							; Indicate success
                             
d62d :                       fs_mkdir_fin
d62d : 60               [ 6] 	rts
                             
                             ;** Wrapper function which saves A,X,Y **
d62e :                       fs_mkdir_w
d62e : 48               [ 3] 	pha
d62f : da               [ 3] 	phx
d630 : 5a               [ 3] 	phy
                             	
d631 : 8683             [ 3] 	stx fh_handle+FH_FSpecPtr
d633 : 8584             [ 3] 	sta fh_handle+FH_FSpecPtr+1
d635 : 20a9d5           [ 6] 	jsr fs_mkdir
                             
d638 : 7a               [ 4] 	ply
d639 : fa               [ 4] 	plx
d63a : 68               [ 4] 	pla
d63b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_dir_fhandle_to_str
                             ;* Unpack contents of fhandle to a string 
                             ;* Input : fs_fhandle, A,X=pointer to string
                             ;* Output : 43 bytes of string (inc, zero pointer
                             ;* Column	Len	Offset	Desc
                             ;*	name	12	0 		8.3 space padded to right
                             ;*	type	3	13		DIR if directory else FIL
                             ;*	date	8	19		DD/MM/YY
                             ;*	time	8	28		hh/mm/ss
                             ;*	size	5	37		right justified no leading zeros
                             ;* Regs affected : None
                             ;****************************************
d63c :                       fs_dir_str
d63c : 444952                	db "DIR"
d63f :                       fs_dir_fil
d63f : 202020                	db "   "
d642 :                       fs_dir_fhandle_str
d642 : 863f             [ 3] 	stx tmp_v1
d644 : 8540             [ 3] 	sta tmp_v1+1
                             	; Put zero terminator at pos 41
d646 : a028             [ 2] 	ldy #40
AS65 Assembler for R6502 [1.42].                                     Page   93
---------------------------------- bank2.s -----------------------------------

d648 : a900             [ 2] 	lda #0
d64a : 913f             [ 5] 	sta (tmp_v1),y
                             	; Pre-fill with spaces
d64c : 88               [ 2] 	dey
d64d : a920             [ 2] 	lda #' '
d64f :                       fs_dir_fhandle_pad_spc
d64f : 913f             [ 5] 	sta (tmp_v1),y
d651 : 88               [ 2] 	dey
d652 : 10fb             [ 3] 	bpl fs_dir_fhandle_pad_spc
                             	; Put '/' separator for date
d654 : a92f             [ 2] 	lda #'/'
d656 : a013             [ 2] 	ldy #19
d658 : 913f             [ 5] 	sta (tmp_v1),y
d65a : a016             [ 2] 	ldy #22
d65c : 913f             [ 5] 	sta (tmp_v1),y
                             	; Put ':' separator for time
d65e : a93a             [ 2] 	lda #':'
d660 : a01c             [ 2] 	ldy #28
d662 : 913f             [ 5] 	sta (tmp_v1),y
d664 : a01f             [ 2] 	ldy #31
d666 : 913f             [ 5] 	sta (tmp_v1),y
                             	;* Unpack name - copy 8.3 (12 chars) until zero
d668 : a200             [ 2] 	ldx #FH_Name				; Source
d66a : a000             [ 2] 	ldy #0						; Name offset
d66c :                       fs_dir_fhandle_name
d66c : b556             [ 4] 	lda fh_handle,x				; Get name char
d66e : f00b             [ 3] 	beq	fs_dir_fhandle_dotype	; Process attribute if
d670 : 201bd2           [ 6] 	jsr fs_to_upper				; Case insensitive
d673 : 913f             [ 5] 	sta (tmp_v1),y
d675 : e8               [ 2] 	inx
d676 : c8               [ 2] 	iny
d677 : c00c             [ 2] 	cpy #12
d679 : d0f1             [ 3] 	bne fs_dir_fhandle_name		; Max 12 chars for a fi
d67b :                       fs_dir_fhandle_dotype
d67b : a563             [ 3] 	lda fh_handle+FH_Attr		; Check the type
d67d : a00d             [ 2] 	ldy #13						; Point to column for type
d67f : a200             [ 2] 	ldx #0						; Point to DIR string
d681 : c910             [ 2] 	cmp #FAT_Attr_Dir			; Directory?
d683 : f002             [ 3] 	beq fs_dir_fhandle_type
d685 : a203             [ 2] 	ldx #3						; Point to FIL string
d687 :                       fs_dir_fhandle_type				; copy 3 chars
d687 : bd3cd6           [ 4] 	lda fs_dir_str,x
d68a : 913f             [ 5] 	sta (tmp_v1),y
d68c : e8               [ 2] 	inx
d68d : c8               [ 2] 	iny
d68e : c010             [ 2] 	cpy #16
d690 : d0f5             [ 3] 	bne fs_dir_fhandle_type
                             
                             	;* Date
                             	; Extract year
d692 : a581             [ 3] 	lda fh_handle+FH_TimeDate+4 ; Top 7 bits is year
d694 : 4a               [ 2] 	lsr a
d695 : 38               [ 2] 	sec							; Remove offset from 1980 (-20)
d696 : e914             [ 2] 	sbc #20
d698 : a017             [ 2] 	ldy #23						; Save to date field
d69a : 200cd7           [ 6] 	jsr fs_util_num_bcd			; Put digits
                             	; Extract month
d69d : a581             [ 3] 	lda fh_handle+FH_TimeDate+4 ; Bottom bit is bit 
d69f : 4a               [ 2] 	lsr a						; Put in to C
d6a0 : a580             [ 3] 	lda fh_handle+FH_TimeDate+3	; Top 3 bits are mon
d6a2 : 6a               [ 2] 	ror a						; Rotate in C for bit 3 (now have 4 b
d6a3 : 4a               [ 2] 	lsr a						; Bring to low nibble
AS65 Assembler for R6502 [1.42].                                     Page   94
---------------------------------- bank2.s -----------------------------------

d6a4 : 4a               [ 2] 	lsr a
d6a5 : 4a               [ 2] 	lsr a
d6a6 : 4a               [ 2] 	lsr a
d6a7 : a014             [ 2] 	ldy #20						; Month field position
d6a9 : 200cd7           [ 6] 	jsr fs_util_num_bcd			; Put digits
                             	; Extract days
d6ac : a580             [ 3] 	lda fh_handle+FH_TimeDate+3 ; Bottom bottom 5 bi
d6ae : 291f             [ 2] 	and #0x1f					; So mask that
d6b0 : a011             [ 2] 	ldy #17						; Day field position
d6b2 : 200cd7           [ 6] 	jsr fs_util_num_bcd			; Put digits
                             
                             	;* Time
                             	; Extract hours
d6b5 : a57f             [ 3] 	lda fh_handle+FH_TimeDate+2	; Ignore ms. Top5 bi
d6b7 : 4a               [ 2] 	lsr a
d6b8 : 4a               [ 2] 	lsr a
d6b9 : 4a               [ 2] 	lsr a
d6ba : a01a             [ 2] 	ldy #26						; Hours field
d6bc : 200cd7           [ 6] 	jsr fs_util_num_bcd			; Put digits
                             	; Extract minutes
d6bf : a57e             [ 3] 	lda fh_handle+FH_TimeDate+1	; Top 3 bits is bit 
d6c1 : 4a               [ 2] 	lsr a						; Shift it to bottom
d6c2 : 4a               [ 2] 	lsr a
d6c3 : 4a               [ 2] 	lsr a
d6c4 : 4a               [ 2] 	lsr a
d6c5 : 4a               [ 2] 	lsr a
d6c6 : 8d470c           [ 4] 	sta fs_scratch				; Save partial result
d6c9 : a57f             [ 3] 	lda fh_handle+FH_TimeDate+2	; Bottom 3 bits is b
d6cb : 2907             [ 2] 	and #0x07					; Mask for those bits
d6cd : 0a               [ 2] 	asl a						; Shift up in to position 3,4,5
d6ce : 0a               [ 2] 	asl a
d6cf : 0a               [ 2] 	asl a
d6d0 : 0d470c           [ 4] 	ora fs_scratch				; Combine with top 3 bits
d6d3 : a01d             [ 2] 	ldy #29						; Minutes field
d6d5 : 200cd7           [ 6] 	jsr fs_util_num_bcd			; Put digits
                             	; Extract seconds
d6d8 : a57e             [ 3] 	lda fh_handle+FH_TimeDate+1	; Bottom 5 bits is s
d6da : 291f             [ 2] 	and #0x1f					; Mask for those
d6dc : 0a               [ 2] 	asl a						; x2
d6dd : a020             [ 2] 	ldy #32						; Seconds field
d6df : 200cd7           [ 6] 	jsr fs_util_num_bcd			; Put digits
                             	; Extract size
d6e2 : a565             [ 3] 	lda fh_handle+FH_Size+1		; Only taking 16 bits o
d6e4 : a664             [ 3] 	ldx fh_handle+FH_Size+0		; X=Low
d6e6 : 20d3ca           [ 6] 	jsr word_to_bcd				; X,A to BCD in num_a (3 byte
d6e9 : a587             [ 3] 	lda num_a+2					; 100k and 10k digits
d6eb : a023             [ 2] 	ldy #35						; Position of size field
d6ed : 2022d7           [ 6] 	jsr fs_util_num_bcd_a		; Put only 10k digit
d6f0 : a586             [ 3] 	lda num_a+1					; 1k and hundreds digits
d6f2 : 2014d7           [ 6] 	jsr fs_util_num_bcd_xa		; Put digits in AX
d6f5 : a585             [ 3] 	lda num_a+0					; tens and units digits
d6f7 : 2014d7           [ 6] 	jsr fs_util_num_bcd_xa		; Put digits in AX
d6fa : a023             [ 2] 	ldy #35						; Check for leading zeros
d6fc :                       fs_dir_fhandle_zeros
d6fc : b13f             [ 5] 	lda (tmp_v1),y
d6fe : c930             [ 2] 	cmp #'0'
d700 : d009             [ 3] 	bne fs_dir_fhandle_done
d702 : a920             [ 2] 	lda #' '
d704 : 913f             [ 5] 	sta (tmp_v1),y
d706 :                       fs_dir_fhandle_zskip
d706 : c8               [ 2] 	iny
d707 : c027             [ 2] 	cpy #39						; Last zero can stay
AS65 Assembler for R6502 [1.42].                                     Page   95
---------------------------------- bank2.s -----------------------------------

d709 : d0f1             [ 4] 	bne fs_dir_fhandle_zeros
                             	; byte 0 = milliseconds
                             	; byte 1 = mmmsssss
                             	; byte 2 = hhhhhmmm
                             	; byte 3 = MMMDDDDD
                             	; byte 4 = YYYYYYYM
d70b :                       fs_dir_fhandle_done
d70b : 60               [ 6] 	rts
                             
d70c :                       fs_util_num_bcd
d70c : aa               [ 2] 	tax							; Only can do 00-99
d70d : a900             [ 2] 	lda #0						; So high byte = 0
d70f : 20d3ca           [ 6] 	jsr word_to_bcd				; X,A to BCD in num_a
d712 : a585             [ 3] 	lda num_a+0					; Two least significant BCD digi
d714 :                       fs_util_num_bcd_xa				; Enter here if bcd convers
d714 : 48               [ 3] 	pha
d715 : aa               [ 2] 	tax							; X contains this
d716 : 68               [ 4] 	pla							; Two least significant BCD digits (00
d717 : 4a               [ 2] 	lsr a						; Get tens digit 
d718 : 4a               [ 2] 	lsr a
d719 : 4a               [ 2] 	lsr a
d71a : 4a               [ 2] 	lsr a
d71b : 18               [ 2] 	clc
d71c : 6930             [ 2] 	adc #'0'					; Convert to ascii
d71e : 913f             [ 5] 	sta (tmp_v1),y				; Save in string position (2 c
d720 : c8               [ 2] 	iny
d721 : 8a               [ 2] 	txa
d722 :                       fs_util_num_bcd_a				; Enter here if only units n
d722 : 290f             [ 2] 	and #0x0f					; Get units digit
d724 : 18               [ 2] 	clc
d725 : 6930             [ 2] 	adc #'0'					; Convert to ascii
d727 : 913f             [ 5] 	sta (tmp_v1),y
d729 : c8               [ 2] 	iny
d72a : 60               [ 6] 	rts
                             
                             
                             	
d72b :                       msg_initialising_fs
d72b : 4d6f756e74696e..      	db "Mounting filesystem\r\r",0
d741 :                       msg_noinit_fs
d741 : 4e6f2066696c65..      	db "No filesystem available\r\r",0
d75b :                       mod_sz_sd_fs_e
                             
                             
                             	; End of Code
d75b :                       _code_end
d75b :                       _bank2_end
                             	
                             
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
